/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		"mainSmartElement": 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData === 0) {
/******/ 			return new Promise(function(resolve) { resolve(); });
/******/ 		}
/******/
/******/ 		// a Promise means "currently loading".
/******/ 		if(installedChunkData) {
/******/ 			return installedChunkData[2];
/******/ 		}
/******/
/******/ 		// setup Promise in chunk cache
/******/ 		var promise = new Promise(function(resolve, reject) {
/******/ 			installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 		});
/******/ 		installedChunkData[2] = promise;
/******/
/******/ 		// start chunk loading
/******/ 		var head = document.getElementsByTagName('head')[0];
/******/ 		var script = document.createElement('script');
/******/ 		script.type = 'text/javascript';
/******/ 		script.charset = 'utf-8';
/******/ 		script.async = true;
/******/ 		script.timeout = 120000;
/******/
/******/ 		if (__webpack_require__.nc) {
/******/ 			script.setAttribute("nonce", __webpack_require__.nc);
/******/ 		}
/******/ 		script.src = __webpack_require__.p + "" + chunkId + ".js";
/******/ 		var timeout = setTimeout(onScriptComplete, 120000);
/******/ 		script.onerror = script.onload = onScriptComplete;
/******/ 		function onScriptComplete() {
/******/ 			// avoid mem leaks in IE.
/******/ 			script.onerror = script.onload = null;
/******/ 			clearTimeout(timeout);
/******/ 			var chunk = installedChunks[chunkId];
/******/ 			if(chunk !== 0) {
/******/ 				if(chunk) {
/******/ 					chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));
/******/ 				}
/******/ 				installedChunks[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		head.appendChild(script);
/******/
/******/ 		return promise;
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "uiAssets/anakeen/debug/";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/Apps/DOCUMENT/IHM/mainDocument.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/backbone/backbone.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

//     Backbone.js 1.3.3

//     (c) 2010-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function (factory) {

  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.
  // We use `self` instead of `window` for `WebWorker` support.
  var root = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self.self === self && self || (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global.global === global && global;

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("external \"jQuery\""), exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

    // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore'),
        $;
    try {
      $ = require('jquery');
    } catch (e) {}
    factory(root, exports, _, $);

    // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, root.jQuery || root.Zepto || root.ender || root.$);
  }
})(function (root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create a local reference to a common array method we'll want to use later.
  var _slice = Array.prototype.slice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.3.3';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function () {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... this will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Proxy Backbone class methods to Underscore functions, wrapping the model's
  // `attributes` object or collection's `models` array behind the scenes.
  //
  // collection.filter(function(model) { return model.get('age') > 10 });
  // collection.each(this.addView);
  //
  // `Function#apply` can be slow so we use the method's arg count, if we know it.
  var addMethod = function addMethod(length, method, attribute) {
    switch (length) {
      case 1:
        return function () {
          return _[method](this[attribute]);
        };
      case 2:
        return function (value) {
          return _[method](this[attribute], value);
        };
      case 3:
        return function (iteratee, context) {
          return _[method](this[attribute], cb(iteratee, this), context);
        };
      case 4:
        return function (iteratee, defaultVal, context) {
          return _[method](this[attribute], cb(iteratee, this), defaultVal, context);
        };
      default:
        return function () {
          var args = _slice.call(arguments);
          args.unshift(this[attribute]);
          return _[method].apply(_, args);
        };
    }
  };
  var addUnderscoreMethods = function addUnderscoreMethods(Class, methods, attribute) {
    _.each(methods, function (length, method) {
      if (_[method]) Class.prototype[method] = addMethod(length, method, attribute);
    });
  };

  // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.
  var cb = function cb(iteratee, instance) {
    if (_.isFunction(iteratee)) return iteratee;
    if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);
    if (_.isString(iteratee)) return function (model) {
      return model.get(iteratee);
    };
    return iteratee;
  };
  var modelMatcher = function modelMatcher(attrs) {
    var matcher = _.matches(attrs);
    return function (model) {
      return matcher(model.attributes);
    };
  };

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // a custom event channel. You may bind a callback to an event with `on` or
  // remove with `off`; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {};

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Iterates over the standard `event, callback` (as well as the fancy multiple
  // space-separated events `"change blur", callback` and jQuery-style event
  // maps `{event: callback}`).
  var eventsApi = function eventsApi(iteratee, events, name, callback, opts) {
    var i = 0,
        names;
    if (name && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
      // Handle event maps.
      if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;
      for (names = _.keys(name); i < names.length; i++) {
        events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
      }
    } else if (name && eventSplitter.test(name)) {
      // Handle space-separated event names by delegating them individually.
      for (names = name.split(eventSplitter); i < names.length; i++) {
        events = iteratee(events, names[i], callback, opts);
      }
    } else {
      // Finally, standard events.
      events = iteratee(events, name, callback, opts);
    }
    return events;
  };

  // Bind an event to a `callback` function. Passing `"all"` will bind
  // the callback to all events fired.
  Events.on = function (name, callback, context) {
    return internalOn(this, name, callback, context);
  };

  // Guard the `listening` argument from the public API.
  var internalOn = function internalOn(obj, name, callback, context, listening) {
    obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
      context: context,
      ctx: obj,
      listening: listening
    });

    if (listening) {
      var listeners = obj._listeners || (obj._listeners = {});
      listeners[listening.id] = listening;
    }

    return obj;
  };

  // Inversion-of-control versions of `on`. Tell *this* object to listen to
  // an event in another object... keeping track of what it's listening to
  // for easier unbinding later.
  Events.listenTo = function (obj, name, callback) {
    if (!obj) return this;
    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
    var listeningTo = this._listeningTo || (this._listeningTo = {});
    var listening = listeningTo[id];

    // This object is not listening to any other events on `obj` yet.
    // Setup the necessary references to track the listening callbacks.
    if (!listening) {
      var thisId = this._listenId || (this._listenId = _.uniqueId('l'));
      listening = listeningTo[id] = { obj: obj, objId: id, id: thisId, listeningTo: listeningTo, count: 0 };
    }

    // Bind callbacks on obj, and keep track of them on listening.
    internalOn(obj, name, callback, this, listening);
    return this;
  };

  // The reducing API that adds a callback to the `events` object.
  var onApi = function onApi(events, name, callback, options) {
    if (callback) {
      var handlers = events[name] || (events[name] = []);
      var context = options.context,
          ctx = options.ctx,
          listening = options.listening;
      if (listening) listening.count++;

      handlers.push({ callback: callback, context: context, ctx: context || ctx, listening: listening });
    }
    return events;
  };

  // Remove one or many callbacks. If `context` is null, removes all
  // callbacks with that function. If `callback` is null, removes all
  // callbacks for the event. If `name` is null, removes all bound
  // callbacks for all events.
  Events.off = function (name, callback, context) {
    if (!this._events) return this;
    this._events = eventsApi(offApi, this._events, name, callback, {
      context: context,
      listeners: this._listeners
    });
    return this;
  };

  // Tell this object to stop listening to either specific events ... or
  // to every object it's currently listening to.
  Events.stopListening = function (obj, name, callback) {
    var listeningTo = this._listeningTo;
    if (!listeningTo) return this;

    var ids = obj ? [obj._listenId] : _.keys(listeningTo);

    for (var i = 0; i < ids.length; i++) {
      var listening = listeningTo[ids[i]];

      // If listening doesn't exist, this object is not currently
      // listening to obj. Break out early.
      if (!listening) break;

      listening.obj.off(name, callback, this);
    }

    return this;
  };

  // The reducing API that removes a callback from the `events` object.
  var offApi = function offApi(events, name, callback, options) {
    if (!events) return;

    var i = 0,
        listening;
    var context = options.context,
        listeners = options.listeners;

    // Delete all events listeners and "drop" events.
    if (!name && !callback && !context) {
      var ids = _.keys(listeners);
      for (; i < ids.length; i++) {
        listening = listeners[ids[i]];
        delete listeners[listening.id];
        delete listening.listeningTo[listening.objId];
      }
      return;
    }

    var names = name ? [name] : _.keys(events);
    for (; i < names.length; i++) {
      name = names[i];
      var handlers = events[name];

      // Bail out if there are no events stored.
      if (!handlers) break;

      // Replace events if there are any remaining.  Otherwise, clean up.
      var remaining = [];
      for (var j = 0; j < handlers.length; j++) {
        var handler = handlers[j];
        if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) {
          remaining.push(handler);
        } else {
          listening = handler.listening;
          if (listening && --listening.count === 0) {
            delete listeners[listening.id];
            delete listening.listeningTo[listening.objId];
          }
        }
      }

      // Update tail event if the list has any events.  Otherwise, clean up.
      if (remaining.length) {
        events[name] = remaining;
      } else {
        delete events[name];
      }
    }
    return events;
  };

  // Bind an event to only be triggered a single time. After the first time
  // the callback is invoked, its listener will be removed. If multiple events
  // are passed in using the space-separated syntax, the handler will fire
  // once for each event, not once for a combination of all events.
  Events.once = function (name, callback, context) {
    // Map the event into a `{event: once}` object.
    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
    if (typeof name === 'string' && context == null) callback = void 0;
    return this.on(events, callback, context);
  };

  // Inversion-of-control versions of `once`.
  Events.listenToOnce = function (obj, name, callback) {
    // Map the event into a `{event: once}` object.
    var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
    return this.listenTo(obj, events);
  };

  // Reduces the event callbacks into a map of `{event: onceWrapper}`.
  // `offer` unbinds the `onceWrapper` after it has been called.
  var onceMap = function onceMap(map, name, callback, offer) {
    if (callback) {
      var once = map[name] = _.once(function () {
        offer(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
    }
    return map;
  };

  // Trigger one or many events, firing all bound callbacks. Callbacks are
  // passed the same arguments as `trigger` is, apart from the event name
  // (unless you're listening on `"all"`, which will cause your callback to
  // receive the true name of the event as the first argument).
  Events.trigger = function (name) {
    if (!this._events) return this;

    var length = Math.max(0, arguments.length - 1);
    var args = Array(length);
    for (var i = 0; i < length; i++) {
      args[i] = arguments[i + 1];
    }eventsApi(triggerApi, this._events, name, void 0, args);
    return this;
  };

  // Handles triggering the appropriate event callbacks.
  var triggerApi = function triggerApi(objEvents, name, callback, args) {
    if (objEvents) {
      var events = objEvents[name];
      var allEvents = objEvents.all;
      if (events && allEvents) allEvents = allEvents.slice();
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, [name].concat(args));
    }
    return objEvents;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function triggerEvents(events, args) {
    var ev,
        i = -1,
        l = events.length,
        a1 = args[0],
        a2 = args[1],
        a3 = args[2];
    switch (args.length) {
      case 0:
        while (++i < l) {
          (ev = events[i]).callback.call(ev.ctx);
        }return;
      case 1:
        while (++i < l) {
          (ev = events[i]).callback.call(ev.ctx, a1);
        }return;
      case 2:
        while (++i < l) {
          (ev = events[i]).callback.call(ev.ctx, a1, a2);
        }return;
      case 3:
        while (++i < l) {
          (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
        }return;
      default:
        while (++i < l) {
          (ev = events[i]).callback.apply(ev.ctx, args);
        }return;
    }
  };

  // Aliases for backwards compatibility.
  Events.bind = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function (attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId(this.cidPrefix);
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    var defaults = _.result(this, 'defaults');
    attrs = _.defaults(_.extend({}, defaults, attrs), defaults);
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // The prefix is used to create the client id which is used to identify models locally.
    // You may want to override this if you're experiencing name clashes with model ids.
    cidPrefix: 'c',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function initialize() {},

    // Return a copy of the model's `attributes` object.
    toJSON: function toJSON(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function sync() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function get(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function escape(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function has(attr) {
      return this.get(attr) != null;
    },

    // Special-cased proxy to underscore's `_.matches` method.
    matches: function matches(attrs) {
      return !!_.iteratee(attrs, this)(this.attributes);
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function set(key, val, options) {
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      var unset = options.unset;
      var silent = options.silent;
      var changes = [];
      var changing = this._changing;
      this._changing = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }

      var current = this.attributes;
      var changed = this.changed;
      var prev = this._previousAttributes;

      // For each `set` attribute, update or delete the current value.
      for (var attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          changed[attr] = val;
        } else {
          delete changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Update the `id`.
      if (this.idAttribute in attrs) this.id = this.get(this.idAttribute);

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0; i < changes.length; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function unset(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, { unset: true }));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function clear(options) {
      var attrs = {};
      for (var key in this.attributes) {
        attrs[key] = void 0;
      }return this.set(attrs, _.extend({}, options, { unset: true }));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function hasChanged(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function changedAttributes(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      var changed = {};
      for (var attr in diff) {
        var val = diff[attr];
        if (_.isEqual(old[attr], val)) continue;
        changed[attr] = val;
      }
      return _.size(changed) ? changed : false;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function previous(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function previousAttributes() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server, merging the response with the model's
    // local attributes. Any changed attributes will trigger a "change" event.
    fetch: function fetch(options) {
      options = _.extend({ parse: true }, options);
      var model = this;
      var success = options.success;
      options.success = function (resp) {
        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
        if (!model.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function save(key, val, options) {
      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if (key == null || (typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({ validate: true, parse: true }, options);
      var wait = options.wait;

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !wait) {
        if (!this.set(attrs, options)) return false;
      } else if (!this._validate(attrs, options)) {
        return false;
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      var model = this;
      var success = options.success;
      var attributes = this.attributes;
      options.success = function (resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
        if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
        if (serverAttrs && !model.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      // Set temporary attributes if `{wait: true}` to properly find new ids.
      if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);

      var method = this.isNew() ? 'create' : options.patch ? 'patch' : 'update';
      if (method === 'patch' && !options.attrs) options.attrs = attrs;
      var xhr = this.sync(method, this, options);

      // Restore attributes.
      this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function destroy(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;
      var wait = options.wait;

      var destroy = function destroy() {
        model.stopListening();
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function (resp) {
        if (wait) destroy();
        if (success) success.call(options.context, model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      var xhr = false;
      if (this.isNew()) {
        _.defer(options.success);
      } else {
        wrapError(this, options);
        xhr = this.sync('delete', this, options);
      }
      if (!wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function url() {
      var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
      if (this.isNew()) return base;
      var id = this.get(this.idAttribute);
      return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function parse(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function clone() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function isNew() {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function isValid(options) {
      return this._validate({}, _.extend({}, options, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function _validate(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, { validationError: error }));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model, mapped to the
  // number of arguments they take.
  var modelMethods = { keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,
    omit: 0, chain: 1, isEmpty: 1 };

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  addUnderscoreMethods(Model, modelMethods, 'attributes');

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analogous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function (models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({ silent: true }, options));
  };

  // Default options for `Collection#set`.
  var setOptions = { add: true, remove: true, merge: true };
  var addOptions = { add: true, remove: false };

  // Splices `insert` into `array` at index `at`.
  var splice = function splice(array, insert, at) {
    at = Math.min(Math.max(at, 0), array.length);
    var tail = Array(array.length - at);
    var length = insert.length;
    var i;
    for (i = 0; i < tail.length; i++) {
      tail[i] = array[i + at];
    }for (i = 0; i < length; i++) {
      array[i + at] = insert[i];
    }for (i = 0; i < tail.length; i++) {
      array[i + length + at] = tail[i];
    }
  };

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function initialize() {},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function toJSON(options) {
      return this.map(function (model) {
        return model.toJSON(options);
      });
    },

    // Proxy `Backbone.sync` by default.
    sync: function sync() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set. `models` may be Backbone
    // Models or raw JavaScript objects to be converted to Models, or any
    // combination of the two.
    add: function add(models, options) {
      return this.set(models, _.extend({ merge: false }, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function remove(models, options) {
      options = _.extend({}, options);
      var singular = !_.isArray(models);
      models = singular ? [models] : models.slice();
      var removed = this._removeModels(models, options);
      if (!options.silent && removed.length) {
        options.changes = { added: [], merged: [], removed: removed };
        this.trigger('update', this, options);
      }
      return singular ? removed[0] : removed;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function set(models, options) {
      if (models == null) return;

      options = _.extend({}, setOptions, options);
      if (options.parse && !this._isModel(models)) {
        models = this.parse(models, options) || [];
      }

      var singular = !_.isArray(models);
      models = singular ? [models] : models.slice();

      var at = options.at;
      if (at != null) at = +at;
      if (at > this.length) at = this.length;
      if (at < 0) at += this.length + 1;

      var set = [];
      var toAdd = [];
      var toMerge = [];
      var toRemove = [];
      var modelMap = {};

      var add = options.add;
      var merge = options.merge;
      var remove = options.remove;

      var sort = false;
      var sortable = this.comparator && at == null && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      var model, i;
      for (i = 0; i < models.length; i++) {
        model = models[i];

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        var existing = this.get(model);
        if (existing) {
          if (merge && model !== existing) {
            var attrs = this._isModel(model) ? model.attributes : model;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            toMerge.push(existing);
            if (sortable && !sort) sort = existing.hasChanged(sortAttr);
          }
          if (!modelMap[existing.cid]) {
            modelMap[existing.cid] = true;
            set.push(existing);
          }
          models[i] = existing;

          // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(model, options);
          if (model) {
            toAdd.push(model);
            this._addReference(model, options);
            modelMap[model.cid] = true;
            set.push(model);
          }
        }
      }

      // Remove stale models.
      if (remove) {
        for (i = 0; i < this.length; i++) {
          model = this.models[i];
          if (!modelMap[model.cid]) toRemove.push(model);
        }
        if (toRemove.length) this._removeModels(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      var orderChanged = false;
      var replace = !sortable && add && remove;
      if (set.length && replace) {
        orderChanged = this.length !== set.length || _.some(this.models, function (m, index) {
          return m !== set[index];
        });
        this.models.length = 0;
        splice(this.models, set, 0);
        this.length = this.models.length;
      } else if (toAdd.length) {
        if (sortable) sort = true;
        splice(this.models, toAdd, at == null ? this.length : at);
        this.length = this.models.length;
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({ silent: true });

      // Unless silenced, it's time to fire all appropriate add/sort/update events.
      if (!options.silent) {
        for (i = 0; i < toAdd.length; i++) {
          if (at != null) options.index = at + i;
          model = toAdd[i];
          model.trigger('add', model, this, options);
        }
        if (sort || orderChanged) this.trigger('sort', this, options);
        if (toAdd.length || toRemove.length || toMerge.length) {
          options.changes = {
            added: toAdd,
            removed: toRemove,
            merged: toMerge
          };
          this.trigger('update', this, options);
        }
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function reset(models, options) {
      options = options ? _.clone(options) : {};
      for (var i = 0; i < this.models.length; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({ silent: true }, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function push(model, options) {
      return this.add(model, _.extend({ at: this.length }, options));
    },

    // Remove a model from the end of the collection.
    pop: function pop(options) {
      var model = this.at(this.length - 1);
      return this.remove(model, options);
    },

    // Add a model to the beginning of the collection.
    unshift: function unshift(model, options) {
      return this.add(model, _.extend({ at: 0 }, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function shift(options) {
      var model = this.at(0);
      return this.remove(model, options);
    },

    // Slice out a sub-array of models from the collection.
    slice: function slice() {
      return _slice.apply(this.models, arguments);
    },

    // Get a model from the set by id, cid, model object with id or cid
    // properties, or an attributes object that is transformed through modelId.
    get: function get(obj) {
      if (obj == null) return void 0;
      return this._byId[obj] || this._byId[this.modelId(obj.attributes || obj)] || obj.cid && this._byId[obj.cid];
    },

    // Returns `true` if the model is in the collection.
    has: function has(obj) {
      return this.get(obj) != null;
    },

    // Get the model at the given index.
    at: function at(index) {
      if (index < 0) index += this.length;
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function where(attrs, first) {
      return this[first ? 'find' : 'filter'](attrs);
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function findWhere(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function sort(options) {
      var comparator = this.comparator;
      if (!comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      var length = comparator.length;
      if (_.isFunction(comparator)) comparator = _.bind(comparator, this);

      // Run sort based on type of `comparator`.
      if (length === 1 || _.isString(comparator)) {
        this.models = this.sortBy(comparator);
      } else {
        this.models.sort(comparator);
      }
      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function pluck(attr) {
      return this.map(attr + '');
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function fetch(options) {
      options = _.extend({ parse: true }, options);
      var success = options.success;
      var collection = this;
      options.success = function (resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success.call(options.context, collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function create(model, options) {
      options = options ? _.clone(options) : {};
      var wait = options.wait;
      model = this._prepareModel(model, options);
      if (!model) return false;
      if (!wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function (m, resp, callbackOpts) {
        if (wait) collection.add(m, callbackOpts);
        if (success) success.call(callbackOpts.context, m, resp, callbackOpts);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function parse(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function clone() {
      return new this.constructor(this.models, {
        model: this.model,
        comparator: this.comparator
      });
    },

    // Define how to uniquely identify models in the collection.
    modelId: function modelId(attrs) {
      return attrs[this.model.prototype.idAttribute || 'id'];
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function _reset() {
      this.length = 0;
      this.models = [];
      this._byId = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function _prepareModel(attrs, options) {
      if (this._isModel(attrs)) {
        if (!attrs.collection) attrs.collection = this;
        return attrs;
      }
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method called by both remove and set.
    _removeModels: function _removeModels(models, options) {
      var removed = [];
      for (var i = 0; i < models.length; i++) {
        var model = this.get(models[i]);
        if (!model) continue;

        var index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;

        // Remove references before triggering 'remove' event to prevent an
        // infinite loop. #3693
        delete this._byId[model.cid];
        var id = this.modelId(model.attributes);
        if (id != null) delete this._byId[id];

        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }

        removed.push(model);
        this._removeReference(model, options);
      }
      return removed;
    },

    // Method for checking whether an object should be considered a model for
    // the purposes of adding to the collection.
    _isModel: function _isModel(model) {
      return model instanceof Model;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function _addReference(model, options) {
      this._byId[model.cid] = model;
      var id = this.modelId(model.attributes);
      if (id != null) this._byId[id] = model;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function _removeReference(model, options) {
      delete this._byId[model.cid];
      var id = this.modelId(model.attributes);
      if (id != null) delete this._byId[id];
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function _onModelEvent(event, model, collection, options) {
      if (model) {
        if ((event === 'add' || event === 'remove') && collection !== this) return;
        if (event === 'destroy') this.remove(model, options);
        if (event === 'change') {
          var prevId = this.modelId(model.previousAttributes());
          var id = this.modelId(model.attributes);
          if (prevId !== id) {
            if (prevId != null) delete this._byId[prevId];
            if (id != null) this._byId[id] = model;
          }
        }
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var collectionMethods = { forEach: 3, each: 3, map: 3, collect: 3, reduce: 0,
    foldl: 0, inject: 0, reduceRight: 0, foldr: 0, find: 3, detect: 3, filter: 3,
    select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3,
    contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,
    head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,
    without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,
    isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3,
    sortBy: 3, indexBy: 3, findIndex: 3, findLastIndex: 3 };

  // Mix in each Underscore method as a proxy to `Collection#models`.
  addUnderscoreMethods(Collection, collectionMethods, 'models');

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function (options) {
    this.cid = _.uniqueId('view');
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be set as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function $(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function initialize() {},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function render() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function remove() {
      this._removeElement();
      this.stopListening();
      return this;
    },

    // Remove this view's element from the document and all event listeners
    // attached to it. Exposed for subclasses using an alternative DOM
    // manipulation API.
    _removeElement: function _removeElement() {
      this.$el.remove();
    },

    // Change the view's element (`this.el` property) and re-delegate the
    // view's events on the new element.
    setElement: function setElement(element) {
      this.undelegateEvents();
      this._setElement(element);
      this.delegateEvents();
      return this;
    },

    // Creates the `this.el` and `this.$el` references for this view using the
    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
    // context or an element. Subclasses can override this to utilize an
    // alternative DOM manipulation API and are only required to set the
    // `this.el` property.
    _setElement: function _setElement(el) {
      this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
      this.el = this.$el[0];
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    delegateEvents: function delegateEvents(events) {
      events || (events = _.result(this, 'events'));
      if (!events) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[method];
        if (!method) continue;
        var match = key.match(delegateEventSplitter);
        this.delegate(match[1], match[2], _.bind(method, this));
      }
      return this;
    },

    // Add a single event listener to the view's element (or a child element
    // using `selector`). This only works for delegate-able events: not `focus`,
    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
    delegate: function delegate(eventName, selector, listener) {
      this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
      return this;
    },

    // Clears all callbacks previously bound to the view by `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function undelegateEvents() {
      if (this.$el) this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // A finer-grained `undelegateEvents` for removing a single delegated event.
    // `selector` and `listener` are both optional.
    undelegate: function undelegate(eventName, selector, listener) {
      this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
      return this;
    },

    // Produces a DOM element to be assigned to your view. Exposed for
    // subclasses using an alternative DOM manipulation API.
    _createElement: function _createElement(tagName) {
      return document.createElement(tagName);
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function _ensureElement() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        this.setElement(this._createElement(_.result(this, 'tagName')));
        this._setAttributes(attrs);
      } else {
        this.setElement(_.result(this, 'el'));
      }
    },

    // Set attributes from a hash on this view's element.  Exposed for
    // subclasses using an alternative DOM manipulation API.
    _setAttributes: function _setAttributes(attributes) {
      this.$el.attr(attributes);
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function (method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = { type: type, dataType: 'json' };

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? { model: params.data } : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function (xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // Pass along `textStatus` and `errorThrown` from jQuery.
    var error = options.error;
    options.error = function (xhr, textStatus, errorThrown) {
      options.textStatus = textStatus;
      options.errorThrown = errorThrown;
      if (error) error.call(options.context, xhr, textStatus, errorThrown);
    };

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch': 'PATCH',
    'delete': 'DELETE',
    'read': 'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function () {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function (options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam = /(\(\?)?:\w+/g;
  var splatParam = /\*\w+/g;
  var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function initialize() {},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function route(_route, name, callback) {
      if (!_.isRegExp(_route)) _route = this._routeToRegExp(_route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(_route, function (fragment) {
        var args = router._extractParameters(_route, fragment);
        if (router.execute(callback, args, name) !== false) {
          router.trigger.apply(router, ['route:' + name].concat(args));
          router.trigger('route', name, args);
          Backbone.history.trigger('route', router, name, args);
        }
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function execute(callback, args, name) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function navigate(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function _bindRoutes() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route,
          routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function _routeToRegExp(route) {
      route = route.replace(escapeRegExp, '\\$&').replace(optionalParam, '(?:$1)?').replace(namedParam, function (match, optional) {
        return optional ? match : '([^/?]+)';
      }).replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function _extractParameters(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function (param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function () {
    this.handlers = [];
    this.checkUrl = _.bind(this.checkUrl, this);

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function atRoot() {
      var path = this.location.pathname.replace(/[^\/]$/, '$&/');
      return path === this.root && !this.getSearch();
    },

    // Does the pathname match the root?
    matchRoot: function matchRoot() {
      var path = this.decodeFragment(this.location.pathname);
      var rootPath = path.slice(0, this.root.length - 1) + '/';
      return rootPath === this.root;
    },

    // Unicode characters in `location.pathname` are percent encoded so they're
    // decoded for comparison. `%25` should not be decoded since it may be part
    // of an encoded parameter.
    decodeFragment: function decodeFragment(fragment) {
      return decodeURI(fragment.replace(/%25/g, '%2525'));
    },

    // In IE6, the hash fragment and search params are incorrect if the
    // fragment contains `?`.
    getSearch: function getSearch() {
      var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
      return match ? match[0] : '';
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function getHash(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the pathname and search params, without the root.
    getPath: function getPath() {
      var path = this.decodeFragment(this.location.pathname + this.getSearch()).slice(this.root.length - 1);
      return path.charAt(0) === '/' ? path.slice(1) : path;
    },

    // Get the cross-browser normalized URL fragment from the path or hash.
    getFragment: function getFragment(fragment) {
      if (fragment == null) {
        if (this._usePushState || !this._wantsHashChange) {
          fragment = this.getPath();
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function start(options) {
      if (History.started) throw new Error('Backbone.history has already been started');
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options = _.extend({ root: '/' }, this.options, options);
      this.root = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._hasHashChange = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);
      this._useHashChange = this._wantsHashChange && this._hasHashChange;
      this._wantsPushState = !!this.options.pushState;
      this._hasPushState = !!(this.history && this.history.pushState);
      this._usePushState = this._wantsPushState && this._hasPushState;
      this.fragment = this.getFragment();

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          var rootPath = this.root.slice(0, -1) || '/';
          this.location.replace(rootPath + '#' + this.getPath());
          // Return immediately as browser will do redirect to new url
          return true;

          // Or if we've started out with a hash-based route, but we're currently
          // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot()) {
          this.navigate(this.getHash(), { replace: true });
        }
      }

      // Proxy an iframe to handle location events if the browser doesn't
      // support the `hashchange` event, HTML5 history, or the user wants
      // `hashChange` but not `pushState`.
      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
        this.iframe = document.createElement('iframe');
        this.iframe.src = 'javascript:0';
        this.iframe.style.display = 'none';
        this.iframe.tabIndex = -1;
        var body = document.body;
        // Using `appendChild` will throw on IE < 9 if the document is not ready.
        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
        iWindow.document.open();
        iWindow.document.close();
        iWindow.location.hash = '#' + this.fragment;
      }

      // Add a cross-platform `addEventListener` shim for older browsers.
      var addEventListener = window.addEventListener || function (eventName, listener) {
        return attachEvent('on' + eventName, listener);
      };

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._usePushState) {
        addEventListener('popstate', this.checkUrl, false);
      } else if (this._useHashChange && !this.iframe) {
        addEventListener('hashchange', this.checkUrl, false);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function stop() {
      // Add a cross-platform `removeEventListener` shim for older browsers.
      var removeEventListener = window.removeEventListener || function (eventName, listener) {
        return detachEvent('on' + eventName, listener);
      };

      // Remove window listeners.
      if (this._usePushState) {
        removeEventListener('popstate', this.checkUrl, false);
      } else if (this._useHashChange && !this.iframe) {
        removeEventListener('hashchange', this.checkUrl, false);
      }

      // Clean up the iframe if necessary.
      if (this.iframe) {
        document.body.removeChild(this.iframe);
        this.iframe = null;
      }

      // Some environments will throw when clearing an undefined interval.
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function route(_route2, callback) {
      this.handlers.unshift({ route: _route2, callback: callback });
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function checkUrl(e) {
      var current = this.getFragment();

      // If the user pressed the back button, the iframe's hash will have
      // changed and we should use that for comparison.
      if (current === this.fragment && this.iframe) {
        current = this.getHash(this.iframe.contentWindow);
      }

      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function loadUrl(fragment) {
      // If the root doesn't match, no routes can match either.
      if (!this.matchRoot()) return false;
      fragment = this.fragment = this.getFragment(fragment);
      return _.some(this.handlers, function (handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function navigate(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = { trigger: !!options };

      // Normalize the fragment.
      fragment = this.getFragment(fragment || '');

      // Don't include a trailing slash on the root.
      var rootPath = this.root;
      if (fragment === '' || fragment.charAt(0) === '?') {
        rootPath = rootPath.slice(0, -1) || '/';
      }
      var url = rootPath + fragment;

      // Strip the hash and decode for matching.
      fragment = this.decodeFragment(fragment.replace(pathStripper, ''));

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._usePushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

        // If hash changes haven't been explicitly disabled, update the hash
        // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {
          var iWindow = this.iframe.contentWindow;

          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if (!options.replace) {
            iWindow.document.open();
            iWindow.document.close();
          }

          this._updateHash(iWindow.location, fragment, options.replace);
        }

        // If you've told us that you explicitly don't want fallback hashchange-
        // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function _updateHash(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History();

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function extend(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function child() {
        return parent.apply(this, arguments);
      };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function and add the prototype properties.
    child.prototype = _.create(parent.prototype, protoProps);
    child.prototype.constructor = child;

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function urlError() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function wrapError(model, options) {
    var error = options.error;
    options.error = function (resp) {
      if (error) error.call(options.context, model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/bootstrap/js/src/tooltip.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Popper) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global Popper */

var _util = __webpack_require__("./node_modules/bootstrap/js/src/util.js");

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0-beta): tooltip.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */

var Tooltip = function ($) {

  /**
   * Check for Popper dependency
   * Popper - https://popper.js.org
   */
  if (typeof Popper === 'undefined') {
    throw new Error('Bootstrap tooltips require Popper.js (https://popper.js.org)');
  }

  /**
   * ------------------------------------------------------------------------
   * Constants
   * ------------------------------------------------------------------------
   */

  var NAME = 'tooltip';
  var VERSION = '4.0.0-beta';
  var DATA_KEY = 'bs.tooltip';
  var EVENT_KEY = '.' + DATA_KEY;
  var JQUERY_NO_CONFLICT = $.fn[NAME];
  var TRANSITION_DURATION = 150;
  var CLASS_PREFIX = 'bs-tooltip';
  var BSCLS_PREFIX_REGEX = new RegExp('(^|\\s)' + CLASS_PREFIX + '\\S+', 'g');

  var DefaultType = {
    animation: 'boolean',
    template: 'string',
    title: '(string|element|function)',
    trigger: 'string',
    delay: '(number|object)',
    html: 'boolean',
    selector: '(string|boolean)',
    placement: '(string|function)',
    offset: '(number|string)',
    container: '(string|element|boolean)',
    fallbackPlacement: '(string|array)'
  };

  var AttachmentMap = {
    AUTO: 'auto',
    TOP: 'top',
    RIGHT: 'right',
    BOTTOM: 'bottom',
    LEFT: 'left'
  };

  var Default = {
    animation: true,
    template: '<div class="tooltip" role="tooltip">' + '<div class="arrow"></div>' + '<div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    selector: false,
    placement: 'top',
    offset: 0,
    container: false,
    fallbackPlacement: 'flip'
  };

  var HoverState = {
    SHOW: 'show',
    OUT: 'out'
  };

  var Event = {
    HIDE: 'hide' + EVENT_KEY,
    HIDDEN: 'hidden' + EVENT_KEY,
    SHOW: 'show' + EVENT_KEY,
    SHOWN: 'shown' + EVENT_KEY,
    INSERTED: 'inserted' + EVENT_KEY,
    CLICK: 'click' + EVENT_KEY,
    FOCUSIN: 'focusin' + EVENT_KEY,
    FOCUSOUT: 'focusout' + EVENT_KEY,
    MOUSEENTER: 'mouseenter' + EVENT_KEY,
    MOUSELEAVE: 'mouseleave' + EVENT_KEY
  };

  var ClassName = {
    FADE: 'fade',
    SHOW: 'show'
  };

  var Selector = {
    TOOLTIP: '.tooltip',
    TOOLTIP_INNER: '.tooltip-inner',
    ARROW: '.arrow'
  };

  var Trigger = {
    HOVER: 'hover',
    FOCUS: 'focus',
    CLICK: 'click',
    MANUAL: 'manual'

    /**
     * ------------------------------------------------------------------------
     * Class Definition
     * ------------------------------------------------------------------------
     */

  };
  var Tooltip = function () {
    function Tooltip(element, config) {
      _classCallCheck(this, Tooltip);

      // private
      this._isEnabled = true;
      this._timeout = 0;
      this._hoverState = '';
      this._activeTrigger = {};
      this._popper = null;

      // protected
      this.element = element;
      this.config = this._getConfig(config);
      this.tip = null;

      this._setListeners();
    }

    // getters

    _createClass(Tooltip, [{
      key: 'enable',


      // public

      value: function enable() {
        this._isEnabled = true;
      }
    }, {
      key: 'disable',
      value: function disable() {
        this._isEnabled = false;
      }
    }, {
      key: 'toggleEnabled',
      value: function toggleEnabled() {
        this._isEnabled = !this._isEnabled;
      }
    }, {
      key: 'toggle',
      value: function toggle(event) {
        if (event) {
          var dataKey = this.constructor.DATA_KEY;
          var context = $(event.currentTarget).data(dataKey);

          if (!context) {
            context = new this.constructor(event.currentTarget, this._getDelegateConfig());
            $(event.currentTarget).data(dataKey, context);
          }

          context._activeTrigger.click = !context._activeTrigger.click;

          if (context._isWithActiveTrigger()) {
            context._enter(null, context);
          } else {
            context._leave(null, context);
          }
        } else {

          if ($(this.getTipElement()).hasClass(ClassName.SHOW)) {
            this._leave(null, this);
            return;
          }

          this._enter(null, this);
        }
      }
    }, {
      key: 'dispose',
      value: function dispose() {
        clearTimeout(this._timeout);

        $.removeData(this.element, this.constructor.DATA_KEY);

        $(this.element).off(this.constructor.EVENT_KEY);
        $(this.element).closest('.modal').off('hide.bs.modal');

        if (this.tip) {
          $(this.tip).remove();
        }

        this._isEnabled = null;
        this._timeout = null;
        this._hoverState = null;
        this._activeTrigger = null;
        if (this._popper !== null) {
          this._popper.destroy();
        }
        this._popper = null;

        this.element = null;
        this.config = null;
        this.tip = null;
      }
    }, {
      key: 'show',
      value: function show() {
        var _this = this;

        if ($(this.element).css('display') === 'none') {
          throw new Error('Please use show on visible elements');
        }

        var showEvent = $.Event(this.constructor.Event.SHOW);
        if (this.isWithContent() && this._isEnabled) {
          $(this.element).trigger(showEvent);

          var isInTheDom = $.contains(this.element.ownerDocument.documentElement, this.element);

          if (showEvent.isDefaultPrevented() || !isInTheDom) {
            return;
          }

          var tip = this.getTipElement();
          var tipId = _util2.default.getUID(this.constructor.NAME);

          tip.setAttribute('id', tipId);
          this.element.setAttribute('aria-describedby', tipId);

          this.setContent();

          if (this.config.animation) {
            $(tip).addClass(ClassName.FADE);
          }

          var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;

          var attachment = this._getAttachment(placement);
          this.addAttachmentClass(attachment);

          var container = this.config.container === false ? document.body : $(this.config.container);

          $(tip).data(this.constructor.DATA_KEY, this);

          if (!$.contains(this.element.ownerDocument.documentElement, this.tip)) {
            $(tip).appendTo(container);
          }

          $(this.element).trigger(this.constructor.Event.INSERTED);

          this._popper = new Popper(this.element, tip, {
            placement: attachment,
            modifiers: {
              offset: {
                offset: this.config.offset
              },
              flip: {
                behavior: this.config.fallbackPlacement
              },
              arrow: {
                element: Selector.ARROW
              }
            },
            onCreate: function onCreate(data) {
              if (data.originalPlacement !== data.placement) {
                _this._handlePopperPlacementChange(data);
              }
            },
            onUpdate: function onUpdate(data) {
              _this._handlePopperPlacementChange(data);
            }
          });

          $(tip).addClass(ClassName.SHOW);

          // if this is a touch-enabled device we add extra
          // empty mouseover listeners to the body's immediate children;
          // only needed because of broken event delegation on iOS
          // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
          if ('ontouchstart' in document.documentElement) {
            $('body').children().on('mouseover', null, $.noop);
          }

          var complete = function complete() {
            if (_this.config.animation) {
              _this._fixTransition();
            }
            var prevHoverState = _this._hoverState;
            _this._hoverState = null;

            $(_this.element).trigger(_this.constructor.Event.SHOWN);

            if (prevHoverState === HoverState.OUT) {
              _this._leave(null, _this);
            }
          };

          if (_util2.default.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {
            $(this.tip).one(_util2.default.TRANSITION_END, complete).emulateTransitionEnd(Tooltip._TRANSITION_DURATION);
          } else {
            complete();
          }
        }
      }
    }, {
      key: 'hide',
      value: function hide(callback) {
        var _this2 = this;

        var tip = this.getTipElement();
        var hideEvent = $.Event(this.constructor.Event.HIDE);
        var complete = function complete() {
          if (_this2._hoverState !== HoverState.SHOW && tip.parentNode) {
            tip.parentNode.removeChild(tip);
          }

          _this2._cleanTipClass();
          _this2.element.removeAttribute('aria-describedby');
          $(_this2.element).trigger(_this2.constructor.Event.HIDDEN);
          if (_this2._popper !== null) {
            _this2._popper.destroy();
          }

          if (callback) {
            callback();
          }
        };

        $(this.element).trigger(hideEvent);

        if (hideEvent.isDefaultPrevented()) {
          return;
        }

        $(tip).removeClass(ClassName.SHOW);

        // if this is a touch-enabled device we remove the extra
        // empty mouseover listeners we added for iOS support
        if ('ontouchstart' in document.documentElement) {
          $('body').children().off('mouseover', null, $.noop);
        }

        this._activeTrigger[Trigger.CLICK] = false;
        this._activeTrigger[Trigger.FOCUS] = false;
        this._activeTrigger[Trigger.HOVER] = false;

        if (_util2.default.supportsTransitionEnd() && $(this.tip).hasClass(ClassName.FADE)) {

          $(tip).one(_util2.default.TRANSITION_END, complete).emulateTransitionEnd(TRANSITION_DURATION);
        } else {
          complete();
        }

        this._hoverState = '';
      }
    }, {
      key: 'update',
      value: function update() {
        if (this._popper !== null) {
          this._popper.scheduleUpdate();
        }
      }

      // protected

    }, {
      key: 'isWithContent',
      value: function isWithContent() {
        return Boolean(this.getTitle());
      }
    }, {
      key: 'addAttachmentClass',
      value: function addAttachmentClass(attachment) {
        $(this.getTipElement()).addClass(CLASS_PREFIX + '-' + attachment);
      }
    }, {
      key: 'getTipElement',
      value: function getTipElement() {
        return this.tip = this.tip || $(this.config.template)[0];
      }
    }, {
      key: 'setContent',
      value: function setContent() {
        var $tip = $(this.getTipElement());
        this.setElementContent($tip.find(Selector.TOOLTIP_INNER), this.getTitle());
        $tip.removeClass(ClassName.FADE + ' ' + ClassName.SHOW);
      }
    }, {
      key: 'setElementContent',
      value: function setElementContent($element, content) {
        var html = this.config.html;
        if ((typeof content === 'undefined' ? 'undefined' : _typeof(content)) === 'object' && (content.nodeType || content.jquery)) {
          // content is a DOM node or a jQuery
          if (html) {
            if (!$(content).parent().is($element)) {
              $element.empty().append(content);
            }
          } else {
            $element.text($(content).text());
          }
        } else {
          $element[html ? 'html' : 'text'](content);
        }
      }
    }, {
      key: 'getTitle',
      value: function getTitle() {
        var title = this.element.getAttribute('data-original-title');

        if (!title) {
          title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;
        }

        return title;
      }

      // private

    }, {
      key: '_getAttachment',
      value: function _getAttachment(placement) {
        return AttachmentMap[placement.toUpperCase()];
      }
    }, {
      key: '_setListeners',
      value: function _setListeners() {
        var _this3 = this;

        var triggers = this.config.trigger.split(' ');

        triggers.forEach(function (trigger) {
          if (trigger === 'click') {
            $(_this3.element).on(_this3.constructor.Event.CLICK, _this3.config.selector, function (event) {
              return _this3.toggle(event);
            });
          } else if (trigger !== Trigger.MANUAL) {
            var eventIn = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSEENTER : _this3.constructor.Event.FOCUSIN;
            var eventOut = trigger === Trigger.HOVER ? _this3.constructor.Event.MOUSELEAVE : _this3.constructor.Event.FOCUSOUT;

            $(_this3.element).on(eventIn, _this3.config.selector, function (event) {
              return _this3._enter(event);
            }).on(eventOut, _this3.config.selector, function (event) {
              return _this3._leave(event);
            });
          }

          $(_this3.element).closest('.modal').on('hide.bs.modal', function () {
            return _this3.hide();
          });
        });

        if (this.config.selector) {
          this.config = $.extend({}, this.config, {
            trigger: 'manual',
            selector: ''
          });
        } else {
          this._fixTitle();
        }
      }
    }, {
      key: '_fixTitle',
      value: function _fixTitle() {
        var titleType = _typeof(this.element.getAttribute('data-original-title'));
        if (this.element.getAttribute('title') || titleType !== 'string') {
          this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');
          this.element.setAttribute('title', '');
        }
      }
    }, {
      key: '_enter',
      value: function _enter(event, context) {
        var dataKey = this.constructor.DATA_KEY;

        context = context || $(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          $(event.currentTarget).data(dataKey, context);
        }

        if (event) {
          context._activeTrigger[event.type === 'focusin' ? Trigger.FOCUS : Trigger.HOVER] = true;
        }

        if ($(context.getTipElement()).hasClass(ClassName.SHOW) || context._hoverState === HoverState.SHOW) {
          context._hoverState = HoverState.SHOW;
          return;
        }

        clearTimeout(context._timeout);

        context._hoverState = HoverState.SHOW;

        if (!context.config.delay || !context.config.delay.show) {
          context.show();
          return;
        }

        context._timeout = setTimeout(function () {
          if (context._hoverState === HoverState.SHOW) {
            context.show();
          }
        }, context.config.delay.show);
      }
    }, {
      key: '_leave',
      value: function _leave(event, context) {
        var dataKey = this.constructor.DATA_KEY;

        context = context || $(event.currentTarget).data(dataKey);

        if (!context) {
          context = new this.constructor(event.currentTarget, this._getDelegateConfig());
          $(event.currentTarget).data(dataKey, context);
        }

        if (event) {
          context._activeTrigger[event.type === 'focusout' ? Trigger.FOCUS : Trigger.HOVER] = false;
        }

        if (context._isWithActiveTrigger()) {
          return;
        }

        clearTimeout(context._timeout);

        context._hoverState = HoverState.OUT;

        if (!context.config.delay || !context.config.delay.hide) {
          context.hide();
          return;
        }

        context._timeout = setTimeout(function () {
          if (context._hoverState === HoverState.OUT) {
            context.hide();
          }
        }, context.config.delay.hide);
      }
    }, {
      key: '_isWithActiveTrigger',
      value: function _isWithActiveTrigger() {
        for (var trigger in this._activeTrigger) {
          if (this._activeTrigger[trigger]) {
            return true;
          }
        }

        return false;
      }
    }, {
      key: '_getConfig',
      value: function _getConfig(config) {
        config = $.extend({}, this.constructor.Default, $(this.element).data(), config);

        if (config.delay && typeof config.delay === 'number') {
          config.delay = {
            show: config.delay,
            hide: config.delay
          };
        }

        if (config.title && typeof config.title === 'number') {
          config.title = config.title.toString();
        }

        if (config.content && typeof config.content === 'number') {
          config.content = config.content.toString();
        }

        _util2.default.typeCheckConfig(NAME, config, this.constructor.DefaultType);

        return config;
      }
    }, {
      key: '_getDelegateConfig',
      value: function _getDelegateConfig() {
        var config = {};

        if (this.config) {
          for (var key in this.config) {
            if (this.constructor.Default[key] !== this.config[key]) {
              config[key] = this.config[key];
            }
          }
        }

        return config;
      }
    }, {
      key: '_cleanTipClass',
      value: function _cleanTipClass() {
        var $tip = $(this.getTipElement());
        var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);
        if (tabClass !== null && tabClass.length > 0) {
          $tip.removeClass(tabClass.join(''));
        }
      }
    }, {
      key: '_handlePopperPlacementChange',
      value: function _handlePopperPlacementChange(data) {
        this._cleanTipClass();
        this.addAttachmentClass(this._getAttachment(data.placement));
      }
    }, {
      key: '_fixTransition',
      value: function _fixTransition() {
        var tip = this.getTipElement();
        var initConfigAnimation = this.config.animation;
        if (tip.getAttribute('x-placement') !== null) {
          return;
        }
        $(tip).removeClass(ClassName.FADE);
        this.config.animation = false;
        this.hide();
        this.show();
        this.config.animation = initConfigAnimation;
      }

      // static

    }], [{
      key: '_jQueryInterface',
      value: function _jQueryInterface(config) {
        return this.each(function () {
          var data = $(this).data(DATA_KEY);
          var _config = (typeof config === 'undefined' ? 'undefined' : _typeof(config)) === 'object' && config;

          if (!data && /dispose|hide/.test(config)) {
            return;
          }

          if (!data) {
            data = new Tooltip(this, _config);
            $(this).data(DATA_KEY, data);
          }

          if (typeof config === 'string') {
            if (data[config] === undefined) {
              throw new Error('No method named "' + config + '"');
            }
            data[config]();
          }
        });
      }
    }, {
      key: 'VERSION',
      get: function get() {
        return VERSION;
      }
    }, {
      key: 'Default',
      get: function get() {
        return Default;
      }
    }, {
      key: 'NAME',
      get: function get() {
        return NAME;
      }
    }, {
      key: 'DATA_KEY',
      get: function get() {
        return DATA_KEY;
      }
    }, {
      key: 'Event',
      get: function get() {
        return Event;
      }
    }, {
      key: 'EVENT_KEY',
      get: function get() {
        return EVENT_KEY;
      }
    }, {
      key: 'DefaultType',
      get: function get() {
        return DefaultType;
      }
    }]);

    return Tooltip;
  }();

  /**
   * ------------------------------------------------------------------------
   * jQuery
   * ------------------------------------------------------------------------
   */

  $.fn[NAME] = Tooltip._jQueryInterface;
  $.fn[NAME].Constructor = Tooltip;
  $.fn[NAME].noConflict = function () {
    $.fn[NAME] = JQUERY_NO_CONFLICT;
    return Tooltip._jQueryInterface;
  };

  return Tooltip;
}(jQuery);

exports.default = Tooltip;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/popper.js/dist/esm/popper.js")["default"]))

/***/ }),

/***/ "./node_modules/bootstrap/js/src/util.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * --------------------------------------------------------------------------
 * Bootstrap (v4.0.0-beta): util.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * --------------------------------------------------------------------------
 */

var Util = function ($) {

  /**
   * ------------------------------------------------------------------------
   * Private TransitionEnd Helpers
   * ------------------------------------------------------------------------
   */

  var transition = false;

  var MAX_UID = 1000000;

  var TransitionEndEvent = {
    WebkitTransition: 'webkitTransitionEnd',
    MozTransition: 'transitionend',
    OTransition: 'oTransitionEnd otransitionend',
    transition: 'transitionend'

    // shoutout AngusCroll (https://goo.gl/pxwQGp)
  };function toType(obj) {
    return {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
  }

  function isElement(obj) {
    return (obj[0] || obj).nodeType;
  }

  function getSpecialTransitionEndEvent() {
    return {
      bindType: transition.end,
      delegateType: transition.end,
      handle: function handle(event) {
        if ($(event.target).is(this)) {
          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params
        }
        return undefined;
      }
    };
  }

  function transitionEndTest() {
    if (window.QUnit) {
      return false;
    }

    var el = document.createElement('bootstrap');

    for (var name in TransitionEndEvent) {
      if (el.style[name] !== undefined) {
        return {
          end: TransitionEndEvent[name]
        };
      }
    }

    return false;
  }

  function transitionEndEmulator(duration) {
    var _this = this;

    var called = false;

    $(this).one(Util.TRANSITION_END, function () {
      called = true;
    });

    setTimeout(function () {
      if (!called) {
        Util.triggerTransitionEnd(_this);
      }
    }, duration);

    return this;
  }

  function setTransitionEndSupport() {
    transition = transitionEndTest();

    $.fn.emulateTransitionEnd = transitionEndEmulator;

    if (Util.supportsTransitionEnd()) {
      $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Public Util Api
   * --------------------------------------------------------------------------
   */

  var Util = {

    TRANSITION_END: 'bsTransitionEnd',

    getUID: function getUID(prefix) {
      do {
        // eslint-disable-next-line no-bitwise
        prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here
      } while (document.getElementById(prefix));
      return prefix;
    },
    getSelectorFromElement: function getSelectorFromElement(element) {
      var selector = element.getAttribute('data-target');
      if (!selector || selector === '#') {
        selector = element.getAttribute('href') || '';
      }

      try {
        var $selector = $(selector);
        return $selector.length > 0 ? selector : null;
      } catch (error) {
        return null;
      }
    },
    reflow: function reflow(element) {
      return element.offsetHeight;
    },
    triggerTransitionEnd: function triggerTransitionEnd(element) {
      $(element).trigger(transition.end);
    },
    supportsTransitionEnd: function supportsTransitionEnd() {
      return Boolean(transition);
    },
    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {
      for (var property in configTypes) {
        if (configTypes.hasOwnProperty(property)) {
          var expectedTypes = configTypes[property];
          var value = config[property];
          var valueType = value && isElement(value) ? 'element' : toType(value);

          if (!new RegExp(expectedTypes).test(valueType)) {
            throw new Error(componentName.toUpperCase() + ': ' + ('Option "' + property + '" provided type "' + valueType + '" ') + ('but expected type "' + expectedTypes + '".'));
          }
        }
      }
    }
  };

  setTransitionEndSupport();

  return Util;
}(jQuery);

exports.default = Util;

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}

/***/ }),

/***/ "./node_modules/kendo-ui-core/js/cultures/kendo.culture.fr-FR.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports =
/******/function (modules) {
	// webpackBootstrap
	/******/ // The module cache
	/******/var installedModules = {};

	/******/ // The require function
	/******/function __webpack_require__(moduleId) {

		/******/ // Check if module is in cache
		/******/if (installedModules[moduleId])
			/******/return installedModules[moduleId].exports;

		/******/ // Create a new module (and put it into the cache)
		/******/var module = installedModules[moduleId] = {
			/******/exports: {},
			/******/id: moduleId,
			/******/loaded: false
			/******/ };

		/******/ // Execute the module function
		/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

		/******/ // Flag the module as loaded
		/******/module.loaded = true;

		/******/ // Return the exports of the module
		/******/return module.exports;
		/******/
	}

	/******/ // expose the modules object (__webpack_modules__)
	/******/__webpack_require__.m = modules;

	/******/ // expose the module cache
	/******/__webpack_require__.c = installedModules;

	/******/ // __webpack_public_path__
	/******/__webpack_require__.p = "";

	/******/ // Load entry module and return exports
	/******/return __webpack_require__(0);
	/******/
}(
/************************************************************************/
/******/{

	/***/0:
	/***/function _(module, exports, __webpack_require__) {

		__webpack_require__(313);
		module.exports = __webpack_require__(313);

		/***/
	},

	/***/313:
	/***/function _(module, exports) {

		(function (window, undefined) {
			kendo.cultures["fr-FR"] = {
				name: "fr-FR",
				numberFormat: {
					pattern: ["-n"],
					decimals: 2,
					",": " ",
					".": ",",
					groupSize: [3],
					percent: {
						pattern: ["-n %", "n %"],
						decimals: 2,
						",": " ",
						".": ",",
						groupSize: [3],
						symbol: "%"
					},
					currency: {
						name: "Euro",
						abbr: "EUR",
						pattern: ["-n $", "n $"],
						decimals: 2,
						",": " ",
						".": ",",
						groupSize: [3],
						symbol: "€"
					}
				},
				calendars: {
					standard: {
						days: {
							names: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"],
							namesAbbr: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."],
							namesShort: ["di", "lu", "ma", "me", "je", "ve", "sa"]
						},
						months: {
							names: ["janvier", "février", "mars", "avril", "mai", "juin", "juillet", "août", "septembre", "octobre", "novembre", "décembre"],
							namesAbbr: ["janv.", "févr.", "mars", "avr.", "mai", "juin", "juil.", "août", "sept.", "oct.", "nov.", "déc."]
						},
						AM: [""],
						PM: [""],
						patterns: {
							d: "dd/MM/yyyy",
							D: "dddd d MMMM yyyy",
							F: "dddd d MMMM yyyy HH:mm:ss",
							g: "dd/MM/yyyy HH:mm",
							G: "dd/MM/yyyy HH:mm:ss",
							m: "d MMMM",
							M: "d MMMM",
							s: "yyyy'-'MM'-'dd'T'HH':'mm':'ss",
							t: "HH:mm",
							T: "HH:mm:ss",
							u: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'",
							y: "MMMM yyyy",
							Y: "MMMM yyyy"
						},
						"/": "/",
						":": ":",
						firstDay: 1
					}
				}
			};
		})(this);

		/***/
	}

	/******/ });

/***/ }),

/***/ "./node_modules/little-loader/lib/little-loader.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Script loading is difficult thanks to IE. We need callbacks to fire
 * immediately following the script's execution, with no other scripts
 * running in between. If other scripts on the page are able to run
 * between our script and its callback, bad things can happen, such as
 * `jQuery.noConflict` not being called in time, resulting in plugins
 * latching onto our version of jQuery, etc.
 *
 * For IE<10 we use a relatively well-documented "preloading" strategy,
 * which ensures that the script is ready to execute *before* appending
 * it to the DOM. That way when it is finally appended, it is
 * executed immediately.
 *
 * References:
 * - http://www.html5rocks.com/en/tutorials/speed/script-loading/
 * - http://blog.getify.com/ie11-please-bring-real-script-preloading-back/
 * - https://github.com/jrburke/requirejs/issues/526
 * - https://connect.microsoft.com/IE/feedback/details/729164/
 *           ie10-dynamic-script-element-fires-loaded-readystate-prematurely
 */
(function () {

  // Global state.
  var pendingScripts = {};
  var scriptCounter = 0;

  /**
   * Insert script into the DOM
   *
   * @param {Object} script Script DOM object
   * @returns {void}
   */
  var _addScript = function _addScript(script) {
    // Get the first script element, we're just going to use it
    // as a reference for where to insert ours. Do NOT try to do
    // this just once at the top and then re-use the same script
    // as a reference later. Some weird loaders *remove* script
    // elements after the browser has executed their contents,
    // so the same reference might not have a parentNode later.
    var firstScript = document.getElementsByTagName("script")[0];

    // Append the script to the DOM, triggering execution.
    firstScript.parentNode.insertBefore(script, firstScript);
  };

  /**
   * Load Script.
   *
   * @param {String}            src       URI of script
   * @param {Function|Object}   callback  (Optional) Called on script load completion,
   *                                      or options object
   * @param {Object}            context   (Optional) Callback context (`this`)
   * @returns {void}
   */
  var _lload = function _lload(src, callback, context) {
    /*eslint max-statements: [2, 32]*/
    var setup;

    if (callback && typeof callback !== "function") {
      context = callback.context || context;
      setup = callback.setup;
      callback = callback.callback;
    }

    var script = document.createElement("script");
    var done = false;
    var err;
    var _cleanup; // _must_ be set below.

    /**
     * Final handler for error or completion.
     *
     * **Note**: Will only be called _once_.
     *
     * @returns {void}
     */
    var _finish = function _finish() {
      // Only call once.
      if (done) {
        return;
      }
      done = true;

      // Internal cleanup.
      _cleanup();

      // Callback.
      if (callback) {
        callback.call(context, err);
      }
    };

    /**
     * Error handler
     *
     * @returns {void}
     */
    var _error = function _error() {
      err = new Error(src || "EMPTY");
      _finish();
    };

    if (script.readyState && !("async" in script)) {
      /*eslint-disable consistent-return*/

      // This section is only for IE<10. Some other old browsers may
      // satisfy the above condition and enter this branch, but we don't
      // support those browsers anyway.

      var id = scriptCounter++;
      var isReady = { loaded: true, complete: true };
      var inserted = false;

      // Clear out listeners, state.
      _cleanup = function _cleanup() {
        script.onreadystatechange = script.onerror = null;
        pendingScripts[id] = void 0;
      };

      // Attach the handler before setting src, otherwise we might
      // miss events (consider that IE could fire them synchronously
      // upon setting src, for example).
      script.onreadystatechange = function () {
        var firstState = script.readyState;

        // Protect against any errors from state change randomness.
        if (err) {
          return;
        }

        if (!inserted && isReady[firstState]) {
          inserted = true;

          // Append to DOM.
          _addScript(script);
        }

        // --------------------------------------------------------------------
        //                       GLORIOUS IE8 HACKAGE!!!
        // --------------------------------------------------------------------
        //
        // Oh IE8, how you disappoint. IE8 won't call `script.onerror`, so
        // we have to resort to drastic measures.
        // See, e.g. http://www.quirksmode.org/dom/events/error.html#t02
        //
        // As with all things development, there's a Stack Overflow comment that
        // asserts the following combinations of state changes in IE8 indicate a
        // script load error. And crazily, it seems to work!
        //
        // http://stackoverflow.com/a/18840568/741892
        //
        // The `script.readyState` transitions we're interested are:
        //
        // * If state starts as `loaded`
        // * Call `script.children`, which _should_ change state to `complete`
        // * If state is now `loading`, then **we have a load error**
        //
        // For the reader's amusement, here is HeadJS's catalog of various
        // `readyState` transitions in normal operation for IE:
        // https://github.com/headjs/headjs/blob/master/src/2.0.0/load.js#L379-L419
        if (firstState === "loaded") {
          // The act of accessing the property should change the script's
          // `readyState`.
          //
          // And, oh yeah, this hack is so hacky-ish we need the following
          // eslint disable...
          /*eslint-disable no-unused-expressions*/
          script.children;
          /*eslint-enable no-unused-expressions*/

          if (script.readyState === "loading") {
            // State transitions indicate we've hit the load error.
            //
            // **Note**: We are not intending to _return_ a value, just have
            // a shorter short-circuit code path here.
            return _error();
          }
        }

        // It's possible for readyState to be "complete" immediately
        // after we insert (and execute) the script in the branch
        // above. So check readyState again here and react without
        // waiting for another onreadystatechange.
        if (script.readyState === "complete") {
          _finish();
        }
      };

      // Onerror handler _may_ work here.
      script.onerror = _error;

      // Since we're not appending the script to the DOM yet, the
      // reference to our script element might get garbage collected
      // when this function ends, without onreadystatechange ever being
      // fired. This has been witnessed to happen. Adding it to
      // `pendingScripts` ensures this can't happen.
      pendingScripts[id] = script;

      // call the setup callback to mutate the script tag
      if (setup) {
        setup.call(context, script);
      }

      // This triggers a request for the script, but its contents won't
      // be executed until we append it to the DOM.
      script.src = src;

      // In some cases, the readyState is already "loaded" immediately
      // after setting src. It's a lie! Don't append to the DOM until
      // the onreadystatechange event says so.
    } else {
      // This section is for modern browsers, including IE10+.

      // Clear out listeners.
      _cleanup = function _cleanup() {
        script.onload = script.onerror = null;
      };

      script.onerror = _error;
      script.onload = _finish;
      script.async = true;
      script.charset = "utf-8";

      // call the setup callback to mutate the script tag
      if (setup) {
        setup.call(context, script);
      }

      script.src = src;

      // Append to DOM.
      _addScript(script);
    }
  };

  // UMD wrapper.
  /*global define:false*/
  if (( false ? "undefined" : _typeof(exports)) === "object" && ( false ? "undefined" : _typeof(module)) === "object") {
    // CommonJS
    module.exports = _lload;
  } else if (true) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
      return _lload;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    // VanillaJS
    window._lload = _lload;
  }
})();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/mustache/mustache.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */

/*global define: false Mustache: true*/

(function defineMustache(global, factory) {
  if (( false ? 'undefined' : _typeof(exports)) === 'object' && exports && typeof exports.nodeName !== 'string') {
    factory(exports); // CommonJS
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD
  } else {
    global.Mustache = {};
    factory(global.Mustache); // script, wsh, asp
  }
})(undefined, function mustacheFactory(mustache) {

  var objectToString = Object.prototype.toString;
  var isArray = Array.isArray || function isArrayPolyfill(object) {
    return objectToString.call(object) === '[object Array]';
  };

  function isFunction(object) {
    return typeof object === 'function';
  }

  /**
   * More correct typeof string handling array
   * which normally returns typeof 'object'
   */
  function typeStr(obj) {
    return isArray(obj) ? 'array' : typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
  }

  function escapeRegExp(string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
  }

  /**
   * Null safe way of checking whether or not an object,
   * including its prototype, has a given property
   */
  function hasProperty(obj, propName) {
    return obj != null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && propName in obj;
  }

  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
  // See https://github.com/janl/mustache.js/issues/189
  var regExpTest = RegExp.prototype.test;
  function testRegExp(re, string) {
    return regExpTest.call(re, string);
  }

  var nonSpaceRe = /\S/;
  function isWhitespace(string) {
    return !testRegExp(nonSpaceRe, string);
  }

  var entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;',
    '`': '&#x60;',
    '=': '&#x3D;'
  };

  function escapeHtml(string) {
    return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
      return entityMap[s];
    });
  }

  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var equalsRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;

  /**
   * Breaks up the given `template` string into a tree of tokens. If the `tags`
   * argument is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
   * course, the default is to use mustaches (i.e. mustache.tags).
   *
   * A token is an array with at least 4 elements. The first element is the
   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
   * all text that appears outside a symbol this element is "text".
   *
   * The second element of a token is its "value". For mustache tags this is
   * whatever else was inside the tag besides the opening symbol. For text tokens
   * this is the text itself.
   *
   * The third and fourth elements of the token are the start and end indices,
   * respectively, of the token in the original template.
   *
   * Tokens that are the root node of a subtree contain two more elements: 1) an
   * array of tokens in the subtree and 2) the index in the original template at
   * which the closing tag for that section begins.
   */
  function parseTemplate(template, tags) {
    if (!template) return [];

    var sections = []; // Stack to hold section tokens
    var tokens = []; // Buffer to hold the tokens
    var spaces = []; // Indices of whitespace tokens on the current line
    var hasTag = false; // Is there a {{tag}} on the current line?
    var nonSpace = false; // Is there a non-space char on the current line?

    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace() {
      if (hasTag && !nonSpace) {
        while (spaces.length) {
          delete tokens[spaces.pop()];
        }
      } else {
        spaces = [];
      }

      hasTag = false;
      nonSpace = false;
    }

    var openingTagRe, closingTagRe, closingCurlyRe;
    function compileTags(tagsToCompile) {
      if (typeof tagsToCompile === 'string') tagsToCompile = tagsToCompile.split(spaceRe, 2);

      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2) throw new Error('Invalid tags: ' + tagsToCompile);

      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
      closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
      closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
    }

    compileTags(tags || mustache.tags);

    var scanner = new Scanner(template);

    var start, type, value, chr, token, openSection;
    while (!scanner.eos()) {
      start = scanner.pos;

      // Match any text between tags.
      value = scanner.scanUntil(openingTagRe);

      if (value) {
        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
          chr = value.charAt(i);

          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } else {
            nonSpace = true;
          }

          tokens.push(['text', chr, start, start + 1]);
          start += 1;

          // Check for whitespace on the current line.
          if (chr === '\n') stripSpace();
        }
      }

      // Match the opening tag.
      if (!scanner.scan(openingTagRe)) break;

      hasTag = true;

      // Get the tag type.
      type = scanner.scan(tagRe) || 'name';
      scanner.scan(whiteRe);

      // Get the tag value.
      if (type === '=') {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(closingTagRe);
      } else if (type === '{') {
        value = scanner.scanUntil(closingCurlyRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(closingTagRe);
        type = '&';
      } else {
        value = scanner.scanUntil(closingTagRe);
      }

      // Match the closing tag.
      if (!scanner.scan(closingTagRe)) throw new Error('Unclosed tag at ' + scanner.pos);

      token = [type, value, start, scanner.pos];
      tokens.push(token);

      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === '/') {
        // Check section nesting.
        openSection = sections.pop();

        if (!openSection) throw new Error('Unopened section "' + value + '" at ' + start);

        if (openSection[1] !== value) throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
      } else if (type === 'name' || type === '{' || type === '&') {
        nonSpace = true;
      } else if (type === '=') {
        // Set the tags for the next time around.
        compileTags(value);
      }
    }

    // Make sure there are no open sections when we're done.
    openSection = sections.pop();

    if (openSection) throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

    return nestTokens(squashTokens(tokens));
  }

  /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */
  function squashTokens(tokens) {
    var squashedTokens = [];

    var token, lastToken;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      if (token) {
        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }

    return squashedTokens;
  }

  /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */
  function nestTokens(tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];

    var token, section;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      switch (token[0]) {
        case '#':
        case '^':
          collector.push(token);
          sections.push(token);
          collector = token[4] = [];
          break;
        case '/':
          section = sections.pop();
          section[5] = token[2];
          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
          break;
        default:
          collector.push(token);
      }
    }

    return nestedTokens;
  }

  /**
   * A simple string scanner that is used by the template parser to find
   * tokens in template strings.
   */
  function Scanner(string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }

  /**
   * Returns `true` if the tail is empty (end of string).
   */
  Scanner.prototype.eos = function eos() {
    return this.tail === '';
  };

  /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */
  Scanner.prototype.scan = function scan(re) {
    var match = this.tail.match(re);

    if (!match || match.index !== 0) return '';

    var string = match[0];

    this.tail = this.tail.substring(string.length);
    this.pos += string.length;

    return string;
  };

  /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */
  Scanner.prototype.scanUntil = function scanUntil(re) {
    var index = this.tail.search(re),
        match;

    switch (index) {
      case -1:
        match = this.tail;
        this.tail = '';
        break;
      case 0:
        match = '';
        break;
      default:
        match = this.tail.substring(0, index);
        this.tail = this.tail.substring(index);
    }

    this.pos += match.length;

    return match;
  };

  /**
   * Represents a rendering context by wrapping a view object and
   * maintaining a reference to the parent context.
   */
  function Context(view, parentContext) {
    this.view = view;
    this.cache = { '.': this.view };
    this.parent = parentContext;
  }

  /**
   * Creates a new context using the given view with this context
   * as the parent.
   */
  Context.prototype.push = function push(view) {
    return new Context(view, this);
  };

  /**
   * Returns the value of the given name in this context, traversing
   * up the context hierarchy if the value is absent in this context's view.
   */
  Context.prototype.lookup = function lookup(name) {
    var cache = this.cache;

    var value;
    if (cache.hasOwnProperty(name)) {
      value = cache[name];
    } else {
      var context = this,
          names,
          index,
          lookupHit = false;

      while (context) {
        if (name.indexOf('.') > 0) {
          value = context.view;
          names = name.split('.');
          index = 0;

          /**
           * Using the dot notion path in `name`, we descend through the
           * nested objects.
           *
           * To be certain that the lookup has been successful, we have to
           * check if the last object in the path actually has the property
           * we are looking for. We store the result in `lookupHit`.
           *
           * This is specially necessary for when the value has been set to
           * `undefined` and we want to avoid looking up parent contexts.
           **/
          while (value != null && index < names.length) {
            if (index === names.length - 1) lookupHit = hasProperty(value, names[index]);

            value = value[names[index++]];
          }
        } else {
          value = context.view[name];
          lookupHit = hasProperty(context.view, name);
        }

        if (lookupHit) break;

        context = context.parent;
      }

      cache[name] = value;
    }

    if (isFunction(value)) value = value.call(this.view);

    return value;
  };

  /**
   * A Writer knows how to take a stream of tokens and render them to a
   * string, given a context. It also maintains a cache of templates to
   * avoid the need to parse the same template twice.
   */
  function Writer() {
    this.cache = {};
  }

  /**
   * Clears all cached templates in this writer.
   */
  Writer.prototype.clearCache = function clearCache() {
    this.cache = {};
  };

  /**
   * Parses and caches the given `template` and returns the array of tokens
   * that is generated from the parse.
   */
  Writer.prototype.parse = function parse(template, tags) {
    var cache = this.cache;
    var tokens = cache[template];

    if (tokens == null) tokens = cache[template] = parseTemplate(template, tags);

    return tokens;
  };

  /**
   * High-level method that is used to render the given `template` with
   * the given `view`.
   *
   * The optional `partials` argument may be an object that contains the
   * names and templates of partials that are used in the template. It may
   * also be a function that is used to load partial templates on the fly
   * that takes a single argument: the name of the partial.
   */
  Writer.prototype.render = function render(template, view, partials) {
    var tokens = this.parse(template);
    var context = view instanceof Context ? view : new Context(view);
    return this.renderTokens(tokens, context, partials, template);
  };

  /**
   * Low-level method that renders the given array of `tokens` using
   * the given `context` and `partials`.
   *
   * Note: The `originalTemplate` is only ever used to extract the portion
   * of the original template that was contained in a higher-order section.
   * If the template doesn't use higher-order sections, this argument may
   * be omitted.
   */
  Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate) {
    var buffer = '';

    var token, symbol, value;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      value = undefined;
      token = tokens[i];
      symbol = token[0];

      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);else if (symbol === '&') value = this.unescapedValue(token, context);else if (symbol === 'name') value = this.escapedValue(token, context);else if (symbol === 'text') value = this.rawValue(token);

      if (value !== undefined) buffer += value;
    }

    return buffer;
  };

  Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate) {
    var self = this;
    var buffer = '';
    var value = context.lookup(token[1]);

    // This function is used to render an arbitrary template
    // in the current context by higher-order sections.
    function subRender(template) {
      return self.render(template, context, partials);
    }

    if (!value) return;

    if (isArray(value)) {
      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
      }
    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' || typeof value === 'string' || typeof value === 'number') {
      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
    } else if (isFunction(value)) {
      if (typeof originalTemplate !== 'string') throw new Error('Cannot use higher-order sections without the original template');

      // Extract the portion of the original template that the section contains.
      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

      if (value != null) buffer += value;
    } else {
      buffer += this.renderTokens(token[4], context, partials, originalTemplate);
    }
    return buffer;
  };

  Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate) {
    var value = context.lookup(token[1]);

    // Use JavaScript's definition of falsy. Include empty arrays.
    // See https://github.com/janl/mustache.js/issues/186
    if (!value || isArray(value) && value.length === 0) return this.renderTokens(token[4], context, partials, originalTemplate);
  };

  Writer.prototype.renderPartial = function renderPartial(token, context, partials) {
    if (!partials) return;

    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
    if (value != null) return this.renderTokens(this.parse(value), context, partials, value);
  };

  Writer.prototype.unescapedValue = function unescapedValue(token, context) {
    var value = context.lookup(token[1]);
    if (value != null) return value;
  };

  Writer.prototype.escapedValue = function escapedValue(token, context) {
    var value = context.lookup(token[1]);
    if (value != null) return mustache.escape(value);
  };

  Writer.prototype.rawValue = function rawValue(token) {
    return token[1];
  };

  mustache.name = 'mustache.js';
  mustache.version = '2.3.0';
  mustache.tags = ['{{', '}}'];

  // All high-level mustache.* functions use this writer.
  var defaultWriter = new Writer();

  /**
   * Clears all cached templates in the default writer.
   */
  mustache.clearCache = function clearCache() {
    return defaultWriter.clearCache();
  };

  /**
   * Parses and caches the given template in the default writer and returns the
   * array of tokens it contains. Doing this ahead of time avoids the need to
   * parse templates on the fly as they are rendered.
   */
  mustache.parse = function parse(template, tags) {
    return defaultWriter.parse(template, tags);
  };

  /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer.
   */
  mustache.render = function render(template, view, partials) {
    if (typeof template !== 'string') {
      throw new TypeError('Invalid template! Template should be a "string" ' + 'but "' + typeStr(template) + '" was given as the first ' + 'argument for mustache#render(template, view, partials)');
    }

    return defaultWriter.render(template, view, partials);
  };

  // This is here for backwards compatibility with 0.4.x.,
  /*eslint-disable */ // eslint wants camel cased function name
  mustache.to_html = function to_html(template, view, partials, send) {
    /*eslint-enable*/

    var result = mustache.render(template, view, partials);

    if (isFunction(send)) {
      send(result);
    } else {
      return result;
    }
  };

  // Export the escaping function so that the user may override it.
  // See https://github.com/janl/mustache.js/issues/244
  mustache.escape = escapeHtml;

  // Export these mainly for testing, but also for advanced usage.
  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;

  return mustache;
});

/***/ }),

/***/ "./node_modules/popper.js/dist/esm/popper.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.12.5
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var nativeHints = ['native code', '[object MutationObserverConstructor]'];

/**
 * Determine if a function is implemented natively (as opposed to a polyfill).
 * @method
 * @memberof Popper.Utils
 * @argument {Function | undefined} fn the function to check
 * @returns {Boolean}
 */
var isNative = function isNative(fn) {
  return nativeHints.some(function (hint) {
    return (fn || '').toString().indexOf(hint) > -1;
  });
};

var isBrowser = typeof window !== 'undefined';
var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
  if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
    timeoutDuration = 1;
    break;
  }
}

function microtaskDebounce(fn) {
  var scheduled = false;
  var i = 0;
  var elem = document.createElement('span');

  // MutationObserver provides a mechanism for scheduling microtasks, which
  // are scheduled *before* the next task. This gives us a way to debounce
  // a function but ensure it's called *before* the next paint.
  var observer = new MutationObserver(function () {
    fn();
    scheduled = false;
  });

  observer.observe(elem, { attributes: true });

  return function () {
    if (!scheduled) {
      scheduled = true;
      elem.setAttribute('x-index', i);
      i = i + 1; // don't use compund (+=) because it doesn't get optimized in V8
    }
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

// It's common for MutationObserver polyfills to be seen in the wild, however
// these rely on Mutation Events which only occur when an element is connected
// to the DOM. The algorithm used in this module does not use a connected element,
// and so we must ensure that a *native* MutationObserver is available.
var supportsNativeMutationObserver = isBrowser && isNative(window.MutationObserver);

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsNativeMutationObserver ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element || ['HTML', 'BODY', '#document'].indexOf(element.nodeName) !== -1) {
    return window.document.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  // NOTE: 1 DOM access here
  var offsetParent = element && element.offsetParent;
  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return window.document.documentElement;
  }

  // .offsetParent will return the closest TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return window.document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = window.document.documentElement;
    var scrollingElement = window.document.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return +styles['border' + sideA + 'Width'].split('px')[0] + +styles['border' + sideB + 'Width'].split('px')[0];
}

/**
 * Tells if you are running Internet Explorer 10
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean} isIE10
 */
var isIE10 = undefined;

var isIE10$1 = function isIE10$1() {
  if (isIE10 === undefined) {
    isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;
  }
  return isIE10;
};

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE10$1() ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
}

function getWindowSizes() {
  var body = window.document.body;
  var html = window.document.documentElement;
  var computedStyle = isIE10$1() && window.getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty = function defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  if (isIE10$1()) {
    try {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } catch (err) {}
  } else {
    rect = element.getBoundingClientRect();
  }

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
  var width = sizes.width || element.clientWidth || result.right - result.left;
  var height = sizes.height || element.clientHeight || result.bottom - result.top;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var isIE10 = isIE10$1();
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = +styles.borderTopWidth.split('px')[0];
  var borderLeftWidth = +styles.borderLeftWidth.split('px')[0];

  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = +styles.marginTop.split('px')[0];
    var marginLeft = +styles.marginLeft.split('px')[0];

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var html = window.document.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = getScroll(html);
  var scrollLeft = getScroll(html, 'left');

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  return isFixed(getParentNode(element));
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  // NOTE: 1 DOM access here
  var boundaries = { top: 0, left: 0 };
  var offsetParent = findCommonOffsetParent(popper, reference);

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(popper));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = window.document.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = window.document.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  boundaries.left += padding;
  boundaries.top += padding;
  boundaries.right -= padding;
  boundaries.bottom -= padding;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var commonOffsetParent = findCommonOffsetParent(popper, reference);
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier.function) {
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier.function || modifier.fn;
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length - 1; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof window.document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroy the popper
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.left = '';
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicity asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? window : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  window.addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  window.removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger onUpdate callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    window.cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper.
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  // floor sides to avoid blurry text
  var offsets = {
    left: Math.floor(popper.left),
    top: Math.floor(popper.top),
    bottom: Math.floor(popper.bottom),
    right: Math.floor(popper.right)
  };

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    top = -offsetParentRect.height + offsets.bottom;
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    left = -offsetParentRect.width + offsets.right;
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjuction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var popperMarginSide = getStyleComputedProperty(data.instance.popper, 'margin' + sideCapitalized).replace('px', '');
  var sideValue = center - getClientRect(data.offsets.popper)[side] - popperMarginSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = {};
  data.offsets.arrow[side] = Math.round(sideValue);
  data.offsets.arrow[altSide] = ''; // make sure to unset any eventual altSide value from the DOM node

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-right` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement);
  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unitless, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the height.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * An scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper this makes sure the popper has always a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier, can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near eachothers
   * without leaving any gap between the two. Expecially useful when the arrow is
   * enabled and you want to assure it to point to its reference element.
   * It cares only about the first axis, you can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjuction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations).
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position,
     * the popper will never be placed outside of the defined boundaries
     * (except if keepTogether is enabled)
     */
    boundariesElement: 'viewport'
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define you own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3d transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties.
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the informations used by Popper.js
 * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overriden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass as 3rd argument an object with the same
 * structure of this object, example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Whether events (resize, scroll) are initially enabled
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated, this callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Create a new Popper.js instance
   * @class Popper
   * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper.
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference.jquery ? reference[0] : reference;
    this.popper = popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedule an update, it will run on the next UI update available
     * @method scheduleUpdate
     * @memberof Popper
     */

    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */

Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

exports.default = Popper;
//# sourceMappingURL=popper.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/underscore/underscore.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (true) {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
      return _;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
}.call(this));


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/collections/attributes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/models/mAttributeData.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/models/mAttributeStructural.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/models/mAttributeArray.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, ModelAttributeData, ModelAttributeStructural, ModelAttributeArray) {
    'use strict';

    return Backbone.Collection.extend({
        comparator: "logicalOrder",

        model: function CollectionAttributesSelectModel(attributes, options) {
            if (attributes.type === "array") {
                return new ModelAttributeArray(attributes, options);
            }
            if (attributes.type === "tab" || attributes.type === "frame") {
                return new ModelAttributeStructural(attributes, options);
            }
            return new ModelAttributeData(attributes, options);
        },

        initialize: function CollectionAttributes_initialize(values, options) {
            this.documentModel = options.documentModel;
            this.renderOptions = options.renderOptions;
            this.renderMode = options.renderMode;
        },

        destroy: function CollectionAttributes_destroy() {
            var model;
            while (model = this.first()) {
                // jshint ignore:line
                model.destroy();
            }
            delete this.documentModel;
            delete this.renderOptions;
            delete this.renderMode;
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/collections/contentAttributes.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone) {
    'use strict';

    return Backbone.Collection.extend({

        comparator: "logicalOrder",

        toData: function toData(index, extended) {
            var elements = [];
            this.each(function (currentAttribute) {
                elements.push(currentAttribute.toData(index, extended));
            });
            return elements;
        },

        destroy: function destroy() {
            var model;
            while (model = this.first()) {
                // jshint ignore:line
                model.destroy();
            }
        },

        propageEvent: function propageEvent(eventName) {
            this.each(function (currentModel) {
                currentModel.trigger(eventName);
                if (currentModel.get("content")) {
                    currentModel.get("content").propageEvent(eventName);
                }
            });
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/collections/menus.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/models/mMenu.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, ModelMenu) {
    'use strict';

    return Backbone.Collection.extend({
        model: ModelMenu,

        destroy: function CollectionMenu_destroy() {
            var model;
            while (model = this.first()) {
                // jshint ignore:line
                model.destroy();
            }
        },

        _deepSearchMenu: function CollectionMenu__deepSearchMenu(contents, id, key, value) {
            var scope = this,
                subMenu,
                i,
                subSubMenu;
            if (contents) {
                for (i = 0; i < contents.length; i++) {
                    subMenu = contents[i];
                    if (subMenu.id === id) {
                        if (key) {
                            subMenu[key] = value;
                        }
                        return subMenu;
                    } else {
                        subSubMenu = scope._deepSearchMenu(subMenu.content, id, key, value);
                        if (subSubMenu) {
                            return subSubMenu;
                        }
                    }
                }
            }
            return null;
        },

        getMenu: function CollectionMenu_getMenu(id) {
            var menuInfo = null,
                menuInfoItem = null,
                scope = this;

            if (this.get(id)) {
                return this.get(id).attributes;
            } else {
                this.each(function (oneMenu) {
                    if (oneMenu.get("content")) {
                        menuInfoItem = scope._deepSearchMenu(oneMenu.get("content"), id);
                        if (menuInfoItem) {
                            menuInfo = menuInfoItem;
                        }
                    }
                });
                return menuInfo;
            }
        },

        setMenu: function CollectionMenu_setMenu(id, key, value) {
            var menuInfo = null,
                menuInfoItem = null,
                scope = this,
                menuModel = null,
                newContent = {};

            if (this.get(id)) {
                menuModel = this.get(id);
                menuModel.set(key, value);
                return menuModel.attributes;
            } else {
                this.each(function (oneMenu) {
                    if (oneMenu.get("content")) {
                        menuInfoItem = scope._deepSearchMenu(oneMenu.get("content"), id, key, value);
                        if (menuInfoItem) {
                            newContent = oneMenu.get("content");
                            oneMenu.set("content", newContent);
                            menuInfo = newContent;
                            oneMenu.trigger('change');
                        }
                    }
                });
                return menuInfo;
            }
        }

    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/controllerObjects/attributeInterface.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function attributeInterface(_) {
    'use strict';

    var AttributPrototype = function AttributePrototype() {
        this.id = this._attributeModel.id;
    };
    /**
     * Get the property of the current attribute
     *
     * @returns {*}
     */
    AttributPrototype.prototype.getProperties = function AttributeInterfaceGetProperties() {
        var properties = _.clone(this._attributeModel.attributes),
            content = properties.content;
        properties = _.omit(properties, "isValueAttribute", "title", "attributeValue", "content");
        properties.content = [];
        if (content && content.length) {
            properties.content = content.map(function attributeInterface_convertChild(currentAttribute) {
                return new AttributeInterface(currentAttribute);
            });
        }
        return properties;
    };

    /**
     * Change the label of an attribute
     *
     * @returns {*}
     */
    AttributPrototype.prototype.setLabel = function AttributeInterfaceSetLabel(label) {
        this._attributeModel.set("label", label);
    };

    /**
     * Get the data to build a widget
     *
     * @returns {*}
     */
    AttributPrototype.prototype.getWidgetData = function AttributeInterfaceGetWidgetData(index) {
        return _.clone(this._attributeModel.toData(index, true));
    };

    /**
     * Get the options of the current attribute
     * @returns {*}
     */
    AttributPrototype.prototype.getOptions = function AttributeInterfaceGetOptions() {
        var options = this._attributeModel.getOptions();
        return _.clone(options);
    };

    /**
     * Get an option of the current attribute
     *
     * @param name
     * @returns {*}
     */
    AttributPrototype.prototype.getOption = function AttributeInterfaceGetOption(name) {
        return this._attributeModel.getOption(name);
    };

    /**
     * Set an option of the current
     * Add an effect only on beforeRender
     * @param name
     * @param value
     * @constructor
     */
    AttributPrototype.prototype.setOption = function AttributeInterfaceSetOption(name, value) {
        this._attributeModel.setOption(name, value);
    };

    AttributPrototype.prototype.getValue = function AttributeInterfaceGetValue(type) {
        if (_.isUndefined(type) || type === "current") {
            return this._attributeModel.get("attributeValue");
        }
        if (type === "previous") {
            return this._attributeModel.previous("attributeValue");
        }
        if (type === "initial") {
            return this._attributeModel._initialAttributeValue;
        }
        if (type === "all") {
            return {
                "current": this._attributeModel.get("attributeValue"),
                "previous": this._attributeModel.previous("attributeValue"),
                "initial": this._attributeModel._initialAttributeValue
            };
        }
        throw new Error("Unknown type of getValue (current, previous, initial, all");
    };

    AttributPrototype.prototype.setValue = function AttributeInterfaceSetValue(value, dryRun) {
        var index;
        var currentValue;
        if (this._attributeModel.get("multiple")) {
            if (_.isArray(value)) {
                _.each(value, function AttributeInterfaceSetValueVerify(singleValue) {
                    if (!_.isObject(singleValue) || _.isUndefined(singleValue.value)) {
                        throw new Error("Each values must be an object with at least value properties");
                    }
                });
            } else {
                if (!_.isObject(value) || _.isUndefined(value.value) || _.isUndefined(value.index) || value.index === null) {
                    throw new Error("Value must be an object with at least value and index properties");
                }

                index = parseInt(value.index);
                if (index < 0) {
                    throw new Error("Index value must be positive or null");
                }

                if (this._attributeModel.isDoubleMultiple()) {
                    if (!_.isArray(value.value)) {
                        throw new Error("Value must be an array for multiple in arrays");
                    }
                    value = value.value;
                } else {
                    value = _.defaults(value, { displayValue: value.value });
                }

                currentValue = this._attributeModel.get("attributeValue").slice();
                currentValue[index] = _.clone(value);
                value = currentValue;
            }
        } else {
            if (!_.isObject(value) || _.isUndefined(value.value)) {
                throw new Error("Value must be an object with at least value properties");
            }

            value = _.defaults(value, { displayValue: value.value });
        }
        if (!dryRun) {
            this._attributeModel.set("attributeValue", value);
        }
    };

    AttributPrototype.prototype.toJSON = function AttributeInterfacetoJSON() {
        return {
            "id": this._attributeModel.id,
            "properties": _.omit(this._attributeModel.attributes, "isValueAttribute", "title", "options", "attributeValue"),
            "options": this._attributeModel.getOptions()
        };
    };

    var AttributeInterface = function AttributeInterface(attributeModel) {
        this._attributeModel = attributeModel;
        AttributPrototype.call(this);
    };

    AttributeInterface.prototype = Object.create(AttributPrototype.prototype);
    AttributeInterface.prototype.constructor = AttributPrototype;

    return AttributeInterface;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/controllerObjects/constraintHandler.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function require_constraintHandler(_) {
    'use strict';

    return function ConstraintHandler() {
        var _messages = [];
        this.addConstraintMessage = function addConstraintMessage(message, index) {
            index = _.isNumber(index) ? index : -1;
            _messages.push({ message: message, index: index });
        };
        this.getConstraintMessages = function getConstraintMessages() {
            return _messages.slice(0);
        };
        this.hasConstraintMessages = function hasConstraintMessages() {
            return _messages.length > 0;
        };
        this.deleteConstaintMessages = function deleteConstaintMessages() {
            _messages = [];
        };
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/controllerObjects/menuInterface.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function menuInterface(_) {
    'use strict';

    var MenuError = function MenuError(message) {
        this.name = 'MenuError';
        this.message = message || 'Default Message';
        this.stack = new Error().stack;
    };
    MenuError.prototype = Object.create(Error.prototype);
    MenuError.prototype.constructor = MenuError;

    var MenuPrototope = function AttributePrototype() {
        if (this._menuModel) {
            this.id = this._menuModel.id;
        } else {
            this.id = null;
        }
    };
    MenuPrototope.prototype._menuModel = null;
    MenuPrototope.prototype._set = function MenuPrototope_set(key, value, options) {
        if (options && options.strict === true && !this.id) {
            throw new MenuError("This menu doesn't exist");
        }
        if (this.id || options && options.strict === true) {
            this._menuModel.set(key, value, options);
        }
    };
    /**
     * Get the property of the current attribute
     *
     * @returns {*}
     */
    MenuPrototope.prototype.getProperties = function menuInterfaceGetProperties(options) {
        if (options && options.strict === true && !this.id) {
            throw new MenuError("This menu doesn't exist");
        }
        if (this.id || options && options.strict === true) {
            return _.clone(this._menuModel.attributes);
        }
        return {};
    };

    /**
     * Disable an item menu
     *
     * @returns {*}
     */
    MenuPrototope.prototype.disable = function menuInterfaceDisable(options) {
        this._set("visibility", "disabled", options);
    };
    /**
     * Enable and show an item menu
     *
     * @returns {*}
     */
    MenuPrototope.prototype.enable = function menuInterfaceEnable(options) {
        this._set("visibility", "visible", options);
    };

    /**
     * Hide an item menu
     *
     * @returns {*}
     */
    MenuPrototope.prototype.hide = function menuInterfaceHide(options) {
        this._set("visibility", "hidden", options);
    };

    /**
     * Change text label
     * @param label raw text
     *
     * @returns {*}
     * @param options
     */
    MenuPrototope.prototype.setLabel = function menuInterfaceSetLabel(label, options) {
        this._set("label", label, options);
    };

    /**
     * Change html label
     * @param label html fragment
     *
     * @returns {*}
     * @param options
     */
    MenuPrototope.prototype.setHtmlLabel = function menuInterfaceSetHtmlLabel(label, options) {
        this._set("htmlLabel", label, options);
    };

    /**
     * Change icon url
     * @param url image url
     *
     * @returns {*}
     * @param options
     */
    MenuPrototope.prototype.setIconUrl = function menuInterfaceSetIconUrl(url, options) {
        this._set("iconUrl", url, options);
    };
    /**
     * Change custom css class
     * @param cssClass css class
     *
     * @returns {*}
     * @param options
     */
    MenuPrototope.prototype.setCssClass = function menuInterfaceSetCssClass(cssClass, options) {
        this._set("cssClass", cssClass, options);
    };

    /**
     * Change url
     * @param url
     *
     * @returns {*}
     * @param options
     */
    MenuPrototope.prototype.setUrl = function menuInterfaceSetUrl(url, options) {
        this._set("url", url, options);
    };

    MenuPrototope.prototype.redraw = function menuInterfaceRedraw() {
        this._menuModel.trigger("reload");
    };

    var MenuInterface = function menuInterface(attributeModel) {
        this._menuModel = attributeModel;
        MenuPrototope.call(this);
    };

    MenuInterface.prototype = Object.create(MenuPrototope.prototype);
    MenuInterface.prototype.constructor = MenuPrototope;

    return MenuInterface;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/controllerObjects/transitionInterface.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function require_transitionInterface(_) {
    'use strict';

    var TransitionInterfacePrototype = function TransitionInterfacePrototype() {};

    TransitionInterfacePrototype.prototype.getValues = function TransitionInterfacePrototype_getValues() {
        if (!this._TransitionModel) {
            return null;
        }
        return this._TransitionModel.toJSON();
    };

    TransitionInterfacePrototype.prototype.hide = function TransitionInterfacePrototype_hide() {
        if (!this._TransitionModel) {
            return null;
        }
        return this._TransitionModel.trigger("hide");
    };

    TransitionInterfacePrototype.prototype.show = function TransitionInterfacePrototype_show() {
        if (!this._TransitionModel) {
            return null;
        }
        return this._TransitionModel.trigger("show");
    };

    TransitionInterfacePrototype.prototype.close = function TransitionInterfacePrototype_close() {
        if (!this._TransitionModel) {
            return null;
        }
        return this._TransitionModel.trigger("close");
    };

    var TransitionInterface = function TransitionInterface(transitionModel, $el, nextState, transition) {
        this._TransitionModel = transitionModel;
        this.$el = $el;
        this.nextState = nextState;
        this.transition = transition;
        TransitionInterfacePrototype.call(this);
    };

    TransitionInterface.prototype = Object.create(TransitionInterfacePrototype.prototype);
    TransitionInterface.prototype.constructor = TransitionInterfacePrototype;

    return TransitionInterface;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/i18n/documentCatalog.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

window.dcp = window.dcp || {};

(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./src/Apps/DOCUMENT/IHM/i18n/translatorFactory.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //Load translation and load i18n handler for non require project
        $.get("api/v1/i18n/DOCUMENT").done(function translationLoaded(catalog) {
            window.dcp.i18n = catalog;
            factory(window.dcp.translatorFactory);
            //Trigger an event when translation loaded
            $(window).trigger("documentCatalogLoaded");
        });
    }
})(window, function documentCatalog(translatorFactory) {
    "use strict";
    //Register document translation in the global window.dcp.documentCatalog

    window.dcp.documentCatalog = translatorFactory(window.dcp.i18n);
    return window.dcp.documentCatalog;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/i18n/translatorFactory.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
// use "text!dcpContextRoot/api/v1/i18n/DOCUMENT" to get only DDUI translation

window.dcp = window.dcp || {};

(function umdRequire(root, requireFunction) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (requireFunction),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    root.dcp.translatorFactory = requireFunction([]);
})(window, function require_translatorFactory() {
    "use strict";

    var isString = function isString(obj) {
        return typeof obj === 'string';
    };

    return function catalog(translation) {
        if (isString(translation)) {
            try {
                translation = JSON.parse(translation);
            } catch (e) {
                translation = { data: { catalog: {} } };
                console.error("Locale catalog error : " + e.message);
            }
        }

        return {
            _catalog: translation.data.catalog,
            _locale: translation.data.locale,

            /**
             * Return key translation
             * @param key text to translate
             * @returns string
             */
            _: function i18n_gettext(key) {
                if (key && this._catalog[key]) {
                    return this._catalog[key];
                }
                return key;
            },
            /**
             * Return key translation in context
             * @param key text to translate
             * @param ctxt context
             * @returns {*}
             */
            ___: function i18n_pgettext(key, ctxt) {
                if (key && this._catalog && this._catalog._msgctxt_ && this._catalog._msgctxt_[ctxt] && this._catalog._msgctxt_[ctxt][key]) {
                    return this._catalog._msgctxt_[ctxt][key];
                }
                return key;
            },
            /**
             * Return some info on the current locale
             * 
             * @returns {locale|{culture}|*|string|string}
             */
            getLocale: function i18n_getLocale() {
                return this._locale;
            }
        };
    };
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/loading/loading.css":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/mainDocument.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("./src/Apps/DOCUMENT/IHM/loading/loading.css");

var _jquery = __webpack_require__("external \"jQuery\"");

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Main bootstraper
 */
/*global require, console*/
_jquery2.default.get("api/v1/i18n/DOCUMENT").done(function translationLoaded(catalog) {

    //Trigger an event when translation loaded
    window.dcp.i18n = catalog;
    var _ = __webpack_require__("./node_modules/underscore/underscore.js");
    __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/documentController/documentController.js");
    __webpack_require__("external \"kendo\"");

    'use strict';
    console.timeEnd("js loading");

    var $document = (0, _jquery2.default)(".document"),
        currentValues,
        varWidgetValue = "widgetValue";

    window.dcp = window.dcp || {};

    window.dcp.documentReady = false;

    if (!window.dcp.viewData && window.location.hash) {
        currentValues = window.location.hash;
        if (currentValues[0] === "#") {
            currentValues = currentValues.slice(1);
        }
        if (currentValues.indexOf(varWidgetValue) === 0) {
            try {
                window.dcp.viewData = JSON.parse(currentValues.slice(varWidgetValue.length));
            } catch (ex1) {
                try {
                    window.dcp.viewData = JSON.parse(decodeURI(currentValues.slice(varWidgetValue.length)));
                } catch (ex2) {
                    $document.documentController("showMessage", {
                        type: "error",
                        message: "unable to retrieve document"
                    });
                }
            }
        }
    }

    window.dcp.triggerReload = function triggerReload() {
        // Init bind events in case of use extern document controller
        if (window.documentLoaded && _.isFunction(window.documentLoaded) && !window.dcp.documentReady) {
            window.documentLoaded($document, window.dcp.viewData);
            window.dcp.documentReady = true;
        }
    };

    if (window.dcp.viewData !== false && window.dcp.viewData.initid) {
        $document.documentController(window.dcp.viewData);
        $document.one("documentready", function launchReady() {
            window.dcp.triggerReload();
            _.each(window.dcp.messages, function (msg) {
                $document.documentController("showMessage", {
                    type: msg.type,
                    message: msg.contentText
                });
            });
        });
    } else {
        $document.documentController();
        window.dcp.triggerReload();
    }

    window.dcp.document = $document;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/models/mAttribute.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/backbone/backbone.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function require_mAttribute(_, $, Backbone) {
    'use strict';

    return Backbone.Model.extend({

        typeModel: "ddui:attribute",
        defaults: {
            title: null,
            isValueAttribute: false,
            parent: undefined,
            mode: "read",
            errorMessage: null
        },

        initialize: function mAttributeinitialize() {
            this.listenTo(this, "change:documentMode", this._computeMode);
            this.listenTo(this, "change:visibility", this._computeMode);
            this._computeValueMode();
            this._computeMode();
            this.set("title", this.id + '(' + this.get("label") + ')');
            this.set("errorMessage", null);
        },

        toData: function mAttributetoData(index, extended) {
            var content = this.toJSON();
            if (typeof index !== "undefined" && index !== null && this.get("multiple") === false) {
                throw new Error("You need to be multiple");
            }
            if (_.isNumber(index)) {
                content.attributeValue = content.attributeValue ? content.attributeValue[index] : null;
                content.index = index;
            }
            content.isDisplayable = this.isDisplayable();
            content.content = [];
            if (this.get("content") && _.isFunction(this.get("content").toData)) {
                content.content = this.get("content").toData(index, extended);
            }
            if (extended) {
                content.renderOptions = this.getOptions();
                content.labels = content.labels || {};
                content.locale = this.getDocumentModel().get("locale");
                content.templates = {};
                if (this.getTemplates().attribute) {
                    if (this.getTemplates().attribute[this.get("type")]) {
                        content.templates = this.getTemplates().attribute[this.get("type")];
                    } else {
                        // fallback in case of no specific templates
                        content.templates = this.getTemplates().attribute["default"];
                    }
                }
                content.deleteButton = true;
                content.sourceValues = this.get("enumItems");
                content.sourceUri = this.get("enumUrl");
                if (!content.templates.label) {
                    content.templates.label = this.getTemplates().attribute.label;
                }
            }
            return content;
        },

        isDisplayable: function mAttributeisDisplayable() {
            var canBeDisplayable;
            if (this.get("mode") === "hidden") {
                return false;
            }
            if (this.get("isValueAttribute")) {
                if (this.get("mode") === "read") {
                    if (this.getOption('showEmptyContent') !== null) {
                        return true;
                    } else {
                        canBeDisplayable = this.get("attributeValue") && this.get("attributeValue").value !== null;
                        if (_.isArray(this.get("attributeValue"))) {
                            canBeDisplayable = _.isArray(this.get("attributeValue")) && this.get("attributeValue").length > 0;
                        }
                        return canBeDisplayable;
                    }
                } else if (this.get("mode") === "write") {
                    return true;
                }
            }
            if (this.get("content").length === 0) {
                return false;
            }
            if (this.getOption('showEmptyContent') === null) {
                if (this.get("content").some) {
                    return this.get("content").some(function mAttribute_checkDisplayable(value) {
                        return value.isDisplayable();
                    });
                }
                return false;
            }
            return true;
        },

        hasMultipleOption: function mAttributehasMultipleOption() {
            return this.attributes.options && this.attributes.options.multiple === "yes";
        },

        isDoubleMultiple: function mAttributehasMultipleOption() {
            return this.hasMultipleOption() && this.getParent().get("type") === "array";
        },

        getParent: function mAttributegetParent() {
            if (this.attributes.parent) {
                return this.getDocumentModel().get('attributes').get(this.attributes.parent);
            }
            return null;
        },

        hasValueChanged: function mAttributehasReallyChanged() {
            return this.get("attributeValue") && (this.get("attributeValue").value !== undefined && ((this._initialAttributeValue || {}).value || '') !== (this.get("attributeValue").value || '') || !_.isEqual(_.pluck(_.flatten(this._initialAttributeValue), "value"), _.pluck(_.flatten(this.get("attributeValue")), "value")));
        },

        _computeMode: function mAttribute_computeMode() {
            var visibility = this.get("visibility"),
                documentMode = this.collection.renderMode;
            if (visibility === "H" || visibility === "I") {
                this.set("mode", "hidden");
                return;
            }
            if (documentMode === "view") {
                if (visibility === "O") {
                    this.set("mode", "hidden");
                    return;
                }
                if (this.get("isValueAttribute") && (_.isEmpty(this.get("attributeValue")) || _.isUndefined(this.get("attributeValue") || this.get("attributeValue").value === null))) {
                    if (this.getOption('showEmptyContent') === null) {
                        this.set("mode", "hidden");
                        return;
                    }
                }
                this.set("mode", "read");
                return;
            }
            if (documentMode === "edit") {
                if (visibility === "W" || visibility === "O") {
                    this.set("mode", "write");
                    return;
                }
                if (visibility === "R") {
                    this.set("mode", "hidden");
                    return;
                }
                if (visibility === "R" || visibility === "S") {
                    this.set("mode", "read");
                    return;
                }
                if (visibility === "U") {
                    this.set("mode", "write");
                    this.set("addTool", false);
                    return;
                }
            }
            throw new Error("unkown mode " + documentMode + " or visibility " + visibility + " " + this.get("id"));
        },

        _computeValueMode: function mAttribute_computeValueMode() {
            var type = this.get("type"),
                visibility = this.get("visibility");
            if (type === "frame" || type === "array" || type === "tab" || visibility === "I") {
                this.set("isValueAttribute", false);
            }
        },
        /**
         * Return all options for an attribute
         *
         * @returns {{}}
         */
        getOptions: function mAttributegetOptions() {
            var optionsCommon = {},
                optionsValue = {},
                optionsAttribute = {},
                renderOptions,
                labels = {};
            this._options = this._options || false;

            if (this._options === false) {
                renderOptions = this.collection.renderOptions;
                if (renderOptions.common) {
                    optionsCommon = renderOptions.common || {};
                    labels = _.clone(optionsCommon.translatedLabels) || {};
                }

                if (renderOptions.types) {
                    optionsValue = renderOptions.types[this.get("type")] || {};
                    labels = _.extend(labels, _.clone(optionsValue.translatedLabels));
                }
                if (renderOptions.attributes) {
                    optionsAttribute = renderOptions.attributes[this.id] || {};
                }
                // labels must be merged
                optionsAttribute.labels = _.extend(labels, optionsAttribute.translatedLabels);
                this._options = {};
            }

            _.extend(this._options, optionsCommon, optionsValue, optionsAttribute);

            return this._options;
        },

        /**
         * Get value for an option
         *
         * @param key option identifier
         * @returns {*}
         */
        getOption: function mAttributegetOption(key) {
            var options = this.getOptions();
            if (typeof options[key] !== "undefined") {
                return options[key];
            }
            return null;
        },

        /**
         * Set the value of an option
         *
         * @param key
         * @param value
         * @returns {*}
         */
        setOption: function mAttributesetOption(key, value) {
            var options = this.getOptions();
            options[key] = value;
            this._options = options;
            this.trigger("optionModified", key);
            return this;
        },

        getDocumentModel: function mAttributegetDocumentModelgetDocumentModel() {
            return this.collection.documentModel;
        },

        getTemplates: function mAttributegetTemplatesgetTemplates() {
            var templates = this.getDocumentModel().get("templates");
            if (!templates) {
                templates = window.dcp.templates;
            }
            return templates;
        },

        setErrorMessage: function mAttributesetErrorMessage(message, index) {
            var parentId = this.get('parent');
            if (this.get("multiple") && typeof index !== "undefined") {
                var errorMessage = this.get('errorMessage') || [];
                // delete duplicate
                _.reject(errorMessage, function mAttribute_reindex(indexMessage) {
                    return indexMessage.index === index;
                });
                this.set('errorMessage', [{ message: message, index: index }].concat(errorMessage));
            } else {
                this.set('errorMessage', message);
            }
            if (parentId) {
                // Propagate error message on parent structure
                var parentModel = this.getDocumentModel().get('attributes').get(parentId);
                if (parentModel) {
                    parentModel.setErrorMessage(message);
                }
            }
        },

        checkConstraint: function mAttributecheckConstraint() {
            return true;
        },

        haveView: function mAttributeHaveView() {
            var view = { haveView: false, elements: $() };
            this.trigger("haveView", view);
            return view;
        },
        /**
         * Attribute model are not linked to REST element so always new
         * @returns {boolean}
         */
        isNew: function mAttribute_isNew() {
            return true;
        }

    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/models/mAttributeArray.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/models/mAttributeStructural.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, AttributeStructuralModel) {
    'use strict';

    return AttributeStructuralModel.extend({

        typeModel: "ddui:attributeArray",
        removeIndexedLine: function mAttributeArrayRemoveIndexLine(index) {
            this.trigger("removeWidgetLine", { index: index }, { silent: true });
            this.trigger("array", "remove", this, index);
        },

        addIndexedLine: function mAttributeArrayaddIndexedLine(index) {
            this.trigger("addWidgetLine", { index: index });
            this.trigger("array", "add", this, index);
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/models/mAttributeData.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/models/mAttribute.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/controllerObjects/constraintHandler.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function require_mAttributeData(_, AttributeModel, ConstraintHandler) {
    'use strict';

    return AttributeModel.extend({
        typeModel: "ddui:attributeData",
        defaults: {
            isValueAttribute: true,
            multiple: false,
            attributeValue: null
        },

        initialize: function mAttributeinitialize() {
            this.listenTo(this, "change:attributeValue", this.checkConstraint);
            this._initialAttributeValue = this.get("attributeValue") || { value: null };
            AttributeModel.prototype.initialize.apply(this, arguments);
        },

        getValue: function mAttributegetValue() {
            return this.get("attributeValue");
        },
        setValue: function mAttributesetValue(value, index) {
            var currentValue, idx;
            if (this.get("multiple") && !_.isNumber(index) && !_.isArray(value)) {
                throw new Error("You need to add an index to set value for a multiple id " + this.id);
            }
            if (this.get("multiple") && index >= 0) {
                currentValue = _.clone(this.get("attributeValue"));
                if (currentValue.length < index) {
                    for (idx = currentValue.length; idx < index; idx++) {
                        currentValue.push({ value: null, displayValue: '' });
                    }
                }
                currentValue[index] = value;
                this.set("attributeValue", currentValue);
            } else {
                this.set("attributeValue", value);
            }
        },

        addValue: function mAttributeaddValue(value, index, options) {
            var currentValue;
            if (this.hasMultipleOption() && !_.isNumber(index)) {
                throw new Error("You need to add an index to set value for a multiple id " + this.id);
            }
            // clone array references
            currentValue = _.toArray(_.map(this.get("attributeValue"), _.clone));

            if (this.hasMultipleOption() && index >= 0) {
                //Init the multiple value if void
                if (!currentValue[index]) {
                    currentValue[index] = [];
                }
                currentValue[index].push(value);
                this.set("attributeValue", currentValue, options);
            } else {
                currentValue.push(value);
                this.set("attributeValue", currentValue, options);
            }
        },

        removeIndexValue: function mAttributeremoveIndexValue(index, options) {
            var currentValue, oldValue;
            if (!this.get("multiple") || !_.isNumber(index)) {
                throw new Error("You need to add an index to set value for a multiple id " + this.id);
            }
            oldValue = this.get("attributeValue");
            currentValue = _.clone(this.get("attributeValue"));
            _.each(currentValue, function mAttributeRemoveIndex(value, currentIndex) {
                currentIndex = parseInt(currentIndex, 10);
                if (currentIndex === index) {
                    delete currentValue[index];
                }
                if (currentIndex > index && oldValue[currentIndex]) {
                    delete currentValue[currentIndex];
                    currentValue[currentIndex - 1] = oldValue[currentIndex];
                }
            });
            currentValue = _.filter(currentValue, function removeUndefined(currentValue) {
                return !_.isUndefined(currentValue);
            });
            this.set("attributeValue", currentValue, { notUpdateArray: true });
        },

        /**
         * Add an indexed value with or without default value
         * Used by attributes in array to add new line or duplicate line
         *
         * @param index
         * @param copy
         * @param updateArray set to true to resize array widget
         */
        createIndexedValue: function mAttributeCreateIndexedValue(index, copy, updateArray) {
            var currentValue, defaultValue;
            var newValue;
            if (!this.get("multiple") || !_.isNumber(index)) {
                throw new Error("You need to add an index to set value for a multiple id " + this.id);
            }
            currentValue = _.toArray(_.map(this.get("attributeValue"), _.clone));
            defaultValue = this.attributes.defaultValue;
            if (copy) {
                newValue = _.clone(currentValue[index]);
            } else if (defaultValue) {
                newValue = defaultValue;
            } else if (this.hasMultipleOption()) {
                newValue = [];
            } else {
                newValue = { value: null, displayValue: '' };
            }

            if (index > currentValue.length) {
                currentValue.push(newValue);
            } else {
                currentValue.splice(index, 0, newValue);
            }
            this.set("attributeValue", currentValue, { notUpdateArray: !updateArray });
        },

        /**
         * Add values to indexed element
         * Used by attributes in array to add new line or duplicate line
         *
         * @param newValue
         * @param index
         */
        addIndexedValue: function mAttributeAddIndexedValue(newValue, index) {
            var currentValue;
            if (!_.isNumber(index)) {
                throw new Error("You need to add an index to set value indexed value " + this.id);
            }
            currentValue = _.toArray(_.map(this.get("attributeValue"), _.clone));

            if (index > currentValue.length) {
                currentValue.push(newValue);
            } else {
                currentValue.splice(index, 0, newValue);
            }
            this.set("attributeValue", currentValue);
        },

        /**
         * move a value in multiple value attribute
         * @param fromIndex
         * @param toIndex
         */
        moveIndexValue: function mAttributemoveIndexValue(fromIndex, toIndex) {
            var currentValue, fromValue;
            if (!this.get("multiple")) {
                throw new Error("Move only multiple attribute : " + this.id);
            }
            currentValue = _.toArray(this.get("attributeValue"));
            fromValue = _.clone(currentValue[fromIndex]);

            currentValue.splice(fromIndex, 1);
            currentValue.splice(toIndex, 0, fromValue);

            this.set("attributeValue", currentValue);
            this.trigger("moved", { from: fromIndex, to: toIndex });
        },

        getNbLines: function mAttributegetNbLines() {
            var nbLines = 0;
            if (!this.get("multiple")) {
                return -1;
            }
            _.each(this.get("attributeValue"), function mAttributeGetMaxLine(value, index) {
                if (index > nbLines) {
                    nbLines = index;
                }
            });
            return nbLines;
        },

        isInArray: function mAttributeisInArray() {
            var aparent = this.getParent();
            return aparent && aparent.attributes && aparent.attributes.type === "array";
        },

        checkConstraint: function mAttributecheckConstraint(config) {
            var response = new ConstraintHandler(),
                responseText = {};
            var scope = this;
            config = _.extend({ clearError: this.hasInternalError, displayError: true }, config);
            this.trigger("constraint", { model: this, response: response, value: this.get("attributeValue") });
            if (response.hasConstraintMessages()) {

                _.each(response.getConstraintMessages(), function mAttributeData_checkConstraintElement(currentResponse) {
                    responseText[currentResponse.index] = responseText[currentResponse.index] || '';
                    responseText[currentResponse.index] += currentResponse.message + " ";
                });
                if (config.displayError) {
                    this.hasInternalError = true;
                    // Force redraw
                    scope.setErrorMessage(null); // jshint ignore:line

                    _.each(responseText, function mAttributeData_checkErrorMessage(text, index) {
                        index = parseInt(index);
                        scope.setErrorMessage(text, index);
                    });
                }
                return false;
            } else {
                if (config.clearError) {
                    this.setErrorMessage(null);
                    this.hasInternalError = false;
                }
                return true;
            }
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/models/mAttributeStructural.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/models/mAttribute.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/collections/contentAttributes.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, AttributeModel, CollectionContentAttributes) {
    'use strict';

    return AttributeModel.extend({
        typeModel: "ddui:structureAttribute",
        defaults: {
            content: []
        },

        setContentCollection: function mAttributesetContentCollection(attributes) {
            var collection = new CollectionContentAttributes();
            _.each(attributes, function (currentChild) {
                collection.push(currentChild);
            });
            this.set("content", collection);
        }

    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/models/mDocument.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define, console, require*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js"), __webpack_require__("./node_modules/little-loader/lib/little-loader.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/models/mDocumentProperties.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/models/mDocumentLock.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/models/mFamilyStructure.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/collections/attributes.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/collections/menus.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/i18n/documentCatalog.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function mDocument($, _, Backbone, load, DocumentProperties, DocumentLock, FamilyStructure, CollectionAttributes, CollectionMenus, i18n) {
    'use strict';

    var flattenAttributes = function mDocumentflattenAttributes(currentAttributes, attributes, parent) {
        if (!_.isArray(attributes)) {
            attributes = _.values(attributes);
        }
        if (parent) {
            _.each(attributes, function mDocumentEachflattenParentAttributes(value) {
                value.parent = parent;
            });
        }
        currentAttributes = _.union(currentAttributes, attributes);
        _.each(attributes, function mDocumentEachflattenAttributes(currentAttr) {
            if (currentAttr.content) {
                currentAttributes = _.union(currentAttributes, flattenAttributes(currentAttributes, currentAttr.content, currentAttr.id));
            }
        });
        return currentAttributes;
    };

    //noinspection JSValidateJSDoc
    return Backbone.Model.extend({
        typeModel: "ddui:document",
        idAttribute: "initid",

        defaults: {
            revision: -1,
            viewId: undefined,
            renderMode: "view",
            properties: undefined,
            menus: undefined,
            attributes: undefined
        },
        // Record custom data in model directly - not in model property because must not be reset by clear method
        _customClientData: {},
        _uploadingFile: 0,
        /**
         * Compute the REST URL for the current document
         *
         * Used internaly by backbone in fetch, save, destroy
         *
         * @returns {string}
         */
        url: function mDocumenturl() {
            var urlData = "api/v1/",
                viewId = this.get("viewId");
            var customClientData = this._customClientData;
            var currentMethod = this.get("currentHttpMethod");
            var revision = this.get("revision");

            if (this.get("creationFamid") && this.id === null) {
                urlData += "families/" + encodeURIComponent(this.get("creationFamid")) + "/documentsViews/";
            } else {
                urlData += "documents/" + encodeURIComponent(this.id);
                //Don't add revision for the deletion of a alive document
                if (revision !== null && currentMethod !== "delete") {
                    if (_.isObject(revision) && revision.state) {
                        urlData += "/revisions/" + encodeURIComponent("state:" + revision.state);
                    } else if (revision >= 0) {
                        urlData += "/revisions/" + encodeURIComponent(revision);
                    }
                }
                if (viewId === undefined) {
                    if (this.get("renderMode") === "view" || currentMethod === "delete") {
                        viewId = "!defaultConsultation";
                    } else if (this.get("renderMode") === "edit") {
                        viewId = "!defaultEdition";
                    } else {
                        viewId = "!defaultConsultation";
                    }
                }
                if (currentMethod === "delete" && this.get("renderMode") === "edit") {
                    viewId = "!defaultConsultation";
                }
                urlData += "/views/" + encodeURIComponent(viewId);
            }

            if (!_.isEmpty(customClientData) && (currentMethod === "read" || currentMethod === "delete")) {
                urlData += "?customClientData=" + encodeURIComponent(JSON.stringify(customClientData));
            }
            return urlData;
        },

        /**
         * override Backbone sync to record method
         * @param method
         * @param model
         * @param options
         * @returns {*}
         */
        sync: function mDocumentSync(method, model, options) {
            this.set("currentHttpMethod", method); // record for url method
            return Backbone.Model.prototype.sync.apply(this, arguments);
        },
        /**
         * Initialize event handling
         *
         */
        initialize: function mDocumentinitialize() {
            var theModel = this;

            this.listenTo(this, "dduiDocumentFail", this.propagateSynchroError);
            this.listenTo(this, "destroy", this.destroySubcollection);
            this.listenTo(this, "destroy", this.unbindLoadEvent);

            $(window).on("beforeunload." + this.cid, function mDocumentBeforeUnload() {
                var security = theModel.get("properties") ? theModel.get("properties").get("security") : null,
                    event = { prevent: false };
                if (theModel.hasAttributesChanged()) {
                    return i18n.___("The form has been modified and is is not saved", "ddui");
                }

                theModel.trigger("beforeClose", event, theModel.getServerProperties(), this._customClientData);

                if (event.prevent) {
                    return i18n.___("Unable to close the document", "ddui");
                }

                if (theModel.get("renderMode") === "edit" && security && security.lock && security.lock.temporary) {
                    // No use model destroy : page is destroyed before request is some case
                    $.ajax({
                        url: "api/v1/documents/" + theModel.get("initid") + "/locks/temporary",
                        type: "DELETE",
                        async: false
                    });
                    theModel.set("unlocking", true);
                }
            });

            $(window).on("pagehide." + this.cid, function mDocumentPageHide(event) {
                var security = theModel.get("properties") ? theModel.get("properties").get("security") : null;
                var unlocking = theModel.get("unlocking");

                theModel.trigger("close", event, theModel.getServerProperties(), this._customClientData);

                if (!unlocking && theModel.get("renderMode") === "edit" && security && security.lock && security.lock.temporary) {
                    $.ajax({
                        url: "api/v1/documents/" + theModel.get("initid") + "/locks/temporary",
                        type: "DELETE",
                        async: false
                    });
                }
            });
        },

        /**
         * Return a plain object of the current document for an usage in the view
         *
         * @returns {{document: {}}}
         */
        toData: function mDocumenttoData() {
            var returnObject = {
                document: {}
            };
            returnObject.document.properties = this.getServerProperties();
            returnObject.menus = this.get("menus").toJSON();
            returnObject.templates = this.get("templates");
            return returnObject;
        },

        /**
         * Return all the values of the current document
         *
         * @returns {{}}
         */
        getValues: function mDocumentdocumentGetValues() {
            var values = {};
            if (!this.get("attributes")) {
                return values;
            }
            this.get("attributes").each(function mDocumentGetValue(currentAttribute) {
                var currentValue = currentAttribute.get("attributeValue"),
                    i,
                    arrayValues = [];
                if (!currentAttribute.get("isValueAttribute")) {
                    return;
                }
                if (currentAttribute.get("multiple")) {
                    currentValue = _.toArray(currentValue);
                    if (currentValue.length > 0) {
                        for (i = 0; i < currentValue.length; i += 1) {
                            arrayValues.push(currentValue[i] || { value: null });
                        }
                    } else {
                        arrayValues = []; //{value: null};
                    }
                    values[currentAttribute.id] = arrayValues;
                } else {
                    values[currentAttribute.id] = currentValue;
                }
            });
            return values;
        },

        /**
         * reset all values with a new set of values
         */
        setValues: function mDocumentdocumentSetValues(values) {
            this.get("attributes").each(function mDocumentSetValue(currentAttribute) {
                var newValue = values[currentAttribute.id];
                if (!currentAttribute.get("isValueAttribute")) {
                    return;
                }
                currentAttribute.set("attributeValue", newValue);
                // reset change also
                currentAttribute.changed = {};
            });
        },

        /**
         * reset all properties with a new set of properties
         */
        setProperties: function mDocumentdocumentSetProperties(values) {
            var model = this;
            _.each(values, function mDocumentSetProperties(value, key) {
                model.get("properties").set(key, value);
            });
        },

        lockDocument: function mDocumentLockDocument() {
            var docModel = this;
            var lockModel = new DocumentLock({ "initid": this.get("initid"), "type": "permanent" });
            var security = this.get("properties").get("security");
            lockModel.save({}, {
                success: function mDocumentLockDocumentSuccess(theModel, data) {
                    var menu = docModel.get("menus");
                    security.lock = data.data.lock;
                    docModel.get("properties").set("security,", security);

                    menu.setMenu("lock", "visibility", "hidden");
                    menu.setMenu("unlock", "visibility", "visible");

                    docModel.get("properties").trigger("change");
                },
                error: function mDocumentLockDocumentError(theModel, HttpResponse) {
                    var response = JSON.parse(HttpResponse.responseText);

                    docModel.trigger("showError", {
                        title: response.exceptionMessage
                    });
                }
            });
        },

        unlockDocument: function mDocumentUnLockDocument() {
            var docModel = this;
            //  type = empty means Delete all locks
            var lockModel = new DocumentLock({ "initid": this.get("initid"), "type": "" });
            var security = this.get("properties").get("security");
            lockModel.destroy({
                success: function mDocumentUnLockDocumentSuccess() {
                    var menu = docModel.get("menus");
                    security.lock = {
                        lockedBy: {
                            id: 0
                        }
                    };
                    docModel.get("properties").set("security,", security);

                    menu.setMenu("lock", "visibility", "visible");
                    menu.setMenu("unlock", "visibility", "hidden");
                    docModel.get("properties").trigger("change");
                },
                error: function mDocumentUnLockDocumentError(theModel, HttpResponse) {
                    var response = JSON.parse(HttpResponse.responseText);

                    docModel.trigger("showError", {
                        title: response.exceptionMessage
                    });
                }
            });
        },
        /**
         * Get a plain object with properties of the document
         *
         * @returns {*}
         */
        getModelProperties: function mDocumentdocumentGetProperties() {
            var properties = {};
            if (this.get("properties")) {
                properties = this.get("properties").toJSON();
            }
            properties.initid = this.get("initid");
            properties.revision = this.get("revision");
            properties.viewId = this.get("viewId");
            properties.renderMode = this.get("renderMode");

            return properties;
        },

        /**
         * Get the initial properties as transfered by the server
         * @returns {*|{revision, viewId, renderMode, properties, menus, attributes}|{resizeMarginHeight, resizeMarginWidth, resizeDebounceTime, withoutResize, eventPrefix}|{content}|{title, isValueAttribute, parent, mode, errorMessage}|{documentId, documentModel, state, attributes}}
         */
        getServerProperties: function mDocument_getCurrentProperties() {
            var properties;
            properties = this.initialProperties;
            if (properties) {
                properties.hasUploadingFiles = this.hasUploadingFile();
            }
            return properties;
        },

        /**
         * Indicate if one attribute of the document is modified
         *
         * @returns {*|boolean}
         */
        isModified: function mDocument_isModified() {
            return this.hasAttributesChanged();
        },

        /**
         * Get document properties, values and labels of attributes
         */
        getDocumentData: function mDocumentGetDocumentData() {
            var documentData = {
                properties: this.getModelProperties(),
                attributeValues: this.getValues(),
                attributeLabels: {},
                createAttributeView: function mDocumentGetDocumentDataCreate() {
                    return this.id;
                }
            };
            this.get("attributes").each(function mDocumentGetDocumentDataEach(currentAttribute) {
                documentData.attributeLabels[currentAttribute.id] = currentAttribute.get("label");
            });
            return documentData;
        },
        /**
         * Return true if one the attribute of the document hasChanged
         *
         * @returns {boolean|*}
         */
        hasAttributesChanged: function mDocumenthasAttributesChanged() {
            if (!this.get("attributes")) {
                return false;
            }
            return this.get("attributes").some(function mDocumenthasAttributesChangedSome(currentAttr) {
                return currentAttr.hasValueChanged();
            });
        },

        hasUploadingFile: function mdocumenthasUploadingFile() {
            return this._uploadingFile > 0;
        },

        /**
         * Analyze return in case of sync uncomplete and trigger event error
         *
         * @param model
         * @param xhr
         */
        propagateSynchroError: function mDocumentpropagateSynchroError(model, xhr) {
            var attrModel,
                currentModel = this,
                parsedReturn,
                errorCode = null,
                title = "",
                properties;
            //Analyze XHR
            var messages = [];
            try {
                if (!xhr && model.message) {
                    messages.push({ type: "error", contentText: model.message });
                    xhr = { status: 500, statusText: "Internal - No HTTP response" };
                } else {
                    var result = JSON.parse(xhr.responseText);
                    messages = result.messages;
                }
            } catch (e) {
                //Unable to parse responseText (error is not in JSON)
                this.cleanErrorMessages();
                if (window.dcp.logger) {
                    window.dcp.logger(e);
                } else {
                    console.error(e);
                }
                properties = currentModel.getServerProperties();
                if (!properties || !properties.initid) {
                    //First loading, unable to load display reload iframe panel
                    currentModel.trigger("displayNetworkError");
                    return;
                }
                //There is an initd, so there is a document
                //We display a message and let the user try again
                //Status 0 indicate offline browser
                if (xhr && xhr.status === 0) {
                    currentModel.trigger("showError", {
                        "errorCode": "offline",
                        "title": i18n.___("Your navigator seems offline, try later", "ddui")
                    });
                } else {
                    currentModel.trigger("showError", {
                        "errorCode": "unableToParseJson",
                        "title": i18n.___("Server return unreadable", "ddui")
                    });
                }
                currentModel.setProperties(properties);
                this.trigger("dduiDocumentDisplayView");
                return;
            }

            parsedReturn = {
                messages: messages,
                responseText: "Unexpected error: " + xhr.status + " " + xhr.statusText
            };

            this.cleanErrorMessages();
            if (parsedReturn.messages.length === 0) {
                if (currentModel.get("properties")) {
                    title = currentModel.get("properties").get("title");
                }
                currentModel.trigger("showError", {
                    "errorCode": errorCode,
                    "title": i18n.___("Unexpected error ", "ddui") + title,
                    "message": parsedReturn.responseText
                });
            }
            _.each(parsedReturn.messages, function mDocumentpropagateSynchroErrorMessages(message) {
                switch (message.code) {
                    case "CRUD0211":
                        // Syntax Error
                        if (message.data && message.data.id) {
                            attrModel = currentModel.get('attributes').get(message.data.id);
                            if (attrModel) {
                                attrModel.setErrorMessage(message.data.err, message.data.index);
                                currentModel.trigger("showError", {
                                    title: message.contentText,
                                    htmlMessage: message.contentHtml,
                                    message: attrModel.attributes.label + ' : ' + message.data.err,
                                    errorCode: message.code
                                });
                            } else {
                                currentModel.trigger("showError", {
                                    title: message.contentText,
                                    htmlMessage: message.contentHtml,
                                    message: message.data.err,
                                    errorCode: message.code
                                });
                            }
                        }
                        break;
                    case "CRUD0212":
                        // Constraint Error
                        if (message.data && message.data.constraint) {
                            _.each(message.data.constraint, function mDocumentpropagateSynchroError0212(constraint) {
                                attrModel = currentModel.get('attributes').get(constraint.id);
                                if (attrModel) {
                                    attrModel.setErrorMessage(constraint.err, constraint.index);
                                    currentModel.trigger("showError", {
                                        title: message.contentText,
                                        htmlMessage: message.contentHtml,
                                        message: attrModel.attributes.label + ' : ' + constraint.err,
                                        "errorCode": message.code
                                    });
                                } else {
                                    currentModel.trigger("showError", {
                                        title: message.contentText,
                                        htmlMessage: message.contentHtml,
                                        message: constraint.err,
                                        "errorCode": message.code
                                    });
                                }
                            });
                        }
                        if (message.data && message.data.preStore) {
                            currentModel.trigger("showError", {
                                title: message.contentText,
                                htmlMessage: message.contentHtml,
                                message: message.data.preStore,
                                errorCode: message.code
                            });
                        }
                        break;

                    default:
                        if (message.type === "error" && message.contentText) {
                            currentModel.trigger("showError", {
                                title: message.contentText + " " + (message.code ? message.code : ""),
                                htmlMessage: message.contentHtml,
                                errorCode: message.code
                            });
                        } else {
                            if (message.type && message.contentText) {
                                currentModel.trigger("showMessage", {
                                    title: message.contentText + " " + (message.code ? message.code : ""),
                                    type: message.type,
                                    htmlMessage: message.contentHtml,
                                    errorCode: message.code
                                });
                            } else {
                                console.error("Error", message);
                            }
                        }
                }
            });
            this.trigger("dduiDocumentDisplayView");
        },

        /**
         * Validate the content of the model before synchro
         */
        validate: function mDocumentvalidate(documentElements, options) {
            var success = true,
                currentDocument = this,
                errorMessage = [],
                event = { prevent: false },
                templateMessage,
                error;
            try {
                this.trigger("validate", event);
                if (event.prevent) {
                    return {
                        title: "Unable to save"
                    };
                }
                this.get("attributes").each(function mDocumentvalidateEach(currentAttribute) {
                    var parentAttribute = currentDocument.get("attributes").get(currentAttribute.get("parent"));
                    currentAttribute.setErrorMessage(null);

                    if (currentAttribute.get("needed") === true) {
                        var currentValue = currentAttribute.get("attributeValue"),
                            oneSuccess = true;

                        if (currentAttribute.get("multiple")) {
                            if (parentAttribute.get("type") === "array") {
                                // Verify each index
                                _.each(currentValue, function mDocumentvalidateArray(attributeValue, index) {
                                    //If the attribute is multiple we check if the array has a size superior to 0
                                    if (_.isArray(attributeValue) && attributeValue.length > 0) {
                                        return;
                                    }
                                    if ((!attributeValue || !attributeValue.value) && attributeValue.value !== 0) {
                                        currentAttribute.setErrorMessage(i18n.___("Empty value not allowed", "ddui"), index);

                                        templateMessage = _.template(i18n.___("{{parentLabel}} / {{label}} (row # {{index}}) is needed", "ddui"), { escape: /\{\{(.+?)\}\}/g });
                                        errorMessage.push(templateMessage({
                                            parentLabel: parentAttribute.get('label'),
                                            label: currentAttribute.get("label"),
                                            index: index + 1
                                        }));
                                        success = false;
                                    }
                                });
                            } else {
                                if (!currentValue || currentValue.length === 0) {
                                    oneSuccess = false;
                                }
                            }
                        } else {
                            if ((!currentValue || !currentValue.value) && currentValue.value !== 0) {
                                currentAttribute.setErrorMessage(i18n.___("Empty value not allowed", "ddui"));
                                oneSuccess = false;
                            }
                        }
                        if (!oneSuccess) {
                            templateMessage = _.template(i18n.___("{{parentLabel}} / {{label}} is needed", "ddui"), { escape: /\{\{(.+?)\}\}/g });
                            errorMessage.push(templateMessage({
                                parentLabel: parentAttribute.get('label'),
                                label: currentAttribute.get("label")
                            }));
                            currentAttribute.setErrorMessage(i18n.___("The field must not be empty", "ddui"));
                            success = false;
                        }
                    }

                    if (!currentAttribute.checkConstraint({ clearError: false })) {
                        success = false;
                        if (_.isArray(currentAttribute.get("errorMessage"))) {
                            templateMessage = _.template("<%= parentLabel %> / <%= label %> " + "<% for(var msg in errorMessage) { %>" + "\n<%- rowText %> <%= errorMessage[msg].index + 1 %> : <%= errorMessage[msg].message %>\n <% } %> ");
                        } else {
                            templateMessage = _.template("<%= parentLabel %> / <%= label %> <%= errorMessage %>");
                        }
                        errorMessage.push(templateMessage({
                            parentLabel: parentAttribute.get('label'),
                            label: currentAttribute.get("label"),
                            rowText: i18n.___("Row #", "ddui"),
                            errorMessage: currentAttribute.get("errorMessage")
                        }));
                    }
                });
                if (!success) {
                    error = {
                        title: i18n.___("Unable to save", "ddui"),
                        message: errorMessage.join(', ' + "\n"),
                        errorCode: "attributeNeeded"
                    };
                    if (options.error) {
                        options.error(_.extend({ "eventPrevented": true }, error));
                    }
                    return error;
                }
            } catch (e) {
                console.error("Unable to validate");
                console.error(e);
            }

            return undefined;
        },

        /**
         * Redraw messages for the error displayed
         */
        redrawErrorMessages: function mDocumentredrawErrorMessages() {
            var attrModels = this.get('attributes') || [];
            _.each(attrModels.models, function mDocumentredrawErrorMessagesEach(attrModel) {
                var message = attrModel.get("errorMessage");
                // redo error after document is show
                if (message) {
                    attrModel.setErrorMessage(null); // use double affect to force tooltip redraw
                    attrModel.setErrorMessage(message);
                }
            });
        },

        /**
         * Propagate to attributes a clear message for the error displayed
         */
        cleanErrorMessages: function mDocumentCleanErrorMessages() {
            var attrModels = this.get('attributes') || [];
            _.each(attrModels.models, function mDocumentCleanErrorMessagesEach(attrModel) {
                attrModel.setErrorMessage(null);
            });
        },
        /**
         * Parse the return of the REST API
         * @param response
         * @returns {{properties: (*|properties|exports.defaults.properties|exports.parse.properties|.createObjectExpression.properties), menus: (app.views.shared.menu|*), locale: *, renderMode: string, attributes: Array, templates: *, renderOptions: *}}
         */
        parse: function mDocumentParse(response) {
            var values,
                renderMode = "view",
                view = response.data.view;

            if (response.success === false) {
                throw new Error("Unable to get the data from documents");
            }
            this.trigger("beforeParse");
            if (view.renderOptions.mode) {
                if (view.renderOptions.mode === "edit") {
                    renderMode = "edit";
                } else if (view.renderOptions.mode === "view") {
                    renderMode = "view";
                } else {
                    throw new Error("Unkown render mode " + view.renderOptions.mode);
                }
            }

            this.initialProperties = _.defaults({
                "renderMode": renderMode || "view",
                "viewId": response.data.properties.requestIdentifier
            }, view.documentData.document.properties);

            //Clean attributes
            if (this.get("attributes") instanceof CollectionAttributes) {
                this.get("attributes").destroy();
            }

            values = {
                initid: response.data.properties.creationView === true ? null : view.documentData.document.properties.initid,
                properties: view.documentData.document.properties,
                menus: view.menu,
                viewId: response.data.properties.requestIdentifier,
                revision: view.documentData.document.properties.revision,
                locale: view.locale.culture,
                renderMode: renderMode || "view",
                attributes: undefined,
                templates: view.templates,
                renderOptions: view.renderOptions,
                customCSS: view.style.css,
                customJS: view.script.js,
                customServerData: view.customServerData,
                messages: response.messages,
                originalValues: view.documentData.document.attributes
            };
            this._customClientData = {};
            if (response.data.properties.creationView === true) {
                values.creationFamid = view.documentData.document.properties.family.name;
            } else {
                values.creationFamid = false;
            }
            return values;
        },

        /**
         * Generate the collection of the current model and bind events on the new collection
         *
         * @param keyOrValues string|object of properties or key of the current property
         * @param value
         * @returns {*}
         */
        "set": function mDocumentsetValues(keyOrValues, value) {
            var currentModel = this;
            if (keyOrValues.properties !== undefined) {
                if (currentModel.get("properties") instanceof DocumentProperties) {
                    currentModel.get("properties").trigger("destroy");
                }
                keyOrValues.properties = new DocumentProperties(keyOrValues.properties);
            }

            if (keyOrValues.menus !== undefined) {
                if (currentModel.get("menus") instanceof CollectionMenus) {
                    currentModel.get("menus").destroy();
                }
                keyOrValues.menus = new CollectionMenus(keyOrValues.menus);
            }
            if (keyOrValues === "attributes") {
                value = new CollectionAttributes(value, {
                    documentModel: currentModel,
                    renderOptions: currentModel.get("renderOptions"),
                    renderMode: currentModel.get("renderMode")
                });
                //Set the internal content collection (for structure attributes)
                value.each(function mDocumentsetValuesEachAttributes(currentAttributeModel) {
                    if (currentAttributeModel.get("isValueAttribute")) {
                        return;
                    }
                    var childAttributes = value.filter(function mDocumentsetValuesEachAttributesFilter(candidateChildModel) {
                        return candidateChildModel.get("parent") === currentAttributeModel.id;
                    });
                    if (childAttributes.length > 0) {
                        currentAttributeModel.setContentCollection(childAttributes);
                    }
                });
                //Propagate the change event to the model
                currentModel.listenTo(value, "change:attributeValue", function mDocumentsetValuesListenChange(model) {
                    _.defer(function mDocumentAttributeChangerTrigger() {
                        currentModel.trigger("changeValue", {
                            attributeId: model.id
                        });
                    });
                });
                //Propagate the validate event to the model
                currentModel.listenTo(value, "constraint", function mDocumentsetValuesListenConstraint(options) {
                    currentModel.trigger("constraint", options.model.id, options.response);
                });
                //Propagate the renderDone event of the attributes to the model
                currentModel.listenTo(value, "renderDone", function mDocumentsetValuesListenRenderDone(options) {
                    currentModel.trigger("attributeRender", options.model.id, options.$el, options.index);
                });
                //Propagate the beforeRender event of the attributes to the model
                currentModel.listenTo(value, "beforeRender", function mDocumentsetValuesListenBeforeRender(event, options) {
                    currentModel.trigger("beforeAttributeRender", event, options.model.id, options.$el, options.index);
                });
                //Propagate the array event modified to the model
                currentModel.listenTo(value, "array", function mDocumentsetValuesListenArray(type, model, options) {
                    currentModel.trigger("arrayModified", {
                        attributeId: model.id,
                        "type": type,
                        "options": options
                    });
                });
                //Propagate the event externalLinkSelected to the model
                currentModel.listenTo(value, "internalLinkSelected", function mDocumentsetValuesListenLinkSelected(event, options) {
                    currentModel.trigger("internalLinkSelected", event, options);
                });
                //Propagate the event downloadFile to the model
                currentModel.listenTo(value, "downloadFile", function mDocumentsetValuesListenDownloadfile(event, attrid, options) {
                    currentModel.trigger("downloadFile", event, attrid, options);
                });

                //Propagate the event uploadFile to the model
                currentModel.listenTo(value, "uploadFile", function mDocumentListenUploadfileStart(event, attrid, options) {
                    var attr, attrValue;
                    currentModel.trigger("uploadFile", event, attrid, options);

                    if (!event.prevent) {
                        attr = currentModel.get("attributes").get(attrid);

                        currentModel._uploadingFile++;

                        if (attr) {
                            attrValue = attr.get("attributeValue");
                            if (options.index >= 0) {
                                attrValue = _.clone(attrValue);
                                attrValue[options.index] = { value: "-^-", displayValue: "Uploading" };
                            } else {
                                attrValue = { value: "--", displayValue: "Uploading" };
                            }
                            // Use Silent to not redraw widget - it will be redraw at the end of uploading
                            attr.set("attributeValue", attrValue, { silent: true });
                            currentModel.trigger("changeValue", {
                                attributeId: attrid
                            });
                        }
                    }
                });

                //Propagate the event uploadFile to the model
                currentModel.listenTo(value, "uploadFileDone", function mDocumentListenuploadFileDone(event, attrid, options) {
                    currentModel._uploadingFile--;
                    currentModel.trigger("uploadFileDone", event, attrid, options);

                    if (currentModel._uploadingFile <= 0) {
                        currentModel.trigger("uploadFileFinished");
                    }
                });

                //Propagate the event helperSearch to the model
                currentModel.listenTo(value, "helperSearch", function mDocumentsetValuesListenHelperSearch(event, attrid, options, index) {
                    currentModel.trigger("helperSearch", event, attrid, options, index);
                });
                //Propagate the event helperResponse to the model
                currentModel.listenTo(value, "helperResponse", function mDocumentsetValuesListenHelperResponse(event, attrid, options, index) {
                    currentModel.trigger("helperResponse", event, attrid, options, index);
                });
                //Propagate the event helperResponse to the model
                currentModel.listenTo(value, "helperSelect", function mDocumentsetValuesListenHelperSelect(event, attrid, options, index) {
                    currentModel.trigger("helperSelect", event, attrid, options, index);
                });
                //Propagate the click on an anchor to the model
                currentModel.listenTo(value, "anchorClick", function mDocumentsetValuesListenAnchorClicked(event, attrid, options) {
                    currentModel.trigger("anchorClick", event, attrid, options);
                });
            }
            return Backbone.Model.prototype.set.call(this, keyOrValues, value);
        },

        unbindLoadEvent: function mDocumentUnbindLoadEvent() {
            $(window).off("." + this.cid);
        },

        /**
         * Destroy the collection associated to the document (used in the destroy part of the view)
         *
         */
        destroySubcollection: function mDocumentdestroySubcollection() {
            if (this.get("menus") instanceof CollectionMenus) {
                this.get("menus").destroy();
            }
            if (this.get("properties") instanceof DocumentProperties) {
                this.get("properties").trigger("destroy");
            }
            if (this.get("attributes") instanceof CollectionAttributes) {
                this.get("attributes").destroy();
            }
        },

        /**
         * Inject JS in the main page before render view
         * To launch beforeRender and beforeRenderAttribute
         */
        injectCurrentDocJS: function mDocumentInjectCurrentDocJS() {
            var allInjectPromises = [],
                customJS = _.pluck(this.get("customJS"), "path");
            _.each(customJS, function injectElement(currentPath) {
                allInjectPromises.push(new Promise(function addJs(resolve, reject) {
                    load(currentPath, function addJsDone(err) {
                        if (err) {
                            reject(err);
                        } else {
                            resolve();
                        }
                    });
                }));
            });

            return Promise.all(allInjectPromises);
        },

        /**
         * Inject an array of js in the current page
         *
         * @param jsToInject Array of string to inject
         * @return Promise
         */
        injectJS: function mDocumentInjectJs(jsToInject) {
            var allInjectPromises = [];
            if (!_.isArray(jsToInject)) {
                throw new Error("The js to inject must be an array of string path");
            }
            _.each(jsToInject, function injectElement(currentPath) {
                allInjectPromises.push(new Promise(function addJs(resolve, reject) {
                    load(currentPath, function addJsDone(err) {
                        if (err) {
                            reject(err);
                        } else {
                            resolve();
                        }
                    });
                }));
            });
            return Promise.all(allInjectPromises);
        },

        /**
         * Inject an array of css path in the current page
         *
         * @param customCss
         */
        injectCSS: function mDocumentInjectCSS(customCss) {
            // add custom css style
            var $head = $("head"),
                cssLinkTemplate = _.template('<link rel="stylesheet" type="text/css" ' + 'href="<%= path %>" data-injected="true">');

            if (!_.isArray(customCss)) {
                throw new Error("The css to inject must be an array of string path");
            }

            // Inject new CSS
            _.each(customCss, function vDocumentInjectNewCSS(cssItem) {
                if (document.createStyleSheet) {
                    document.createStyleSheet(cssItem);
                }
                $head.append(cssLinkTemplate({ "path": cssItem }));
            });
        },

        /**
         * Used by backbone for the save part
         * @returns {{document: {attributes: *, properties : *}}}
         */
        toJSON: function mDocumenttoJSON() {
            return {
                document: {
                    properties: this.getModelProperties(),
                    attributes: this.getValues()
                },
                customClientData: this._customClientData
            };
        },

        /**
         * Get render option for document widget
         * @param optId
         * @returns {*}
         */
        getOption: function mDocumentGetOption(optId) {
            var renderOptions = this.get("renderOptions");
            if (renderOptions && renderOptions.document) {
                return renderOptions.document[optId];
            }
            return undefined;
        },

        _promiseCallback: function mDocument_promiseCallback() {
            var promise,
                success,
                error,
                properties = this.getServerProperties();

            promise = new Promise(function mDocument_promiseInternObject(resolve, reject) {
                success = function onSuccess(values) {
                    var successArguments = values;
                    if (values && successArguments["arguments"]) {
                        successArguments = values["arguments"];
                    } else {
                        successArguments = arguments;
                    }
                    if (values && successArguments.documentProperties) {
                        properties = successArguments.documentProperties;
                    }
                    resolve({ documentProperties: properties, arguments: successArguments });
                };
                error = function onError(values) {
                    var errorArguments = values;
                    if (values && errorArguments["arguments"]) {
                        errorArguments = values["arguments"];
                    } else {
                        errorArguments = arguments;
                    }
                    if (values && errorArguments.documentProperties) {
                        properties = errorArguments.documentProperties;
                    }
                    reject({ documentProperties: properties, arguments: errorArguments });
                };
            });

            //noinspection JSUnusedAssignment
            return {
                "promise": promise,
                "success": success,
                "error": error
            };
        },

        /**
         * Complete the loading of the document
         * Fetch the structure and external js deps
         *
         * @private
         */
        _loadDocument: function mDocumentLoadDocument(currentModel) {
            var properties = this.getServerProperties();

            return new Promise(function mDocument_promiseLoadDocument(resolve, reject) {
                //Complete the structure after
                currentModel._completeStructure().then(function onGetStructureDone() {
                    currentModel.injectCurrentDocJS().then(function mDocument_injectJSDone(values) {
                        resolve({ documentProperties: properties, successArguments: arguments });
                    }, function mDocument_injectJSFail(values) {
                        reject({ documentProperties: properties, arguments: arguments });
                        currentModel.trigger.apply(currentModel, _.union(["dduiDocumentFail"], values.arguments));
                    });
                }, function mDocument_onGetStructureFail(values) {
                    reject({ documentProperties: properties, arguments: arguments });
                    currentModel.trigger.apply(currentModel, _.union(["dduiDocumentFail"], values.arguments));
                });
            });
        },

        fetchDocument: function mDocumentFetchDocument(values, options) {
            var globalCallback = this._promiseCallback(),
                documentCallback = this._promiseCallback(),
                serverProperties = this.getServerProperties(),
                currentModel = this,
                needToUnlock = {},
                beforeCloseReturn = { prevent: false },
                lockModel = null,
                nextView = false,
                security,
                previousMode,
                lockCallback = this._promiseCallback();

            options = options || {};
            values = values || {};

            if (_.isEmpty(this._customClientData)) {
                this.trigger("getCustomClientData");
            }

            //Register promise events
            documentCallback.promise.then(function onFetchDocumentDone(currentModelProperties) {
                currentModel._loadDocument(currentModel).then(function mDocument_loadDocumentDone(values) {
                    globalCallback.success.apply(currentModelProperties, values);
                }, function mDocument_loadDocumentFail(values) {
                    globalCallback.error.apply(currentModelProperties, values);
                });
            }, function mDocument_onFetchDocumentFail(values) {
                globalCallback.error.call(serverProperties, values);
            });

            globalCallback.promise.then(function onPrepareDocumentDone(values) {
                if (_.isFunction(options.success)) {
                    options.success(values);
                }
                currentModel.trigger("close", serverProperties);
                currentModel.trigger.apply(currentModel, _.union(["dduiDocumentReady"], values.arguments));
            }, function onPrepareDocumentFail(values) {
                if (_.isFunction(options.error)) {
                    options.error(values);
                }
                if (!(values.arguments && values.arguments[0] && values.arguments[0].eventPrevented)) {
                    currentModel.trigger.apply(currentModel, _.union(["dduiDocumentFail"], values.arguments));
                }
            });

            //Init default values
            _.defaults(values, { revision: -1, viewId: "!defaultConsultation", initid: this.get("initid") });

            //Trigger (synchronous) before close event
            this.trigger("beforeClose", beforeCloseReturn, values, this._customClientData);

            if (beforeCloseReturn.prevent === false) {
                this.trigger("displayLoading");

                //***********Lock Part*********************************************************************************

                // Verify if current document need to be unlocked before fetch another
                security = this.get("properties") ? this.get("properties").get("security") : null;
                previousMode = this.get("renderMode");

                if (previousMode === "edit" && security && security.lock && security.lock.temporary) {

                    needToUnlock = {
                        initid: serverProperties.initid
                    };
                }
                //Compute the next view
                nextView = values.viewId;

                if (!nextView) {
                    nextView = this.get("renderMode") === "edit" ? "!defaultEdition" : "!defaultConsultation";
                }

                if (nextView !== "!defaultConsultation" && nextView !== "!coreCreation" && nextView !== "!defaultCreation" && this.get("renderMode") !== "create") {
                    //if the document is locked and the next view doesn't need the same lock delete it
                    if (needToUnlock.initid && needToUnlock.initid !== values.initid) {
                        lockModel = new DocumentLock({ "initid": needToUnlock.initid, "type": "temporary" });
                        lockModel.destroy();
                    }
                    // The next view needs a lock, ask for it and fetch the document after
                    lockModel = new DocumentLock({ initid: values.initid, viewId: nextView, type: "temporary" });
                    lockModel.save({}, lockCallback);
                } else {
                    if (needToUnlock) {
                        if (needToUnlock.initid === values.initid) {
                            // If same document "get" must be perform after unlock
                            lockModel = new DocumentLock({ "initid": needToUnlock.initid, "type": "temporary" });
                            lockModel.destroy(lockCallback);
                        } else {
                            lockModel = new DocumentLock({ "initid": needToUnlock.initid, "type": "temporary" });
                            lockModel.destroy();
                            lockCallback.success();
                        }
                    } else {
                        lockCallback.success();
                    }
                }

                lockCallback.promise.then(function mdocument_lockSucess() {
                    //save the new options in the currentDocument for the fetch
                    _.each(_.pick(values, "initid", "revision", "viewId"), function mDocument_SetNewOptions(value, key) {
                        currentModel.set(key, value);
                    });
                    currentModel.fetch(documentCallback);
                }, function mDocument_lockFail() {
                    globalCallback.error.apply(currentModel, arguments);
                });
            } else {
                //Reinit properties
                currentModel.set(serverProperties);
                //Indicate success to the promise object
                globalCallback.error({ eventPrevented: true });
            }

            return globalCallback.promise;
        },

        saveDocument: function mDocumentSaveDocument(attributes, options) {
            var globalCallback = this._promiseCallback(),
                saveCallback = this._promiseCallback(),
                beforeSaveEvent = { prevent: false },
                currentModel = this,
                serverProperties = this.getServerProperties();

            options = options || {};

            if (_.isEmpty(this._customClientData)) {
                this.trigger("getCustomClientData");
            }
            this.trigger("beforeSave", beforeSaveEvent, this._customClientData);

            if (beforeSaveEvent.prevent !== false) {
                globalCallback.error({ eventPrevented: true });
            } else {
                saveCallback.promise.then(function mDocument_saveDone() {
                    currentModel._loadDocument(currentModel).then(function mDocument_loadDocumentDone() {
                        globalCallback.success();
                    }, function mDocument_loadDocumentFail() {
                        globalCallback.error.apply(currentModel, arguments);
                    });
                }, function mDocument_saveFail() {
                    globalCallback.error.apply(currentModel, arguments);
                });

                if (currentModel.hasUploadingFile()) {

                    this.trigger("displayLoading", {
                        isSaving: true,
                        text: i18n.___("Recording files in progress", "ddui")
                    });
                    currentModel.trigger("showMessage", {
                        title: i18n.___("Waiting uploads in progress", "ddui"),
                        type: "info"
                    });
                    currentModel.once("uploadFileFinished", function mDocumentsetValuesListenUploadUntilTheEnd(event) {
                        this.trigger("displayLoading", { isSaving: true });
                        currentModel.save(attributes, saveCallback);
                    });
                } else {

                    this.trigger("displayLoading", { isSaving: true });
                    currentModel.save(attributes, saveCallback);
                }
            }

            globalCallback.promise.then(function onSaveSuccess(values) {
                currentModel.trigger("afterSave", serverProperties);
                currentModel.trigger("close", serverProperties);
                if (_.isFunction(options.success)) {
                    options.success();
                }
                currentModel.trigger.apply(currentModel, _.union(["dduiDocumentReady"], values.arguments));
            }, function onSaveFail(values) {
                if (_.isFunction(options.error)) {
                    options.error();
                }
                if (!(values.arguments && values.arguments[0] && values.arguments[0].eventPrevented)) {
                    currentModel.trigger.apply(currentModel, _.union(["dduiDocumentFail"], values.arguments));
                }
            });

            return globalCallback.promise;
        },

        deleteDocument: function mDocumentDelete(options) {
            var globalCallback = this._promiseCallback(),
                deleteCallback = this._promiseCallback(),
                beforeDeleteEvent = { prevent: false },
                currentModel = this,
                serverProperties = this.getServerProperties();

            options = options || {};

            if (_.isEmpty(this._customClientData)) {
                this.trigger("getCustomClientData");
            }
            this.trigger("beforeDelete", beforeDeleteEvent, this._customClientData);

            if (beforeDeleteEvent.prevent !== false) {
                globalCallback.error({ eventPrevented: true });
            } else {
                this.trigger("displayLoading");
                deleteCallback.promise.then(function mDocument_deleteDone() {
                    currentModel.fetchDocument({ initid: currentModel.get("initid") }).then(function mDocument_afterDeleteLoadDone() {
                        globalCallback.success();
                    }, function mDocument_afterDeleteLoadFail() {
                        globalCallback.error.apply(currentModel, arguments);
                    });
                }, function mDocument_deleteFail() {
                    globalCallback.error.apply(currentModel, arguments);
                });

                this.sync('delete', this, deleteCallback);
            }

            globalCallback.promise.then(function onDeleteSuccess(values) {
                currentModel.trigger("afterDelete", serverProperties);
                currentModel.trigger("close", serverProperties);
                if (_.isFunction(options.success)) {
                    options.success();
                }
                currentModel.trigger.apply(currentModel, _.union(["dduiDocumentReady"], values.arguments));
            }, function onDeleteFail(values) {
                if (_.isFunction(options.error)) {
                    options.error();
                }
                if (!(values.arguments && values.arguments[0] && values.arguments[0].eventPrevented)) {
                    currentModel.trigger.apply(currentModel, _.union(["dduiDocumentFail", currentModel], values.arguments));
                }
            });

            return globalCallback.promise;
        },

        restoreDocument: function mDocumentRestoreDocument(options) {
            var globalCallback = this._promiseCallback(),
                restoreCallback = this._promiseCallback(),
                beforeRestoreEvent = { prevent: false },
                currentModel = this,
                serverProperties = this.getServerProperties();

            options = options || {};

            if ("deleted" === this.get("properties").get("status")) {
                if (_.isEmpty(this._customClientData)) {
                    this.trigger("getCustomClientData");
                }
                this.trigger("beforeRestore", beforeRestoreEvent, this._customClientData);

                if (beforeRestoreEvent.prevent !== false) {
                    globalCallback.error({ eventPrevented: true });
                } else {
                    this.trigger("displayLoading", { isSaving: true });

                    restoreCallback.promise.then(function mDocument_restoreDocument_Success() {
                        currentModel._loadDocument(currentModel).then(function mDocument_restoreDocument_loadSuccess() {
                            globalCallback.success();
                        }, function mDocument_restoreDocument_loadFail() {
                            globalCallback.error.apply(currentModel, arguments);
                        });
                    }, function mDocument_restoreDocument_Fail() {
                        globalCallback.error.apply(currentModel, arguments);
                    });

                    this.get("properties").set("status", "alive");
                    currentModel.save({}, restoreCallback);
                }
            } else {
                globalCallback.error({ systemError: true, errorMessage: "Unable to restore alive doc" });
            }

            globalCallback.promise.then(function mDocument_restoreDocument_onSuccess(values) {
                currentModel.trigger("afterRestore", serverProperties);
                currentModel.trigger("close", serverProperties);
                if (_.isFunction(options.success)) {
                    options.success();
                }
                currentModel.trigger.apply(currentModel, _.union(["dduiDocumentReady"], values.arguments));
            }, function mDocument_restoreDocument_onFail(values) {
                if (_.isFunction(options.error)) {
                    options.error();
                }
                if (!(values.arguments && values.arguments[0] && (values.arguments[0].eventPrevented || values.arguments[0].systemError))) {
                    currentModel.trigger.apply(currentModel, _.union(["dduiDocumentFail"], values.arguments));
                }
            });

            return globalCallback.promise;
        },

        /**
         * Get complementary data : family structure
         */
        _completeStructure: function mDocumentCompleteStructure() {
            var mStructure,
                documentModel = this,
                structurePromise = this._promiseCallback();

            var neededAttributes = this.get("renderOptions").needed;
            var visibilityAttributes = this.get("renderOptions").visibilities;
            var valueAttributes = this.get("originalValues");

            if (this.get("properties").get("type") === "family") {
                // Family has no attributes
                this.set("attributes", []);
                structurePromise.success();
                return structurePromise.promise;
            }

            if (!_.isUndefined(this.get("attributes"))) {
                this.set("attributes", this.get("attributes")); // to convert attributes to models
                structurePromise.success();
                return structurePromise.promise;
            }

            mStructure = new FamilyStructure({
                familyId: this.get("properties").get("family").name,
                referencedocument: {
                    initid: this.get("initid"),
                    viewId: this.get("viewId"),
                    revision: this.get("revision")
                }
            });

            mStructure.fetch({
                success: function mDocumentCompleteStructureSuccess(structureModel, response) {
                    if (_.isEqual(structureModel.get("referencedocument"), {
                        initid: documentModel.get("initid"),
                        viewId: documentModel.get("viewId"),
                        revision: documentModel.get("revision")
                    })) {
                        var attributes = flattenAttributes(attributes, response.data.family.structure);
                        _.each(attributes, function mDocumentCompleteStructureSuccessEach(currentAttributeStructure) {
                            if (currentAttributeStructure.id && valueAttributes[currentAttributeStructure.id]) {
                                currentAttributeStructure.attributeValue = valueAttributes[currentAttributeStructure.id];
                                currentAttributeStructure.needed = neededAttributes[currentAttributeStructure.id] === true;
                            }
                            if (currentAttributeStructure.id && visibilityAttributes[currentAttributeStructure.id]) {
                                currentAttributeStructure.visibility = visibilityAttributes[currentAttributeStructure.id];
                            }
                        });
                        documentModel.set("attributes", attributes);
                        structurePromise.success();
                    }
                },

                error: structurePromise.error
            });
            return structurePromise.promise;
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/models/mDocumentLock.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function require_lock(_, Backbone) {
    "use strict";

    var urlCore = _.template("api/v1/documents/<%- initid %>/locks/<%- type %>");
    var urlView = _.template("api/v1/documents/<%- initid %>/views/<%- viewId %>/locks/<%- type %>");

    return Backbone.Model.extend({
        typeModel: "ddui:lock",
        idAttribute: "initid",
        viewId: "",

        url: function mDocumentLock_url() {
            //console.log("lock model", this.get("viewId"));
            if (this.get("viewId")) {
                return urlView({
                    initid: this.get("initid"),
                    type: this.get("type"),
                    viewId: this.get("viewId")
                });
            } else {
                return urlCore({
                    initid: this.get("initid"),
                    type: this.get("type")
                });
            }
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/models/mDocumentProperties.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone) {
    'use strict';

    return Backbone.Model.extend({

        typeModel: "ddui:properties"
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/models/mDocumentTab.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone) {
    "use strict";

    var url = _.template("api/v1/documents/<%- initid %>/usertags/lasttab");

    return Backbone.Model.extend({

        typeModel: "ddui:attributeTab",
        idAttribute: "initid",

        url: function mDocumentTag_url() {
            return url({ initid: this.get("initid") });
        },

        toJSON: function mDocumentTag_toJSON() {
            return this.get("tabId");
        }

    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/models/mFamilyStructure.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function require_structure(_, Backbone) {
    "use strict";

    return Backbone.Model.extend({

        typeModel: "ddui:familyStructure",
        idAttribute: "familyId",

        url: function mFamilyStructure_url() {
            var urlStructure = _.template("api/v1/families/<%- familyId %>/views/structure");

            return urlStructure({
                familyId: this.get("familyId")
            });
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/models/mMenu.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function mMenu(_, Backbone) {
    'use strict';

    return Backbone.Model.extend({
        typeModel: "ddui:menu",
        /**
         * Menu model are not linked to REST element so always new
         * @returns {boolean}
         */
        isNew: function mMenu_isNew() {
            return true;
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/models/mTransition.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/models/mDocument.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function requireModelTransition(_, Backbone, mDocument) {
    'use strict';

    return mDocument.extend({

        typeModel: "ddui:transition",
        defaults: {
            documentId: undefined,
            documentModel: undefined,
            state: undefined,
            attributes: []
        },

        /**
         * Compute the REST URL for the current document
         *
         * Used internally by backbone in fetch, save, destroy
         *
         * @returns {string}
         */
        url: function mTransition_url() {
            var urlData = "api/v1/documents/<%= documentId %>/views/states/<%= state %>";

            urlData = urlData.replace("<%= documentId %>", encodeURIComponent(this.get("documentId")));
            urlData = urlData.replace("<%= state %>", encodeURIComponent(this.get("state")));

            return urlData;
        },
        /**
         * Parse the return of the REST API
         * @param response
         * @returns {{properties: (*|properties|exports.defaults.properties|exports.parse.properties|.createObjectExpression.properties), menus: (app.views.shared.menu|*), locale: *, renderMode: string, attributes: Array, templates: *, renderOptions: *}}
         */
        parse: function mTransition_Parse(response) {
            var values, attributes, templates, renderOptions;
            var documentModel = this.get("documentModel");
            if (response.success === false) {
                throw new Error("Unable to get the data from change state");
            }
            attributes = [];

            renderOptions = response.data.renderOptions;

            if (!renderOptions) {
                renderOptions = documentModel.get("renderOptions");
            }
            if (response.data.transition && response.data.transition.askAttributes.length > 0) {
                _.each(response.data.transition.askAttributes, function mTransition_parseAsk(ask) {
                    attributes.push(ask);
                });
            }
            templates = documentModel.get("templates");

            if (response.data.templates) {
                templates.body = response.data.templates.body;
                _.each(response.data.templates.sections, function mTransition_parseTemplate(templateContent, templateIndex) {
                    templates.sections[templateIndex] = templateContent;
                });
            }

            this.initialProperties = {
                "renderMode": "edit",
                "viewId": "!Transition"
            };

            values = {
                initid: null, //response.data.workflow.properties.initid, // set to null to send a POST (create) when save
                properties: response.data.workflow.properties,
                menus: [],
                viewId: "!Transition",
                locale: documentModel.get("locale").culture,
                renderMode: "edit",
                attributes: attributes,
                templates: documentModel.get("templates"),
                renderOptions: renderOptions,
                customCSS: response.data.css,
                customJS: response.data.js,
                messages: response.messages,
                workflow: {
                    transition: response.data.transition,
                    state: response.data.state,
                    labels: response.data.labels
                }
            };
            return values;
        },

        /**
         * Used by backbone for the save part
         * @returns {{document: {attributes: *, properties : *}}}
         */
        toJSON: function mTransition_toJSON() {
            var values = this.getValues(),
                returnValues = { parameters: {} };

            _.each(values, function mTransition_analyzeContent(value, aid) {
                if (aid === "_workflow_comment_") {
                    returnValues.comment = _.isObject(value) ? value.value : '';
                } else {

                    if (_.isArray(value)) {
                        if (value.length > 0 && _.isArray(value[0])) {
                            // double multiple
                            returnValues.parameters[aid] = _.map(value, function mTransition_getParameter(aValue) {
                                return _.pluck(aValue, "value");
                            });
                        } else {
                            returnValues.parameters[aid] = _.pluck(value, "value");
                        }
                    } else if (_.isObject(value)) {
                        returnValues.parameters[aid] = value.value;
                    } else {
                        returnValues.parameters[aid] = value;
                    }
                }
            });
            return returnValues;
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/models/mTransitionGraph.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/models/mDocument.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, mDocument) {
    'use strict';

    return Backbone.Model.extend({

        typeModel: "ddui:transitionGraph",
        defaults: {
            documentId: undefined,
            state: undefined
        },

        /**
         * Compute the REST URL for the current document
         *
         * Used internaly by backbone in fetch, save, destroy
         *
         * @returns {string}
         */
        url: function mTransition_url() {
            var urlData = "api/v1/documents/<%= documentId %>/workflows/states/?allStates=1";

            urlData = urlData.replace("<%= documentId %>", encodeURIComponent(this.get("documentId")));

            return urlData;
        },
        /**
         * Parse the return of the REST API
         * @param response
         * @returns {{properties: (*|properties|exports.defaults.properties|exports.parse.properties|.createObjectExpression.properties), menus: (app.views.shared.menu|*), locale: *, renderMode: string, attributes: Array, templates: *, renderOptions: *}}
         */
        parse: function mTransition_Parse(response) {
            var values;
            if (response.success === false) {
                throw new Error("Unable to get the data from change state");
            }

            values = {
                state: this.get("state"),
                messages: response.messages,
                workflowStates: response.data.states
            };
            return values;
        }

    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/routers/router.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function define_router(_, Backbone) {
    'use strict';

    return Backbone.Router.extend({
        initialize: function router_initialize(options) {
            var currentRouter = this;
            this.useHistory = options.useHistory;

            this.document = options.document;

            this.route(/api\/v1\/documents\/([^\/]+)\.html/, "viewDocument");
            this.route(/api\/v1\/documents\/(.+)\/revisions\/([^\/]+)\.html/, "viewRevision");
            this.route(/api\/v1\/documents\/(.+)\/views\/([^\/]+)\.html/, "viewView");
            this.route(/api\/v1\/documents\/(.+)\/revisions\/([^\/]+)\/views\/([^\/]+)\.html/, "viewRevisionView");

            this.route(/[^?]*\?app=DOCUMENT([^#]+)/, "fetch");

            // Listen to document sync and update url
            this.document.listenTo(this.document, "sync", function sync() {
                var searchArguments;

                var viewId = currentRouter.document.get("viewId"),
                    options = {
                    "path": window.location.pathname,
                    "initid": currentRouter.document.get("initid"),
                    "revision": currentRouter.document.get("revision") >= 0 ? currentRouter.document.get("revision") : undefined,
                    "viewId": undefined
                };
                var docProperties = currentRouter.document.getServerProperties();

                if (!options.initid) {

                    if (docProperties.renderMode === "edit") {
                        options.initid = docProperties.family.name;
                    }
                }
                options.viewId = viewId;
                if (docProperties && docProperties.status === "alive") {
                    // No write revision if not a fixed one
                    options.revision = -1;
                }

                searchArguments = currentRouter.getUrlParameters(window.location.search);
                if (searchArguments.app) {
                    // old school url
                    currentRouter.rewriteAppUrl(searchArguments, options);
                } else {
                    // api url
                    currentRouter.rewriteApiUrl(options);
                }
            });
        },

        /**
         * Rewrite access document render HTML page from url like ?app=DOCUMENT&initid=1456&revision=45
         * @param searchArguments
         * @param options
         */
        rewriteAppUrl: function router_rewriteAppUrl(searchArguments, options) {
            var searchPart,
                urlSecondPart = '',
                newUrl;
            if (searchArguments.app) {
                if (options.initid) {
                    // Extract all GET parameters and rewrite if needed
                    _.each(searchArguments, function routerGetUrl(getParameter, getKey) {
                        if (["id", "initid", "app", "viewId", "revision"].indexOf(getKey) >= 0) {
                            searchArguments[getKey] = null;
                        }
                    });

                    searchPart = _.compact(_.map(searchArguments, function router_composeSearchLocation(GETValue, GETKey) {
                        if (GETValue === null) {
                            return null;
                        }
                        return GETKey + "=" + encodeURIComponent(GETValue);
                    }));

                    if (options.viewId !== '!defaultConsultation') {
                        urlSecondPart = "/views/" + encodeURIComponent(options.viewId);
                        if (options.revision >= 0) {
                            urlSecondPart += "/revisions/" + encodeURIComponent(options.revision);
                        }
                    } else {
                        if (options.revision >= 0) {
                            urlSecondPart = "/revisions/" + encodeURIComponent(options.revision);
                        }
                    }
                    newUrl = window.location.pathname + 'api/v1/documents/' + options.initid + urlSecondPart + ".html";
                    if (searchPart.length > 0) {
                        newUrl += '?' + searchPart.join('&');
                    }
                    newUrl += window.location.hash;
                    this.navigate(newUrl, { replace: !this.useHistory });
                }
            }
        },

        /**
         * Rewrite URL if mismatches detected between server information and url access
         * @param options
         */
        rewriteApiUrl: function router_rewriteApiUrl(options) {
            var parsePath = false,
                parseHash = false,
                beginPath = '',
                urlSecondPart = '',
                locationSearch = window.location.search,
                locationHash = window.location.hash;
            var noRecordHistory;
            if (options.initid) {
                parsePath = window.location.pathname.match('(.*)api\\/v1\\/documents\\/(.*)');
                if (parsePath) {
                    beginPath = parsePath[1];

                    if (options.viewId !== '!defaultConsultation') {
                        urlSecondPart = "/views/" + encodeURIComponent(options.viewId);
                        if (options.revision >= 0) {
                            urlSecondPart += "/revisions/" + encodeURIComponent(options.revision);
                        }
                    } else {
                        if (options.revision >= 0) {
                            urlSecondPart = "/revisions/" + encodeURIComponent(options.revision);
                        }
                    }

                    noRecordHistory = /documents\/0\.html$/.test(options.path);

                    parseHash = /#widgetValue{(.*)}/.exec(locationHash);
                    if (parseHash) {
                        try {
                            var hashData = JSON.parse('{' + parseHash[1] + '}');

                            delete hashData.viewId;
                            delete hashData.initid;
                            delete hashData.revision;

                            if (hashData.customClientData) {
                                locationSearch += locationSearch ? '&' : '?';
                                locationSearch += "customClientData=";
                                locationSearch += encodeURIComponent(JSON.stringify(hashData.customClientData));
                                delete hashData.customClientData;
                            }
                            if (noRecordHistory) {
                                locationHash = '';
                            } else {
                                locationHash = '#widgetValue' + JSON.stringify(hashData);
                            }
                        } catch (e) {}
                    }

                    if (!this.useHistory) {
                        noRecordHistory = true;
                    }

                    this.navigate(beginPath + 'api/v1/documents/' + options.initid + urlSecondPart + '.html' + locationSearch + locationHash, { replace: noRecordHistory });
                }
            }
        },
        viewDocument: function router_viewDocument(initid) {
            this.document.fetchDocument({ initid: initid });
        },
        viewRevision: function router_viewRevision(initid, revision) {
            this.document.fetchDocument({
                initid: initid,
                revision: revision
            });
        },

        viewView: function router_viewView(initid, viewId) {
            this.document.fetchDocument({
                initid: initid,
                viewId: viewId
            });
        },

        viewRevisionView: function router_viewRevisionView(initid, revision, viewId) {
            this.document.fetchDocument({
                initid: initid,
                revision: revision,
                viewId: viewId
            });
        },
        fetch: function router_fetch(searchPart) {
            var searchObject,
                newValues = {};
            searchObject = this.getUrlParameters(searchPart);

            if (!_.isUndefined(searchObject.id)) {
                newValues.initid = searchObject.id;
            }
            if (!_.isUndefined(searchObject.initid)) {
                newValues.initid = searchObject.initid;
            }
            if (!_.isUndefined(searchObject.revision)) {
                newValues.revision = parseInt(searchObject.revision, 10);
            } else {
                newValues.revision = -1;
            }
            if (!_.isUndefined(searchObject.viewId)) {
                newValues.viewId = searchObject.viewId;
            } else {
                newValues.viewId = undefined;
            }
            this.document.fetchDocument(newValues);
        },

        /**
         * extract url parameters and return an simple object indexed by parameters keys
         * @param searchPart
         * @returns {{}}
         */
        getUrlParameters: function router_getUrlParameters(searchPart) {
            var extract,
                getParameters = searchPart.substr(1).split('&'),
                result = {};

            for (var i = 0; i < getParameters.length; i++) {
                extract = getParameters[i].match(/^([^=]+)=(.*)$/);
                if (extract) {
                    result[extract[1]] = decodeURIComponent(extract[2]);
                } else {
                    result[getParameters[i]] = "";
                }
            }
            return result;
        }

    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/views/attributes/array/vArray.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define, console*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/attributes/vAttribute.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/attributes/array/vColumn.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/document/attributeTemplate.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/array/wArray.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function vArray($, _, Backbone, Mustache, ViewAttribute, ViewColumn, attributeTemplate) {
    'use strict';

    return Backbone.View.extend({
        className: "row dcpArray",
        displayLabel: true,
        customView: false,
        customRowView: false,
        events: {
            "dcparraylineadded": "addLine",
            "dcparraylineremoved": "removeLine",
            "dcparraylinemoved": "moveLine",
            "dcparrayexternallinkselected": "externalLinkSelected",
            "dcpattributechange .dcpArray__content__cell": "updateValue"
        },

        columnViews: {},

        initialize: function vArray_initialize(options) {
            if (options.displayLabel === false || this.model.getOption("labelPosition") === "none") {
                this.displayLabel = false;
            }
            this.listenTo(this.model, 'change:label', this.updateLabel);
            this.listenTo(this.model, 'destroy', this.remove);
            this.listenTo(this.model, 'cleanView', this.remove);
            this.listenTo(this.model, 'change:errorMessage', this.setArrayError);
            this.listenTo(this.model, 'errorMessage', this.setError);
            this.listenTo(this.model, 'hide', this.hide);
            this.listenTo(this.model, 'show', this.show);
            this.listenTo(this.model, 'removeWidgetLine', this.removeWidgetLine);
            this.listenTo(this.model, 'addWidgetLine', this.addWidgetLine);
            this.listenTo(this.model, 'haveView', this._identifyView);
            this.options = options;
        },

        render: function vArray_render() {
            var currentView = this;
            return new Promise(_.bind(function vArray_renderPromise(resolve, reject) {
                var customRender,
                    data = currentView.model.toData(null, true),
                    event = { prevent: false },
                    promisesColumn = [];

                //Trigger the beforeRender event, and cancel display if asked
                currentView.model.trigger("beforeRender", event, { model: currentView.model, $el: currentView.$el });
                if (event.prevent) {
                    resolve(currentView);
                    return currentView;
                }

                if (currentView.options.originalView !== true) {
                    if (currentView.model.getOption("template")) {
                        customRender = attributeTemplate.renderCustomView(currentView.model);
                        currentView.customView = customRender.$el;
                        customRender.promise.then(resolve);
                        if (currentView.model.getOption("template").match('dcpArray__table')) {
                            // Two case of custom : custom line or global custom array
                            currentView.customRowView = true;
                        }
                    }
                }

                //Extract only the displayable lines
                data.content = _.filter(data.content, function vArray_filterCurrentElement(currentContent) {
                    return currentContent.isDisplayable;
                });
                data.nbLines = currentView.getNbLines();
                currentView.padValues(data.nbLines);
                data.renderOptions = currentView.model.getOptions();
                data.templates = {};
                data.displayLabel = currentView.displayLabel;
                if (currentView.model.getTemplates().attribute[currentView.model.get("type")]) {
                    data.templates = currentView.model.getTemplates().attribute[currentView.model.get("type")];
                }
                if (data.nbLines === 0 && data.mode === "read") {
                    data.showEmpty = currentView.model.getOption('showEmptyContent');
                } else {
                    if (!currentView.customView || currentView.customRowView) {
                        currentView.columnViews = [];
                        currentView.model.get("content").each(function vArray_analyzeContent(currentAttr) {
                            if (!currentAttr.isDisplayable()) {
                                return;
                            }
                            try {
                                if (currentAttr.getOption("attributeLabel")) {
                                    data.content = _.map(data.content, function vArray_changeLabelCurrentElement(currentContent) {
                                        if (currentContent.id === currentAttr.id) {
                                            currentContent.label = currentAttr.getOption("attributeLabel");
                                        }
                                        return currentContent;
                                    });
                                }
                                if (currentAttr.get("isValueAttribute")) {
                                    currentView.columnViews[currentAttr.id] = new ViewColumn({
                                        el: currentView.el,
                                        els: function vArray_findScope() {
                                            return currentView.$el.find('.dcpArray__cell[data-attrid="' + currentAttr.id + '"],' + '.dcpCustomTemplate--row[data-attrid="' + currentAttr.id + '"]');
                                        },
                                        originalView: true,
                                        model: currentAttr,
                                        parentElement: currentView.$el
                                    });
                                    promisesColumn.push(currentView.columnViews[currentAttr.id].render());
                                }
                            } catch (e) {
                                if (window.dcp.logger) {
                                    window.dcp.logger(e);
                                } else {
                                    console.error(e);
                                }
                            }
                        });
                    }
                }

                if (currentView.customView) {
                    data.customTemplate = currentView.customView;
                    data.customLineCallback = function vArray_callCustomLine(index) {
                        return attributeTemplate.customArrayRowView(index, currentView.model, currentView);
                    };
                }

                try {
                    promisesColumn.push(new Promise(_.bind(function onArrayReady(resolve, reject) {
                        currentView.$el.dcpArray(data).one("dcparraywidgetready", resolve);
                        attributeTemplate.insertDescription(currentView);
                    }, this)));
                } catch (e) {
                    if (window.dcp.logger) {
                        window.dcp.logger(e);
                    } else {
                        console.error(e);
                    }
                }

                Promise.all(promisesColumn).then(function renderDone() {
                    currentView.$el.attr("data-attrid", currentView.model.id);
                    currentView.model.trigger("renderDone", { model: currentView.model, $el: currentView.$el });
                    resolve(currentView);
                });

                return this;
            }, this));
        },

        getNbLines: function vArraygetNbLines() {
            var nbLigne = this.nbLines || 0;
            this.model.get("content").each(function vArray_getCurrentLine(currentAttr) {
                if (currentAttr.get("attributeValue") && nbLigne < _.size(currentAttr.get("attributeValue"))) {
                    nbLigne = _.size(currentAttr.get("attributeValue"));
                }
            });
            return nbLigne;
        },

        padValues: function vArrayPadValues(lineNumber) {
            if (lineNumber > 0) {
                this.model.get("content").each(function vArray_padCurrentLine(currentAttr) {
                    var currentValue = currentAttr.get("attributeValue");
                    if (currentValue !== null && currentValue !== undefined && _.size(currentValue) < lineNumber) {
                        for (var idx = currentValue.length; idx < lineNumber; idx++) {
                            currentValue.push({ value: null, displayValue: '' });
                        }
                    }
                });
            }
        },

        updateLabel: function vArrayupdateLabel() {
            this.$el.find(".dcpArray__label").text(this.model.get("label"));
        },

        updateValue: function vArray_UpdateValue(event, options) {
            var attributeModel = this.model.get("content").get(options.id);
            if (!attributeModel) {
                throw new Error("Unknown attribute " + options.id);
            }
            attributeModel.setValue(options.value, options.index);
        },

        refresh: function vArray_Refresh() {
            this.nbLines = this.$el.dcpArray("option", "nbLines");
            this.$el.dcpArray("destroy");
            this.render();
        },

        removeLine: function vArray_removeLine(event, options) {
            this.model.get("content").each(function vArray_removeLine(currentContent) {
                currentContent.removeIndexValue(options.line);
            });
            this.model.trigger("array", "removeLine", this.model, options.line);
        },

        removeWidgetLine: function vArray_RemoveWidgetLine(options) {
            this.$el.dcpArray("removeLine", options.index, { silent: true });
        },

        addWidgetLine: function vArray_addWidgetLine(options) {
            this.$el.dcpArray("addLine", options.index);
        },

        addLine: function vArray_AddLine(event, options) {
            var currentArrayView = this,
                customView = null;
            var allPromiseAttributes = [];
            this.model.get("content").each(function vArray_addLineGetContent(currentContent) {
                var currentViewColumn;
                if (options.needAddValue || options.copyValue) {
                    currentContent.createIndexedValue(options.line, options.copyValue);
                }
                currentViewColumn = currentArrayView.columnViews[currentContent.id];
                if (currentViewColumn) {
                    customView = null;
                    if (currentContent.getOption("template")) {
                        customView = attributeTemplate.renderCustomView(currentContent, function vArray_customViewInit() {
                            var $this = $(this),
                                currentWidgetOption = currentViewColumn.getData(options.line);
                            //Check if the asked attribute is the current attribute
                            if ($this.data("attrid") !== currentContent.id) {
                                throw Error("An attribute template in an array cannot asked" + " for another attribute than the current (" + $this.data("attrid") + " asked instead of " + currentContent.id + ")");
                            }
                            currentWidgetOption.viewCid = _.uniqueId(currentWidgetOption.viewCid);
                            currentViewColumn.widgetInit($this, currentWidgetOption);
                            currentViewColumn.moveValueIndex({});
                        }, { index: options.line });
                        allPromiseAttributes.push(customView.promise);
                    }
                    if (customView && customView.$el) {
                        allPromiseAttributes.push(currentViewColumn.addNewWidget(options.line, customView.$el));
                    } else {
                        allPromiseAttributes.push(currentViewColumn.addNewWidget(options.line));
                    }
                }
            });
            Promise.all(allPromiseAttributes).then(_.bind(function addlinePromiseAllDone() {
                this.model.trigger("array", "addLine", this.model, options.line);
                options.resolve();
            }, this))["catch"](options.reject);
        },

        moveLine: function vArray_moveLine(event, options) {
            this.model.get("content").each(function vArray_getMoveLineContent(currentContent) {
                currentContent.moveIndexValue(options.fromLine, options.toLine);
            });
            this.model.trigger("array", "moveLine", this.model, options);
        },
        getAttributeModel: function vArray_getAttributeModel(attributeId) {
            var docModel = this.model.getDocumentModel();
            return docModel.get('attributes').get(attributeId);
        },

        setError: function vArray_setError(event, message) {
            var parentId = this.model.get('parent');

            if (message) {
                this.$el.find(".dcpArray__label").addClass("has-error");
            } else {
                this.$el.find(".dcpArray__label").removeClass("has-error");
            }

            if (parentId) {
                var parentModel = this.getAttributeModel(parentId);
                if (parentModel) {
                    parentModel.trigger("errorMessage", event, message);
                }
            }
        },
        setArrayError: function vArray_setArrayError(event, message) {
            this.setError(event, message);
            // global error on array itself
            this.$el.dcpArray("setError", message);
        },

        hide: function vArray_hide() {
            this.$el.hide();
        },

        show: function vArray_show() {
            this.$el.show();
        },

        _identifyView: function vArray_identifyView(event) {
            event.haveView = true;
            //Add the pointer to the current jquery element to a list passed by the event
            event.elements = event.elements.add(this.$el);
        },
        externalLinkSelected: function vArrayExternalLinkSelected(event, options) {
            var documentModel = this.model.getDocumentModel();
            options.attrid = this.model.id;
            this.model.trigger("internalLinkSelected", event, options);
            if (event.prevent) {
                return this;
            }
            documentModel.trigger("actionAttributeLink", event, options);
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/views/attributes/array/vColumn.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/attributes/vAttribute.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/document/attributeTemplate.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function vColumn($, _, Backbone, Mustache, ViewAttribute, attributeTemplate) {
    'use strict';

    return ViewAttribute.extend({

        /**
         * Use special event to trigger only attributes of model
         */
        attributeEvents: function vColumnEvents() {
            var events = {};
            this._mergeEvent(events, "delete", "deleteValue");
            this._mergeEvent(events, "changeattrmenuvisibility", "changeMenuVisibility");
            this._mergeEvent(events, "changeattrsvalue", "changeAttributesValue");
            this._mergeEvent(events, "fetchdocument", "loadDocument");
            this._mergeEvent(events, "externallinkselected", "externalLinkSelected");
            this._mergeEvent(events, "downloadfile", "downloadFileSelect");
            this._mergeEvent(events, "uploadfile", "uploadFileSelect");
            this._mergeEvent(events, "uploadfiledone", "uploadFileDone");
            this._mergeEvent(events, "anchorclick", "anchorClick");
            this.listenTo(this.model, "change:label", this.changeLabel);
            return events;
        },

        _mergeEvent: function vColumn_addEvent(events, name, method) {
            events["dcpattribute" + name + ' .dcpArray__content__cell[data-attrid="' + this.model.id + '"]'] = method;
        },

        render: function vColumnRender() {
            var scope = this;
            if (this.displayLabel === false) {
                // Need to defer because thead is not construct yet
                _.defer(function vColumnHideHead() {
                    var $head = scope.$el.find('.dcpArray__head__cell[data-attrid="' + scope.model.id + '"]');
                    $head.hide();
                });
            } else {
                // Need to defer because thead is not construct yet
                _.defer(function vColumnDescriptionHead() {
                    var $head = scope.$el.find('.dcpArray__head__cell[data-attrid="' + scope.model.id + '"]');
                    attributeTemplate.insertDescription(scope, $head);
                });
            }
            this.model.trigger("renderColumnDone", { model: this.model, $el: this.$el });
            return this;
        },

        /**
         * Change the label of the column
         */
        changeLabel: function vColumnChangeLabel() {
            this.$el.find('.dcpArray__head__cell[data-attrid="' + this.model.id + '"]').text(this.model.get("label"));
        },

        /**
         * called by vArray::addLine()
         * @param index row index
         * @param customView HTML fragment to use for a custom view
         */
        addNewWidget: function vColumnAddNewWidget(index, customView) {
            return new Promise(_.bind(function vColumnAddNewWidget_promise(resolve, reject) {
                if (this.options) {
                    var cells = this.options.parentElement.find('.dcpArray__content__cell[data-attrid="' + this.model.id + '"]'),
                        $el,
                        data = this.getData(index),
                        event = { prevent: false };

                    if (cells[index]) {
                        try {
                            $el = $(cells[index]);
                            this.model.trigger("beforeRender", event, { model: this.model, $el: $el, index: index });
                            if (event.prevent) {
                                return this;
                            }
                            if (customView) {
                                $el.append(customView);
                                this.model.trigger("renderDone", { model: this.model, $el: $el, index: index });
                                this.moveValueIndex({});
                                resolve($el);
                            } else {
                                $el.one("dcpattributewidgetready .dcpAttribute__content", _.bind(function vcolumnRender_widgetready() {
                                    this.model.trigger("renderDone", { model: this.model, $el: $el, index: index });
                                    this.moveValueIndex({});
                                    resolve();
                                }, this));
                                this.widgetInit($el, data);
                                attributeTemplate.insertDescription(this, $el.parent());
                            }
                        } catch (error) {
                            if (window.dcp.logger) {
                                window.dcp.logger(error);
                            } else {
                                console.error(error);
                            }
                        }
                    }
                }
            }, this));
        },

        /**
         *
         * @param event
         * @param options
         */
        loadDocument: function vColumnLoadDocument(event, options) {
            var tableLine = options.tableLine,
                index = options.index,
                initid,
                valueLine = this.model.get("attributeValue")[tableLine],
                documentModel = this.model.getDocumentModel();
            if (_.isUndefined(index)) {
                initid = valueLine.value;
            } else {
                initid = valueLine[index].value;
            }

            this.model.trigger("internalLinkSelected", event, {
                eventId: "document.load",
                target: event.target,
                attrid: this.model.id,
                options: [initid, "!defaultConsultation"],
                index: options.index,
                row: tableLine
            });

            if (event.prevent) {
                return this;
            }

            documentModel.fetchDocument({
                "initid": initid,
                "revision": -1,
                "viewId": "!defaultConsultation"
            });
        },

        /**
         * Hide all items of the column
         */
        hide: function vColumnHide() {
            this.getDOMElements().each(function vColumnHideEach() {
                var $cell = $(this);
                var tagName = $cell.prop("tagName").toLowerCase();

                if (tagName !== "td" && tagName !== "th") {
                    $cell = $cell.closest("td.dcpArray__cell, th.dcpArray__head");
                }
                $cell.hide();
            });

            this.$el.find('thead th[data-attrid="' + this.model.id + '"]').hide();
        },
        /**
         * Show all hidden items of the column
         */
        show: function vColumnShow() {
            this.getDOMElements().each(function vColumnShowEach() {
                var $cell = $(this);
                var tagName = $cell.prop("tagName").toLowerCase();

                if (tagName !== "td" && tagName !== "th") {
                    $cell = $cell.closest("td.dcpArray__cell, th.dcpArray__head");
                }
                $cell.show();
            });
            this.$el.find('thead th[data-attrid="' + this.model.id + '"]').show();
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/views/attributes/frame/vFrame.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define, console*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/attributes/vAttribute.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/attributes/array/vArray.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/document/attributeTemplate.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function require_vFrame($, _, Backbone, Mustache, ViewAttribute, ViewAttributeArray, attributeTemplate) {
    'use strict';

    return Backbone.View.extend({

        className: "card card-default dcpFrame",
        customView: false,
        displayLabel: true,

        events: {
            "click .dcpFrame--collapsable": "toggle",
            'click a[href^="#action/"], a[data-action], button[data-action]': 'externalLinkSelected'
        },

        initialize: function vFrame_initialize(options) {

            if (options.displayLabel === false || this.model.getOption("labelPosition") === "none") {
                this.displayLabel = false;
            }
            this.listenTo(this.model, 'change:label', this.updateLabel);
            this.listenTo(this.model.get("content"), 'add', this.render);
            this.listenTo(this.model.get("content"), 'remove', this.render);
            this.listenTo(this.model.get("content"), 'reset', this.render);
            this.listenTo(this.model, 'errorMessage', this.setError);
            this.listenTo(this.model, 'change:errorMessage', this.setError);
            this.listenTo(this.model, 'destroy', this.remove);
            this.listenTo(this.model, 'resize', this.setResponsiveClasse);
            this.listenTo(this.model, 'cleanView', this.remove);
            this.listenTo(this.model, 'hide', this.hide);
            this.listenTo(this.model, 'show', this.show);
            this.listenTo(this.model, 'haveView', this._identifyView);

            this.options = options;
        },

        render: function vFrame_render() {
            var currentView = this;
            return new Promise(_.bind(function vFrame_renderPromise(resolve, reject) {
                var customRender,
                    $content,
                    labelElement,
                    contentElement = '',
                    customView = null,
                    event = { prevent: false },
                    contentData,
                    promiseAttributes = [];

                currentView.model.trigger("beforeRender", event, { model: currentView.model, $el: currentView.$el });
                if (event.prevent) {
                    resolve(currentView);
                    return currentView;
                }

                if (currentView.options.originalView !== true) {
                    if (currentView.model.getOption("template")) {
                        customRender = attributeTemplate.renderCustomView(currentView.model);
                        currentView.customView = customRender.$el;
                        promiseAttributes.push(customRender.promise);
                    }
                }

                contentData = currentView.model.toData(null, true);
                if (currentView.model.getOption("attributeLabel")) {
                    contentData.label = currentView.model.getOption("attributeLabel");
                }
                contentData.collapsable = contentData.renderOptions.collapse !== "none";

                currentView.templateLabel = currentView.model.getTemplates().attribute.frame.label;
                labelElement = $(Mustache.render(currentView.templateLabel || "", contentData));

                if (currentView.customView) {
                    contentElement = currentView.customView;
                    contentElement.addClass("dcpFrame__content dcpFrame__content--open");
                } else {
                    currentView.templateContent = currentView.model.getTemplates().attribute.frame.content;
                    contentElement = $(Mustache.render(currentView.templateContent || "", contentData));
                }
                currentView.$el.empty();
                if (currentView.displayLabel === true) {
                    currentView.$el.append(labelElement);
                }
                currentView.$el.append(contentElement);
                currentView.$el.attr("data-attrid", currentView.model.id);

                $content = currentView.$el.find(".dcpFrame__content");
                var hasOneContent = currentView.model.get("content").some(function vFrame_getDisplayable(value) {
                    return value.isDisplayable();
                });

                if (!currentView.customView) {
                    if (!hasOneContent) {
                        $content.append(currentView.model.getOption('showEmptyContent'));
                    } else {
                        currentView.model.get("content").each(function vFrame_AnalyzeContent(currentAttr) {
                            var attributeView;
                            if (!currentAttr.isDisplayable()) {
                                return;
                            }
                            try {
                                customView = null;
                                if (currentAttr.get("isValueAttribute")) {
                                    attributeView = new ViewAttribute({
                                        model: currentAttr,
                                        customView: customView
                                    });
                                    promiseAttributes.push(attributeView.render());
                                    $content.append(attributeView.$el);
                                    return;
                                }
                                if (currentAttr.get("type") === "array") {
                                    attributeView = new ViewAttributeArray({
                                        model: currentAttr
                                    });
                                    promiseAttributes.push(attributeView.render());
                                    $content.append(attributeView.$el);
                                }
                            } catch (e) {
                                $content.append('<h1 class="bg-danger"><span class="glyphicon glyphicon-warning-sign" aria-hidden="true"></span>Unable to render ' + currentAttr.id + '</h1>');
                                if (window.dcp.logger) {
                                    window.dcp.logger(e);
                                } else {
                                    console.error(e);
                                }
                            }
                        });
                    }

                    attributeTemplate.insertDescription(currentView);
                }

                if (currentView.model.getOption("collapse") === "collapse") {
                    currentView.toggle(null, true);
                }
                Promise.all(promiseAttributes).then(function allRenderDone() {
                    currentView.model.trigger("renderDone", { model: currentView.model, $el: currentView.$el });
                    if (currentView.model.getOption("responsiveColumns")) {
                        currentView.responsiveColumns();
                    }
                    resolve(currentView);
                }).catch(reject);
            }), this);
        },

        setResponsiveClasse: function vFrame_setResponsiveClasse() {
            var _this = this;
            var fWidth = 0;
            var matchesResponsive = 0;
            var responseColumnsDefs = this.model.getOption("responsiveColumns") || [];
            var isTopBottom = false;
            var isGrow = false;

            if (responseColumnsDefs.length > 0) {
                fWidth = $(this.$el).width();

                if (fWidth <= 0) {
                    return;
                }
                var $vattrs = this.$el.find("> .dcpFrame__content > .row");

                _.each(responseColumnsDefs, function vFrame_setResponsiveClasses(responseColumnsInfo) {
                    if (fWidth >= responseColumnsInfo.minAbsWidth && fWidth < responseColumnsInfo.maxAbsWidth) {

                        matchesResponsive = responseColumnsInfo.number;
                        if (responseColumnsInfo.grow === true) {
                            _this.$el.addClass("dcp-column--grow");
                            isGrow = true;
                        } else {
                            _this.$el.removeClass("dcp-column--grow");
                            isGrow = false;
                        }
                        isTopBottom = responseColumnsInfo.direction === "topBottom";

                        if (isGrow) {
                            if ($vattrs.length < matchesResponsive) {
                                matchesResponsive = $vattrs.length;
                            } else if (isTopBottom) {
                                var rowNumber = Math.ceil($vattrs.length / matchesResponsive);
                                for (var i = matchesResponsive; i--; i > 1) {
                                    if (Math.ceil($vattrs.length / i) === rowNumber) {
                                        // Decrease column number if not enough data to avoid empty columns
                                        matchesResponsive = i;
                                    }
                                }
                            }
                        }

                        if (matchesResponsive > 1) {
                            _this.$el.addClass("dcp-column--" + matchesResponsive);
                        }
                    } else {
                        _this.$el.removeClass("dcp-column--" + responseColumnsInfo.number);
                    }
                });

                if (matchesResponsive > 1) {
                    _this.$el.addClass("dcp-column");
                    if (matchesResponsive !== this.frameColumnNumber) {

                        this.frameColumnNumber = matchesResponsive;

                        if (isTopBottom) {
                            this.$el.addClass("dcp-column--topbottom");
                            this.$el.removeClass("dcp-column--leftright");
                        } else {
                            this.$el.removeClass("dcp-column--topbottom");
                            this.$el.addClass("dcp-column--leftright");
                        }
                    }
                } else {
                    this.frameColumnNumber = matchesResponsive;
                    this.$el.removeClass("dcp-column");
                    this.$el.removeClass("dcp-column--topbottom");
                    this.$el.removeClass("dcp-column--leftright");
                    this.$el.removeClass("dcp-column--grow");
                }
            }
        },

        responsiveColumns: function vFrame_responsiveColumns() {
            var responseColumnsDefs = this.model.getOption("responsiveColumns") || [];
            var _this = this;
            var $fake = $("<div/>").css({ position: "absolute", top: 0, overflow: "hidden" });
            var $fakeWidth = $("<div/>");

            $("body").append($fake.append($fakeWidth));

            // Compute absolute width
            _.each(responseColumnsDefs, function vFrame_computeResponsiveWidth(responseColumnsInfo) {
                if (!responseColumnsInfo.minWidth) {
                    responseColumnsInfo.minAbsWidth = 0;
                } else {
                    $fakeWidth.width(responseColumnsInfo.minWidth);
                    responseColumnsInfo.minAbsWidth = $fakeWidth.width();
                }

                if (!responseColumnsInfo.maxWidth) {
                    responseColumnsInfo.maxAbsWidth = Infinity;
                } else {
                    $fakeWidth.width(responseColumnsInfo.maxWidth);
                    responseColumnsInfo.maxAbsWidth = $fakeWidth.width();
                }
            });

            $fake.remove();
            $(window).on("resize.v" + this.model.cid, _.bind(this.setResponsiveClasse, this));
            _.defer(_.bind(this.setResponsiveClasse, this));
        },

        getAttributeModel: function vFrame_getAttributeModel(attributeId) {
            var docModel = this.model.getDocumentModel();
            return docModel.get('attributes').get(attributeId);
        },

        setError: function vFrame_setError(event, data) {
            if (data) {
                this.$el.find(".dcpFrame__label").addClass("has-error");
            } else {
                this.$el.find(".dcpFrame__label").removeClass("has-error");
            }
        },

        updateLabel: function vFrame_updateLabel() {
            this.$el.find(".dcpFrame__label").text(this.model.get("label"));
        },

        toggle: function vFrame_toggle(event, hideNow) {
            var $contentElement = this.$(".dcpFrame__content");
            this.$(".dcp__frame__caret").toggleClass("fa-caret-right fa-caret-down");
            $contentElement.toggleClass("dcpFrame__content--open dcpFrame__content--close");
            if (hideNow) {
                $contentElement.hide();
            } else {
                $contentElement.slideToggle(200);
                if ($contentElement.hasClass("dcpFrame__content--open")) {
                    this.model.getDocumentModel().redrawErrorMessages();
                }
            }
        },

        hide: function vFrame_hide() {
            this.$el.hide();
        },

        show: function vFrame_show() {
            this.$el.show();
        },

        externalLinkSelected: function vAttributeExternalLinkSelected(event) {
            var $target = $(event.currentTarget),
                action,
                options,
                eventOptions,
                documentModel,
                internalEvent = {
                prevent: false
            };

            event.preventDefault();
            if (event.stopPropagation) {
                event.stopPropagation();
            }

            action = $target.data('action') || $target.attr("href");
            options = action.substring(8).split(":");
            eventOptions = {
                target: event.target,
                index: -1,
                eventId: options.shift(),
                options: options
            };
            documentModel = this.model.getDocumentModel();

            this.model.trigger("internalLinkSelected", internalEvent, eventOptions);
            if (event.prevent) {
                return this;
            }

            documentModel.trigger("actionAttributeLink", internalEvent, eventOptions);

            return this;
        },

        _identifyView: function vFrame_identifyView(event) {
            event.haveView = true;
            //Add the pointer to the current jquery element to a list passed by the event
            event.elements = event.elements.add(this.$el);
        },

        /**
         * Destroy the associated widget and suppress event listener before remov the dom
         *
         * @returns {*}
         */
        remove: function vFrame_Remove() {
            $(window).off(".v" + this.model.cid);

            return Backbone.View.prototype.remove.call(this);
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/views/attributes/tab/vTabContent.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define, console*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/attributes/frame/vFrame.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/document/attributeTemplate.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/i18n/documentCatalog.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function vTabContent($, _, Backbone, Mustache, ViewAttributeFrame, attributeTemplate, i18n) {
    'use strict';

    return Backbone.View.extend({

        tagName: "div",

        className: "dcpTab__content",
        customView: false,

        initialize: function vTabContentInitialize(options) {
            this.listenTo(this.model, 'change:label', this.updateLabel);
            this.listenTo(this.model.get("content"), 'add', this.render);
            this.listenTo(this.model.get("content"), 'remove', this.render);
            this.listenTo(this.model.get("content"), 'reset', this.render);
            this.listenTo(this.model, 'cleanView', this.remove);
            this.listenTo(this.model, 'destroy', this.remove);
            this.listenTo(this.model, 'showTab', this.renderContent);
            this.listenTo(this.model, 'hide', this.hide);
            this.listenTo(this.model, 'show', this.show);
            this.listenTo(this.model, 'haveView', this._identifyView);
            this.initializeContent = options.initializeContent;
            this.initialized = false;
            this.options = options;
        },

        render: function vTabContentRender() {
            var currentView = this;
            return new Promise(_.bind(function vTabContentRender_Promise(resolve, reject) {
                var hasOneContent;
                currentView.$el.empty().append($('<div class="dcpTab__content--loading"><span class="fa fa-spinner fa-spin"></span>' + i18n.___("Displaying", "ddui") + '</div>'));
                currentView.$el.attr("id", currentView.model.id);
                currentView.$el.attr("data-attrid", currentView.model.id);

                hasOneContent = currentView.model.get("content").some(function vTabContentIsDisplayable(value) {
                    return value.isDisplayable();
                });

                if (!hasOneContent || !currentView.initializeContent) {
                    currentView.$el.append(currentView.model.getOption('showEmptyContent'));
                    currentView.$el.removeClass("dcpTab__content--loading");
                    currentView.model.trigger("renderDone", { model: currentView.model, $el: currentView.$el });
                    currentView.propageShowTab();
                    resolve(currentView);
                } else {
                    currentView.renderContent().then(function vTabContentRender_renderContent() {
                        resolve(currentView);
                    });
                }
            }, this));
        },

        renderContent: function vTabContentRenderContent(options) {
            var currentView = this;
            return new Promise(_.bind(function vTabContentRenderContent_Promise(resolve, reject) {
                var customRender,
                    $content = currentView.$el,
                    model = currentView.model,
                    promisesFrame = [];
                if (currentView.initialized === false) {
                    currentView.$el.empty();
                    if (currentView.originalView !== true) {
                        if (currentView.model.getOption("template")) {
                            customRender = attributeTemplate.renderCustomView(currentView.model);
                            currentView.customView = customRender.$el;
                            promisesFrame.push(customRender.promise);
                        }
                    }
                    if (currentView.customView) {
                        $content.append(currentView.customView);
                    } else {
                        currentView.model.get("content").each(function vTabContentRenderContent(currentAttr) {
                            var view;
                            try {
                                if (!currentAttr.isDisplayable()) {
                                    return;
                                }
                                if (currentAttr.get("type") === "frame") {
                                    view = new ViewAttributeFrame({ model: currentAttr });
                                    promisesFrame.push(view.render());
                                    $content.append(view.$el);
                                } else {
                                    //noinspection ExceptionCaughtLocallyJS
                                    throw new Error("unkown type " + currentAttr.get("type") + " for id " + currentAttr.id + " for tab " + model.id);
                                }
                            } catch (e) {
                                if (window.dcp.logger) {
                                    window.dcp.logger(e);
                                } else {
                                    console.error(e);
                                }
                            }
                        });
                        attributeTemplate.insertDescription(this);
                        if (currentView.model.getOption("responsiveColumns")) {
                            currentView.responsiveColumns();
                        }
                    }

                    Promise.all(promisesFrame).then(function tabAllFramesRenderDone() {
                        currentView.$el.removeClass("dcpTab__content--loading");
                        currentView.model.trigger("renderDone", { model: currentView.model, $el: currentView.$el });
                        currentView.initialized = true;
                        resolve();
                    }).catch(reject);
                }
                $(window.document).trigger("redrawErrorMessages");
                currentView.model.get("content").propageEvent('resize');
            }, this));
        },

        /**
         * Add responsive column classes according to responsiveColumns render option
         */
        responsiveColumns: function vTab_responsiveColumns() {
            var responseColumnsDefs = this.model.getOption("responsiveColumns") || [];
            var _this = this;
            var $fake = $("<div/>").css({ position: "absolute", top: 0, overflow: "hidden" });
            var $fakeWidth = $("<div/>");
            var setResponsiveClasse = function vTab_setResponsiveClasses() {
                var fWidth = $(_this.$el).width();
                var matchesResponsive = 0;

                _.each(responseColumnsDefs, function vTab_setResponsiveClasses(responseColumnsInfo) {
                    if (fWidth >= responseColumnsInfo.minAbsWidth && fWidth < responseColumnsInfo.maxAbsWidth) {
                        _this.$el.addClass("dcp-column--" + responseColumnsInfo.number);
                        matchesResponsive = responseColumnsInfo.number;
                        if (responseColumnsInfo.grow === true) {
                            _this.$el.addClass("dcp-column--grow");
                        } else {
                            _this.$el.removeClass("dcp-column--grow");
                        }
                    } else {
                        _this.$el.removeClass("dcp-column--" + responseColumnsInfo.number);
                    }
                });

                if (matchesResponsive > 1) {
                    _this.$el.addClass("dcp-column");
                } else {
                    _this.$el.removeClass("dcp-column");
                }
                if (matchesResponsive !== _this.frameIsResized) {
                    _this.frameIsResized = matchesResponsive;
                    // Send resize to frame in case they have also responsive.
                    _this.model.get("content").propageEvent('resize');
                }
            };

            $("body").append($fake.append($fakeWidth));

            // Compute absolute width
            _.each(responseColumnsDefs, function vTab_computeResponsiveWidth(responseColumnsInfo) {
                if (!responseColumnsInfo.minWidth) {
                    responseColumnsInfo.minAbsWidth = 0;
                } else {
                    $fakeWidth.width(responseColumnsInfo.minWidth);
                    responseColumnsInfo.minAbsWidth = $fakeWidth.width();
                }

                if (!responseColumnsInfo.maxWidth) {
                    responseColumnsInfo.maxAbsWidth = Infinity;
                } else {
                    $fakeWidth.width(responseColumnsInfo.maxWidth);
                    responseColumnsInfo.maxAbsWidth = $fakeWidth.width();
                }
            });

            $fake.remove();
            $(window).on("resize.v" + this.model.cid, setResponsiveClasse);
            _.defer(setResponsiveClasse);
        },

        propageShowTab: function vTabContentPropageShowTab() {
            this.model.get("content").propageEvent('showTab');
        },

        updateLabel: function vTabContentUpdateLabel() {
            this.$el.find(".dcpFrame__label").text(this.model.get("label"));
        },

        hide: function vTabContentHide() {
            this.$el.hide();
        },

        show: function vTabContentShow() {
            this.$el.show();
        },

        _identifyView: function vAttribute_identifyView(event) {
            event.haveView = true;
            //Add the pointer to the current jquery element to a list passed by the event
            event.elements = event.elements.add(this.$el);
        },
        remove: function vFrame_Remove() {
            $(window).off(".v" + this.model.cid);

            return Backbone.View.prototype.remove.call(this);
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/views/attributes/tab/vTabLabel.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/document/attributeTemplate.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function vTabLabel($, _, Backbone, Mustache, attributeTemplate) {
    'use strict';

    return Backbone.View.extend({

        tagName: "li",

        className: "dcpTab__label dcpLabel",

        events: {
            'click a[href^="#action/"], a[data-action], button[data-action]': 'externalLinkSelected'
        },

        displayLabel: true,

        initialize: function vTabLabel_initialize(options) {
            if (options.displayLabel === false || this.model.getOption("labelPosition") === "none") {
                this.displayLabel = false;
            }
            this.listenTo(this.model, 'change:label', this.updateLabel);
            this.listenTo(this.model.get("content"), 'add', this.render);
            this.listenTo(this.model.get("content"), 'remove', this.render);
            this.listenTo(this.model.get("content"), 'reset', this.render);
            this.listenTo(this.model, 'errorMessage', this.setError);
            this.listenTo(this.model, 'change:errorMessage', this.setError);
            this.listenTo(this.model, 'destroy', this.remove);
            this.listenTo(this.model, 'cleanView', this.remove);
            this.listenTo(this.model, 'hide', this.hide);
            this.listenTo(this.model, 'show', this.show);
        },

        render: function vTabLabel_render() {
            var label = this.model.get("label");
            var tooltipLabel = this.model.getOption("tooltipLabel");
            var attrData = this.model.attributes;
            var helpId = this.model.getOption("helpLinkIdentifier");
            var documentModel = this.model.getDocumentModel();

            this.$el.empty();
            if (this.displayLabel !== false) {
                if (this.model.getOption("attributeLabel")) {
                    label = this.model.getOption("attributeLabel");
                }

                if (helpId) {
                    this.$el.append(Mustache.render('<span class="dcpLabel__text">{{label}} <a class="dcpLabel__help__link" href="#action/document.help:{{helpId}}:{{attrid}}"><span class="fa fa-question-circle"></span></a></span>', {
                        helpId: helpId,
                        attrid: this.model.id,
                        label: label
                    }));
                } else {
                    this.$el.html($('<span class="dcpLabel__text" />').text(label));
                }

                attributeTemplate.insertDescription(this);
                if (tooltipLabel) {
                    tooltipLabel = Mustache.render(tooltipLabel || "", attrData);
                    if (!this.model.getOption("tooltipHtml")) {
                        // Need encode itself because the dropselect tooltip also need
                        tooltipLabel = $('<div/>').text(tooltipLabel).html();
                    }
                    this.$el.data("tooltipLabel", Mustache.render(tooltipLabel || "", attrData));
                    this.$el.tooltip({
                        placement: "top",
                        container: ".dcpDocument",
                        html: true,
                        title: function vDocumentTooltipTitle() {
                            if ($(this).find(".k-input.dcpTab__label__select").length > 0) {
                                // It is a selected Tab
                                return $(this).data("tooltipLabelSelect");
                            }
                            return $(this).data("tooltipLabel"); // set the element text as content of the tooltip
                        }
                    });
                }
            }

            this.$el.attr("data-attrid", this.model.id);

            return this;
        },

        setError: function vTabLabel_setError(event, data) {
            if (data) {
                this.$el.addClass("has-error");
            } else {
                this.$el.removeClass("has-error");
            }
        },

        updateLabel: function vTabLabel_updateLabel() {
            this.$el.text(this.model.get("label"));
        },

        hide: function vTabLabel_hide() {
            this.$el.hide();
        },

        show: function vTabLabel_show() {
            this.$el.show();
        },

        externalLinkSelected: function vAttributeExternalLinkSelected(event) {
            var $target = $(event.currentTarget),
                action,
                options,
                eventOptions,
                documentModel,
                internalEvent = {
                prevent: false
            };

            event.preventDefault();
            if (event.stopPropagation) {
                event.stopPropagation();
            }

            action = $target.data('action') || $target.attr("href");
            options = action.substring(8).split(":");
            eventOptions = {
                target: event.target,
                index: scopeWidget._getIndex(),
                eventId: options.shift(),
                options: options
            };
            documentModel = this.model.getDocumentModel();

            this.model.trigger("internalLinkSelected", internalEvent, eventOptions);
            if (event.prevent) {
                return this;
            }

            documentModel.trigger("actionAttributeLink", internalEvent, options);

            return this;
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/views/attributes/vAttribute.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*global define, console*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/document/attributeTemplate.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/label/wLabel.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/text/wText.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/int/wInt.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/longtext/wLongtext.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/htmltext/wHtmltext.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/timestamp/wTimestamp.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/time/wTime.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/image/wImage.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/money/wMoney.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/enum/wEnum.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/color/wColor.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/password/wPassword.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/file/wFile.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/double/wDouble.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/docid/wDocid.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function vAttribute($, _, Backbone, Mustache, attributeTemplate) {
    'use strict';

    return Backbone.View.extend({

        className: "row dcpAttribute form-group",
        customView: false,
        displayLabel: true,
        //Don't use standard event to launch the event only when there is no template
        //********************************************************************************************
        // If you add an event here, you probably want to add it in vColumn.js and test it in an array
        //********************************************************************************************
        attributeEvents: {
            "dcpattributechange .dcpAttribute__content,[data-dcpattribute_content]": "updateValue",
            "dcpattributedelete .dcpAttribute__content": "deleteValue",
            "dcpattributechangeattrmenuvisibility .dcpAttribute__content": "changeMenuVisibility",
            "dcpattributechangeattrsvalue .dcpAttribute__content": "changeAttributesValue",
            "dcpattributefetchdocument .dcpAttribute__content": "loadDocument",
            "dcpattributeexternallinkselected .dcpAttribute__content": "externalLinkSelected",
            "dcplabelexternallinkselected": "externalLinkSelected",
            "dcpattributedownloadfile  .dcpAttribute__content": "downloadFileSelect",
            "dcpattributeuploadfile  .dcpAttribute__content": "uploadFileSelect",
            "dcpattributeuploadfiledone  .dcpAttribute__content": "uploadFileDone",
            "dcpattributeanchorclick .dcpAttribute__content": "anchorClick",
            "dcpattributewidgetready .dcpAttribute__content": "setWidgetReady"
        },

        initialize: function vAttributeInitialize(options) {
            var events;
            this.listenTo(this.model, 'change:label', this.refreshLabel);
            this.listenTo(this.model, 'change:attributeValue', this.refreshValue);
            this.listenTo(this.model, 'change:errorMessage', this.refreshError);
            this.listenTo(this.model, 'moved', this.moveValueIndex);
            this.listenTo(this.model, 'destroy', this.remove);
            this.listenTo(this.model, 'showTab', this.afterShow);
            this.listenTo(this.model, 'hide', this.hide);
            this.listenTo(this.model, 'show', this.show);
            this.listenTo(this.model, 'haveView', this._identifyView);
            this.listenTo(this.model, 'closeWidget', this._closeWidget);
            this.templateWrapper = this.model.getTemplates().attribute.simpleWrapper;

            options = options || {};

            //Guess if the view is a template (originalView = false in this case)
            options.originalView = options.originalView !== false;

            if (options.displayLabel === false || this.model.getOption("labelPosition") === "none") {
                this.displayLabel = false;
            }

            //Attribute without template so we bind event
            if (options.originalView === true) {
                events = this.attributeEvents;
                //For vColumn events
                if (_.isFunction(events)) {
                    events = events.apply(this);
                }
                this.delegateEvents(events);
            }
            this.options = options;
        },

        /**
         * The Data are the source of data shared with widget and templates
         *
         * @param index
         * @returns {*}
         */
        getData: function vAttributeGetData(index) {
            var data;

            //Made to JSON for all the values, or to data for value indexed (in cas of multiple)
            data = this.model.toData(index, true);
            data.viewCid = this.cid + '-' + this.model.id;
            data.labels.deleteAttributeNames = this.getDeleteLabels();
            // autoComplete detected
            data.autocompleteRequest = _.bind(this.autocompleteRequestRead, this);

            return data;
        },

        render: function vAttributeRender() {
            var currentView = this;
            var renderPromise = new Promise(_.bind(function vAttributeRender_Promise(resolve, reject) {
                var data,
                    event = { prevent: false },
                    customRender;

                currentView.model.trigger("beforeRender", event, { model: currentView.model, $el: currentView.$el });
                if (event.prevent) {
                    resolve();
                    return currentView;
                }

                //We fetch data after beforeRender, if some data is modified by beforeRender we get it
                data = currentView.getData();

                currentView.$el.addClass("dcpAttribute--type--" + currentView.model.get("type"));
                currentView.$el.addClass("dcpAttribute--visibility--" + currentView.model.get("visibility"));
                currentView.$el.attr("data-attrid", currentView.model.get("id"));
                if (currentView.model.get("needed")) {
                    currentView.$el.addClass("dcpAttribute--needed");
                }

                currentView.$el.append($(Mustache.render(currentView.templateWrapper || "", data)));

                attributeTemplate.insertDescription(currentView);

                //analyze the display label and add display class
                if (currentView.displayLabel === false) {
                    currentView.$el.find(".dcpAttribute__label").remove();
                    // set to 100% width
                    currentView.$el.find(".dcpAttribute__right").addClass("dcpAttribute__right--full");
                } else {
                    if (currentView.model.getOption("labelPosition") === "left") {
                        currentView.$el.addClass("dcpAttribute__labelPosition--left");
                        currentView.$el.find(".dcpAttribute__right").not(".dcpAttribute__description").addClass("dcpAttribute__labelPosition--left");
                        currentView.$el.find(".dcpAttribute__left").not(".dcpAttribute__description").addClass("dcpAttribute__labelPosition--left");
                    }
                    if (currentView.model.getOption("labelPosition") === "up") {
                        currentView.$el.addClass("dcpAttribute__labelPosition--up");
                        currentView.$el.find(".dcpAttribute__right").not(".dcpAttribute__description").addClass("dcpAttribute__labelPosition--up");
                        currentView.$el.find(".dcpAttribute__left").not(".dcpAttribute__description").addClass("dcpAttribute__labelPosition--up");
                    }
                    if (currentView.model.getOption("labelPosition") === "auto") {
                        currentView.$el.addClass("dcpAttribute__labelPosition--auto");
                        currentView.$el.find(".dcpAttribute__right").addClass("dcpAttribute__labelPosition--auto");
                        currentView.$el.find(".dcpAttribute__left").addClass("dcpAttribute__labelPosition--auto");
                    }
                    currentView.$el.find(".dcpAttribute__label").dcpLabel(data);
                }

                //If there is a template render it
                if (currentView.options.originalView !== true && currentView.model.getOption("template")) {
                    customRender = attributeTemplate.renderCustomView(currentView.model);
                    currentView.customView = customRender.$el;
                    currentView.$el.find(".dcpAttribute__content").append(currentView.customView);
                    customRender.promise.then(resolve);
                    customRender.promise["catch"](reject);
                } else {
                    //there is not template render (default)
                    currentView.$el.one("dcpattributewidgetready .dcpAttribute__content", function vattributeRender_widgetready() {
                        resolve();
                    });
                    currentView.currentDcpWidget = currentView.widgetInit(currentView.$el.find(".dcpAttribute__content"), data);
                }

                currentView.renderDone = true;
                if (currentView.customView) {
                    currentView.widgetReady = true;
                }

                currentView.triggerRenderDone();
                return currentView;
            }, this));
            return renderPromise;
        },

        refreshLabel: function vAttributeRefreshLabel() {
            var label = this.model.get("label"),
                labelDom = this.getDOMElements().find(".dcpAttribute__label");
            if (this.model.getOption("attributeLabel")) {
                label = this.model.getOption("attributeLabel");
            }
            if (labelDom.data("dcpDcpLabel")) {
                this.getDOMElements().find(".dcpAttribute__label").dcpLabel("setLabel", label);
            }
        },

        /**
         * Autorefresh value when model change
         */
        refreshValue: function vAttributeRefreshValue(model, values, options) {
            var scope = this,
                allWrapper,
                arrayWrapper;
            if (options.notUpdateArray) {
                return this;
            }

            allWrapper = this.getDOMElements();

            if (this.model.isInArray()) {
                // adjust line number to column length
                arrayWrapper = this.$el;
                arrayWrapper.dcpArray("setLines", values.length, options).then(_.bind(function setValue() {
                    values = _.toArray(values);
                    _.each(values, function analyzeValues(currentValue, index) {
                        if (_.isUndefined(currentValue)) {
                            return;
                        }
                        var cssIndex = '.dcpAttribute__content--widget[data-attrid="' + model.id + '"]';
                        $(allWrapper[index]).find(cssIndex).addBack(cssIndex).each(function vAttributeRefreshOneValue(index, element) {
                            scope.widgetApply($(element), "setValue", currentValue);
                        });
                    });
                }, this));
            } else {
                this.widgetApply(allWrapper.find('.dcpAttribute__content--widget[data-attrid="' + model.id + '"]'), "setValue", values);
            }
        },

        /**
         * Display error message around the widget if needed
         * @param event
         */
        refreshError: function vAttributeRefreshError(event) {
            this.$el.find(".dcpAttribute__label").dcpLabel("setError", this.model.get("errorMessage"));
            // andSelf method was removed from jQuery 3.0.0+ use addBack instead
            var jqueryVersion = +$().jquery.split('.')[0];
            if (jqueryVersion >= 3) {
                this.widgetApply(this.getDOMElements().find(".dcpAttribute__content--widget").addBack().filter(".dcpAttribute__content--widget"), "setError", this.model.get("errorMessage"));
            } else {
                this.widgetApply(this.getDOMElements().find(".dcpAttribute__content--widget").andSelf().filter(".dcpAttribute__content--widget"), "setError", this.model.get("errorMessage"));
            }
        },

        /**
         * Modify several attribute
         * @param event event object
         * @param index the value rank in case of multiple
         * @param options object {dataItem :, valueIndex :}
         */
        changeAttributesValue: function vAttributeChangeAttributesValue(event, options, index) {
            var externalEvent = { prevent: false },
                currentView = this,
                dataItem = options.dataItem,
                valueIndex = options.valueIndex,
                currentValue;
            this.model.trigger("helperSelect", externalEvent, this.model.id, dataItem, index);
            if (externalEvent.prevent) {
                return this;
            }
            _.each(dataItem.values, function vAttributeChangeAttributeValue(attributeValue, attributeId) {
                if ((typeof attributeValue === 'undefined' ? 'undefined' : _typeof(attributeValue)) === "object") {
                    if (attributeValue.value === null) {
                        //Value not completed by helper so don't use it
                        return;
                    }

                    var attrModel = currentView.model.getDocumentModel().get('attributes').get(attributeId);
                    if (attrModel) {
                        if (attrModel.hasMultipleOption()) {
                            currentValue = attrModel.getValue();
                            if (valueIndex >= 0) {
                                currentValue = currentValue[valueIndex];
                            }
                            // No add same value twice
                            if (!_.some(currentValue, function vAttributeNoDouble(itemValue) {
                                return itemValue.value === attributeValue.value;
                            })) {
                                attrModel.addValue({
                                    value: attributeValue.value,
                                    displayValue: attributeValue.displayValue
                                }, valueIndex);
                            }
                        } else {
                            attrModel.setValue({
                                value: attributeValue.value,
                                displayValue: attributeValue.displayValue
                            }, valueIndex);
                        }
                    } else {
                        console.error("Unable to find " + attributeId);
                    }
                }
            });
        },

        /**
         * Modify view : triggered by wDocid
         * @param event
         * @param options
         * @returns {*}
         */
        loadDocument: function changeAttributesValueLoadDocument(event, options) {
            var index = options.index,
                initid = null,
                attributeValue = this.model.get("attributeValue"),
                documentModel = this.model.getDocumentModel(),
                revision = -1;
            if (_.isUndefined(index)) {
                initid = attributeValue.value;
                revision = attributeValue.revision;
            } else {
                initid = attributeValue[index].value;
                revision = attributeValue[index].revision;
            }

            this.model.trigger("internalLinkSelected", event, {
                eventId: "document.load",
                target: event.target,
                attrid: this.model.id,
                options: [initid, "!defaultConsultation"],
                index: options.index
            });

            if (event.prevent) {
                return this;
            }

            documentModel.trigger("loadDocument", {
                initid: initid,
                viewId: "!defaultConsultation",
                revision: revision
            });
        },

        /**
         * Create dialog window to create and insert document
         */
        displayFormDocument: function vAttributedisplayFormDocument(event, buttonConfig, index) {
            var attrid = this.model.id;
            if (buttonConfig.createLabel) {
                var documentModel = this.model.getDocumentModel();

                __webpack_require__.e/* require.ensure */("wCreateDocument").then((function vDocumentCreateDocument() {
                    __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/docid/wCreateDocument.js");
                    var $bdw = $('<div class="dcpDocid-create-window"/>');
                    var $dcp = $bdw.dcpCreateDocument(_.extend(buttonConfig, {
                        originDocumentModel: documentModel,
                        attributeId: attrid,
                        index: index,
                        listener: function vDocumentCreateListener(event, triggerId, options) {
                            options.dialogDocument = this;
                            options.triggerId = triggerId;
                            documentModel.trigger("createDialogListener", event, attrid, options);
                        }
                    })).data("dcpCreateDocument");
                    $dcp.open();
                }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
            }
        },

        externalLinkSelected: function vAttributeExternalLinkSelected(event, options) {
            var documentModel = this.model.getDocumentModel();
            options.attrid = this.model.id;
            this.model.trigger("internalLinkSelected", event, options);
            if (event.prevent) {
                return this;
            }
            if (options.eventId === "attribute.createDocumentRelation") {
                this.displayFormDocument(event, options.buttonConfig, options.index);
            } else {
                documentModel.trigger("actionAttributeLink", event, options);
            }
        },
        downloadFileSelect: function vAttributedownloadFileSelect(widgetEvent, options) {
            var event = { prevent: false };

            this.model.trigger("downloadFile", event, this.model.id, options);
            if (event.prevent) {
                widgetEvent.preventDefault();
            }
        },
        uploadFileSelect: function vAttributeuploadFileSelect(widgetEvent, options) {
            var event = { prevent: false };

            this.model.trigger("uploadFile", event, this.model.id, options);
            if (event.prevent) {
                widgetEvent.preventDefault();
            }
        },
        uploadFileDone: function vAttributeuploadFileSEnd(widgetEvent, options) {
            var event = { prevent: false };

            this.model.trigger("uploadFileDone", event, this.model.id, options);
        },

        anchorClick: function vAttributeAnchorClick(widgetEvent, options) {
            var internalEvent = { prevent: false };

            this.model.trigger("anchorClick", internalEvent, this.model.id, options);
            if (internalEvent.prevent) {
                widgetEvent.preventDefault();
            }
        },

        /**
         * Delete value,
         * If has help, clear also target attributes
         * @param event
         * @param data index info {index:"the index}
         */
        deleteValue: function changeAttributesValueDeleteValue(event, data) {

            if (data.id === this.model.id) {
                var attrToClear = this.model.get('helpOutputs'),
                    docModel = this.model.getDocumentModel();
                if (!attrToClear || typeof attrToClear === "undefined") {
                    attrToClear = [this.model.id];
                } else {
                    attrToClear = _.toArray(attrToClear);
                }
                _.each(attrToClear, function vAttributeCleanAssociatedElement(aid) {
                    var attr = docModel.get('attributes').get(aid);
                    if (attr) {
                        if (attr.hasMultipleOption()) {
                            attr.setValue([], data.index);
                        } else {
                            attr.setValue({ value: null, displayValue: '' }, data.index);
                        }
                    }
                });
            }
        },

        /**
         * Return another attribute model
         *
         * @param attributeId
         * @returns {*}
         */
        getAttributeModel: function vAttributeGetAttributeModel(attributeId) {
            var docModel = this.model.getDocumentModel();
            return docModel.get('attributes').get(attributeId);
        },

        /**
         * Used for render attribute
         *
         * @returns {Array}
         */
        getDeleteLabels: function vAttributeGetDeleteLabels() {
            var attrToClear = this.model.get('helpOutputs'),
                scope = this,
                attrLabels;
            if (!attrToClear || typeof attrToClear === "undefined") {
                attrToClear = [this.model.id];
            } else {
                attrToClear = _.toArray(attrToClear);
            }
            attrLabels = _.map(attrToClear, function vAttributeGetAssociatedLabel(aid) {
                var attr = scope.getAttributeModel(aid);
                if (attr) {
                    return attr.attributes.label;
                }
                return '';
            });
            return attrLabels;
        },

        /**
         * Propagate move value event to widgets
         * @param eventData
         */
        moveValueIndex: function vAttributeMoveValueIndex(eventData) {
            this.getDOMElements().trigger("postMoved", eventData);
        },

        /**
         * method use for transport multiselect widget
         * @param index the row index of autocomplete when it is in array
         * @param options
         */
        autocompleteRequestRead: function vAttributeAutocompleteRequestRead(options, index) {
            var currentView = this,
                documentModel = this.model.getDocumentModel(),
                success = options.success,
                externalOptions = {
                setResult: function vAttributeAutoCompleteSet(content) {
                    _.each(content, function (item) {
                        if (item.message) {
                            item.message.contentText = item.message.contentText || '';
                            item.message.contentHtml = item.message.contentHtml || '';
                            item.message.type = item.message.type || 'message';
                        } else if (item.error) {
                            item.message = {
                                contentHtml: '',
                                contentText: item.error,
                                type: "error"
                            };
                        }
                        item.title = item.title || '';
                    });
                    success(content);
                },
                data: options.data
            },
                autocompleteUrl,
                event = { prevent: false };
            //Add helperResonse event (can be used to reprocess the content of the request)
            success = _.wrap(success, function vAttributeAutoCompleteSuccess(success, content) {
                var options = {},
                    event = { prevent: false };
                options.data = content;
                currentView.model.trigger("helperResponse", event, currentView.model.id, options, index);
                if (event.prevent) {
                    return success([]);
                }
                success(content);
            });

            //Add helperSearch event (can prevent default ajax request)
            options.data.attributes = documentModel.getValues();
            this.model.trigger("helperSearch", event, this.model.id, externalOptions, index);
            if (event.prevent) {
                return this;
            }
            autocompleteUrl = "api/v1/documents/" + (documentModel.id || "0") + "/autocomplete/" + this.model.id;

            options.data.fromid = documentModel.get("properties").get("family").id;

            $.ajax({
                type: "POST",
                url: autocompleteUrl,
                data: options.data,

                dataType: "json" // "jsonp" is required for cross-domain requests; use "json" for same-domain requestsons.error(result);
            }).pipe(function vAttributeAutocompletehandleSuccessRequest(response) {
                if (response.success) {
                    return response;
                } else {
                    return $.Deferred().reject(response);
                }
            }, function vAttributeAutocompletehandleErrorRequest(response) {
                if (response.status === 0) {
                    return {
                        success: false,
                        error: "Your navigator seems offline, try later"
                    };
                }
                return {
                    success: false,
                    error: "Unexpected error: " + response.status + " " + response.statusText
                };
            }).then(function vAttributeAutocompleteSuccessResult(result) {
                // notify the data source that the request succeeded
                _.each(result.messages, function (message) {
                    message.contentText = message.contentText || '';
                    message.contentHtml = message.contentHtml || '';
                    result.data.unshift({
                        message: message,
                        title: ''
                    });
                });
                success(result.data);
            }, function vAttributeAutocompleteErrorResult(result) {
                // notify the data source that the request failed
                if (_.isArray(result.error)) {
                    result.error = result.error.join(" ");
                }
                //use the success callback because http error are handling by the pipe
                success([{ "title": "", "error": result.error }]);
            });
        },

        /**
         * Modify visibility access of an item menu
         * @param event event object
         * @param data menu config {id: menuId, visibility: "disabled", "visible", "hidden"}
         */
        changeMenuVisibility: function vAttributeChangeMenuVisibility(event, data) {
            this.model.trigger("changeMenuVisibility", event, data);
        },

        getDOMElements: function vAttributeGetDOMElements() {
            if (this.options && this.options.els) {
                return this.options.els();
            } else {
                return this.$el;
            }
        },

        afterShow: function vAttributeAfterShow() /*event, data*/{
            // propagate event to widgets
            this.getDOMElements().trigger("show");
        },
        /**
         *
         * @param event
         * @param data
         */
        updateValue: function vAttributeUpdateValue(event, data) {
            this.model.setValue(data.value, data.index);
        },

        widgetInit: function vAttributeWidgetInit($element, data) {
            $element.addClass("dcpAttribute__content--widget");
            return this.getWidgetClass($element).call($element, data);
        },

        widgetApply: function vAttributeWidgetApply($element, method, argument) {
            try {
                if (_.isString(method) && $element && this.getWidgetClass($element)) {
                    this.getWidgetClass($element).call($element, method, argument);
                }
            } catch (e) {
                if (window.dcp.logger) {
                    window.dcp.logger(e);
                } else {
                    console.error(e);
                }
            }
            return this;
        },

        getWidgetClass: function vAttributeGetWidgetClass($element) {
            $element = $element || this.$el;
            if (!$element.data("currentWidgetClass")) {
                $element.data("currentWidgetClass", this.getTypedWidgetClass(this.model.get("type")));
            }
            return $element.data("currentWidgetClass");
        },

        getTypedWidgetClass: function vAttributeGetTypedWidgetClass(type) {
            switch (type) {
                case "text":
                    return $.fn.dcpText;
                case "int":
                    return $.fn.dcpInt;
                case "double":
                    return $.fn.dcpDouble;
                case "money":
                    return $.fn.dcpMoney;
                case "longtext":
                    return $.fn.dcpLongtext;
                case "htmltext":
                    return $.fn.dcpHtmltext;
                case "date":
                    return $.fn.dcpDate;
                case "timestamp":
                    return $.fn.dcpTimestamp;
                case "time":
                    return $.fn.dcpTime;
                case "image":
                    return $.fn.dcpImage;
                case "color":
                    return $.fn.dcpColor;
                case "file":
                    return $.fn.dcpFile;
                case "enum":
                    return $.fn.dcpEnum;
                case "password":
                    return $.fn.dcpPassword;
                case "thesaurus":
                case "account":
                case "docid":
                    return $.fn.dcpDocid;
                default:
                    return $.fn.dcpText;
            }
        },

        setWidgetReady: function Vattribute_setWidgetReady() {
            this.widgetReady = true;
            this.triggerRenderDone();
        },

        triggerRenderDone: function vAttribute_triggerRenderDone() {
            if (this.noRenderEvent !== false && this.renderDone && this.widgetReady && !this.triggerRender) {
                this.model.trigger("renderDone", { model: this.model, $el: this.$el });
                this.triggerRender = true;
            }
        },

        remove: function vAttributeRemove() {
            try {
                if (this.currentDcpWidget && this.getWidgetClass(this.currentDcpWidget) && this._findWidgetName(this.$el)) {
                    this.getWidgetClass(this.currentDcpWidget).call(this.$el, "destroy");
                }
            } catch (e) {
                if (window.dcp.logger) {
                    window.dcp.logger(e);
                } else {
                    console.error(e);
                }
            }
            return Backbone.View.prototype.remove.call(this);
        },

        hide: function vAttributeHide() {
            this.$el.hide();
        },

        show: function vAttributeShow() {
            this.$el.show();
        },

        _closeWidget: function vAttribute__closeWidget() {
            try {
                if (this.currentDcpWidget && this.getWidgetClass(this.currentDcpWidget) && this._findWidgetName(this.currentDcpWidget)) {
                    this.getWidgetClass(this.currentDcpWidget).call(this.currentDcpWidget, "close");
                }
            } catch (e) {
                if (window.dcp.logger) {
                    window.dcp.logger(e);
                } else {
                    console.error(e);
                }
            }
        },

        _findWidgetName: function vAttribute_findWidgetName($element) {
            return _.find(_.keys($element.data()), function vAttribute_findWidgetNameFind(currentKey) {
                return currentKey.indexOf("dcpDcp") !== -1;
            });
        },

        _identifyView: function vAttribute_identifyView(event) {
            event.haveView = true;
            //Add the pointer to the current jquery element to a list passed by the event
            event.elements = event.elements.add(this.$el);
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/views/document/attributeTemplate.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
!(__WEBPACK_AMD_DEFINE_RESULT__ = function attributeTemplate(require /*, exports, module*/) {
    'use strict';

    var _ = __webpack_require__("./node_modules/underscore/underscore.js");
    var $ = __webpack_require__("external \"jQuery\"");
    var Mustache = __webpack_require__("./node_modules/mustache/mustache.js");

    return {

        customLineTemplate: '',

        /**
         * Get some data to complete custom attribute template
         * @param documentModel document model
         * @returns {{properties: *, attributes: {}}}
         * @public
         */
        getTemplateModelInfo: function attributeTemplateGetTemplateModelInfo(documentModel) {
            var documentData = documentModel.getDocumentData();
            var templateInfo = {
                properties: documentData.properties,
                attributes: {}
            };
            var currentTemplate = this;

            templateInfo.properties.isWriteMode = templateInfo.properties.renderMode === "edit";
            templateInfo.properties.isReadMode = templateInfo.properties.renderMode === "view";

            _.each(documentData.attributeValues, function associateValue(attributeValue, attributeId) {
                templateInfo.attributes[attributeId] = { attributeValue: attributeValue };
            });
            _.each(documentData.attributeLabels, function attributeTemplategetTemplateModelInfoEach(attributeLabel, attributeId) {
                var currentAttributeModel = documentModel.get('attributes').get(attributeId);
                if (currentAttributeModel.getOption("attributeLabel")) {
                    attributeLabel = currentAttributeModel.getOption("attributeLabel");
                }

                if (templateInfo.attributes[attributeId]) {
                    templateInfo.attributes[attributeId].label = attributeLabel;
                } else {
                    templateInfo.attributes[attributeId] = { label: attributeLabel };
                }

                templateInfo.attributes[attributeId].id = attributeId;
                templateInfo.attributes[attributeId].isEmpty = currentTemplate._isEmptyAttribute(currentAttributeModel);

                templateInfo.attributes[attributeId].htmlContent = _.bind(currentTemplate.getCustomTemplate, currentTemplate, currentAttributeModel, false, false);
                templateInfo.attributes[attributeId].htmlView = _.bind(currentTemplate.getCustomTemplate, currentTemplate, currentAttributeModel, true, false);
                templateInfo.attributes[attributeId].htmlDefaultContent = _.bind(currentTemplate.getCustomTemplate, currentTemplate, currentAttributeModel, false, true);
                templateInfo.attributes[attributeId].htmlDefaultView = _.bind(currentTemplate.getCustomTemplate, currentTemplate, currentAttributeModel, true, true);
                templateInfo.attributes[attributeId].isReadMode = currentAttributeModel.get("mode") === "read";
                templateInfo.attributes[attributeId].isWriteMode = currentAttributeModel.get("mode") === "write";
                templateInfo.attributes[attributeId].renderOptions = currentAttributeModel.getOptions();
                if (currentAttributeModel.get("type") === "array") {
                    templateInfo.attributes[attributeId].toolsEnabled = templateInfo.attributes[attributeId].isWriteMode && currentAttributeModel.get("visibility") !== "U" && (currentAttributeModel.getOption("rowAddDisable") !== true || currentAttributeModel.getOption("rowDelDisable") !== true || currentAttributeModel.getOption("rowMoveDisable") !== true);
                    templateInfo.attributes[attributeId].rows = _.bind(currentTemplate.getArrayRowInfo, currentTemplate, currentAttributeModel);
                    templateInfo.attributes[attributeId].tableTools = _.bind(currentTemplate.getArrayTools, currentTemplate, currentAttributeModel);
                }
            });
            return templateInfo;
        },

        _isEmptyAttribute: function attributeTemplate_isEmptyAttribute(attributeModel) {
            var currentTemplate = this;
            if (attributeModel.get("isValueAttribute")) {
                var attrValue = attributeModel.get("attributeValue");
                return _.isEmpty(attrValue) || attrValue.value === "" || attrValue.value === null;
            }
            if (!attributeModel.get("content") || attributeModel.get("content").length === 0) {
                return true;
            }
            if (attributeModel.get("content").some) {
                return !attributeModel.get("content").some(function attributeTemplate_isEmptyAttribute_checkEmpty(value) {
                    return !currentTemplate._isEmptyAttribute(value);
                });
            }
        },

        /**
         * Get some data to complete custom attribute template
         * @returns {{properties: *, attributes: {}}}
         * @private
         */
        getTemplateInfo: function attributeTemplateGetTemplateInfo(attributeModel) {
            var templateInfo = this.getTemplateModelInfo(attributeModel.getDocumentModel());
            var attributeId = attributeModel.id;
            var extraKeys = attributeModel.getOption("templateKeys");

            templateInfo.attribute = templateInfo.attributes[attributeId];
            if (extraKeys) {
                var copyextraKeys = _.clone(extraKeys);
                if (copyextraKeys.attribute && copyextraKeys.attribute.rows) {
                    copyextraKeys.attribute = _.clone(extraKeys.attribute);
                    delete copyextraKeys.attribute.rows;
                }
                templateInfo = this._deepExtend(templateInfo, copyextraKeys);
            }
            return templateInfo;
        },

        /**
         * Recursively extend data
         *
         * @param target
         * @param source
         * @returns {*}
         */
        _deepExtend: function attributeTemplate_deepExtend(target, source) {
            for (var prop in source) {
                if (source.hasOwnProperty(prop)) {
                    if (prop in target) {
                        this._deepExtend(target[prop], source[prop]);
                    } else {
                        target[prop] = source[prop];
                    }
                }
            }
            return target;
        },

        /**
         * Construct custom view based on template options
         *
         * @param attrModel Attribute model
         * @param callBackView Callback to call after
         * @returns {*|HTMLElement}
         * @param config
         */
        renderCustomView: function attributeTemplateCustomView(attrModel, callBackView, config) {
            var customTemplate = '<div class="dcpCustomTemplate" data-attrid="' + attrModel.id + '">' + attrModel.getOption("template") + '</div>';
            var templateInfo = this.getTemplateInfo(attrModel);
            var $render;
            var completePromise;

            if (config && !_.isUndefined(config.index) && config.index >= 0) {
                templateInfo.attribute.attributeValue = templateInfo.attribute.attributeValue[config.index];
            }
            $render = $(Mustache.render(customTemplate || "", templateInfo));
            completePromise = this.completeCustomContent($render, attrModel.getDocumentModel(), callBackView, config);
            return { "$el": $render, "promise": completePromise };
        },

        /**
         *
         * Render the custom element of the template
         *
         * @param $el
         * @param documentModel
         * @param callBackView
         * @param config
         */
        completeCustomContent: function attributeTemplateCompleteCustomContent($el, documentModel, callBackView, config) {
            var renderElementPromises = [];
            $el.find(".dcpCustomTemplate--content").each(function attributeTemplatecompleteCustomContentEach() {
                var attrId = $(this).data("attrid"),
                    displayLabel = $(this).data("displaylabel") === true,
                    currentAttributeModel = documentModel.get('attributes').get(attrId),
                    attrContent = "NO VIEW FOR " + attrId,
                    view = '',
                    BackView = null,

                // guess if the template is the true version (without template, only the widget)
                originalView = $(this).data("originalview") === true;

                if (currentAttributeModel) {

                    if (_.isFunction(callBackView)) {
                        // When called from vColumn to render widget in a cell
                        callBackView.apply($(this));
                        attrContent = '';
                    } else {
                        try {
                            switch (currentAttributeModel.get("type")) {
                                case "array":
                                    BackView = __webpack_require__("./src/Apps/DOCUMENT/IHM/views/attributes/array/vArray.js");
                                    break;
                                case "tab":
                                    BackView = __webpack_require__("./src/Apps/DOCUMENT/IHM/views/attributes/tab/vTabContent.js");
                                    break;
                                case "frame":
                                    BackView = __webpack_require__("./src/Apps/DOCUMENT/IHM/views/attributes/frame/vFrame.js");
                                    break;
                                default:
                                    BackView = __webpack_require__("./src/Apps/DOCUMENT/IHM/views/attributes/vAttribute.js");
                            }

                            //If the attribute has no template, so it's the view with the widget, we annotate it to bind the events
                            if (!currentAttributeModel.getOption("template")) {
                                originalView = true;
                            }

                            if (originalView === false && currentAttributeModel.customViewRended === true) {
                                throw new Error("Cannot use \"htmlView\" / \"htmlContent\" for itself on own custom view for " + currentAttributeModel.id + ". Use \"htmlDefaultView\" / \"htmlDefaultContent\" instead");
                            }
                            if (originalView === false) {
                                currentAttributeModel.customViewRended = true;
                            }

                            view = new BackView({
                                model: currentAttributeModel,
                                originalView: originalView,
                                initializeContent: config && config.initializeContent || false,
                                displayLabel: displayLabel
                            });
                            renderElementPromises.push(view.render());
                            attrContent = view.$el;
                        } catch (e) {
                            attrContent = $("<div/>").addClass("bg-danger").text(e.message);
                        }
                    }
                }
                $(this).append(attrContent);
            });
            return Promise.all(renderElementPromises);
        },

        /**
         * Information used when add new line
         * @param attributeModel
         * @param index line index
         * @private
         * @returns {{properties: *, attributes: {}}}
         */
        getLineInfo: function attributeTemplategetLineInfo(attributeModel, index) {
            var documentData = attributeModel.getDocumentModel().getDocumentData();
            var templateInfo = this.getTemplateInfo(attributeModel);
            var extraKeys = attributeModel.getOption("templateKeys");

            _.each(documentData.attributeLabels, function attributeTemplate_eachLabel(attributeLabel, attributeId) {
                var currentAttributeModel = attributeModel.getDocumentModel().get('attributes').get(attributeId);
                // Reset some special keys which are not allowed here
                if (currentAttributeModel.get("type") === "array") {
                    templateInfo.attributes[attributeId].rows = [];
                    templateInfo.attributes[attributeId].tableTools = 'NO TABLE TOOL ALLOWED HERE';
                }
            });

            templateInfo.rowTools = this.getRowTool(attributeModel);
            templateInfo.content = {};
            attributeModel.get("content").each(function attributeTemplate_eachContent(currentAttribute) {
                var attributeId = currentAttribute.id;
                var attributeLabel = currentAttribute.get('label');

                if (!currentAttribute.isDisplayable()) {
                    return;
                }

                if (currentAttribute.getOption("attributeLabel")) {
                    attributeLabel = currentAttribute.getOption("attributeLabel");
                }
                templateInfo.content[attributeId] = {};
                templateInfo.content[attributeId].attributeValue = {
                    value: null, // No value for the moment. Value will be set by array view with default values
                    displayValue: ""
                };
                templateInfo.content[attributeId].label = attributeLabel;
                templateInfo.content[attributeId].htmlContent = '<div class="dcpCustomTemplate--row dcpArray__content__cell dcpAttribute__content" data-displaylabel="false" data-attrid="' + attributeId + '"/>';
            });

            if (extraKeys && extraKeys.attribute && extraKeys.attribute.rows) {
                _.each(extraKeys.attribute.rows, function attributeTemplategetLineInfoEach(extraValues, extraKey) {
                    templateInfo[extraKey] = extraValues[index];
                });
            }

            return templateInfo;
        },

        /**
         * Extract rows template line to customLineTemplate
         * @param attrModel
         * @private
         * @returns {{attribute: {rows: Function}}}
         */
        extractRow: function attributeTemplateExtractRow(attrModel) {
            var scope = this;
            var info;

            info = {
                attribute: {
                    rows: function attributeTemplateExtractRowContent() {
                        return function attributeTemplate_getRowContent(text) {
                            scope.customLineTemplate = text.trim();
                        };
                    }
                }
            };
            info.attributes = {};
            info.attributes[attrModel.id] = info.attributes;
            return info;
        },

        /**
         * Construct custom line (declared in vArray::render and used in wArray::_getLineContent)
         * @param index
         * @param attrModel
         * @returns {*|HTMLElement}
         */
        customArrayRowView: function attributeTemplateCustomArrayRowView(index, attrModel) {

            var $render;

            // Extract line to customLineTemplate variable
            Mustache.render(attrModel.getOption("template") || "", this.extractRow(attrModel));
            $render = $(Mustache.render(this.customLineTemplate || "", this.getLineInfo(attrModel, index)));

            return $render;
        },

        /**
         * Get element where custom template will be inserted (htmlContent and htmlView)
         * @param attributeModel
         * @param displayLabel
         * @param originalView
         * @private
         * @returns {string}
         */
        getCustomTemplate: function attributeTemplategetCustomTemplate(attributeModel, displayLabel, originalView) {
            return '<div class="dcpCustomTemplate--content ' + (displayLabel ? "dcpCustomTemplate--content--view" : "dcpCustomTemplate--content--value") + '" data-displaylabel="' + (displayLabel ? "true" : "false") + '" data-originalview="' + (originalView ? "true" : "false") + '" data-attrid="' + attributeModel.id + '"/>';
        },

        /**
         * Extract dcpArray__tools from content array template
         * @param attributeModel
         * @private
         * @returns {*}
         */
        getArrayTools: function attributeTemplateGetArrayTools(attributeModel) {
            var tpls = attributeModel.getTemplates().attribute[attributeModel.get("type")];
            if (tpls && tpls.content) {
                return $(Mustache.render(tpls.content || "", { tools: true })).find(".dcpArray__tools").get(0).outerHTML;
            }
            return 'no tools';
        },

        /**
         * Extract dcpArray__content__toolCell from line array template
         * @param attributeModel
         * @private
         * @returns {*}
         */
        getRowTool: function attributeTemplateGetRowTool(attributeModel) {
            var templates = attributeModel.getTemplates().attribute[attributeModel.get("type")];
            var tool = '';
            if (templates && templates.line) {
                tool = $(Mustache.render(templates.line || "", {
                    tools: true,
                    lineCid: _.uniqueId(attributeModel.id)
                })).find(".dcpArray__toolCell").html();
            }
            return tool;
        },

        /**
         * Get data for mustache "rows" variable
         * @param attributeModel
         * @private
         * @returns {Array}
         */
        getArrayRowInfo: function attributeTemplategetArrayRowInfo(attributeModel) {

            var rows = [];
            var line = this.getRowTool(attributeModel);

            attributeModel.get("content").each(function attributeTemplate_eachContent(currentAttribute) {
                var values;
                var attributeId = currentAttribute.id;
                var attributeLabel = currentAttribute.get('label');
                if (!currentAttribute.isDisplayable()) {
                    return;
                }

                if (currentAttribute.getOption("attributeLabel")) {
                    attributeLabel = currentAttribute.getOption("attributeLabel");
                }
                values = currentAttribute.get('attributeValue');
                _.each(values, function attributeTemplategetArrayRowInfoEach(singleValue, index) {
                    if (_.isUndefined(rows[index])) {
                        rows[index] = { content: {} };
                    }
                    rows[index].index = index;
                    rows[index].content[attributeId] = {
                        label: attributeLabel,
                        attributeValue: singleValue,
                        htmlContent: '<div class="dcpCustomTemplate--row dcpArray__content__cell dcpAttribute__content"  data-attrid="' + currentAttribute.id + '"/>'
                    };

                    rows[index].rowTools = line;
                });
            });

            return rows;
        },

        renderClickDesc: function renderClickDesc($tip, nsOn) {
            $tip.on("click" + nsOn, function vAttributeShowDesc(event) {
                event.stopPropagation();
                $(this).tooltip("toggle");
            }).one("show.bs.tooltip", function wDescTooltip() {
                var tipElement = $(this).data("bs.tooltip").tip;
                if (tipElement) {
                    $(tipElement).addClass("dcpAttribute__description-info");
                }
            }).one("shown.bs.tooltip", function wDescTooltip() {
                var tipElement = $(this).data("bs.tooltip").tip;
                if (tipElement) {
                    $(tipElement).find(".tooltip-inner").prepend('<span class="btn btn-secondary button-close-error"><span class="fa fa-times" />&nbsp;</span>');

                    $(tipElement).on("click" + nsOn, ".button-close-error", function vAttributeCloseDesc(event) {
                        event.stopPropagation();
                        $(tipElement).tooltip("hide");
                    });
                }
            });
        },

        /**
         * Insert attribute description
         * @param attributeView Backbone view
         * @param $customElement specific other DOM element instead of default element view
         */
        insertDescription: function attributeTemplateInsertDescription(attributeView, $customElement) {
            var data = attributeView.model.toData(null, true);

            if (!data.renderOptions.description) {
                return;
            }
            var descriptionTemplate;
            var $tip;
            var nsOn = ".v" + attributeView.model.cid;
            var $viewElement = $customElement ? $customElement : attributeView.$el;
            var isFrame = $viewElement.hasClass("dcpFrame");
            var isArray = $viewElement.hasClass("dcpArray");
            var isArrayHead = $viewElement.hasClass("dcpArray__head__cell");
            var isArrayCell = $viewElement.hasClass("dcpArray__cell");
            var isAttribute = $viewElement.hasClass("dcpAttribute");
            var isTabContent = $viewElement.hasClass("dcpTab__content");
            var isTabLabel = $viewElement.hasClass("dcpTab__label");
            var $descriptionElement;

            descriptionTemplate = attributeView.model.getTemplates().attribute.description;
            data.renderOptions.description.htmlContentRender = Mustache.render(data.renderOptions.description.htmlContent, data);
            data.renderOptions.description.htmlTitleRender = Mustache.render(data.renderOptions.description.htmlTitle, data);

            $descriptionElement = $(Mustache.render(descriptionTemplate || "", data));

            if (isFrame) {
                switch (data.renderOptions.description.position) {
                    case "bottom":
                        $viewElement.append($descriptionElement);
                        break;
                    case "top":
                    case "topLabel":
                        $viewElement.prepend($descriptionElement);
                        break;
                    case "left":
                        $viewElement.find(".dcpFrame__content").addClass("dcpFrame__content--left-description");
                        $descriptionElement.insertAfter($viewElement.find(".dcpFrame__label"));
                        break;
                    case "right":
                        // Need to add class because no have css selector
                        $viewElement.append($descriptionElement);
                        $viewElement.find(".dcpFrame__content").addClass("dcpFrame__content--right-description");
                        break;
                    case "bottomLabel":
                        $descriptionElement.insertAfter($viewElement.find(".dcpFrame__label"));
                        break;
                    case "topValue":
                        $viewElement.find(".dcpFrame__content").prepend($descriptionElement);
                        break;
                    case "bottomValue":
                        $viewElement.find(".dcpFrame__content").append($descriptionElement);
                        break;
                    case "click":
                        $viewElement.append($descriptionElement);
                        $viewElement.find(".dcpFrame__label").prepend('<a class="dcpAttribute__label_description"><span class="fa fa-info-circle"></span></a>');
                        $tip = $viewElement.find(".dcpFrame__label > .dcpAttribute__label_description").tooltip({
                            html: true,
                            container: $viewElement,
                            title: $descriptionElement,
                            placement: "auto",
                            trigger: "manual"
                        });

                        this.renderClickDesc($tip, nsOn);

                }
            }
            if (isTabContent || isTabLabel) {
                switch (data.renderOptions.description.position) {
                    case "top":
                    case "topValue":
                        if (isTabContent) {
                            $viewElement.prepend($descriptionElement);
                        }
                        break;
                    case "bottom":
                    case "bottomValue":
                        if (isTabContent) {
                            $viewElement.append($descriptionElement);
                        }
                        break;
                    case "click":
                        if (isTabLabel) {
                            $viewElement.append($descriptionElement);
                            $viewElement.find(".dcpLabel__text").prepend('<a class="dcpAttribute__label_description"><span class="fa fa-info-circle"></span></a>');

                            $tip = $viewElement.find(".dcpAttribute__label_description").tooltip({
                                html: true,
                                container: ".dcpDocument",
                                title: $descriptionElement,
                                placement: "auto",
                                trigger: "manual"
                            });

                            this.renderClickDesc($tip, nsOn);
                        }
                        break;

                    case "bottomLabel":
                    case "topLabel":
                    case "left":
                    case "right":
                        console.error("Cannot use \"" + data.renderOptions.description.position + "\" description position in tab attribute : " + data.id);
                }
            }
            if (isArray) {
                switch (data.renderOptions.description.position) {
                    case "top":
                        $viewElement.prepend($descriptionElement);
                        break;
                    case "topLabel":
                        $viewElement.find(".dcpArray__label").prepend($descriptionElement);
                        break;
                    case "bottomLabel":
                        $viewElement.find(".dcpArray__label").append($descriptionElement);
                        break;
                    case "topValue":
                        $viewElement.find(".dcpArray__content").prepend($descriptionElement);
                        break;
                    case "bottomValue":
                        $descriptionElement.insertAfter($viewElement.find(".dcpArray__table"));
                        break;
                    case "bottom":
                        $viewElement.append($descriptionElement);
                        break;
                    case "click":
                        $viewElement.append($descriptionElement);
                        $viewElement.find(".dcpArray__label").prepend('<a class="dcpAttribute__label_description"><span class="fa fa-info-circle"></span></a>');

                        $tip = $viewElement.find(".dcpArray__label > .dcpAttribute__label_description").tooltip({
                            html: true,
                            container: $viewElement,
                            title: $descriptionElement,
                            placement: "auto",
                            trigger: "manual"
                        });

                        this.renderClickDesc($tip, nsOn);

                        break;

                    case "left":
                    case "right":
                        console.error("Cannot use \"" + data.renderOptions.description.position + "\" description position in array attribute : " + data.id);
                        break;
                }
            }
            if (isAttribute) {
                switch (data.renderOptions.description.position) {
                    case "bottom":
                        $viewElement.append($descriptionElement);
                        break;
                    case "top":
                        $viewElement.prepend($descriptionElement);
                        break;
                    case "left":
                        $viewElement.find(".dcpAttribute__label").append($descriptionElement);
                        break;
                    case "right":
                        $viewElement.find(".dcpAttribute__content").append($descriptionElement);
                        break;
                    case "topValue":
                        $viewElement.prepend($descriptionElement);
                        $descriptionElement.addClass("dcpAttribute__right");
                        break;
                    case "topLabel":
                        $viewElement.prepend($descriptionElement);
                        $descriptionElement.addClass("dcpAttribute__left");
                        break;
                    case "bottomValue":
                        $viewElement.append($descriptionElement);
                        $descriptionElement.addClass("dcpAttribute__right");
                        break;
                    case "bottomLabel":
                        $viewElement.append($descriptionElement);
                        $descriptionElement.addClass("dcpAttribute__left");
                        break;
                    case "click":
                        $viewElement.append($descriptionElement);
                        $viewElement.find(".dcpAttribute__label").append('<a class="dcpAttribute__label_description"><span class="fa fa-info-circle"></span></a>');

                        $tip = $viewElement.find(".dcpAttribute__label_description").tooltip({
                            html: true,
                            container: $viewElement,
                            placement: "auto",
                            title: $descriptionElement,
                            trigger: "manual"
                        });

                        this.renderClickDesc($tip, nsOn);

                }
            }

            if (isArrayCell || isArrayHead) {
                switch (data.renderOptions.description.position) {
                    case "topLabel":
                    case "top":
                        if (isArrayHead) {
                            $viewElement.prepend($descriptionElement);
                        }
                        break;
                    case "topValue":
                        if (isArrayCell) {
                            $viewElement.prepend($descriptionElement);
                        }
                        break;
                    case "bottomValue":
                        if (isArrayCell) {
                            $viewElement.append($descriptionElement);
                        }
                        break;
                    case "bottom":
                    case "bottomLabel":
                        if (isArrayHead) {
                            $viewElement.append($descriptionElement);
                        }
                        break;
                    case "click":
                        if (isArrayHead) {
                            $viewElement.append($descriptionElement);
                            $viewElement.prepend('<a class="dcpAttribute__label_description"><span class="fa fa-info-circle"></span></a>');

                            $tip = $viewElement.find(".dcpAttribute__label_description").tooltip({
                                html: true,
                                container: $viewElement,
                                placement: "auto",
                                title: $viewElement.find("> .dcpAttribute__description"),
                                trigger: "manual"
                            });

                            this.renderClickDesc($tip, nsOn);
                        }
                        break;
                    case "left":
                    case "right":
                        // No use in column context
                        console.error("Cannot use \"" + data.renderOptions.description.position + "\" description position in column attribute : " + data.id);
                        break;
                }
            }
            if (data.renderOptions.description.htmlContent) {
                $viewElement.on("click" + nsOn, ".dcpAttribute__description__title", function vAttribute_descToggle() {
                    var $contentElement = $(this).closest(".dcpAttribute__description").find(".dcpAttribute__description__content");
                    $(this).find(".dcpAttribute__description__title__expand").toggleClass("fa-caret-right fa-caret-down");
                    $contentElement.slideToggle(200);
                });
                if (data.renderOptions.description.collapsed === true) {
                    $viewElement.find(".dcpAttribute__description__title__expand").toggleClass("fa-caret-right fa-caret-down");
                    $viewElement.find(".dcpAttribute__description__content").hide();
                }
            }
        }
    };
}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/views/document/header/vHeader.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js"), __webpack_require__("./node_modules/mustache/mustache.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function require_vheader($, _, Backbone, Mustache) {
    'use strict';

    return Backbone.View.extend({

        className: "dcpDocument",

        /**
         * The current model is the document model
         * The header template comes from template "sections/header"
         */
        headerTemplate: null,

        initialize: function vHeaderInitialize() {
            this.listenTo(this.model.get("properties"), 'change', this.updateHeader);
            this.listenTo(this.model, 'destroy', this.remove);
            this.listenTo(this.model, 'cleanView', this.remove);
            this.listenTo(this.model, 'changeValue', this.documentHasChanged);
            this.headerTemplate = this.getTemplates("sections").header;
        },

        /**
         * apply mustache template to inner content
         * @returns {*}
         */
        render: function vheaderRender() {
            var currentView = this;
            return new Promise(_.bind(function vheaderRenderPromise(resolve, reject) {
                var data = currentView.model.toData(),
                    properties = currentView.model.getModelProperties(),
                    security = properties.security || false;

                data.document.properties = properties;

                data.document.properties.security = security || { lock: { lockedBy: null } };
                data.document.properties.security.lock.isLocked = data.document.properties.security.lock.lockedBy && data.document.properties.security.lock.lockedBy.id > 0;

                var headerRender = $(Mustache.render(currentView.headerTemplate || "", data));
                var $header = currentView.$el;
                $header.empty();
                _.each(headerRender.children(), function eachChildren(elt) {
                    $header.append(elt);
                });

                $header.find(".dcpDocument__header__lock, .dcpDocument__header__readonly, .dcpDocument__header__modified").tooltip({
                    placement: "bottom",
                    html: true
                });

                return resolve(currentView);
            }, this));
        },

        /**
         * reset mustache template
         * update window title also
         * @returns {*}
         */
        updateHeader: function vheaderUpdateHeader() {
            var doctitle = this.model.get("properties").get('title');
            if (doctitle) {
                window.document.title = doctitle;
            }
            return this.render();
        },

        getTemplates: function vheadergetTemplates(key) {
            var templates = {};
            if (this.model && this.model.get("templates")) {
                templates = this.model.get("templates");
            }
            if (templates[key]) {
                return templates[key];
            }
            if (window.dcp && window.dcp.templates && window.dcp.templates[key]) {
                return window.dcp.templates[key];
            }
            throw new Error("Unknown template  " + key);
        },
        documentHasChanged: function vheaderdocumentHasChanged() {
            var wTitle = window.document.title.replace(/^\*+/g, "");

            if (this.model.hasAttributesChanged()) {
                this.$el.find(".dcpDocument__header__modified").show();
                window.document.title = "*" + wTitle;
            } else {
                this.$el.find(".dcpDocument__header__modified").hide();
                window.document.title = wTitle;
            }
            if (this.model.hasUploadingFile()) {
                this.$el.find(".dcpDocument__header__modified").addClass("fa-spin");
            } else {
                this.$el.find(".dcpDocument__header__modified").removeClass("fa-spin");
            }
        }

    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/views/document/menu/vMenu.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/menu/wMenu.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function (_, Backbone, Mustache, WidgetMenu) {
    'use strict';

    return Backbone.View.extend({

        className: "dcpDocument",

        events: {
            "dcpmenuexternallinkselected": "externalLinkSelected"
        },

        /**
         * The current model is the document model
         * So menuModel reference the menu model
         */
        menuModel: null,

        initialize: function vMenuInitialize() {
            this.listenTo(this.model.get("properties"), 'change', this.updateWidget);
            this.listenTo(this.model.get("menus"), 'change', this.updateWidget);
            this.listenTo(this.model.get("menus"), 'reload', this.updateWidget);
            this.listenTo(this.model.get("attributes"), 'changeMenuVisibility', this.changeVisibility);
            this.listenTo(this.model, 'destroy', this.remove);
            this.listenTo(this.model, 'cleanView', this.remove);
            this.menuModel = this.model.get("menus");
        },

        render: function vMenuRender() {
            var currentView = this;
            return new Promise(_.bind(function vMenuRenderPromise(resolve, reject) {
                currentView.$el.dcpMenu(currentView.model.toData());
                currentView.refresh();
                return resolve(currentView);
            }, this));
        },

        externalLinkSelected: function vAttributeExternalLinkSelected(event, options) {
            var internalEvent = {
                prevent: false
            };

            options.attrid = this.model.id;
            this.model.trigger("internalLinkSelected", internalEvent, options);
            if (event.prevent) {
                return this;
            }
            this.model.trigger("actionAttributeLink", internalEvent, options);
            return this;
        },

        changeVisibility: function vMenuchangeVisibility(event, data) {
            var menuItem = this.menuModel.get(data.id);
            var onlyIfVisible = !!data.onlyIfVisible;
            var visibility;
            if (menuItem) {
                visibility = menuItem.get("visibility");
                if (!onlyIfVisible || visibility !== 'hidden') {
                    menuItem.set("visibility", data.visibility);
                }
            }
        },

        updateWidget: function vMenuUpdateWidget() {
            if (this.$el.dcpMenu && this._findWidgetName(this.$el)) {
                this.$el.dcpMenu("destroy");
            }
            return this.render();
        },

        remove: function vMenuRemove() {
            if (this.$el.dcpMenu && this._findWidgetName(this.$el)) {
                this.$el.dcpMenu("destroy");
            }
            return Backbone.View.prototype.remove.call(this);
        },

        _findWidgetName: function vMenu_findWidgetName($element) {
            return _.find(_.keys($element.data()), function (currentKey) {
                return currentKey.indexOf("dcpDcp") !== -1;
            });
        },

        /**
         * Recompute responsive in case of scrollbar can appear
         */
        refresh: function vMenu_refresh() {
            if (this.$el.dcpMenu && this._findWidgetName(this.$el)) {
                this.$el.dcpMenu("updateResponsiveMenu");
            }
        }

    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/views/document/vDocument.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define, console*/

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/backbone/backbone.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/models/mDocumentTab.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/document/menu/vMenu.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/document/header/vHeader.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/attributes/frame/vFrame.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/attributes/tab/vTabLabel.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/attributes/tab/vTabContent.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/document/attributeTemplate.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/models/mTransitionGraph.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/workflow/vTransitionGraph.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/i18n/documentCatalog.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/history/wHistory.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/properties/wProperties.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function vDocument(_, $, Backbone, Mustache, ModelDocumentTab, ViewDocumentMenu, ViewDocumentHeader, ViewAttributeFrame, ViewAttributeTabLabel, ViewAttributeTabContent, attributeTemplate, ModelTransitionGraph, ViewTransitionGraph, i18n) {
    'use strict';

    var checkTouchEvents = function checkTouchEvents() {
        //From modernizer
        var bool = false;
        if ('ontouchstart' in window || window.DocumentTouch && window.document instanceof window.DocumentTouch) {
            bool = true;
        }
        return bool;
    };

    return Backbone.View.extend({

        className: "dcpDocument container-fluid",

        events: {
            'click .dcpDocument__body a[href^="#action/"], .dcpDocument__body a[data-action], .dcpDocument__body button[data-action]': 'propagateActionClick',
            'click .dcpDocument__body a[href^="#"]': 'handleHashClick'
        },

        /**
         * Init event
         */
        initialize: function vDocumentInitialize() {
            this.listenTo(this.model, 'destroy', this.remove);
            this.listenTo(this.model, 'displayLoading', this.displayLoading);
            this.listenTo(this.model, 'invalid', this.showView);
            this.listenTo(this.model, 'displayNetworkError', this.displayNetworkError);
            this.listenTo(this.model, 'actionAttributeLink', this.doStandardAction);
            this.listenTo(this.model, 'loadDocument', this.loadDocument);
            this.listenTo(this.model, 'dduiDocumentReady', this.cleanAndRender);
            this.listenTo(this.model, 'dduiDocumentDisplayView', this.showView);
        },

        /**
         * Clean the associated view and re-render it
         */
        cleanAndRender: function vDocumentCleanAndRender() {
            this.trigger("loaderShow", i18n.___("Rendering", "ddui"), 70);
            $(".dcpStaticErrorMessage").attr("hidden", true);
            this.$el.show();
            this.$el[0].className = this.$el[0].className.replace(/\bdcpFamily.*\b/g, '');
            this.$el.removeClass("dcpDocument--view").removeClass("dcpDocument--edit");
            try {
                if (this.historyWidget) {
                    this.historyWidget.destroy();
                }
                if (this.propertiesWidget) {
                    this.propertiesWidget.destroy();
                }
                if (this.helpWidget) {
                    this.helpWidget.destroy();
                }
                if (this.transitionGraph && this.transitionGraph.view) {
                    this.transitionGraph.view.remove();
                }
            } catch (e) {
                console.error(e);
            }
            //  this.trigger("cleanNotification");
            this.render();
        },

        /**
         * Render the document view
         * @returns {*}
         */
        render: function vDocumentRender() {
            console.time("render document view");
            var renderPromises = [];
            var $content,
                model = this.model,
                $el = this.$el,
                currentView = this;
            var locale = this.model.get('locale');
            var documentView = this;
            var htmlBody = '<div class="dcpDocument__form form-horizontal">' + '<div class="dcpDocument__frames"></div>' + '<div style="display:none" class="dcpDocument__tabs">' + '<ul class="dcpDocument__tabs__list"></ul></div></div>';
            var $body;
            var tabPlacement = this.model.getOption("tabPlacement") || "top";
            var event = { prevent: false };
            var viewMenus = [];

            this.$el.removeClass("dcpTouch");
            if (checkTouchEvents()) {
                this.$el.addClass("dcpTouch");
            }

            this.selectedTab = this.model.getOption("openFirstTab");
            this.model.trigger("beforeRender", event);

            if (event.prevent) {
                return this;
            }

            this.template = this.getTemplates("body").trim();
            this.partials = this.getTemplates("sections");

            // Hide parasite tooltip if any
            this.$el.find("[aria-describedby*='tooltip']").tooltip("hide");
            this.$el.empty();

            this.renderCss();
            this.publishMessages();

            this.updateTitle();
            this.updateIcon();

            if (!locale) {
                locale = "fr-FR";
            }
            $(window).off(".v" + this.model.cid);

            $(window).on("resize.v" + this.model.cid, _.bind(this.resizeForFooter, this));
            $(window).on("scroll.v" + this.model.cid, _.bind(this.fixedTab, this));
            kendo.culture(locale);
            //add document base
            try {
                var renderData = this.model.toData();
                renderData.document = attributeTemplate.getTemplateModelInfo(this.model);
                this.$el.append($(Mustache.render(this.template || "", renderData, this.partials)));
                attributeTemplate.completeCustomContent(this.$el, this.model, null, { initializeContent: true });
                $body = this.$el.find(".dcpDocument__body").append(htmlBody).addClass("container-fluid");
            } catch (e) {
                if (window.dcp.logger) {
                    window.dcp.logger(e);
                } else {
                    console.error(e);
                }
            }

            this.$el.removeClass("dcpDocument--create");
            if (this.model.get("creationFamid")) {
                this.$el.addClass("dcpDocument--create");
            }
            this.$el.addClass("dcpDocument dcpDocument--" + this.model.get("renderMode"));
            this.$el.addClass("dcpFamily--" + this.model.get("properties").get("family").name);
            this.trigger("loading", 10);
            //add menu
            try {
                this.$el.find(".dcpDocument__menu").each(function vDocumentAddMenu() {
                    var viewMenu = new ViewDocumentMenu({
                        model: currentView.model,
                        el: this
                    });
                    renderPromises.push(viewMenu.render());
                    viewMenus.push(viewMenu);
                });
            } catch (e) {
                if (window.dcp.logger) {
                    window.dcp.logger(e);
                } else {
                    console.error(e);
                }
            }
            try {
                this.$el.find(".dcpDocument__header").each(function vDocumentAddHeader() {
                    renderPromises.push(new ViewDocumentHeader({
                        model: currentView.model,
                        el: this
                    }).render());
                });
            } catch (e) {
                if (window.dcp.logger) {
                    window.dcp.logger(e);
                } else {
                    console.error(e);
                }
            }
            this.trigger("loading", 20, this.model.get("attributes").length);
            //add first level attributes

            $content = this.$el.find(".dcpDocument__frames");
            if ($body && $body.length > 0) {
                this.model.get("attributes").each(function vDocumentRenderAttribute(currentAttr) {
                    var view, viewTabLabel, viewTabContent;
                    if (!currentAttr.isDisplayable()) {
                        currentView.trigger("partRender");
                        return;
                    }
                    if (currentAttr.get("type") === "frame" && _.isEmpty(currentAttr.get("parent"))) {
                        try {

                            view = new ViewAttributeFrame({
                                model: model.get("attributes").get(currentAttr.id)
                            });
                            renderPromises.push(view.render());
                            $content.append(view.$el);
                        } catch (e) {
                            if (window.dcp.logger) {
                                window.dcp.logger(e);
                            } else {
                                console.error(e);
                            }
                        }
                    }
                    if (currentAttr.get("type") === "tab" && _.isEmpty(currentAttr.get("parent"))) {
                        try {
                            var tabModel = model.get("attributes").get(currentAttr.id);
                            var tabContent;
                            viewTabLabel = new ViewAttributeTabLabel({ model: tabModel });

                            viewTabContent = new ViewAttributeTabContent({
                                model: tabModel
                            });
                            renderPromises.push(viewTabContent.render());

                            tabContent = viewTabContent.$el;

                            $el.find(".dcpDocument__tabs__list").append(viewTabLabel.render().$el);

                            $el.find(".dcpDocument__tabs").append(tabContent);
                            $el.find(".dcpDocument__tabs").show();
                        } catch (e) {
                            if (window.dcp.logger) {
                                window.dcp.logger(e);
                            } else {
                                console.error(e);
                            }
                        }
                    }
                    currentView.trigger("partRender");
                });

                this.kendoTabs = this.$(".dcpDocument__tabs").kendoTabStrip({
                    tabPosition: tabPlacement,
                    animation: {
                        open: {
                            duration: 100,
                            effects: "fadeIn"
                        }
                    },
                    activate: function vDocument(event) {
                        if (!this._dcpNotFirstactivate) {
                            _.delay(_.bind(documentView.scrollTobVisibleTab, documentView), 500);
                            this._dcpNotFirstactivate = true;
                        }
                    },
                    show: function vDocumentShowTab(event) {
                        var tabId = $(event.item).data("attrid");
                        var scrollY = $(window).scrollTop();
                        currentView.$(".dcpTab__label").removeClass("dcpLabel--active").addClass("dcpLabel--default");
                        currentView.$('.dcpLabel[data-attrid="' + tabId + '"]').addClass("dcpLabel--active").removeClass("dcpLabel--default");
                        if (documentView.selectedTab !== tabId) {
                            documentView.selectedTab = tabId;
                            documentView.recordSelectedTab(tabId);
                        }
                        _.defer(function selectOneTab() {
                            if (currentView && currentView.model && currentView.model.get("attributes")) {
                                var tab = currentView.model.get("attributes").get(tabId);
                                if (tab) {
                                    // Hide parasite tooltip if any
                                    currentView.$el.find("[aria-describedby*='tooltip']").tooltip("hide");
                                    tab.trigger("showTab");
                                    _.each(viewMenus, function (viewMenu) {
                                        viewMenu.refresh();
                                    });
                                    _.defer(function () {
                                        $(window).scrollTop(scrollY);
                                    });
                                }
                            }
                        });
                    }
                });
                if (tabPlacement === "topProportional") {
                    var tabItems = $el.find(".dcpDocument__tabs__list li");
                    if (tabItems.length > 1) {
                        tabItems.css("width", Math.floor(100 / tabItems.length) - 0.5 + '%');
                    } else {
                        tabItems.css("width", "80%");
                    }
                }
                if (tabPlacement === "left") {
                    this.$(".dcpTab__content").css("min-height", this.$(".dcpDocument__tabs__list").height() + "px");
                    this.$(".dcpDocument__tabs").addClass("dcpDocument__tabs--left");
                }

                if (tabPlacement === "topFix" && this.kendoTabs) {
                    this.$(".dcpDocument__tabs").addClass("dcpDocument__tabs--fixed");

                    $(window).on("resize.v" + this.model.cid, _.debounce(_.bind(this.responsiveTabMenu, this), 100, false));
                }
                if (tabPlacement === "top" && this.kendoTabs) {
                    this.$(".dcpDocument__tabs").addClass("dcpDocument__tabs--fixed");
                    $(window).on("resize.v" + this.model.cid, _.debounce(_.bind(this.scrollTabList, this), 100, false));
                    _.delay(_.bind(this.scrollTabList, this), 500);
                }

                if (this.kendoTabs.length > 0 && this.kendoTabs.data("kendoTabStrip")) {
                    var selectTab = 'li[data-attrid=' + this.selectedTab + ']';
                    if (this.selectedTab && $(selectTab).length > 0) {
                        this.kendoTabs.data("kendoTabStrip").select(selectTab);
                    } else {
                        this.kendoTabs.data("kendoTabStrip").select(0);
                    }
                }
            }
            $(window.document).on("drop.v" + this.model.cid + " dragover." + this.model.cid, function vDocumentPreventDragDrop(e) {
                e.preventDefault();
            }).on("redrawErrorMessages.v" + this.model.cid, function vDocumentRedrawErrorMessages() {
                documentView.model.redrawErrorMessages();
            });
            $(window).on("resize.v" + this.model.cid, _.debounce(function vDocumentResizeDebounce() {
                documentView.model.redrawErrorMessages();
                documentView.scrollTobVisibleTab();
            }, 100, false));

            $(window).on("resize.v" + this.model.cid, _.debounce(function vDocumentResizeDebounce() {
                if (documentView.model.get("attributes")) {
                    documentView.model.get("attributes").each(function vDocument_triggerClose(currentAttributeModel) {
                        currentAttributeModel.trigger("closeWidget");
                    });
                }
            }, 100, false));

            this.$el.addClass("dcpDocument--show");

            this.resizeForFooter();
            console.timeEnd("render document view");
            Promise.all(renderPromises).then(_.bind(function vDocumentRenderDone() {
                this.trigger("renderDone");
            }, this));
            this.$el.show();
            if (tabPlacement === "topFix" && this.kendoTabs) {
                _.defer(_.bind(this.responsiveTabMenu, this)); // need to call here to have good dimensions
            }
            if (tabPlacement === "left") {
                this.$(".dcpTab__content").css("width", "calc(100% - " + ($(".dcpDocument__tabs__list").width() + 30) + "px)");
            }

            _.delay(function vDocumentEndLoading() {
                $(".dcpLoading--init").removeClass("dcpLoading--init");
                if (tabPlacement === "topFix" && documentView.kendoTabs) {
                    documentView.responsiveTabMenu(); // need to call here to have good dimensions
                }
            }, 500);

            return this;
        },

        resizeForFooter: function vDocumentresizeForFooter() {
            var $footer = this.$el.find(".dcpDocument__footer");
            if ($footer.length > 0) {
                var footerHeight = $footer.height();
                if (footerHeight > 0) {
                    $("body").css("margin-bottom", footerHeight + "px");
                }
            }
        },

        /**
         * Scroll to visible tab label
         */
        scrollTobVisibleTab: function vDocumentscrollTobVisibleTab() {
            var kendoTabStrip = this.kendoTabs ? this.kendoTabs.data("kendoTabStrip") : null;
            if (kendoTabStrip && kendoTabStrip._scrollableModeActive) {
                kendoTabStrip._scrollTabsToItem(this.kendoTabs.find("li.k-state-active"));
            }
        },

        fixedTab: function vDocumentfixedTab(event) {
            // @TODO Need a decision to delete this option or not
            return;
            var $tabs = this.$el.find(".dcpDocument__tabs");
            var $ul;
            if ($tabs.length > 0) {
                var tabPlacement = this.model.getOption("tabPlacement") || "top";
                var menuHeight = this.$el.find(".menu__content").height();
                var kendoTabStrip = this.kendoTabs.data("kendoTabStrip");
                var isAlreadyFixed = $tabs.hasClass("tab--fixed");
                var $liActive = $tabs.find("li.k-state-active");
                var scrollTop = $(window).scrollTop();
                var $navButtons = $tabs.find(".k-bare");
                var resizeMode = event.type === "resize";
                if (scrollTop > $tabs.offset().top - menuHeight) {
                    $tabs.addClass("tab--fixed");
                    $tabs.css("top", menuHeight + "px");
                    if (tabPlacement === "top") {
                        // Special case for scrolling tabs
                        $ul = $tabs.find(".dcpDocument__tabs__list");
                        if (resizeMode) {
                            kendoTabStrip.resize();
                        }
                        var $navButtonsVisible = $tabs.find(".k-bare:visible");
                        if ($navButtonsVisible.length > 0) {

                            if (!isAlreadyFixed || resizeMode) {
                                $ul.css("width", "");
                                if (!$ul.data("margins")) {
                                    if (parseInt($navButtonsVisible.width()) > 0) {
                                        $ul.data("fixMargins", { left: $navButtonsVisible.width(), right: $navButtonsVisible.width() });
                                        $ul.data("originalMargins", { left: $ul.css("margin-left"), right: $ul.css("margin-right") });
                                    }
                                }
                                if ($ul.data("fixMargins")) {
                                    $ul.css("margin-left", $ul.data("fixMargins").left);
                                    $ul.css("margin-right", $ul.data("fixMargins").right);
                                }

                                var ulWidth = $tabs.width() - parseInt($ul.css("margin-right")) - parseInt($ul.css("margin-left"));
                                $ul.css("width", ulWidth + "px");
                                $navButtons.css("height", $ul.outerHeight() + "px");

                                $ul.css("top", menuHeight + "px");
                                $tabs.find(".k-bare").css("top", menuHeight + 0 + "px");

                                if ($liActive.length === 1) {
                                    kendoTabStrip.activateTab($liActive);
                                }
                            }
                        } else {
                            if (parseInt($ul.css("margin-left")) > 0) {
                                $ul.data("margins", { left: $ul.css("margin-left"), right: $ul.css("margin-right") });
                            }
                            $ul.css("width", "").css("margin-right", "").css("margin-left", "");
                        }
                    }
                } else {
                    var $tabContent = this.$el.find(".dcpTab__content.k-state-active").first();
                    var $tabList = this.$el.find(".dcpDocument__tabs__list");

                    if ($tabContent.length > 0 && scrollTop < Math.max($tabContent.offset().top - menuHeight - $tabList.height(), $tabList.height())) {
                        if (isAlreadyFixed) {
                            $tabs.removeClass("tab--fixed");
                            $tabs.css("top", "");
                            if (tabPlacement === "top") {
                                $navButtons.css("height", "");
                                $ul = $tabs.find(".dcpDocument__tabs__list");
                                $ul.css("width", "").css("top", "");
                                $tabs.find(".k-bare").css("top", "");
                                if ($ul.data("originalMargins")) {
                                    $ul.css("margin-left", $ul.data("originalMargins").left);
                                    $ul.css("margin-right", $ul.data("originalMargins").right);
                                }
                                if ($liActive.length === 1) {
                                    kendoTabStrip.activateTab($liActive);
                                }
                                kendoTabStrip.resize();
                            }
                        }
                    }
                }
            }
        },

        scrollTabList: function vDocumentScrollTabList(event) {
            var kendoTabStrip = this.kendoTabs.data("kendoTabStrip");
            var $tabs = this.$el.find(".dcpDocument__tabs");

            if ($tabs.hasClass("tab--fixed")) {

                _.defer(_.bind(this.fixedTab, this, event));
            } else {
                if (kendoTabStrip) {
                    kendoTabStrip.resize();
                }
            }
        },
        /**
         * Add menu if needed in topFix placement tab
         */
        responsiveTabMenu: function vDocumentTabFixMenu() {
            var $tabLabel = this.$(".dcpDocument__tabs__list li");

            var documentWidth = this.$(".dcpDocument__tabs").width() - 12;
            var currentWidth = 0;
            var hiddens = [];
            var lastShow = null;
            var $dropSelect;
            var $dropTopSelect;
            var $kendoTabs = this.kendoTabs.data("kendoTabStrip");
            var liIndex = 0;
            var $tabs = this.$(".dcpDocument__tabs");
            var $selectedTabId = this.selectedTab;
            var hiddenSelected = false;
            var dataSource = null;
            var iOS = /(iPad|iPhone|iPod)/g.test(navigator.userAgent);

            // $tabs.find(".dcpDocument__tabs__list").css("overflow", "hidden").css("max-height", "2.7em");
            // Restore initial tabs
            $tabLabel.show();

            $tabLabel.each(function vDocumentHideTabWidth() {
                currentWidth += $(this).outerWidth();
                if (currentWidth > documentWidth) {
                    $(this).hide();
                    if (hiddens.length === 0) {
                        hiddens.push({
                            tooltipLabel: $(lastShow).data("tooltipLabel"),
                            label: $(lastShow).find(".k-link").text(),
                            id: $(lastShow).data("attrid"),
                            index: liIndex - 1
                        });
                    }
                    hiddens.push({
                        tooltipLabel: $(this).data("tooltipLabel"),
                        label: $(this).find(".k-link").text(),
                        id: $(this).data("attrid"),
                        index: liIndex
                    });
                } else {
                    $kendoTabs.enable && $kendoTabs.enable($(this));
                    lastShow = this;
                }

                liIndex++;
            });

            /**
             * Need to recompute container width
             */
            $(".dcpLabel__select-hide:visible").each(function vDocumentSelectContainer() {
                var $container = $(this).closest(".k-list-container");
                var x = $container.offset().left;
                var maxWidth = $('body').width() - x - 20 + "px";

                $container.css("max-width", maxWidth);
                $container.closest(".k-animation-container").css("max-width", maxWidth);
                $(this).css("max-width", "");
            });

            if ($tabs.data("hiddenTabsLength") === hiddens.length) {
                // Optimization if no new tabs to hide
                if (hiddens.length > 0) {
                    $kendoTabs && $kendoTabs.disable && $kendoTabs.disable($(lastShow));
                }

                //$tabs.find(".dcpDocument__tabs__list").css("overflow", "").css("max-height", "");
                return;
            }

            // Delete fixed height
            //$tabLabel.css("height", '');
            // Record hidden count to optimization
            $tabs.data("hiddenTabsLength", hiddens.length);
            $tabLabel.find(".k-link").show(); // Restore original link (tab label)

            $dropTopSelect = $tabs.find(".dcpTab__label__select.k-combobox").hide();
            $tabs.find("input.dcpTab__label__select[data-role=combobox]").each(function vDocumentSelectTabClose() {
                $(this).data("kendoComboBox") && $(this).data("kendoComboBox").close && $(this).data("kendoComboBox").close();
            });

            $tabs.find(".dcpLabel--select").removeClass("dcpLabel--select k-state-active");
            $tabs.find(".dcpLabel[data-attrid=" + $selectedTabId + "]").addClass("k-state-active");

            if (hiddens.length > 0) {

                // Need to disable tab to use own events managing
                if (lastShow) {
                    $kendoTabs.disable($(lastShow));
                }

                // Hide original link
                $(lastShow).find(".k-link").hide();
                // Replace it to a dropdown selector
                hiddenSelected = _.some(hiddens, function vDocumentSomeHiddens(item) {
                    return item.id === $selectedTabId;
                });

                if (hiddenSelected) {
                    $(lastShow).addClass("k-state-active");
                } else {
                    if ($(lastShow).data("attrid") !== $selectedTabId) {
                        $(lastShow).removeClass("k-state-active");
                    }
                }

                $(lastShow).addClass("dcpLabel--select");
                //$(lastShow).height(currentHeight - 5);
                if ($dropTopSelect.length === 0) {
                    $dropSelect = $('<input class="dcpTab__label__select" />');
                    $(lastShow).append($dropSelect);
                    $dropSelect.kendoComboBox({
                        value: hiddenSelected ? $selectedTabId : hiddens[0].id,
                        dataSource: hiddens,
                        dataTextField: "label",
                        dataValueField: "id",
                        dataBound: function vDocumentTabSelectDatabound() {
                            var myTab = $(this.element).closest("li");
                            var liItem = $tabs.find("li[data-attrid=" + this.value() + "]");
                            myTab.data("tooltipLabelSelect", liItem.data("tooltipLabel"));
                        },
                        select: function vDocumentTabSelectSelect(event) {
                            var dataItem = this.dataSource.at(event.item.index());
                            var liItem = $tabs.find("li[data-attrid=" + dataItem.id + "]");
                            var myTab = $(this.element).closest("li");

                            myTab.data("tooltipLabelSelect", dataItem.tooltipLabel);
                            // Need to reset class and enable to really trigger show events
                            myTab.removeClass("k-state-active");
                            $kendoTabs.enable(myTab);
                            $kendoTabs.select(liItem);
                            $kendoTabs.disable(myTab);
                            myTab.addClass("k-state-active");
                            myTab.find(".k-input").blur(); // Because input is read only
                        },
                        open: function vDocumentTabSelectOpen() {
                            // Need to compute width of container to see elements
                            // Set max-width to not be out of body
                            var $ul = $(this.ul);
                            var $li = $(this.element).closest("li");
                            var x = $li.offset().left;
                            var bodyWidth = $('body').width();
                            $ul.css("max-width", Math.max(bodyWidth - x - 20, $(lastShow).width()) + "px");
                            $ul.css("min-width", $li.width());
                            _.defer(function vDocumentSelectTabOpen() {
                                $ul.closest(".k-animation-container").addClass("menu__select_container");
                            });
                        },

                        template: function vDocumentTabSelectTemplate(event) {
                            if (event.tooltipLabel) {
                                return Mustache.render('<span class="dcpLabel__select--tooltip" data-tooltipLabel="{{tooltipLabel}}">{{label}}</span>', event);
                            }
                            return event.label;
                        }
                    });

                    $dropSelect.data("kendoComboBox").ul.addClass("dcpLabel__select-hide");
                    // The container width is computed by open event
                    $dropSelect.data("kendoComboBox").list.width("auto");
                    // No use input selector
                    $(lastShow).find("input").attr("aria-readonly", "true").prop("readonly", true);
                    $(lastShow).find(".k-select").prepend($("<span/>").addClass("dcpLabel__count"));

                    $dropSelect.data("kendoComboBox").ul.tooltip({
                        selector: "li.k-item ",
                        placement: "left",
                        container: ".dcpDocument",
                        html: true,
                        title: function vDocumentTabSelectTitle() {
                            return $(this).find(".dcpLabel__select--tooltip").attr("data-tooltipLabel");
                        }
                    });
                    $dropSelect.parent().find(".k-input").css("width", "");
                } else {
                    // Reuse dropDown created previously
                    $dropTopSelect.show();
                    $dropSelect = $tabs.find("input.dcpTab__label__select[data-role=combobox]");
                    $(lastShow).append($dropTopSelect); // Move to new lastShow
                    if ($dropSelect.data("kendoComboBox")) {
                        $dropSelect.data("kendoComboBox").value(hiddenSelected ? $selectedTabId : hiddens[0].id);
                        dataSource = new kendo.data.DataSource({
                            data: hiddens
                        });
                        $dropSelect.data("kendoComboBox").setDataSource(dataSource);
                    }
                }

                // Add count in select button
                $(lastShow).find(".dcpLabel__count").text(hiddens.length);

                if (!$tabs.data("selectFixOn")) {
                    // Add callback only one time
                    $tabs.on("click", ".dcpLabel--select .k-dropdown-wrap .k-input", function vDocumentTabSelectClick(event) {
                        var selectedTab = $kendoTabs.select().data("attrid");
                        var selectedItem = $tabs.data("selectFixOn").data("kendoComboBox").value();
                        var liItem = $tabs.find("li[data-attrid=" + selectedItem + "]");
                        var myTab = $(this).closest("li");

                        if (selectedItem !== selectedTab) {
                            myTab.removeClass("k-state-active");
                            $kendoTabs.enable(myTab);
                            $kendoTabs.select(liItem);
                            $kendoTabs.disable(myTab);
                            myTab.addClass("k-state-active");
                        }
                    });

                    $tabs.on("focus", ".dcpLabel--select .k-dropdown-wrap .k-input", function vDocumentTabFocus() {
                        $(this).blur();
                    });
                }

                // Memorize dropdown to reuse it in callback and to listen only one
                $tabs.data("selectFixOn", $dropSelect);
            }
            if ('ontouchstart' in document.documentElement && iOS) {
                $("body").off('show.bs.tooltip').on('show.bs.tooltip', "[data-original-title]", function vDocumentWorkaroundIosTouch(e) {
                    // prevent ios double tap
                    var $tooltip = $(this);
                    var tooltipObject = $tooltip.data("bs.tooltip");

                    if (tooltipObject && tooltipObject.inState.click === false && tooltipObject.inState.focus === false && tooltipObject.inState.hover === false) {
                        return;
                    }

                    if ('ontouchstart' in document.documentElement) {
                        if (!$tooltip.data("showios")) {
                            e.preventDefault();
                            $tooltip.data("showios", true);
                            _.delay(function vDocumentWorkaroundIosDelay() {
                                $tooltip.tooltip("show");
                                $tooltip.data("showios", false);
                                _.delay(function vDocumentWorkaroundIosSecondDelay() {
                                    $tooltip.tooltip("hide");
                                }, 2000);
                            }, 500);
                        }
                    }
                });
            }

            //$tabs.find(".dcpDocument__tabs__list").css("overflow", "").css("max-height", "");
        },

        /**
         *
         * Register the current tab for the current user
         *
         * @param tabId
         */
        recordSelectedTab: function vDocumentRecordSelectedTab(tabId) {
            if (this.model.get("initid")) {
                var tagTab = new ModelDocumentTab({ "initid": this.model.get("initid"), "tabId": tabId });
                tagTab.save();
            }
        },

        /**
         * Publish associated model message
         */
        publishMessages: function vDocumentPublishMessages() {
            var currentView = this;
            _.each(this.model.get("messages"), function vDocumentPublishAMessage(aMessage) {
                currentView.trigger("showMessage", {
                    type: aMessage.type,
                    title: aMessage.contentText,
                    htmlMessage: aMessage.contentHtml
                });
            });
        },

        /**
         * Inject associated CSS in the DOM
         *
         * Inject new CSS, remove old CSS
         */
        renderCss: function vDocumentRenderCss(noRemove) {
            // add custom css style
            var $head = $("head"),
                cssLinkTemplate = _.template('<link rel="stylesheet" type="text/css" ' + 'href="<%= path %>" data-id="<%= key %>" data-view="true">'),
                customCss = this.model.get("customCSS");

            if (noRemove !== true) {
                //Remove old CSS

                _.each($("link[data-view=true]"), function vDocumentRemoveOldCSS(currentLink) {
                    var findCss = function vDocumentFindCss(currentCss) {
                        return $(currentLink).data("id") === currentCss.key;
                    };
                    if (_.find(customCss, findCss) === undefined) {
                        $(currentLink).remove();
                    }
                });
            }
            // Inject new CSS
            _.each(customCss, function vDocumentInjectNewCSS(cssItem) {
                var $existsLink = $('link[rel=stylesheet][data-id=' + cssItem.key + ']');

                if ($existsLink.length === 0) {
                    if (document.createStyleSheet) {
                        // Special thanks to IE : ! up to 31 css cause errors...
                        document.createStyleSheet(cssItem.path);
                    }
                    $head.append(cssLinkTemplate(cssItem));
                }
            });
        },

        /**
         * Show the help document in dialog
         *
         */
        showHelp: function vDocumentShowHelp(event, helpId, attrid) {
            var $document = $(this.el);
            var scope = this;
            var $dialogDiv = $document.data("dcpHelpDocument-" + helpId);
            var currentTarget = event.originalEvent ? event.originalEvent.currentTarget : event.currentTarget;
            var htmlLink = {
                target: "_dialog",
                windowWidth: "400px",
                windowHeight: "300px",
                windowTitle: '<span class="fa fa-question-circle"></span> ' + i18n.___("Info", "ddui")
            };

            __webpack_require__.e/* require.ensure */("wDocument").then((function vDocumentHelp() {
                __webpack_require__("./src/Apps/DOCUMENT/IHM/document.js");
                var helpX, helpY, bodyH, dialogH, dialogW;

                if (!$dialogDiv || $dialogDiv.is(":visible") === false) {

                    if (scope.helpWidget) {
                        scope.helpWidget.destroy();
                    }
                    $dialogDiv = $('<div/>').addClass("dcpHelp-wrapper");

                    $dialogDiv.kendoWindow({
                        title: htmlLink.windowTitle,
                        width: htmlLink.windowWidth,
                        height: htmlLink.windowHeight,
                        iframe: true,
                        content: "about:blank",
                        actions: ["Maximize", "Close"],
                        close: function vDocumentSelectHelpClose() {
                            $(".dcpLabel__help__link--selected").removeClass("dcpLabel__help__link--selected");
                        }
                    });

                    $dialogDiv.on("documentcreate", function vDocumentHelpCreate() {
                        $dialogDiv.find("> iframe").addClass("k-content-frame");
                    });

                    $dialogDiv.document({
                        "initid": helpId,
                        withoutResize: true
                    }).on("documentloaded", function vDocumentSelectHelpChapter() {
                        _.defer(function vDocumentHelpReady() {
                            $dialogDiv.document("triggerEvent", "custom:helppageSelect", attrid);
                        });
                    });

                    $document.data("dcpHelpDocument-" + helpId, $dialogDiv);
                } else {
                    $dialogDiv.document("triggerEvent", "custom:helppageSelect", attrid);
                }

                scope.helpWidget = $dialogDiv.data('kendoWindow');
                $(".dcpLabel__help__link--selected").removeClass("dcpLabel__help__link--selected");

                if ($(currentTarget).length > 0) {
                    $(currentTarget).addClass("dcpLabel__help__link--selected");

                    // Compute new position of help dialog window
                    helpX = $(currentTarget).offset().left;
                    helpY = $(currentTarget).offset().top;
                    bodyH = $("body").height();
                    dialogH = $(scope.helpWidget.wrapper).closest(".k-window").height();
                    dialogW = $(scope.helpWidget.wrapper).closest(".k-window").width();
                    if (helpX > dialogW + 50) {
                        helpX = helpX - dialogW - 30;
                    } else {
                        helpX = helpX + 30;
                    }

                    if (helpY > bodyH - dialogH) {
                        helpY = bodyH - dialogH - 50;
                    }

                    helpY = helpY < 0 ? 0 : helpY;

                    $(scope.helpWidget.wrapper).css({
                        top: helpY + "px",
                        left: helpX + "px"
                    });
                } else {
                    scope.helpWidget.center();
                }
                scope.helpWidget.open();
            }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
        },

        /**
         * Show the history widget
         *
         */
        showHistory: function vDocumentShowHistory(docid) {
            var scope = this;
            var $target = $('<div class="document-history"/>');
            this.historyWidget = $target.dcpDocumentHistory({
                documentId: docid || this.model.get("properties").get("initid"),
                window: {
                    width: "80%",
                    height: "80%",
                    title: i18n.___("Document History", "historyUi")
                },
                labels: {
                    version: i18n.___("Version", "historyUi"),
                    revision: i18n.___("Rev", "historyUi"),
                    state: i18n.___("State", "historyUi"),
                    activity: i18n.___("Activity", "historyUi"),
                    owner: i18n.___("Owner", "historyUi"),
                    code: i18n.___("Code", "historyUi"),
                    date: i18n.___("Date", "historyUi"),
                    diff: i18n.___("Diff", "historyUi"),
                    level: i18n.___("Level", "historyUi"),
                    message: i18n.___("Message", "historyUi"),
                    pastRevision: i18n.___("past Revision", "historyUi"),
                    showDetail: i18n.___("Show details", "historyUi"),
                    hideDetail: i18n.___("Hide details", "historyUi"),
                    showNotice: i18n.___("Show notices", "historyUi"),
                    noOneNotice: i18n.___("No one notices", "historyUi"),
                    hideNotice: i18n.___("Hide notices", "historyUi"),
                    filterMessages: i18n.___("Filter messages", "historyUi"),
                    linkRevision: i18n.___("See revision number #", "historyUi"),
                    historyTitle: i18n.___("History for {{title}}", "historyUi"),
                    loading: i18n.___("Loading ...", "historyUi"),
                    revisionDiffLabels: {
                        "title": i18n.___("Difference between two revisions", "historyDiffUi"),
                        "first": i18n.___("First document", "historyDiffUi"),
                        "second": i18n.___("Second document", "historyDiffUi"),
                        "attributeId": i18n.___("Attribute id", "historyDiffUi"),
                        "attributeLabel": i18n.___("Attribute label", "historyDiffUi"),
                        "documentHeader": i18n.___("{{title}}  (Revision : {{revision}}). <br/>Created on <em>{{revdate}}</em>", "historyDiffUi"),
                        "filterMessages": i18n.___("Filter data", "historyDiffUi"),
                        "showOnlyDiff": i18n.___("Show only differences", "historyDiffUi"),
                        "showAll": i18n.___("Show all", "historyDiffUi")
                    }
                }
            }).data("dcpDocumentHistory");

            this.historyWidget.open();
            this.historyWidget.element.on("viewRevision", function vDocumentViewRevision(event, data) {
                scope.model.fetchDocument({
                    initid: data.initid,
                    revision: data.revision
                });
            });
        },

        /**
         * Lock document
         *
         */
        lockDocument: function vDocumentLockDocument() {
            this.model.lockDocument();
        },
        /**
         * Lock document
         *
         */
        unlockDocument: function vDocumentUnLockDocument() {
            this.model.unlockDocument();
        },
        /**
         * Show the transition view
         *
         */
        showtransition: function vDocumentShowtransition(transition, nextState) {
            this.model.trigger("showTransition", nextState, transition);
        },

        /**
         * Show the transition view
         *
         */
        showTransitionGraph: function vDocumentShowtransitionGraph() {
            var documentView = this;
            var transitionGraph = {};
            var $target = $('<div class="dcpTransitionGraph"/>');
            //Init transition model
            transitionGraph.model = new ModelTransitionGraph({
                documentId: this.model.id,
                state: this.model.get("properties").get("state")
            });

            transitionGraph.model.fetch({
                success: function vDocumentTransitionSuccess() {
                    //Init transition view
                    transitionGraph.view = new ViewTransitionGraph({
                        model: transitionGraph.model,
                        el: $target
                    });
                    transitionGraph.view.render();
                    transitionGraph.view.$el.on("viewTransition", function vDocumentTransitionView(event, nextState) {
                        transitionGraph.view.remove();
                        documentView.model.trigger("showTransition", nextState);
                    });
                }
            });

            this.transitionGraph = transitionGraph;
        },
        /**
         * Show the properties widget
         *
         */
        showProperties: function vDocumentShowProperties(docid) {
            var scope = this;
            var $target = $('<div class="document-properties"/>');

            this.propertiesWidget = $target.dcpDocumentProperties({
                documentId: docid || this.model.get("properties").get("initid"),
                window: {
                    width: "500px",
                    height: "80%",
                    title: i18n.___("Document properties", "propertyUi")
                },
                labels: {
                    identifier: i18n.___("Identifier", "propertyUi"),
                    title: i18n.___("Title", "propertyUi"),
                    logicalName: i18n.___("Logical name", "propertyUi"),
                    revision: i18n.___("Revision number", "propertyUi"),
                    version: i18n.___("Version", "propertyUi"),
                    family: i18n.___("Family", "propertyUi"),
                    lockedBy: i18n.___("Locked by", "propertyUi"),
                    createdBy: i18n.___("Created by", "propertyUi"),
                    notLocked: i18n.___("Not locked", "propertyUi"),
                    confidential: i18n.___("Confidential", "propertyUi"),
                    notConfidential: i18n.___("Not confidential", "propertyUi"),
                    creationDate: i18n.___("Creation date", "propertyUi"),
                    lastModificationDate: i18n.___("Last modification date", "propertyUi"),
                    lastAccessDate: i18n.___("Last access date", "propertyUi"),
                    profil: i18n.___("Profil", "propertyUi"),
                    profilReference: i18n.___("Profil reference", "propertyUi"),
                    viewController: i18n.___("View controller", "propertyUi"),
                    property: i18n.___("Property", "propertyUi"),
                    propertiesTitle: i18n.___("Properties for {{title}}", "propertyUi"),
                    propertyValue: i18n.___("Value", "propertyUi"),
                    workflow: i18n.___("Workflow", "propertyUi"),
                    activity: i18n.___("Activity", "propertyUi")
                }
            }).data("dcpDocumentProperties");

            this.propertiesWidget.open();
            this.propertiesWidget.element.on("viewDocument", function vDocumentViewDocument(event, data) {
                scope.model.fetchDocument({ initid: data });
            });
        },

        /**
         * Update the title of the current page
         */
        updateTitle: function vDocumentUpdateTitle() {
            var title = this.model.get("properties").get("title");

            if (!_.isEmpty(title)) {
                document.title = title;
            }
        },

        /**
         * Update the icon of the current page
         */
        updateIcon: function vDocumentUpdateIcon() {
            $("link[rel='shortcut icon']").attr("href", this.model.get("properties").get("icon"));
        },

        /**
         * Delete the current document
         *
         */
        deleteDocument: function dvDocumentDocumentDelete() {
            this.model.deleteDocument();
        },

        /**
         * Display the loading widget
         */
        displayLoading: function vDocumentDisplayLoading(options) {
            var text = i18n.___("Loading", "ddui"),
                avance = 50;
            options = options || {};
            if (this.$el.find(".dcpDocument--disabled") === 0) {
                this.$el.append('<div class="dcpDocument--disabled"/>');
            }
            if (options.isSaving) {
                text = i18n.___("Recording", "ddui");
                avance = 70;
            }
            if (options.text) {
                text = options.text;
            }
            this.trigger("cleanNotification");
            this.trigger("loaderShow", text, avance);
        },

        /**
         * Show the view
         *
         * Hide the loader, show the view
         */
        showView: function vDocumentShowView() {
            this.$el.hide();
            this.$el.find(".dcpDocument--disabled").remove();
            this.trigger("loaderHide");
            this.$el.show();
            this.model.redrawErrorMessages();
        },

        /**
         * Switch the view
         *
         * @param viewId
         */
        closeDocument: function vDocumentCloseDocument(viewId) {
            if (!viewId) {
                if (this.model.get("renderMode") === "edit") {
                    viewId = "!defaultEdition";
                } else {
                    viewId = "!defaultConsultation";
                }
            }
            this.loadDocument({
                initid: this.model.get("initid"),
                viewId: viewId
            });
        },

        /**
         * Save the current document
         */
        saveDocument: function vDocumentSaveDocument() {
            this.trigger("cleanNotification");
            var currentView = this,
                saveDocument = this.model.saveDocument();
            //Use promise and display success when done
            if (saveDocument && saveDocument.then) {
                saveDocument.then(function vDocumentSaveDisplaySuccess() {
                    currentView.trigger("showSuccess", { title: i18n.___("Document Recorded", "ddui") });
                });
            }
        },

        /**
         * Save and close the current document
         */
        saveAndCloseDocument: function vDocumentSaveAndCloseDocument(viewId) {
            this.trigger("cleanNotification");
            var currentView = this,
                saveDocument = this.model.saveDocument();
            if (saveDocument && saveDocument.then) {
                saveDocument.then(function vDocumentSaveAndCloseSuccess() {
                    var initid = currentView.model.get("initid");

                    currentView.model.fetchDocument({
                        initid: initid,
                        viewId: viewId || "!defaultConsultation"
                    });
                });
            }
        },

        /**
         * Create the current document
         */
        createDocument: function vDocumentCreateDocument() {
            var currentView = this,
                saveDocument = this.model.saveDocument();
            if (saveDocument && saveDocument.then) {
                saveDocument.then(function vDocumentCreateDisplaySuccess() {
                    currentView.trigger("showSuccess", { title: i18n.___("Document Created", "ddui") });
                });
            }
        },

        /**
         * Create the current document
         */
        createAndCloseDocument: function vDocumentCreateDocument(viewId) {
            var currentView = this,
                saveDocument = this.model.saveDocument();
            if (saveDocument && saveDocument.then) {
                saveDocument.then(function vDocumentCreateAndCloseSuccess() {
                    var initid = currentView.model.get("initid");

                    currentView.model.fetchDocument({
                        initid: initid,
                        viewId: viewId || "!defaultConsultation"
                    });
                });
            }
        },

        /**
         * load another document document  : confirm if modified
         * options : {initid, viewId, revision}
         * callbacks : {success, error}
         */
        loadDocument: function vDocumentLoadDocument(options, callbacks) {
            var confirmWindow;
            var documentView = this;

            callbacks = callbacks || {};

            if (this.model.hasAttributesChanged()) {
                confirmWindow = $('body').dcpConfirm({
                    title: i18n.___("Confirm close document", "ddui"),
                    width: "45rem",
                    height: "12rem",
                    maxWidth: $(window).width(),
                    messages: {
                        okMessage: i18n.___("Abort modification", "ddui"),
                        cancelMessage: i18n.___("Stay on the form", "ddui"),
                        htmlMessage: i18n.___("The form has been modified without saving", "ddui"),
                        textMessage: ''
                    },
                    confirm: function wMenuConfirm() {
                        documentView.model.fetchDocument({
                            initid: options.initid,
                            viewId: options.viewId,
                            revision: options.revision
                        }).then(callbacks.success, callbacks.error);
                    },
                    cancel: function wLoadCancel() {
                        if (callbacks && _.isFunction(callbacks.error)) {
                            callbacks.error({
                                errorMessage: {
                                    code: "USERCANCEL",
                                    contentText: i18n.___("User has cancelled the action.", "ddui")
                                }
                            });
                        }
                    },
                    templateData: { templates: this.model.get("templates") }
                });
                confirmWindow.data('dcpWindow').open();
            } else {
                this.model.fetchDocument({
                    initid: options.initid,
                    viewId: options.viewId,
                    revision: options.revision
                }).then(callbacks.success, callbacks.error);
            }
        },

        /**
         * Restore the deleted document
         *
         * @returns {exports}
         */
        restoreDocument: function vDocumentRestoreDocument() {
            this.model.restoreDocument();
        },

        propagateActionClick: function vDocumentPropagateActionClick(event) {
            var $target = $(event.currentTarget),
                action,
                options,
                eventOptions,
                internalEvent = {
                prevent: false
            };

            event.preventDefault();
            if (event.stopPropagation) {
                event.stopPropagation();
            }

            action = $target.data('action') || $target.attr("href");
            options = action.substring(8).split(":");
            eventOptions = {
                target: event.target,
                eventId: options.shift(),
                options: options
            };

            this.model.trigger("internalLinkSelected", internalEvent, eventOptions);
            if (internalEvent.prevent) {
                return this;
            }

            return this.doStandardAction(internalEvent, eventOptions);
        },

        handleHashClick: function vDocumenthandleHashClick(event) {
            var $target = $(event.currentTarget),
                href = $target.attr('href');

            if (!href || !href.substring || href.substring(0, 7) === '#action') {
                return;
            }

            event.preventDefault();
            if (event.stopPropagation) {
                event.stopPropagation();
            }

            window.location.hash = href;
        },

        /**
         * Propagate menu event
         *test
         * @param event
         * @param options
         * @returns {*}
         */
        doStandardAction: function vDocumentdoStandardAction(event, options) {
            var eventArgs = options.options;

            if (options.eventId === "document.save") {
                return this.saveDocument();
            }
            if (options.eventId === "document.saveAndClose") {
                return this.saveAndCloseDocument(eventArgs[0]);
            }
            if (options.eventId === "document.history") {
                return this.showHistory(eventArgs[0]);
            }
            if (options.eventId === "document.transition") {
                return this.showtransition(eventArgs[0], eventArgs[1]);
            }
            if (options.eventId === "document.transitionGraph") {
                return this.showTransitionGraph();
            }
            if (options.eventId === "document.properties") {
                return this.showProperties(eventArgs[0]);
            }
            if (options.eventId === "document.delete") {
                return this.deleteDocument();
            }
            if (options.eventId === "document.close") {
                return this.closeDocument(eventArgs[0]);
            }
            if (options.eventId === "document.edit") {
                return this.closeDocument("!defaultEdition");
            }
            if (options.eventId === "document.create") {
                return this.createDocument();
            }
            if (options.eventId === "document.createAndClose") {
                return this.createAndCloseDocument(eventArgs[0]);
            }
            if (options.eventId === "document.load") {
                return this.loadDocument({
                    initid: eventArgs[0], viewId: eventArgs[1], revision: eventArgs[2]
                });
            }
            if (options.eventId === "document.lock") {
                return this.lockDocument();
            }
            if (options.eventId === "document.unlock") {
                return this.unlockDocument();
            }
            if (options.eventId === "document.restore") {
                return this.restoreDocument();
            }
            if (options.eventId === "document.help") {
                return this.showHelp(event, eventArgs[0], eventArgs[1]);
            }
        },

        displayNetworkError: function vDocument_displayNetworkError() {
            this.$el.hide();
            $(".dcpStaticErrorMessage").removeAttr("hidden");
        },

        /**
         * Get the template for the current view
         *
         * @param key
         * @returns {*}
         */
        getTemplates: function vDocumentGetTemplates(key) {
            var templates = {};
            if (this.model && this.model.get("templates")) {
                templates = this.model.get("templates");
            }
            if (templates[key]) {
                return templates[key];
            }
            // Get from a gobal element (for unittest)
            if (window.dcp && window.dcp.templates && window.dcp.templates[key]) {
                return window.dcp.templates[key];
            }
            throw new Error("Unknown template  " + key);
        },

        /**
         * Destroy the associated widget and suppress event listener before remov the dom
         *
         * @returns {*}
         */
        remove: function vDocumentRemove() {
            try {
                if (this.kendoTabs && this.kendoTabs.data("kendoTabStrip")) {
                    this.kendoTabs.data("kendoTabStrip").destroy();
                }
            } catch (e) {
                if (window.dcp.logger) {
                    window.dcp.logger(e);
                } else {
                    console.error(e);
                }
            }
            $(window).off("." + this.model.cid);
            $(window.document).off("." + this.model.cid);

            return Backbone.View.prototype.remove.call(this);
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/views/workflow/vTransition.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/backbone/backbone.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/document/vDocument.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/window/wDialog.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function vTransition(_, $, Backbone, Mustache, ViewDocument) {
    'use strict';

    return ViewDocument.extend({

        messages: [],

        templates: {
            htmlContent: '<div class="dcpTransition--content-activity" >' + ' <span class="dcpTransition--activity" style="border-color:{{transition.beginState.color}}">{{transition.beginState.displayValue}}</span>' + '<span class="dcpTransition--transition {{^transition.id}}dcpTransition--transition--invalid{{/transition.id}}" >{{transition.label}}</span>' + '<span class="dcpTransition--arrow"><span class="fa fa-caret-right fa-2x {{^transition.id}}dcpTransition--transition--invalid{{/transition.id}}"></span></span>' + '<span class="dcpTransition--activity" style="border-color:{{transition.endState.color}}">{{transition.endState.displayValue}}</span> ' + '</div>',

            htmlStateContent: '<div class="dcpTransition--content-activity">' + '<span class="dcpTransition--success" >{{labels.success}}</span>' + '</div>',

            htmlStateButtons: '<button title="{{labels.close}}" class="dcpTransition-button-close btn btn-outline-secondary btn-sm">' + '{{labels.close}} </button>',

            htmlLoading: '<div class="dcpTransition--loading"><span class="fa fa-2x fa-spinner fa-spin"></span> {{labels.inprogress}}</div>',

            htmlButtons: '{{#hasAttributes}}<button class="dcpTransition-button-cancel btn btn-outline-secondary btn-sm">{{labels.cancel}}</button>' + '<button title="{{transition.label}}" ' + 'class="dcpTransition-button-ok btn {{#transition.id}}btn-primary{{/transition.id}}  {{^transition.id}}btn-danger{{/transition.id}} btn-sm">' + '{{labels.confirm}}</button>{{/hasAttributes}}'
        },

        events: {
            "click .dcpTransition-button-ok ": "clickOnOk",
            "click .dcpTransition-button-cancel": "clickOnCancel",
            "click .dcpTransition-button-close": "clickOnClose"
        },

        initialize: function vTransition_initialize(options) {
            //Call parent
            ViewDocument.prototype.initialize.apply(this, arguments);
            this.listenTo(this.model, 'showError', this.displayError);
            //this.listenTo(this.model, 'invalid', this.displayError);
            this.listenTo(this.model, 'request', this.transitionDisplayLoading);
            this.listenTo(this.model, 'hide', function vTransition_hide() {
                this.$el.hide();
            });
            this.listenTo(this.model, 'show', function vTransition_show() {
                this.$el.show();
            });
            this.listenTo(this.model, 'close', function vTransition_close() {
                if (this.transitionWindow) {
                    this.transitionWindow.close();
                }
            });
            this.options = options;
        },

        remove: function vTransition_remove() {
            if (this.transitionWindow) {
                this.transitionWindow.close();
            }
            //Call parent
            ViewDocument.prototype.remove.apply(this, arguments);
            //Remove custom CSS
            var customCss = _.pluck(this.model.get("customCSS"), "key");
            if (customCss.length > 0) {
                _.each(customCss, function vTransition_removeLink(cssKey) {
                    $('link[data-view=true][data-id="' + cssKey + '"]').remove();
                });
            }
        },

        displayError: function vTransition_displayError(error) {
            var workflow = this.model.get("workflow"),
                attributes = this.model.get("attributes"),
                $okButton = this.$el.find(".dcpTransition-button-ok"),
                $cancelButton = this.$el.find(".dcpTransition-button-cancel"),
                errorMessage;
            this.reactiveWidget();
            if (_.isObject(error)) {
                if (error.errorCode === "offline") {
                    errorMessage = '<div class="dcpTransition--error">{{{htmlMessage}}}</div>';
                } else {
                    errorMessage = '<div class="dcpTransition--error">{{title}} {{{htmlMessage}}}</div>';
                }
                $(Mustache.render(errorMessage || "", error)).insertBefore(this.$el.find(".dcpTransition--buttons"));
            }
            if (attributes.length === 0) {
                $okButton.hide();
                $cancelButton.text(workflow.labels.close);
            } else {
                //noinspection JSUnresolvedVariable
                $okButton.text(workflow.labels.retry);
            }
        },

        cleanAndRender: function vTransition_cleanAndRender() {
            var workflow = this.model.get("workflow"),
                transition = workflow.transition,
                state = workflow.state;

            this.render();
            this.displayMessages(this.model.get("messages"));
            this.clearError();
            this.reactiveWidget();
            if (!transition && state) {
                this.model.trigger("success", this.messages);
            }
        },
        /**
         * Inject associated CSS in the DOM
         *
         * Inject new CSS, no remove old CSS
         */
        renderCss: function vTransitionRenderCss() {
            ViewDocument.prototype.renderCss.apply(this, [true]);
        },
        updateTitle: function vTransitionupdateTitle() {
            // No update title
        },
        updateIcon: function vTransitionupdateIcon() {
            // No update icon
        },
        clearError: function vTransition_clearError() {
            this.$el.find(".dcpTransition--error").remove();
        },

        reactiveWidget: function vTransition_reactiveWidget() {

            var workflow = this.model.get("workflow"),
                attributes = this.model.get("attributes"),
                $loading = this.$el.find(".dcpTransition--loading"),
                $okButton = this.$el.find(".dcpTransition-button-ok"),
                $cancelButton = this.$el.find(".dcpTransition-button-cancel");

            if (attributes.length > 0) {
                if (workflow && workflow.labels.confirm) {
                    $okButton.text(workflow.labels.confirm);
                }
                $okButton.prop("disabled", false);
            }
            $cancelButton.prop("disabled", false);

            this.$el.find(".dcpDocument--disabled").remove();
            $loading.hide();
        },

        /**
         * Display the loading widget
         */
        transitionDisplayLoading: function vTransition_transitionDisplayLoading() {
            var $loading = this.$el.find(".dcpTransition--loading"),
                $okButton = this.$el.find(".dcpTransition-button-ok"),
                $cancelButton = this.$el.find(".dcpTransition-button-cancel");

            $loading.show();
            this.clearError();
            $okButton.prop("disabled", true);
            $cancelButton.prop("disabled", true);
        },

        displayMessages: function vTransition_displayMessages(messages) {
            var currentView = this,
                template = '<div class="dcpTransition--message dcpTransition--message--{{type}}">{{contentText}} {{{contentHtml}}}</div>',
                $message = this.$el.find(".dcpTransition--messages");

            this.messages = [];

            _.each(messages, function vTransition_analyzeCurrentMessage(message) {
                $message.append($(Mustache.render(template || "", message)));
                //noinspection JSUnresolvedVariable
                currentView.messages.push({
                    title: message.contentText,
                    type: message.type,
                    htmlMessage: message.contentHtml
                });
            });
        },

        /**
         * Render the document view
         * @returns {*}
         */
        render: function vTransition_render() {
            var currentView = this,
                workflow = this.model.get("workflow"),
                attributes = this.model.get("attributes"),
                transition = workflow.transition,
                state = workflow.state;

            //Call parent
            ViewDocument.prototype.render.apply(this, arguments);

            workflow.hasAttributes = attributes.length > 0;
            if (transition) {
                // Transition ask
                this.$el.find(".dcpTransition--header").append(Mustache.render(this.templates.htmlContent || "", workflow));
                this.$el.find(".dcpTransition--messages").append(Mustache.render(this.templates.htmlLoading || "", workflow));
                this.$el.find(".dcpTransition--buttons").append(Mustache.render(this.templates.htmlButtons || "", workflow));
                this.$el.find(".dcpTransition-button-ok").tooltip();

                if (attributes.length === 0) {
                    // Direct send transition without user control
                    _.defer(function vTransition_saveForMe() {
                        var event = { prevent: false },
                            saveXhr;
                        currentView.model.trigger("beforeChangeState", event);
                        if (event.prevent === false) {
                            saveXhr = currentView.model.save();
                            if (saveXhr) {
                                saveXhr.then(function vTransition_direct_afterSave() {
                                    currentView.model.trigger("success", currentView.getMessages());
                                }).fail(function vTransition_direct_error(response, statusTxt, errorTxt) {
                                    if (response.responseJSON) {
                                        _.each(response.responseJSON.messages, function vTransition_clickOnOk_displayError(aMessage) {
                                            currentView.displayError({
                                                title: aMessage.contentText
                                            });
                                        });
                                    } else {
                                        if (errorTxt && !errorTxt.title && errorTxt.message) {
                                            errorTxt.title = errorTxt.message;
                                            currentView.displayError(errorTxt);
                                        } else if (_.isString(errorTxt)) {
                                            currentView.displayError({ title: errorTxt });
                                        }
                                    }
                                });
                            }
                        }
                    });
                }
                this.$el.attr("data-state", state.id);
                if (transition.id) {
                    this.$el.attr("data-transition", transition.id);
                }

                // No use border color if same as background
                _.defer(function vTransition_renderWhiteOnWhite() {
                    currentView.$el.find(".dcpTransition--activity").each(function vTransition_renderBorderColor() {
                        if (currentView.$el.css("background-color") === $(this).css("border-color")) {
                            $(this).css("border-color", "");
                        }
                    });
                });
            } else if (state) {
                // Transition success
                this.$el.find(".dcpTransition--header").append(Mustache.render(this.templates.htmlStateContent || "", workflow));
                this.$el.find(".dcpTransition--buttons").append(Mustache.render(this.templates.htmlStateButtons || "", workflow));
                this.$el.find(".dcpTransition-button-close").tooltip();
            }

            if (!this.transitionWindow) {
                this.transitionWindow = this.$el.dcpDialog({
                    window: {
                        // maxWidth: "600px",
                        height: "auto",
                        close: function registerCloseEvent(e) {
                            var event = { prevent: false };
                            currentView.model.trigger("beforeChangeStateClose", event);
                            if (event.prevent !== false) {
                                e.preventDefault();
                            }
                        }
                    }
                }).data("dcpDialog");
                this.$el.kendoWindow("title", workflow.transition.label);
                this.transitionWindow.open();
            }
            this.trigger("renderTransitionWindowDone");
        },

        clickOnOk: function vTransition_clickOnOk() {
            var event = { prevent: false },
                currentView = this,
                saveXhr;
            this.model.trigger("beforeChangeState", event);

            if (event.prevent === false) {
                saveXhr = this.model.save();
                if (saveXhr) {
                    saveXhr.then(function vTransition_clickOnOk_afterSave() {
                        currentView.model.trigger("success", currentView.getMessages());
                    }).fail(function vTransition_clickOnOk_error(response, statusTxt, errorTxt) {
                        if (response.responseJSON) {
                            _.each(response.responseJSON.messages, function vTransition_clickOnOk_displayError(aMessage) {
                                currentView.displayError({
                                    title: aMessage.contentText
                                });
                            });
                        } else {
                            if (errorTxt && !errorTxt.title && errorTxt.message) {
                                errorTxt.title = errorTxt.message;
                                currentView.displayError(errorTxt);
                            } else if (_.isString(errorTxt)) {
                                currentView.displayError({ title: errorTxt });
                            }
                        }
                    });
                }
            }
        },

        clickOnCancel: function vTransition_clickOnCancel() {
            this.transitionWindow.close();
        },

        clickOnClose: function vTransition_clickOnClose() {
            this.transitionWindow.close();
        },

        getMessages: function vTransition_getMessages() {
            var messages = [];
            _.each(this.model.get("messages"), function vTransition_getMessagesAMessage(aMessage) {
                messages.push({
                    type: aMessage.type,
                    title: aMessage.contentText,
                    htmlMessage: aMessage.contentHtml
                });
            });
            return messages;
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/views/workflow/vTransitionGraph.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/backbone/backbone.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/i18n/documentCatalog.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/window/wDialog.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function vTransitionGraph(_, $, Backbone, Mustache, i18n) {
    'use strict';

    return Backbone.View.extend({

        messages: [],

        remove: function vTransitionGraph_remove() {
            if (this.transitionGraphWindow && this.$el.data("kendoWindow")) {
                this.transitionGraphWindow.destroy();
            }

            //Call parent
            Backbone.View.prototype.remove.apply(this, arguments);
        },

        /**
         * Render the document view
         * @returns {*}
         */
        render: function vTransitionGraph_render() {
            var currentView = this;

            this.$el.append($('<div class="dcpTransitionGraph--from"/>' + '<div class="dcpTransitionGraph--to"/>'));

            this.displayCurrentState();

            // Init Events
            this.$el.on("mouseover", ".dcpTransitionGraph--to .dcpTransitionGraph_state", function vTransitionGraph_renderMouseOver() {
                var to = $(this).data("to");
                if (!$(this).hasClass("dcpTransitionGraph_state--error")) {

                    currentView.$el.find(".dcpTransitionGraph__arrow--" + to).addClass("dcpTransitionGraph__arrow--selected");
                }
            });
            this.$el.on("mouseout", ".dcpTransitionGraph--to .dcpTransitionGraph_state", function vTransitionGraph_renderMouseOut() {

                currentView.$el.find(".dcpTransitionGraph__arrow").removeClass("dcpTransitionGraph__arrow--selected");
            });

            this.$el.on("click", ".dcpTransitionGraph--to .dcpTransitionGraph_state", function vTransitionGraph_renderClick() {
                var to = $(this).data("to");

                if (!$(this).hasClass("dcpTransitionGraph_state--error")) {
                    currentView.$el.trigger("viewTransition", to);
                }
            });

            this.$el.find(".dcpTransitionGraph_state ").tooltip({
                placement: "top",
                html: true
            });

            if (!this.transitionGraphWindow) {
                this.transitionGraphWindow = this.$el.dcpDialog({
                    window: {
                        height: "auto",
                        width: "600px",
                        close: function registerCloseEvent() {
                            currentView.remove();
                        },
                        activate: function vTransitionGraph_windowActivate() {
                            currentView.displayArrows();
                            currentView.previousHeight = currentView.$el.height();
                        },
                        resize: function vTransitionGraph_windowResize() {
                            var isMaximized = currentView.$el.data("kendoWindow").options.isMaximized;

                            if (!isMaximized && currentView.isMaximizedNow) {

                                currentView.$el.find(".dcpTransitionGraph--to").height(currentView.previousHeight);
                                currentView.$el.find(".dcpTransitionGraph--from").height(currentView.previousHeight);
                                currentView.isMaximizedNow = false;
                            }
                            currentView.displayArrows();

                            if (!isMaximized) {
                                currentView.previousHeight = currentView.$el.height();
                            } else {
                                currentView.isMaximizedNow = true;
                            }
                        }
                    }
                }).data("dcpDialog");
                this.$el.kendoWindow("title", i18n.___("Transition Graph", "ddui"));
                this.transitionGraphWindow.open();
            }
        },

        displayCurrentState: function vTransitionGraphdisplayCurrentState() {
            var tpl = '<div class="dcpTransitionGraph_state {{#transition.error}}dcpTransitionGraph_state--error{{/transition.error}}" ' + 'data-to="{{id}}" {{^transition.error}}title="{{title}}{{transition.error}}"{{/transition.error}} style="border-color:{{color}}">{{displayValue}}' + '{{#transition.error}}<div class="dcpTransitionGraph_state_message">{{transition.error}}</div>{{/transition.error}}' + '</div>';
            var states = this.model.get("workflowStates");
            var currentState = this.model.get("state");
            var currentView = this;

            this.$el.find(".dcpTransitionGraph--from").append(Mustache.render(tpl || "", _.extend(currentState, { title: i18n.___("Current workflow activity", "ddui") })));

            _.each(states, function vTransitionGraphdisplayCurrentStateEach(item) {
                if (item.transition && item.transition.authorized !== false) {
                    item.title = Mustache.render(i18n.___("Next step. Apply transition {{label}}", "ddui"), { label: item.transition.label });
                    currentView.$el.find(".dcpTransitionGraph--to").append(Mustache.render(tpl, item));
                }
            });
        },

        displayArrows: function vTransitionGraph_displayArrows() {
            var states = this.model.get("workflowStates");
            var currentView = this;

            var $from = this.$el.find(".dcpTransitionGraph--from .dcpTransitionGraph_state");
            var $to;

            this.$el.find(".dcpTransitionGraph__arrow").remove();

            this.$el.find(".dcpTransitionGraph--to").height(this.$el.height());
            this.$el.find(".dcpTransitionGraph--from").height(this.$el.height());
            _.each(states, function vTransitionGraph_connectStates(item) {
                if (item.transition && item.transition.authorized !== false) {
                    $to = currentView.$el.find(".dcpTransitionGraph--to .dcpTransitionGraph_state[data-to=" + item.id + "]");
                    currentView.connect($from.get(0), $to.get(0), 2, item);
                }
            });
        },

        /**
         * return element top, left, width, height
         * @param el DOM element
         * @returns {*|jQuery}
         */
        getOffset: function vTransitionGraph_getOffset(el) {
            var offset = $(el).offset();
            offset.width = $(el).outerWidth();
            offset.height = $(el).outerHeight();
            return offset;
        },

        /**
         * draw a line connecting elements
         * @param div1 from div
         * @param div2 to div
         * @param thickness of the arraow
         * @param item transition info
         */
        connect: function vTransitionGraph_connect(div1, div2, thickness, item) {
            var off1 = this.getOffset(div1);
            var off2 = this.getOffset(div2);
            var origin = this.getOffset(this.$el.get(0));

            // bottom right
            var x2 = off1.left + off1.width - origin.left;
            var y2 = off1.top + off1.height / 2 - origin.top;
            // top right
            var x1 = off2.left - origin.left;
            var y1 = off2.top + off2.height / 2 - origin.top;
            // distance
            var length = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            // center
            var cx = (x1 + x2) / 2 - length / 2;
            var cy = (y1 + y2) / 2 - thickness / 2;
            // angle
            var angle = Math.atan2(y1 - y2, x1 - x2) * (180 / Math.PI);

            //
            var htmlLine = "<div class='dcpTransitionGraph__arrow dcpTransitionGraph__arrow--{{id}} {{#error}}dcpTransitionGraph__arrow--error{{/error}}' " + "style=' height:{{height}}px;left:{{left}}px; top:{{top}}px; width:{{width}}px;" + " -moz-transform:rotate({{angle}}deg); " + "-webkit-transform:rotate({{angle}}deg); " + "-o-transform:rotate({{angle}}deg); " + "-ms-transform:rotate({{angle}}deg); " + "transform:rotate({{angle}}deg);' ><div class='dcpTransitionGraph__arrow__label'>{{text}}</div>" + "<span class='dcpTransitionGraph__arrow__end fa fa-2x fa-caret-right'></span> </div>";

            this.$el.append(Mustache.render(htmlLine || "", {
                error: item.transition.error,
                id: item.id,
                height: thickness,
                width: length,
                top: cy,
                left: cx,
                angle: angle,
                text: item.transition.label
            }));
        }

    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/attributes/array/wArray.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/widget.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //noinspection JSUnresolvedVariable
        factory(window.jQuery, window._, window.Mustache);
    }
})(window, function require_array($, _, Mustache) {
    'use strict';

    $.widget("dcp.dcpArray", {

        options: {
            tools: true,
            nbLines: 0,
            renderOptions: {
                rowCountThreshold: -1,
                rowAddDisable: false,
                rowDelDisable: false,
                rowMoveDisable: false,
                rowMinLimit: -1,
                rowMinDefault: 0,
                rowMaxLimit: -1,
                collapse: false,
                arrayBreakPoints: {
                    transpositionRule: "@media (max-width: 768px)",
                    upRule: "@media (max-width: 1200px)"
                }
            },
            displayLabel: true,
            customTemplate: false,
            labels: {
                closeErrorMessage: "Close message",
                limitMaxMessage: "Row count limit to {{limit}}",
                limitMinMessage: "Min row limit is {{limit}}"
            }
        },

        /**
         * get Selected line element (jquery, length = 0 if no selected)
         * @returns {*}
         */
        getSelectedLineElement: function dcpArraygetSelectedLineElement() {
            return this.element.find('.dcpArray__content__line--selected.active');
        },
        /**
         * get Selected line index (0 : first, null : no selected line)
         * @returns {*}
         */
        getSelectedLineIndex: function dcpArray_getSelectedLineIndex() {
            var index = this.getSelectedLineElement().data("line");
            if (_.isUndefined(index) || _.isNull(index)) {
                return null;
            }
            return index;
        },
        /**
         *
         * @private
         */
        _create: function dcpArray_create() {
            this.options.tools = this.options.mode === "write" && this.options.visibility !== "U";
            if (this.options.renderOptions.rowAddDisable === true && this.options.renderOptions.rowDelDisable === true && this.options.renderOptions.rowMoveDisable === true) {
                this.options.tools = false;
            }
            if (this.options.renderOptions.attributeLabel) {
                this.options.label = this.options.renderOptions.attributeLabel;
            }

            this.initializing = true;
            this._initDom().then(_.bind(function onDomOK() {
                this._trigger("widgetReady");
            }, this));
            this._initActionClickEvent();
            this._bindEvents();
            if (this.options.renderOptions.collapse === "collapse") {
                this.toggleCollapse(null, true);
            }
            this.initializing = false;
        },

        _initDom: function dcpArray_initDom() {
            return new Promise(_.bind(function dcpArray_initDom_initDom(resolve, reject) {
                var scope = this,
                    $table;
                if (this.options.mode === "read" && this.options.nbLines === 0 && this.options.showEmpty !== true) {
                    if (this.options.showEmpty) {
                        this.element.addClass("card card-default");
                        // showEmptyCOntent option
                        if (this.options.displayLabel !== false) {
                            this.element.append(Mustache.render(this._getTemplate("label") || "", this.options));
                            if (this.options.renderOptions.labelPosition === "left") {
                                this.element.find(".dcpLabel").addClass("dcpArray__label--left");
                            }
                        }

                        this.element.append(this.options.showEmpty);
                    }
                } else {
                    this.element.addClass("card card-default");
                    if (this.options.displayLabel !== false) {
                        this.element.append(Mustache.render(this._getTemplate("label") || "", _.extend(this.options, {
                            collapsable: this.options.renderOptions.collapse !== "none",
                            displayCount: this.options.renderOptions.rowCountThreshold >= 0 && this.options.nbLines >= this.options.renderOptions.rowCountThreshold
                        })));
                    }

                    if (this.options.customTemplate) {
                        // The template is already composed on view
                        this.element.append(this.options.customTemplate);
                        this.element.find(".dcpCustomTemplate table.dcpArray__table tbody tr").addClass("dcpArray__content__line");
                        this._indexLine();
                        this.element.find(".dcpArray__content__line").attr("data-attrid", this.options.id);
                        this.element.find(".dcpCustomTemplate").addClass("dcpArray__content dcpArray__content--open");
                    } else {
                        _.each(this.options.content, function wArrayCopyRenderContent(anOption) {
                            // Need duplicate because Mustache is confused when 2 attributes has same name
                            anOption.contentRenderOptions = anOption.renderOptions;
                        });
                        this.element.append(Mustache.render(this._getTemplate("content") || "", this.options));

                        if (this.options.mode === "write") {
                            this.element.find(".dcpArray__content").addClass("dcpArray--tooltips");
                            this.element.tooltip({
                                selector: ".dcpArray--tooltips .dcpArray__content__toolCell span, .dcpArray--tooltips .dcpArray__tools .dcpArray__button",
                                placement: function placement(tooltipDom, targetDom) {
                                    // Auto hide after 3s
                                    _.delay(function () {
                                        $(targetDom).tooltip("hide");
                                    }, 3000);
                                    if ($(targetDom).closest(".dcpArray__tools").length > 0) {
                                        return "bottom";
                                    }
                                    return "top";
                                },
                                container: ".dcpDocument",

                                delay: {
                                    hide: 0,
                                    show: 500
                                }
                            });
                        }
                    }
                    if (this.options.displayLabel !== false) {
                        var labelPosition = this.options.renderOptions.labelPosition;
                        if (labelPosition === "auto" || labelPosition === "left") {
                            this.element.find(".dcpArray__label").addClass("dcpAttribute__left");
                            this.element.find(".dcpArray__content").addClass("dcpAttribute__right");
                            this.element.addClass("dcpArray--left");
                        }

                        this.element.find(".dcpAttribute__right").addClass("dcpAttribute__labelPosition--" + labelPosition);
                        this.element.find(".dcpAttribute__left").addClass("dcpAttribute__labelPosition--" + labelPosition);
                        this.element.addClass("dcpAttribute__labelPosition--" + labelPosition);
                    }

                    if (this.options.renderOptions.rowAddDisable === true) {
                        this.element.find(".dcpArray__button--add, .dcpArray__button--copy").hide();
                    }

                    // Set system css classes
                    $table = this.element.find(".dcpArray__table");
                    $table.addClass("table table-condensed table-hover table-bordered responsive");
                    $table.find("> tbody").addClass("dcpArray__body").attr("data-attrid", this.options.id);
                    $table.find("> thead").attr("data-attrid", this.options.id).find("tr").addClass("dcpArray__head").attr("data-attrid", this.options.id);

                    if (this.options.mode === "write" && this.options.renderOptions.rowMoveDisable !== true) {
                        //Initiate drag drop events
                        this.element.find('tbody').kendoDraggable({
                            axis: "y",
                            container: scope.element.find('tbody'),
                            filter: '.dcpArray__content__toolCell__dragDrop',
                            hint: function dcpArrayhint(element) {
                                var dragLine = element.closest('tr');
                                var lineWidth = dragLine.width();
                                var classTable = element.closest('table').attr("class");

                                scope._hideTooltips();
                                scope._disableTooltips();

                                return $('<table/>').addClass("dcpArray__dragLine " + classTable).css("width", lineWidth).css("margin-left", "-" + (element.offset().left - dragLine.offset().left) + "px").append(dragLine.clone());
                            },
                            dragstart: function dcpArraydragstart(event) {
                                if (event.currentTarget) {
                                    var dragLine = $(event.currentTarget).closest('tr');
                                    dragLine.css("opacity", "0");
                                    dragLine.data("fromLine", dragLine.data("line"));
                                }
                            },
                            dragend: function dcpArraydragend(event) {
                                if (event.currentTarget) {
                                    var dragLine = $(event.currentTarget).closest('tr');
                                    dragLine.css("opacity", "");
                                    scope._trigger("lineMoved", {}, {
                                        fromLine: dragLine.data("fromLine"),
                                        toLine: dragLine.data("line")
                                    });
                                }

                                scope._enableTooltips();
                            }
                        });

                        this.element.find('tbody').kendoDropTargetArea({
                            filter: '.dcpArray__content__line[data-attrid="' + this.options.id + '"]',
                            dragenter: function dragenter(event) {
                                if (event.currentTarget) {
                                    var drap = event.draggable.currentTarget.closest('tr');
                                    var drop = event.dropTarget;
                                    var drapLine = drap.data("line");
                                    var dropLine = drop.data("line");
                                    if (drapLine > dropLine) {
                                        drap.insertBefore(drop);
                                    } else {
                                        drap.insertAfter(drop);
                                    }
                                    scope._indexLine();
                                }
                            }
                        });
                    }
                    this.element.on("click" + this.eventNamespace, ".button-close-error", function destroyTable() /*event*/{
                        scope.element.find(".dcpArray__content table.table").tooltip("destroy");
                    });
                }
                _.delay(_.bind(this._initCSSResponsive, this), 10);
                this.addAllLines(this.options.nbLines).then(resolve)["catch"](reject);
            }, this));
        },
        /**
         * Init event for #action/ links
         *
         * @protected
         */
        _initActionClickEvent: function wAttributeInitActionClickEvent() {
            var scopeWidget = this;

            this.element.on("click." + this.eventNamespace, 'a[href^="#action/"], a[data-action], button[data-action]', function wAttributeActionClick(event) {
                var $this = $(this),
                    action,
                    options,
                    eventOptions;

                event.preventDefault();
                if (event.stopPropagation) {
                    event.stopPropagation();
                }

                action = $this.data('action') || $this.attr("href");
                options = action.substring(8).split(":");
                eventOptions = {
                    target: event.target,
                    index: -1,
                    eventId: options.shift(),
                    options: options
                };

                scopeWidget._trigger("externalLinkSelected", event, eventOptions);
                return this;
            });
        },
        _initCSSResponsive: function _initCSSResponsive() {
            // I9 not support transposition table
            var useTransposition = $("html.k-ie9").length === 0;

            this.element.append(Mustache.render(this._getTemplate("responsive") || "", _.extend(this.options, { useTransposition: useTransposition })));

            if (useTransposition) {
                this.element.find("table.dcpArray__table").addClass("responsive");
                var cssString,
                    cssTemplate,
                    headers = _.map(this.element.find("table.responsive > thead th"), function addResponsiveKey(currentElement, index) {
                    var $currentElement = $(currentElement);
                    var $label = $currentElement.find(".dcpArray__head__label");

                    if ($label.length === 0) {
                        $label = $currentElement;
                    }
                    $label.attr("data-responsiveKey", "rk" + index);
                    return {
                        "key": $label.attr("data-responsiveKey"),
                        "attrid": $label.data("attrid"),
                        "label": $label.text().trim()
                    };
                });

                // Generate CSS string
                cssString = "<style>" + this.options.renderOptions.arrayBreakPoints.transpositionRule + " { ";

                cssTemplate = _.template('.dcpArray__content[data-attrid=' + this.options.id + '] .dcpAttribute__content[data-responsiveKey=<%= key %>]:before { content: "<%= label %>"; }');

                _.each(headers, function initCssHeader(currentHeader) {
                    currentHeader.label = currentHeader.label.replace(/([\\"])/g, "\\$1").replace(/\n/g, " ");
                    cssString += cssTemplate(currentHeader);
                });
                cssString += " }</style>";

                this.element.append(cssString);
            }
        },

        _hideTooltips: function wArray__hideTooltips() {
            var $element = this.element;
            $element.find('[aria-describedby^=tooltip]').tooltip("hide");
            _.delay(function _hideTooltipsOneAgain() {
                // Need redo cause animation delay of 500ms
                $element.find('[aria-describedby^=tooltip]').tooltip("hide");
            }, 500);
        },
        _disableTooltips: function wArray__disableTooltips() {
            this.element.find(".dcpArray__content").removeClass("dcpArray--tooltips");
        },
        _enableTooltips: function wArray__enableTooltips() {
            this.element.find(".dcpArray__content").addClass("dcpArray--tooltips");
        },

        _bindEvents: function dcpArray_bindEvents() {
            var currentWidget = this;
            this.element.on("click" + this.eventNamespace, ".dcpArray__content__toolCell__check input", function selectLineEvent() {
                var $this = $(this);
                var isAlreadyChecked = $this.closest(".dcpArray__content__line").hasClass("dcpArray__content__line--selected");
                currentWidget._hideTooltips();
                currentWidget._unSelectLines();
                if (isAlreadyChecked) {
                    currentWidget.element.find(".dcpArray__copy").prop("disabled", true);
                    $(this).prop("checked", false).removeAttr("checked");
                } else {
                    $this.find('.fa-check').show();
                    $this.closest(".dcpArray__content__line").addClass("dcpArray__content__line--selected active");
                    currentWidget.element.find(".dcpArray__copy").prop("disabled", false);
                    $(this).prop("checked", true).attr("checked", "checked");
                }
            });
            this.element.on("click" + this.eventNamespace, ".dcpArray__add", function addLineEvent() {
                var selectedLine = currentWidget.getSelectedLineIndex();
                currentWidget._hideTooltips();
                if (currentWidget.options.renderOptions.rowMaxLimit < 0 || currentWidget.options.nbLines < currentWidget.options.renderOptions.rowMaxLimit) {
                    if (selectedLine === null || _.isUndefined(selectedLine)) {
                        currentWidget.options.nbLines += 1;
                        currentWidget.addLine(currentWidget.options.nbLines - 1, {
                            needAddValue: true,
                            useSelectedLine: true
                        });
                    } else {
                        currentWidget.options.nbLines += 1;
                        currentWidget.addLine(selectedLine, { needAddValue: true, useSelectedLine: true });
                    }
                }
            });
            this.element.on("click" + this.eventNamespace, ".dcpArray__copy", function copyLineEvent() {
                var selectedLine = currentWidget.getSelectedLineIndex();

                currentWidget._hideTooltips();
                if (currentWidget.options.renderOptions.rowMaxLimit < 0 || currentWidget.options.nbLines < currentWidget.options.renderOptions.rowMaxLimit) {
                    currentWidget.options.nbLines += 1;
                    currentWidget.copyLine(selectedLine, { needAddValue: true, useSelectedLine: true });
                }
            });
            this.element.on("click" + this.eventNamespace, ".dcpArray__content__toolCell__delete button", function deleteLineEvent() {
                currentWidget._hideTooltips();
                currentWidget.removeLine($(this).closest(".dcpArray__content__line").data("line"));
                currentWidget.element.find(".dcpArray__copy").prop("disabled", true);
            });
            this.element.on("click" + this.eventNamespace, ".dcpArray--collapsable", function toogleTable() {
                currentWidget.toggleCollapse.apply(currentWidget);
            });
        },

        toggleCollapse: function toggleCollapse(event, hideNow) {
            this._hideTooltips();
            var $contentElement = this.element.find(".dcpArray__content");
            this.element.find(".dcp__array__caret").toggleClass("fa-caret-right fa-caret-down");
            $contentElement.toggleClass("dcpArray__content--open dcpArray__content--close");
            if (hideNow) {
                $contentElement.hide();
            } else {
                $contentElement.slideToggle(200);
            }
        },

        /**
         * Redraw label with current count
         */
        redrawLabel: function wArrayRedrawLabel() {
            this.element.find(".dcpArray__label").html($(Mustache.render(this._getTemplate("label") || "", _.extend(this.options, {
                displayCount: this.options.renderOptions.rowCountThreshold >= 0 && this.options.nbLines >= this.options.renderOptions.rowCountThreshold
            }))).html());
        },
        setLines: function wArraySetLines(lineNumber, options) {
            return new Promise(_.bind(function wArraySetLines_promise(resolve, reject) {
                var linesPromise = [];
                if (!this.initializing) {
                    // No auto add lines when array is initializing itself
                    var currentLineNumber = this.options.nbLines;
                    var i;
                    if (lineNumber > currentLineNumber) {
                        for (i = 0; i < lineNumber - currentLineNumber; i += 1) {
                            linesPromise.push(this.addLine(currentLineNumber + i, options));
                        }
                        Promise.all(linesPromise).then(resolve)["catch"](reject);
                    } else if (lineNumber < currentLineNumber) {
                        for (i = 0; i < currentLineNumber - lineNumber; i += 1) {
                            this.removeLine(this.options.nbLines - 1, options);
                        }
                        resolve();
                    }
                } else {
                    resolve();
                }
            }, this));
        },

        addAllLines: function dcpArrayaddAllLines(lineNumber) {
            var i,
                min,
                allPromiseLines = [];
            this.element.find(".dcpArray__body").empty();

            for (i = 0; i < lineNumber; i += 1) {
                this.addLine(i);
            }

            min = Math.max(this.options.renderOptions.rowMinLimit, this.options.renderOptions.rowMinDefault);
            if (min > 0) {
                if (this.options.nbLines < min) {
                    for (i = this.options.nbLines; i < min; i += 1) {
                        allPromiseLines.push(this.addLine(i, { needAddValue: true }));
                    }
                }
            }
            return Promise.all(allPromiseLines).then(_.bind(function allLineAdded() {
                this._trigger("linesGenerated");
            }, this));
        },

        _getLineContent: function dcpArray_getLineContent(index) {
            var $content = "NULL LINE";

            this.options.lineCid = _.uniqueId(this.options.id);
            if (this.options.customTemplate) {
                $content = this.options.customLineCallback.apply(this, [index]);
                $content.addClass("dcpArray__content__line");
                $content.attr("data-attrid", this.options.id);
            } else {
                $content = $(Mustache.render(this._getTemplate("line") || "", _.extend({ lineNumber: index }, this.options)));
            }
            $content.find(".dcpArray__content__toolCell").closest('td').addClass("dcpArray__toolCell");

            if (this.options.renderOptions.rowDelDisable === true) {
                $content.find(".dcpArray__content__toolCell__delete").hide();
            }
            if (this.options.renderOptions.rowMoveDisable === true) {
                $content.find(".dcpArray__content__toolCell__dragDrop").hide();
            }
            _.each($content.find(">td"), function dcpArray_addCssClass(currentCell, index) {
                $(currentCell).find(".dcpArray__content__cell").attr("data-responsiveKey", "rk" + index).closest('td').addClass("dcpArray__cell");
            });
            return $content;
        },

        _addNewLine: function dcpArray_addNewLine(lineNumber, options) {
            if (!_.isNumber(lineNumber)) {
                throw new Error("You need to indicate the line number");
            }

            var $content = this._getLineContent(lineNumber);
            var selectedLine = [];

            if (options && options.useSelectedLine) {
                selectedLine = this.getSelectedLineElement();
            }

            if (selectedLine.length === 1) {
                $content.insertBefore(selectedLine);
            } else {
                this.element.find(".dcpArray__body").append($content);
            }
            this._indexLine();
            this.redrawLabel();
            this._activateRowLimits();

            return $content;
        },

        /**
         * Disable/Enable Add/copy button
         */
        _activateRowLimits: function wArray_activateRowLimits() {
            var currentWidget = this;
            if (this.options.renderOptions.rowMaxLimit >= 0) {
                if (this.options.nbLines >= this.options.renderOptions.rowMaxLimit) {
                    this.element.find(".dcpArray__add, .dcpArray__copy").prop("disabled", true);
                    this.element.find(".dcpArray__button--add, .dcpArray__button--copy").each(function dcpArray_initLine() {
                        var $this = $(this);
                        if (!$this.data("originalTitle")) {
                            $this.data("originalTitle", $this.attr("title"));
                        }
                        // reset tooltip
                        $this.tooltip("hide").data("bs.tooltip", null);

                        $this.attr("title", Mustache.render(currentWidget.options.labels.limitMaxMessage || "", { limit: currentWidget.options.renderOptions.rowMaxLimit }));
                    });
                } else {
                    this.element.find(".dcpArray__add, .dcpArray__copy").prop("disabled", false);
                    this.element.find(".dcpArray__button--add, .dcpArray__button--copy").each(function dcpArray_initLine() {
                        // reset tooltip
                        $(this).tooltip("hide").data("bs.tooltip", null);
                        $(this).attr("title", $(this).data("originalTitle"));
                    });
                }
            }

            if (this.options.renderOptions.rowMinLimit >= 0) {
                if (this.options.nbLines <= this.options.renderOptions.rowMinLimit) {
                    this.element.find(".dcpArray__content__toolCell__delete button").prop("disabled", true);
                    this.element.find(".dcpArray__content__toolCell__delete").each(function dcpArray_initLine() {
                        if (!$(this).data("originalTitle")) {
                            $(this).data("originalTitle", $(this).attr("title"));
                        }
                        // reset tooltip
                        $(this).tooltip("hide").data("bs.tooltip", null);

                        $(this).attr("title", Mustache.render(currentWidget.options.labels.limitMinMessage || "", { limit: currentWidget.options.renderOptions.rowMinLimit }));
                    });
                } else {
                    this.element.find(".dcpArray__content__toolCell__delete button").prop("disabled", false);
                    this.element.find(".dcpArray__content__toolCell__delete").each(function dcpArray_initLine() {
                        // reset tooltip
                        $(this).tooltip("hide").data("bs.tooltip", null);
                        $(this).attr("title", $(this).data("originalTitle"));
                    });
                }
            }
        },

        addLine: function dcpArrayaddLine(lineNumber, options) {
            return new Promise(_.bind(function dcpArrayaddLine_promise(resolve, reject) {
                var $content = this._addNewLine(lineNumber, options);
                if ($content) {
                    options = _.defaults(options || {}, { "silent": false, "needAddValue": false });
                    if (options.silent !== true) {
                        this._trigger("lineAdded", {}, {
                            line: lineNumber,
                            element: $content,
                            needAddValue: options.needAddValue,
                            resolve: resolve,
                            reject: reject
                        });
                    }
                }
            }, this));
        },

        copyLine: function dcpArraycopyLine(lineNumber, options) {
            return new Promise(_.bind(function dcpArrayaddLine_promise(resolve, reject) {
                var $content = this._addNewLine(lineNumber, options);
                if ($content) {
                    this._trigger("lineAdded", {}, { line: lineNumber, element: $content, copyValue: true });
                }
            }, this));
        },

        removeLine: function dcpArrayremoveLine(line, options) {
            options = options || {};
            this.element.find("[data-line=" + line + "]").remove();
            this._indexLine();
            if (options.silent !== true) {
                this._trigger("lineRemoved", {}, { line: line });
            }
            this.redrawLabel();
            this._activateRowLimits();
        },

        _destroy: function dcpArray_destroy() {
            var tbody = this.element.find('tbody');
            if (tbody && tbody.data("kendoDropTargetArea")) {
                tbody.data("kendoDropTargetArea").destroy();
            }
            if (tbody && tbody.data("kendoDraggable")) {
                tbody.data("kendoDraggable").destroy();
            }
            this.element.empty();
            this._super();
        },

        _indexLine: function dcpArray_indexLine() {
            var i = 0;
            this.element.find(".dcpArray__content__line").each(function numeroteLine() {
                $(this).attr("data-line", i).data("line", i);
                i += 1;
            });
            this.options.nbLines = i;
        },

        _unSelectLines: function dcpArray_unSelectLines() {
            this.element.find(".dcpArray__content__toolCell__check .fa-check").hide();
            this.element.find(".dcpArray__content__line--selected").removeClass("dcpArray__content__line--selected active");
        },
        /**
         * Display tooltip an error message
         *
         * @param message string or array of [{message:, index:}, ...]
         */
        setError: function dcpArray_SetError(message) {
            var scope = this;
            var $target = this.element.find(".dcpArray__content table.table");
            if (message) {
                $target.tooltip({
                    placement: "top",
                    trigger: "manual",
                    animation: false,
                    html: true,
                    title: function dcpArray_computeTitleError() {
                        var rawMessage = $('<div/>').text(message).html();
                        return '<div>' + '<span title="' + scope.options.labels.closeErrorMessage + '" class="btn fa fa-times button-close-error"> XY &nbsp;</span>' + scope.options.id + rawMessage + '</div>';
                    }

                }).one("shown.bs.tooltip", function wErrorTooltip() {
                    var tipElement = $(this).data("bs.tooltip").tip;
                    if (tipElement) {
                        $(tipElement).addClass("has-error");
                    }
                }).tooltip("show").addClass("dcpArray--error");
            } else {
                $target.tooltip("hide").removeClass("dcpArray--error");
            }
        },
        /**
         * Get the template of the current attribute
         *
         * The template can be in the options or in a global var of dcp namespace (initiated by require for widget)
         *
         * @param key
         * @returns string
         * @private
         */
        _getTemplate: function dcpArray_getTemplate(key) {
            if (this.options.templates && this.options.templates[key]) {
                return this.options.templates[key];
            }
            if (window.dcp && window.dcp.templates && window.dcp.templates[this.getType()] && window.dcp.templates[this.getType()][key]) {
                return window.dcp.templates[this.getType()][key];
            }
            if (window.dcp && window.dcp.templates && window.dcp.templates["default"] && window.dcp.templates["default"][key]) {
                return window.dcp.templates["default"][key];
            }
            throw new Error("Unknown template  " + key + "/" + this.options.type);
        },

        getType: function dcpArray_getType() {
            return "array";
        }

    });

    return $.fn.dcpArray;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/attributes/color/wColor.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define, _super, kendoColorPicker*/

(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/text/wText.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //noinspection JSUnresolvedVariable
        factory(window.jQuery, window._, window.Mustache);
    }
})(window, function require_wColor($, _, Mustache) {
    'use strict';

    $.widget("dcp.dcpColor", $.dcp.dcpText, {

        options: {
            type: "color",

            renderOptions: {
                kendoColorConfiguration: {
                    buttons: false
                }
            },
            labels: {}
        },
        /**
         * The kendoColorPicker widget instance
         */
        kendoWidget: null,

        _initDom: function wColorInitDom() {
            this.element.addClass("dcpAttribute__content");
            this.element.attr("data-type", this.getType());
            this.element.attr("data-attrid", this.options.id);
            if (parseFloat(this.options.attributeValue.displayValue) === parseFloat(this.options.attributeValue.value)) {
                this.options.attributeValue.displayValue = this.formatNumber(this.options.attributeValue.value);
            }

            //noinspection JSPotentiallyInvalidConstructorUsage,JSAccessibilityCheck
            $.dcp.dcpAttribute.prototype._initDom.apply(this, []);

            this.kendoWidget = this.element.find(".dcpAttribute__value--edit");
            if (this.kendoWidget) {
                if (this.options.hasAutocomplete) {
                    this.activateAutocomplete(this.kendoWidget);
                } else {
                    this._activateColor(this.kendoWidget);

                    if (this.kendoWidget.hasClass("form-control")) {
                        this.element.find(".k-colorpicker").addClass("form-control");
                    }
                }
            }
            if (this.element.find(".dcpAttribute__content__buttons button").length === 0) {
                this.element.find(".k-picker-wrap").addClass("dcpAttribute__content__nobutton");
            }
            var colorTag = $("<div></div>", { "class": "dcpAttribute__content__color__tag" });
            colorTag.css('background-color', this.options.attributeValue.value);
            this.element.find(".dcpAttribute__value--read").prepend(colorTag);
        },

        _initChangeEvent: function wcolInitChangeEvent() {
            // set by widget if no autocomplete
            if (this.options.hasAutocomplete) {
                this._super();
            }
        },

        setValue: function wcolSetValue(value) {
            // this._super.(value);
            // Don't call dcpText::setValue()

            value = _.clone(value);

            if (_.has(value, "value") && !_.has(value, "displayValue")) {
                value.displayValue = this.formatNumber(value.value);
            }

            $.dcp.dcpAttribute.prototype.setValue.apply(this, [value]);

            if (this.getMode() === "write") {
                var originalValue = this.kendoWidget.data("kendoColorPicker").value();
                // : explicit lazy equal
                //noinspection JSHint
                if (originalValue != value.value) {
                    this.kendoWidget.data("kendoColorPicker").value(value.value);
                    // Modify value only if different
                    this.flashElement();
                }
            } else if (this.getMode() === "read") {
                this.getContentElements().text(value.displayValue);
                this.element.find(".dcpAttribute__value--read").css("border-color", value.value);
            } else {
                throw new Error("Attribute " + this.options.id + " unkown mode " + this.getMode());
            }
        },

        _activateColor: function wcolActivateNumber(inputValue) {
            return inputValue.kendoColorPicker(this.getKendoColorOptions());
        },

        formatNumber: function wcolFormatNumber(value) {
            return kendo.toString(value, this.getKendoColorOptions().format);
        },

        /**
         * Get kendo option from normal options and from renderOptions.kendoNumeric
         * @returns {*}
         */
        getKendoColorOptions: function wColorgetKendoColorOptions() {
            var scope = this,
                kendoOptions = {},
                defaultOptions = {
                change: function wColor_onchange() {
                    // Need to set by widget to honor decimals option
                    scope.setValue({ value: this.value() });
                }
            };

            if (_.isObject(scope.options.renderOptions.kendoColorConfiguration)) {
                kendoOptions = scope.options.renderOptions.kendoColorConfiguration;
            }
            return _.extend(defaultOptions, kendoOptions);
        },

        getType: function wcolGetType() {
            return "color";
        },

        testValue: function wcolTestValue(value) {
            this._super(value);
            if (!_.isNumber(value.value)) {
                throw new Error("The value must be a number for (attrid : " + this.options.id + ")");
            }
        },

        close: function wColor_close() {
            if (this.kendoWidget && this.kendoWidget.data("kendoColorPicker")) {
                this.kendoWidget.data("kendoColorPicker").close();
            }
            this._super();
        },

        _destroy: function _destroy() {
            if (this.kendoWidget && this.kendoWidget.data("kendoColorPicker")) {
                this.kendoWidget.data("kendoColorPicker").destroy();
            }
            this._super();
        }

    });

    return $.fn.dcpColor;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/attributes/date/wDate.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define, _super*/

(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/text/wText.js"), __webpack_require__("./node_modules/kendo-ui-core/js/cultures/kendo.culture.fr-FR.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //noinspection JSUnresolvedVariable
        factory(window.jQuery, window._, window.Mustache);
    }
})(window, function wDate($, _, Mustache) {
    'use strict';

    $.widget("dcp.dcpDate", $.dcp.dcpText, {

        options: {
            type: "date",
            minDate: new Date(1700, 0, 1),
            renderOptions: {
                kendoDateConfiguration: {
                    parseFormats: ["yyyy-MM-dd"],
                    format: null
                }
            },
            labels: {
                invalidDate: "Invalid Date"
            }
        },

        kendoWidgetClass: "kendoDatePicker",

        _initDom: function wDateInitDom() {

            if (this.options.renderOptions.kendoDateConfiguration.format) {
                this.options.attributeValue.displayValue = this.formatDate(this.parseDate(this.options.attributeValue.value));
            }
            if (this.getMode() === "read") {
                if (this.options.renderOptions.format) {
                    this.options.attributeValue.formatValue = Mustache.render(this.options.renderOptions.format || "", this.options.attributeValue);
                }
            }
            this.element.addClass("dcpAttribute__content");
            this.element.attr("data-type", this.getType());
            this.element.attr("data-attrid", this.options.id);
            //noinspection JSPotentiallyInvalidConstructorUsage,JSAccessibilityCheck
            $.dcp.dcpAttribute.prototype._initDom.apply(this, []);

            this.kendoWidget = this.element.find(".dcpAttribute__value--edit");

            if (this.kendoWidget.length) {
                if (this.options.hasAutocomplete) {
                    this.activateAutocomplete(this.kendoWidget);
                } else {
                    this._activateDate(this.kendoWidget);
                }
            }

            if (this.element.find(".dcpAttribute__content__buttons button").length === 0) {
                this.element.find(".k-picker-wrap").addClass("dcpAttribute__content__nobutton");
            }
        },

        _initChangeEvent: function wDate_initChangeEvent() {
            // set by widget if no autocomplete
            if (this.options.hasAutocomplete) {
                this._super();
            }
        },

        setValue: function wDateSetValue(value) {
            // this._super.(value);
            // Don't call dcpText::setValue()

            var originalValue, originalDate;
            value = _.clone(value);
            if (_.has(value, "value") && !_.has(value, "displayValue")) {
                value.displayValue = this.formatDate(this.parseDate(value.value));
            } else {
                if (this.options.renderOptions.kendoDateConfiguration.format) {
                    value.displayValue = this.formatDate(this.parseDate(value.value));
                }
            }

            //noinspection JSPotentiallyInvalidConstructorUsage
            $.dcp.dcpAttribute.prototype.setValue.call(this, value);

            if (this.getMode() === "write") {
                originalValue = this.convertDateToPseudoIsoString(this.kendoWidget.data(this.kendoWidgetClass).value());
                // : explicit lazy equal
                //noinspection JSHint, EqualityComparisonWithCoercionJS
                if (originalValue != value.value) {
                    if (value.value) {
                        originalDate = new Date(value.value);
                        if (!isNaN(originalDate.getTime())) {
                            this.kendoWidget.data(this.kendoWidgetClass).value(originalDate);
                        }
                    } else {
                        this.getContentElements().val('');
                    }
                    // Modify value only if different
                    if (originalValue || value.value) {
                        this.flashElement();
                    }
                }
            } else if (this.getMode() === "read") {
                this.getContentElements().text(value.displayValue);
            } else {
                throw new Error("Attribute " + this.options.id + " unkown mode " + this.getMode());
            }
        },

        _activateDate: function wDateSetValueActivateDate(inputValue) {
            var currentWidget = this;
            var kOptions = this.getKendoOptions();

            kOptions.change = function wDateChange() {
                if (this.value() !== null) {
                    // only valid date are setted
                    // wrong date are set by blur event
                    var isoDate = currentWidget.convertDateToPseudoIsoString(this.value());
                    // Need to set by widget to use raw date
                    currentWidget.setValue({ value: isoDate, displayValue: inputValue.val() });
                }
            };

            inputValue.kendoDatePicker(kOptions);

            // Workaround for date paste : change event is not trigger in this case
            inputValue.on("paste" + this.eventNamespace, function wDatePaste() {
                var $input = $(this);
                _.defer(function wDatePasteAfter() {
                    // set Value after
                    inputValue.data("kendoDatePicker").value($input.val().trim());
                    inputValue.data("kendoDatePicker").trigger("change");
                });
            });

            this._controlDate(inputValue);
        },

        _controlDate: function wDateControlDate(inputValue) {
            var currentWidget = this;
            inputValue.on('blur' + this.eventNamespace, function validateDate() /*event*/{
                var dateValue = $(this).val().trim();

                if (currentWidget.invalidDate) {
                    currentWidget.setError(null); // clear Error before
                    currentWidget.invalidDate = false;
                }

                currentWidget._setVisibilitySavingMenu("visible");

                if (dateValue) {
                    if (!currentWidget.parseDate(dateValue)) {

                        currentWidget._setVisibilitySavingMenu("disabled");
                        _.defer(function wDateFocus() {
                            currentWidget._getFocusInput().focus();
                        });
                        currentWidget.invalidDate = true;
                        currentWidget.setError(currentWidget.options.labels.invalidDate);
                    }
                }
            });
        },

        formatDate: function wDateFormatDate(value) {
            if (this.options.renderOptions.kendoDateConfiguration.format) {
                return kendo.toString(value, this.options.renderOptions.kendoDateConfiguration.format);
            }
            return kendo.toString(value, "d");
        },

        parseDate: function wDateParseDate(value) {
            var parseFormat = this.options.renderOptions.kendoDateConfiguration.parseFormats;
            var goodDate = kendo.parseDate(value);
            if (goodDate) {
                return goodDate;
            }
            if (this.options.renderOptions.kendoDateConfiguration.format) {
                parseFormat.push(this.options.renderOptions.kendoDateConfiguration.format);
            }
            return kendo.parseDate(value, parseFormat);
        },

        convertDateToPseudoIsoString: function wDateconvertDateToPseudoIsoString(dateObject) {
            if (dateObject && _.isDate(dateObject)) {
                return dateObject.getFullYear() + '-' + this.padNumber(dateObject.getMonth() + 1) + '-' + this.padNumber(dateObject.getDate());
            }
            return '';
        },

        padNumber: function wDatePadNumber(number) {
            if (number < 10) {
                return '0' + number;
            }
            return number;
        },

        /**
         * Get kendo option from normal options and from renderOptions.kendoNumeric
         * @returns {*}
         */
        getKendoOptions: function wDategetKendoOptions() {
            var currentWidget = this,
                kendoOptions = {},
                defaultOptions = {
                min: this.options.minDate
            };

            if (_.isObject(currentWidget.options.renderOptions.kendoDateConfiguration)) {
                kendoOptions = currentWidget.options.renderOptions.kendoDateConfiguration;
            }

            return _.extend(defaultOptions, kendoOptions);
        },

        close: function wDate_close() {
            if (this.kendoWidget.data(this.kendoWidgetClass)) {
                this.kendoWidget.data(this.kendoWidgetClass).close();
            }
            return this._super();
        },

        _destroy: function wDateDestroy() {
            if (this.kendoWidget.data(this.kendoWidgetClass)) {
                this.kendoWidget.data(this.kendoWidgetClass).destroy();
            }
            this._super();
        }
    });

    return $.fn.dcpDate;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/attributes/docid/wDocid.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/

(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/wAttribute.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //noinspection JSUnresolvedVariable
        factory(window.jQuery, window._, window.Mustache);
    }
})(window, function require_wDocid($, _, Mustache) {
    'use strict';

    //noinspection JSUnusedGlobalSymbols

    $.widget("dcp.dcpDocid", $.dcp.dcpAttribute, {

        options: {
            type: "docid",
            renderOptions: {
                kendoMultiSelectConfiguration: {
                    minLength: 1,
                    itemTemplate: '<div class="dcpAutocomplete"><span class="k-state-default">#= data.title#</span>' + '#if (data.message) {#' + '<div class="dcpAutocomplete--#= data.message.type#">#: data.message.contentText# #= data.message.contentHtml#</div>' + '#}# </div>'
                },
                kendoComboBoxConfiguration: {
                    template: '<div class="dcpAutocomplete"><span class="k-state-default">#= data.title#</span>' + '#if (data.message) {#' + '<div class="dcpAutocomplete--#= data.message.type#">#: data.message.contentText# #= data.message.contentHtml#</div>' + '#}# </div>'
                },
                editDisplay: "autoCompletion"
            },
            labels: {
                allSelectedDocument: "No more matching"
            }
        },

        kendoWidget: null,

        _initDom: function wDocidInitDom() {
            var scope = this;
            this.element.addClass("dcpAttribute__content");
            this.element.attr("data-type", this.getType());
            this.element.attr("data-attrid", this.options.id);

            if (this._isMultiple()) {
                this.options.attributeValues = _.toArray(this.options.attributeValue);
                this.options.isMultiple = true;
            }

            if (this.getMode() === "read") {
                if (this.options.renderOptions.format) {
                    if (this._isMultiple()) {
                        _.each(this.options.attributeValues, function wDocidinitDomFormat(singleValue) {
                            singleValue.formatValue = Mustache.render(scope.options.renderOptions.format, singleValue);
                        });
                    } else {
                        this.options.attributeValue.formatValue = Mustache.render(this.options.renderOptions.format, this.options.attributeValue);
                    }
                }
                if (this.options.renderOptions.documentIconSize) {
                    var reSize = /sizes\/([0-9xcfs]+)/;
                    var noIcon = ["0", "0x0", "x0"].indexOf(this.options.renderOptions.documentIconSize) !== -1;
                    if (this._isMultiple()) {
                        _.each(this.options.attributeValues, function wDocidResizeIcons(singleValue) {
                            if (noIcon) {
                                singleValue.icon = null;
                            } else if (singleValue.icon) {
                                singleValue.icon = singleValue.icon.replace(reSize, "sizes/" + scope.options.renderOptions.documentIconSize);
                            }
                        });
                    } else if (noIcon) {
                        this.options.attributeValue.icon = null;
                    } else if (this.options.attributeValue.icon) {
                        this.options.attributeValue.icon = this.options.attributeValue.icon.replace(reSize, "sizes/" + this.options.renderOptions.documentIconSize);
                    }
                }

                //noinspection JSPotentiallyInvalidConstructorUsage,JSAccessibilityCheck
                $.dcp.dcpAttribute.prototype._initDom.apply(this, []);
            } else if (this.getMode() === "write") {
                //noinspection JSPotentiallyInvalidConstructorUsage,JSAccessibilityCheck
                $.dcp.dcpAttribute.prototype._initDom.apply(this, []);
                this.kendoWidget = this.element.find(".dcpAttribute__value--docid");
                if (this.options.renderOptions.placeHolder) {
                    this.options.renderOptions.kendoMultiSelectConfiguration.placeholder = this.options.renderOptions.placeHolder;
                }
                if (this._isMultiple()) {
                    this._decorateMultipleValue(this.kendoWidget);
                } else {
                    switch (this.options.renderOptions.editDisplay) {
                        case "singleMultiple":
                            this._decorateSingleValue(this.kendoWidget);

                            break;
                        case "autoCompletion":
                            this.singleCombobox(this.kendoWidget);
                            break;
                        case "list":
                            this.singleDropdown(this.kendoWidget);
                            break;
                        default:
                            this.singleCombobox(this.kendoWidget);
                    }
                }
                this._updateCreateButton();
            }
        },

        _updateCreateButton: function wDocid_updateCreateButton() {
            var currentValue = this.options.attributeValue;
            var buttonsConfig = this.options.renderOptions.buttons;

            this.element.find(".dcpAttribute__content__button--create").each(function wDocid_updateCreateButtonEach() {
                var $button = $(this);
                var buttonIndex = $button.data("index");
                var buttonConfig = buttonsConfig[buttonIndex];

                $button.prop("disabled", false);
                if (currentValue.value) {
                    $button.html(buttonConfig.renderHtmlContent + buttonConfig.htmlEditContent);
                    // @TODO Find an efficient way to verify edit access of target
                    /*
                     if (!currentValue.value) {
                     $button.prop("disabled", true);
                     }*/
                } else {
                    // also when mutiple always create
                    $button.html(buttonConfig.renderHtmlContent + buttonConfig.htmlCreateContent);
                }
            });
        },

        /**
         * Init event when a hyperlink is associated to the attribute
         *
         * @protected
         */
        _initLinkEvent: function wDocidInitLinkEvent() {
            this._super();
            var htmlLink = this.getLink();
            var currentWidget = this;
            if (htmlLink) {
                this.element.on("click." + this.eventNamespace, '.dcpAttribute__content__link', function wDocidInitLinkOnClick(event) {
                    var $this = $(this);
                    if (htmlLink.target === "_render") {
                        event.preventDefault();
                        currentWidget._trigger("fetchdocument", event, {
                            "index": $this.data("index"),
                            "tableLine": $this.closest(".dcpArray__content__line").data("line")
                        });
                    }
                });
            }
            return this;
        },
        _initButtonsEvent: function _initButtonsEvent() {
            var currentWidget = this;
            this._super();

            this.element.on("click" + this.eventNamespace, ".dcpAttribute__content__button--create", function wAttributeButtonClick(event) {
                var buttonsConfig = currentWidget.options.renderOptions.buttons;
                var $button = $(this);
                var buttonIndex = $button.data("index");
                var buttonConfig = buttonsConfig[buttonIndex];

                currentWidget._trigger("externalLinkSelected", event, {
                    target: event.target,
                    eventId: "attribute.createDocumentRelation",
                    index: currentWidget._getIndex(),
                    buttonConfig: buttonConfig
                });
            });
            this.element.tooltip({
                selector: ".dcpAttribute__content__buttons button",
                placement: "top",
                trigger: "hover",
                html: true,
                title: function wAttributeGetButtonTitle() {
                    var title = $(this).data("title");
                    var attrValue = currentWidget.getValue();
                    return Mustache.render(title || "", attrValue);
                },
                container: this.element
            });

            return this;
        },
        /**
         * Define inputs for focus
         * @protected
         */
        _getFocusInput: function wDocidFocusInput() {
            return this.element.find('input');
        },

        /**
         * Get kendo option from normal options and from renderOptions.kendoMultiSelectConfiguration
         * @returns {*}
         */
        getKendoOptions: function wDocidGetKendoOptions(inputValue, extraOptions) {
            var currentWidget = this;
            var options = {
                autoBind: false,
                clearButton: false,
                dataTextField: "docTitle",
                dataValueField: "docId",
                highlightFirst: true,
                //value: values,
                dataSource: {
                    // type: "json",
                    serverFiltering: true,
                    transport: {
                        read: function wDocidSelectRead(options) {
                            currentWidget._hasBeenRequested = true;
                            options.data.index = currentWidget._getIndex();
                            return currentWidget.options.autocompleteRequest.call(null, options, currentWidget._getIndex());
                        }
                    },
                    schema: {
                        // Add already recorded data to items
                        data: function wDocidSelectSchema(items) {
                            //Add new elements
                            _.each(items, function wDocidDataCompose(currentItem) {
                                if (currentItem.values && currentItem.values[currentWidget.options.id]) {
                                    currentItem.docId = currentItem.values[currentWidget.options.id].value;
                                    currentItem.docTitle = currentItem.values[currentWidget.options.id].displayValue;
                                }
                            });

                            //Suppress multiple items
                            return _.uniq(items, false, function wDocidDataUniq(currentItem) {
                                return currentItem.docId || currentItem.message;
                            });
                        }
                    }
                },
                select: function kendoDocidSelect(event) {
                    if (!event.item || _.isUndefined(event.item.index())) {
                        return;
                    }

                    var valueIndex = currentWidget._getIndex();
                    var dataItem = this.dataSource.at(event.item.index()).toJSON();

                    if (dataItem.message) {
                        event.preventDefault();
                    } else {
                        //The object returned by dataSource.at are internal kendo object so I clean it with toJSON

                        _.defer(function wDocidChangeOnSelect() {
                            // Change others attributes designed by help returns
                            currentWidget._trigger("changeattrsvalue", event, {
                                dataItem: dataItem,
                                valueIndex: valueIndex
                            }, currentWidget._getIndex());
                        });
                    }
                },
                change: function kendoChangeSelect(event) {
                    // set in case of delete item
                    var oldValues = currentWidget.options.attributeValue;
                    var displayValue;
                    var newValues = [];
                    var kMultiSelect = this;
                    var widgetValue = this.value();

                    if (_.isArray(widgetValue)) {
                        _.each(widgetValue, function wDocidSelectChange(val) {
                            if (!_.isUndefined(val)) {
                                displayValue = _.where(oldValues, { value: val });
                                if (displayValue.length === 0) {
                                    displayValue = _.where(kMultiSelect.dataSource.data(), { docId: val });
                                    if (displayValue.length > 0) {
                                        displayValue = displayValue[0].docTitle;
                                    } else {
                                        displayValue = "-";
                                    }
                                } else {
                                    displayValue = displayValue[0].displayValue;
                                }

                                newValues.push({ value: val, displayValue: displayValue });
                            }
                        });

                        if (!currentWidget._isMultiple()) {
                            if (newValues.length > 0) {
                                newValues = newValues[0];
                            } else {
                                newValues = { value: null, displayValue: "" };
                            }
                        }
                    } else {
                        if (widgetValue) {
                            displayValue = _.where(kMultiSelect.dataSource.data(), { docId: widgetValue });
                            if (displayValue.length > 0) {
                                displayValue = displayValue[0].docTitle;
                                newValues = { value: widgetValue, displayValue: displayValue };
                            } else {
                                newValues = { value: null, displayValue: "" };
                            }
                        } else {
                            newValues = { value: null, displayValue: "" };
                        }
                    }

                    currentWidget.setValue(newValues, event);
                },
                open: function wDocidSelectOpen(event) {
                    if (currentWidget._hasBeenRequested !== true) {
                        event.preventDefault();
                        currentWidget.kendoWidgetObject.search("");
                    }
                    this.ul.addClass("dcpAttribute__select--docid");
                },
                close: function wDocidSelectClose() {
                    currentWidget._hasBeenRequested = false;
                },
                filtering: function wDocidSelectOpen() {
                    this._isFiltering = true;
                },
                dataBound: function wDocidFilteringNoOne() {
                    if (this._isFiltering) {
                        if (this.ul.find("li:not(.k-state-selected)").length === 0 && this.ul.find("li.k-state-selected").length > 0) {
                            // No one more : display
                            var $noOne = $('<li class="k-item"/>').append('<span class="k-state-default"/>').append($('<span class="k-state-error dcpAttribute__select--docid-none"/>').text(currentWidget.options.labels.allSelectedDocument));
                            this.ul.append($noOne);
                        }
                        this._isFiltering = false;
                    }
                }
            };

            if (extraOptions) {
                options = _.extend(options, extraOptions);
            }
            if (this.options.renderOptions.kendoComboBoxConfiguration) {
                options = _.extend(this.options.renderOptions.kendoComboBoxConfiguration, options);
            }

            return options;
        },

        /**
         * When docid is not multiple, it is a multiselect limited to one element
         * @param inputValue select  element
         */
        _decorateSingleValue: function wDocidDecorateSingleValue(inputValue) {

            this.options.attributeValues = [];
            if (this.options.attributeValue) {
                this.options.attributeValues.push(this.options.attributeValue);
            }

            this._decorateMultipleValue(inputValue, {
                maxSelectedItems: 1
            });

            if (this.options.attributeValue && this.options.attributeValue.value !== null) {
                this.element.find('.dcpAttribute__value--docid--button').attr("disabled", "disabled");
                this.element.find('input.k-input').attr("disabled", "disabled");
            }
        },

        _decorateMultipleValue: function wDocidDecorateMultipleValue(inputValue, extraOptions) {
            var options = this.getKendoOptions(inputValue, {
                filter: "contains"
            });
            var currentWidget = this,
                values = _.map(this.options.attributeValues, function wDocidSelectMap(val) {
                var info = {};
                info.docTitle = val.displayValue;
                info.docId = val.value;
                return info;
            });

            if (extraOptions) {
                options = _.extend(options, extraOptions);
            }

            if (this.options.renderOptions.kendoMultiSelectConfiguration) {
                options = _.extend(this.options.renderOptions.kendoMultiSelectConfiguration, options);
            }
            //noinspection JSUnresolvedFunction
            inputValue.kendoMultiSelect(options);
            this.kendoWidgetObject = inputValue.data("kendoMultiSelect");
            this.kendoWidgetObject.dataSource.data(values);

            if (this.options.attributeValues.value !== null) {
                // Init kendo widget with identifier array
                this.kendoWidgetObject.value(_.filter(_.map(values, function wDocidInitValue(item) {
                    return item.docId;
                }), function wDocidFilterEmpty(item) {
                    return !_.isEmpty(item);
                }));
            }
            this.element.on("click" + this.eventNamespace, '.dcpAttribute__value--docid--button', function wDocidSelectClick(event) {
                event.preventDefault();
                currentWidget.kendoWidgetObject.search("");
            });

            this.element.find('.dcpAttribute__value--docid--button[title]').tooltip({
                html: true
            });
        },

        singleDropdown: function wDocidSingleDropdown(inputValue) {
            var kendoOptions = this.getKendoOptions(inputValue);

            this.kendoWidgetObject = inputValue.kendoDropDownList(kendoOptions).data("kendoDropDownList");

            this.kendoWidgetObject.list.find(".k-list-optionlabel").addClass("placeholder--clear");
            this.kendoWidgetObject.value(this.options.attributeValue.value);
            this.element.find(".dcpAttribute__value--docid--button").parent().hide();
        },

        singleCombobox: function wDocidSingleCombobox(inputValue) {
            var kendoOptions = this.getKendoOptions(inputValue, {
                filter: "startswith" //@TODO use filter option in standard auto complete
            });
            var kendoSelect;

            this.kendoWidgetObject = inputValue.kendoComboBox(kendoOptions).data("kendoComboBox");
            kendoSelect = this.kendoWidgetObject;
            this.kendoWidgetObject.list.find(".k-list-optionlabel").addClass("placeholder--clear");

            if (this.options.attributeValue && this.options.attributeValue.value) {
                kendoSelect.dataSource.add({
                    docId: this.options.attributeValue.value,
                    docTitle: this.options.attributeValue.displayValue
                });
            }

            if (this.options.attributeValue.value) {
                // Init value in kendo only if any : if not call to server is performed
                this.kendoWidgetObject.value(this.options.attributeValue.value);
            }
            this.element.find(".dcpAttribute__value--docid--button").parent().hide();
        },

        /**
         * Return true if attribut has multiple option
         * @returns bool
         */
        hasMultipleOption: function wDocidHasMultipleOption() {
            return this.options.options && this.options.options.multiple === "yes";
        },

        setValue: function wDocidSetValue(value, event) {
            var newValues;
            this._super(value, event);
            if (this.getMode() === "write") {
                if (!this.hasMultipleOption() && this.options.renderOptions.editDisplay === "singleMultiple") {
                    if (!_.isArray(value)) {
                        if (value.value !== null) {
                            value = [value];
                        } else {
                            value = [];
                        }
                    } else if (value.length === 1 && value.value === null) {
                        value = [];
                    }
                    if (value.length === 0) {
                        this.element.find('.dcpAttribute__value--docid--button').removeAttr("disabled");
                        this.element.find('input.k-input').removeAttr("disabled");
                    } else {
                        this.element.find('.dcpAttribute__value--docid--button').attr("disabled", "disabled");
                        this.element.find('input.k-input').attr("disabled", "disabled");
                    }
                }

                if (this.hasMultipleOption() || this.options.renderOptions.editDisplay === "singleMultiple") {
                    newValues = _.map(value, function wDocidMapValue(val) {
                        return val.value;
                    });
                } else {
                    newValues = value.value;
                }
                var kendoSelect = this.kendoWidgetObject;
                var originalValues = _.clone(kendoSelect.value());
                // update values in kendo widget

                var dataOri = _.map(_.filter(kendoSelect.dataSource.data(), function wDocIdFilter(item) {
                    return !_.isEmpty(item.docId);
                }), function wDocidFilterEmpty(currentElement) {
                    return {
                        docId: currentElement.docId,
                        docTitle: currentElement.docTitle
                    };
                });

                if (!_.isArray(value)) {
                    value = [value];
                }
                _.each(value, function wDocidEachData(val) {
                    var info = {};

                    if (!_.some(dataOri, function wDocidEachUniq(elt) {
                        return val && elt.docId === val.value;
                    })) {
                        // add more static data in dataSource
                        if (val.value !== null) {
                            info.docTitle = val.displayValue;
                            info.docId = val.value;
                            kendoSelect.dataSource.add(info);
                        }
                    }
                });

                if (!this._isEqual(originalValues, newValues)) {
                    kendoSelect.value(newValues);
                    this.flashElement();
                }
                this._updateCreateButton();
            } else if (this.getMode() === "read") {
                this.redraw();
            } else {
                throw new Error("Attribute " + this.options.id + " unkown mode " + this.getMode());
            }
        },

        _isEqual: function _isEqual(values1, values2) {
            var convertToString = function convertToString(currentValue) {
                if (!currentValue || !currentValue.toString) {
                    currentValue = "";
                }
                return currentValue.toString();
            };
            if (!_.isArray(values1)) {
                values1 = [values1];
            }
            if (!_.isArray(values2)) {
                values2 = [values2];
            }
            values1 = _.filter(_.uniq(_.map(values1, convertToString)), function (value) {
                return !!value;
            });
            values2 = _.filter(_.uniq(_.map(values2, convertToString)), function (value) {
                return !!value;
            });
            return _.isEqual(values1, values2);
        },

        close: function wDocid_close() {
            if (this.kendoWidget && this.kendoWidgetObject) {
                this.kendoWidgetObject.close();
            }
        },

        getType: function wDocid_getType() {
            return "docid";
        },

        _destroy: function wDocid__destroy() {
            if (this.kendoWidget && this.kendoWidgetObject) {
                this.kendoWidgetObject.destroy();
            }
            $(".dcpDocid-create-window").each(function wDocid_destroyWindow() {
                var kWindow = $(this).data("dcpWindow");
                if (kWindow) {
                    kWindow.destroy();
                }
            });
            this._super();
        }

    });

    return $.fn.dcpDocid;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/attributes/double/wDouble.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/int/wInt.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //noinspection JSUnresolvedVariable
        factory(window.jQuery);
    }
})(window, function require_double($) {
    'use strict';

    $.widget("dcp.dcpDouble", $.dcp.dcpInt, {

        options: {
            type: "double",
            renderOptions: {
                decimalPrecision: null, // unlimited precision
                numberFormat: '#,#.######################'
            }
        },

        _initDom: function wDoubleInitDom() {
            if (this.options.renderOptions.decimalPrecision !== null && this.options.renderOptions.decimalPrecision >= 0) {
                // view decimal precision
                this.options.renderOptions.numberFormat = '#,#.';
                for (var idx = 0; idx < this.options.renderOptions.decimalPrecision; idx++) {
                    this.options.renderOptions.numberFormat += '0';
                }
            }

            this._super();
        },
        /**
         * Get kendo option from normal options and from renderOptions.kendoNumeric
         * @returns {*}
         */
        getKendoNumericOptions: function wDoubleGetKendoNumericOptions() {
            var options = this._super(); // get from wInt
            //Limits are linked to this bug => https://github.com/telerik/kendo-ui-core/issues/423
            if (options.max === null) {
                options.max = 9.99999e19;
            }
            if (options.min === null) {
                options.min = -9.9999e19;
            }
            if (this.options.renderOptions.decimalPrecision !== null) {
                options.decimals = this.options.renderOptions.decimalPrecision;
            } else {
                options.decimals = 20;
            }
            return options;
        },

        getType: function wDoubleGetType() {
            return "double";
        }

    });

    return $.fn.dcpDouble;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/attributes/enum/wEnum.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define */
(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/wAttribute.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //noinspection JSUnresolvedVariable
        factory(window.jQuery, window._, window.Mustache);
    }
})(window, function require_wenum($, _, Mustache, dcpAttribute) {
    'use strict';

    var localeCompareSupportsLocales = function testLocaleCompareSupportsLocales() {
        try {
            'foo'.localeCompare('bar', 'i');
        } catch (e) {
            return e.name === 'RangeError';
        }
        return false;
    }();

    $.widget("dcp.dcpEnum", $.dcp.dcpAttribute, {

        options: {
            type: "enum",
            sourceValues: [], // [{key:"the key", label:"the label"}, ...}]
            sourceUri: null, // when enum definition is dynamically get by server request
            labels: {
                invalidEntry: "Invalid Entry",
                invertSelection: "Click to answer {{displayValue}}",
                selectMessage: 'Select',
                unselectMessage: 'UnSelect',
                chooseAnotherChoice: "Choose another choice",
                selectAnotherChoice: "Select choice",
                displayOtherChoice: "** {{value}} **"
            },
            renderOptions: {
                kendoDropDownConfiguration: {
                    filter: "none",
                    autoBind: true
                },
                kendoComboBoxConfiguration: {
                    filter: "startswith"
                },
                kendoMultiSelectConfiguration: {
                    filter: "startswith"
                },
                editDisplay: "list", // possible values are ["list', 'vertical', 'horizontal', 'autoCompletion']'
                useFirstChoice: false,
                useSourceUri: false,
                useOtherChoice: false,
                placeHolder: 'Select', // Message to display when no useFirstChoice is true and no value selected
                orderBy: false
            }
        },
        _initDom: function wEnumInitDom() {
            var currentWidget = this;
            if (this.getMode() === "write" && this.options.renderOptions && this.options.renderOptions.orderBy) {
                switch (this.options.renderOptions.orderBy) {
                    case 'key':
                        if (this.options.sourceValues && this.options.sourceValues.sort) {
                            this.options.sourceValues = this.options.sourceValues.sort(function wEnum_initDomSortKey(a, b) {
                                if (a.key === b.key) {
                                    return 0;
                                }
                                return a.key < b.key ? -1 : 1;
                            });
                        }
                        break;
                    case 'label':
                        if (this.options.sourceValues && this.options.sourceValues.sort) {
                            this.options.sourceValues = this.options.sourceValues.sort(function wEnum_initDomSortLabel(a, b) {
                                if (localeCompareSupportsLocales) {
                                    return String(a.label).localeCompare(String(b.label), currentWidget.options.locale, {
                                        numeric: true,
                                        caseFirst: false
                                    });
                                } else {
                                    return String(a.label).localeCompare(String(b.label));
                                }
                            });
                        }
                        break;
                }
            }
            if (this._isMultiple()) {
                this.options.isMultiple = true;
                _.each(this.options.attributeValue, function wEnumDisplayOthers(singleValue) {
                    if (singleValue) {
                        singleValue.exists = singleValue.exists !== false;

                        if (singleValue.exists === false) {
                            singleValue.displayValue = Mustache.render(currentWidget.options.labels.displayOtherChoice, singleValue);
                        }
                    }
                });
            } else {
                if (this.options.attributeValue.exists === false) {
                    this.options.attributeValue.displayValue = Mustache.render(this.options.labels.displayOtherChoice, this.options.attributeValue);
                }
            }

            if (this.getMode() === "read") {
                if (this._isMultiple()) {
                    this.options.attributeValues = _.toArray(this.options.attributeValue);
                    this.options.isMultiple = true;
                } else {
                    this.options.attributeValues = [this.options.attributeValue];
                    this.options.isMultiple = false;
                }
                this._super();
            }

            if (this.getMode() === "write") {
                if (this.options.options && this.options.options.eformat === "auto") {
                    this.options.renderOptions.useSourceUri = true;
                }

                if (this.options.renderOptions.useOtherChoice === true) {
                    this.options.otherUuid = _.uniqueId("enum");
                }
                if (this.options.index >= 0) {
                    var enumIndex = this.element.closest("table").data("enumIndex");

                    if (!enumIndex) {
                        enumIndex = {};
                    }
                    if (!enumIndex[this.options.id]) {
                        enumIndex[this.options.id] = 0;
                    }
                    this.options.inArray = true;
                    this.options.enumIndex = enumIndex[this.options.id];
                    enumIndex[this.options.id]++;
                    this.element.closest("table").data("enumIndex", enumIndex);
                }
                this._initMainElementClass();
                if (this._isMultiple()) {
                    switch (this.options.renderOptions.editDisplay) {
                        case "autoCompletion":
                        case "list":
                            this.multipleSelect();
                            break;
                        case "horizontal":
                        case "vertical":
                            this.checkboxButtons();
                            break;
                        case "bool":
                            throw new Error("Enum bool display cannot be applied to a multiple attribute : " + this.options.id);
                        default:
                            this.multipleSelect();
                    }
                    this.element.on("click" + this.eventNamespace, '.dcpAttribute__value--enum--button', function wEnumSelectClick(event) {
                        event.preventDefault();
                        currentWidget.kendoWidgetObject.search("");
                    });
                } else {
                    switch (this.options.renderOptions.editDisplay) {
                        case "autoCompletion":
                            this.singleCombobox();
                            break;
                        case "list":
                            this.singleDropdown();
                            break;
                        case "bool":
                            this.boolButtons();
                            break;
                        case "horizontal":
                        case "vertical":
                            this.radioButtons();
                            break;
                        default:
                            this.singleDropdown();
                    }
                }
            }

            this.noButtonDisplay();
        },
        getSingleEnumData: function wEnumGetSingleEnumData() {
            var source = [];
            var scope = this;
            var selectedIndex = -1;
            var item;

            if (this.options.renderOptions.useSourceUri) {
                source = [this.options.attributeValue];
                selectedIndex = this.options.attributeValue.value;
            } else {
                _.each(this.options.sourceValues, function wEnum_prepareValue(enumItem) {
                    if (enumItem.key !== '' && enumItem.key !== ' ') {
                        item = {};

                        item.value = enumItem.key;
                        item.displayValue = enumItem.label || '';
                        item.exists = enumItem.exists !== false;
                        item.enumUuid = _.uniqueId("enum");

                        // : no === because json encode use numeric cast when index is numeric
                        //noinspection JSHint
                        if (enumItem.key == scope.options.attributeValue.value) {
                            selectedIndex = source.length;
                            item.selected = true;
                        } else {
                            item.selected = false;
                        }

                        source.push(item);
                    }
                });
                if (selectedIndex === -1 && this.options.attributeValue && !_.isUndefined(this.options.attributeValue.value) && this.options.attributeValue.value !== null) {
                    selectedIndex = source.length;
                    source.push({
                        value: this.options.attributeValue.value,
                        displayValue: this.options.attributeValue.displayValue || '',
                        selected: true,
                        exists: false,
                        enumUuid: _.uniqueId("enum")
                    });
                }
            }

            return { data: source, index: selectedIndex };
        },

        getMultipleEnumData: function wEnumGetMultipleEnumData() {
            var source = [];
            var selectedValues = [];
            var isIn = false;
            var item;
            var values = [];

            if (this.options.attributeValue && this.options.attributeValue.value !== null) {
                values = _.toArray(this.options.attributeValue);
            }

            if (this.options.renderOptions.useSourceUri) {
                source = values;
                selectedValues = _.pluck(values, "value");
            } else {

                _.each(this.options.sourceValues, function wEnum_prepareMultipleValue(enumItem) {
                    item = {};
                    item.value = enumItem.key;
                    item.displayValue = enumItem.label || '';
                    item.selected = false;
                    item.exists = enumItem.exists !== false;
                    item.enumUuid = _.uniqueId("enum");
                    isIn = _.some(values, function wEnum_findSelected(aValue) {
                        //noinspection JSHint
                        return aValue.value == enumItem.key;
                    });

                    // : no === because json encode use numeric cast when index is numeric
                    //noinspection JSHint
                    if (isIn) {
                        item.selected = true;
                    }

                    source.push(item);
                });

                _.each(values, function wEnum_addOtherValues(singleValue) {
                    if (singleValue.value !== null && singleValue.value !== '') {
                        if (singleValue.exists === false) {
                            item = {};
                            item.value = singleValue.value;
                            item.displayValue = singleValue.displayValue;
                            item.selected = true;
                            item.exists = false;
                            item.enumUuid = _.uniqueId("enum");
                            source.push(item);
                        }
                        selectedValues.push(singleValue.value);
                    }
                });
            }

            return {
                data: source,
                selectedValues: selectedValues
            };
        },

        retrieveItems: function wEnumretrieveItemse(done) {
            var scope = this,
                requestData = {};

            if (this.options.renderOptions.orderBy) {
                requestData.orderBy = this.options.renderOptions.orderBy;
            }

            // Get enums data and defer render
            $.ajax({
                type: "GET",
                url: this.options.sourceUri,
                dataType: "json",
                data: requestData
            }).done(function wEnum_retrieveDone(result) {
                scope.options.sourceValues = result.data.enumItems;
                scope.options.renderOptions.useSourceUri = false;
                done(scope);
            }).fail(function wEnum_retrieveFail(response) {
                $('body').trigger("notification", {
                    htmlMessage: "Enumerate " + scope.options.id,
                    message: response.statusText,
                    type: "error"
                });
            });
        },

        noButtonDisplay: function wEnumNoDisplayButton() {
            if (this.element.find(".dcpAttribute__content__buttons button").length === 0) {
                this.element.find(".dcpAttribute__value--enumbuttons").addClass("dcpAttribute__content__nobutton");
                this.element.find(".dcpAttribute__content__buttons").hide();
            }
        },

        boolButtons: function wEnumBoolButtons() {
            var enumData;
            var tplOption = this.options;
            var scope = this;

            if (this.options.renderOptions.useSourceUri) {
                this.retrieveItems(function wEnum_onRetrieveDone(theWidget) {
                    theWidget.boolButtons();
                });
                return;
            }

            enumData = this.getSingleEnumData();
            tplOption.enumValues = enumData.data;

            if (tplOption.enumValues.length > 1) {
                tplOption.enumValues[0].off = true;
                tplOption.enumValues[1].on = true;
            }

            this.options.isMultiple = true; // Just to have checkbox

            this.options.renderOptions.useOtherChoice = false; // Always : no use this options
            this.element.append(Mustache.render(this._getTemplate('writeToggle') || "", this.options));
            this.options.isMultiple = false; // restore isMultiple : it never can be multiple

            if (scope.options.labels.invertSelection) {
                this.element.find(".dcpAttribute__value--toggle").each(function wEnum_insertTooltip(kItem) {
                    if (tplOption.enumValues[kItem]) {
                        $(this).tooltip({
                            trigger: "hover",
                            container: scope.element,
                            title: Mustache.render(scope.options.labels.invertSelection || "", tplOption.enumValues[(kItem + 1) % 2])
                        });
                    }
                });
            }

            this.noButtonDisplay();

            this.element.on("click" + this.eventNamespace, ".dcpAttribute__value--toggle", function wEnum_booleanClick(event) {
                event.preventDefault();
                // Invert selection
                _.some(tplOption.enumValues, function wEnum_comboSetValue(item) {
                    if (scope.options.attributeValue.value === null || item.value !== scope.options.attributeValue.value) {
                        scope.setValue(item, event);
                        return true;
                    }
                    return false;
                });
            });

            this.getContentElements().each(function wEnum_addKButton() {
                $(this).closest(".dcpAttribute__value--enumlabel").addClass("k-button");
            });
            if (scope.options.attributeValue.value === null) {
                // Set to first enum item if empty
                var firstItem = tplOption.enumValues[0];
                if (firstItem) {
                    scope.setValue({ value: firstItem.value, displayValue: firstItem.displayValue });
                }
            }
        },
        /**
         * Identify the input where is the raw value
         * @returns {*}
         */
        getContentElements: function wEnum_getContentElements() {
            if (this.options.inArray && (this.options.renderOptions.editDisplay === "horizontal" || this.options.renderOptions.editDisplay === "vertical" || this.options.renderOptions.editDisplay === "bool")) {

                return this.element.find('.dcpAttribute__value[name="' + this.options.id + '[' + this.options.enumIndex + ']"]');
            } else {
                return this._super();
            }
        },

        radioButtons: function wEnumRadioButtons() {
            var enumData;
            var tplOption = this.options;
            var labels;
            var scope = this;
            var hasNotExists;

            if (this.options.renderOptions.useSourceUri) {
                this.retrieveItems(function wEnum_retrieveDone(theWidget) {
                    theWidget.radioButtons();
                });
                return;
            }

            enumData = this.getSingleEnumData();

            tplOption.enumValues = enumData.data;
            hasNotExists = _.some(enumData.data, function wEnum_findNotExistItem(item) {
                return item.exists === false;
            });

            if (hasNotExists === true) {
                // No set twice for radio
                this.options.renderOptions.useOtherChoice = false;
            }
            this.element.append(Mustache.render(this._getTemplate('writeRadio') || "", this.options));
            labels = this.element.find(".dcpAttribute__value--enumlabel");

            this.noButtonDisplay();
            labels.on("change" + this.eventNamespace, "input[type=radio]", function wEnum_onchange(event) {
                var newValue = {};
                newValue.value = $(this).val();
                newValue.displayValue = $(this).closest(".dcpAttribute__value--enumlabel").find("label").text().trim();
                scope.setValue(newValue, event);
            });

            this.getContentElements().each(function wEnum_addKButton() {
                $(this).closest("label").addClass("k-button");
            });
            if (scope.options.renderOptions.useFirstChoice && scope.options.attributeValue.value === null) {
                // Set to first enum item if empty
                var firstItem = tplOption.enumValues[0];
                if (firstItem) {
                    scope.setValue({ value: firstItem.value, displayValue: firstItem.displayValue });
                }
            }

            if (scope.options.labels.selectMessage) {
                this.element.find(".dcpAttribute__value--enumbuttons").tooltip({
                    container: ".dcpDocument",
                    selector: '.dcpAttribute__value--enumlabel--text',
                    trigger: "hover",
                    title: function wEnum_titleTooltip() {
                        if ($(this).closest(".dcpAttribute__value--enumlabel").find("input").prop("checked")) {
                            return null;
                        } else {
                            return Mustache.render(scope.options.labels.selectMessage, {
                                displayValue: $(this).text(),
                                value: $(this).parent().find("input").val()
                            });
                        }
                    }
                });
            }

            this._checkRadioOther();
        },
        checkboxButtons: function wEnumRadioButtons() {
            var enumData;
            var tplOption = this.options;
            var scope = this;

            if (this.options.renderOptions.useSourceUri) {
                this.retrieveItems(function wEnum_onDone(theWidget) {
                    theWidget.checkboxButtons();
                });
                return;
            }
            enumData = this.getMultipleEnumData();
            tplOption.enumValues = enumData.data;

            this.element.append(Mustache.render(this._getTemplate('writeRadio') || "", this.options));

            this.noButtonDisplay();
            this.element.on("change" + this.eventNamespace, ".dcpAttribute__value--enumlabel input[type=checkbox]", function wEnum_onChange(event) {

                var newValue = [];

                scope.getContentElements().each(function wEnum_findChecked() {
                    var $this = $(this);
                    if ($this.prop("checked")) {
                        var itemValue = {};
                        itemValue.value = $this.val();
                        itemValue.displayValue = $this.closest('label').text().trim();
                        newValue.push(itemValue);
                    }
                });

                scope.setValue(newValue, event);
            });

            this.getContentElements().each(function wEnum_addKButton() {
                $(this).closest("label").addClass("k-button");
            });

            if (this.options.labels.selectMessage) {
                this.element.find(".dcpAttribute__value--enumbuttons").tooltip({
                    container: ".dcpDocument",
                    selector: '.dcpAttribute__value--enumlabel--text',
                    trigger: "hover",
                    title: function wEnum_Cb_titleTooltip() {
                        var $this = $(this);
                        if ($this.closest(".dcpAttribute__value--enumlabel").find("input").prop("checked")) {

                            return Mustache.render(scope.options.labels.unselectMessage, {
                                displayValue: $(this).text(),
                                value: $(this).parent().find("input").val()
                            });
                        } else {
                            return Mustache.render(scope.options.labels.selectMessage, {
                                displayValue: $(this).text(),
                                value: $(this).parent().find("input").val()
                            });
                        }
                    }
                });
            }
            if (this.options.renderOptions.useOtherChoice === true) {
                this._checkBoxOther();
            }
        },

        /**
         * Manage other input for radio
         * @private
         */
        _checkRadioOther: function wEnum__checkRadioOther() {
            this.element.find(".dcpAttribute__value--enum--other").on("focus" + this.eventNamespace, function wEnumRadioOtherInputClick() {

                $(this).trigger("change");
            }).on("change" + this.eventNamespace, function wEnumRadioOtherInputChange() {
                var $label = $(this).closest(".dcpAttribute__value--enumlabel");
                var $input = $label.find(".dcpAttribute__value--edit");
                $input.val($(this).val());
                // Trigger change label input to real set value
                $label.find("input[type=radio]").trigger("change");
            }).on("keyup" + this.eventNamespace, function wEnumRadioOtherInputKeyReturn(event) {
                var code = event.keyCode ? event.keyCode : event.which;
                if (code === 13 || code === 10) {
                    $(this).blur();
                }
            });
        },

        /**
         * Manage other input for checkbox
         * @private
         */
        _checkBoxOther: function wEnum__checkBoxOther() {
            this.element.on("focus" + this.eventNamespace, ".dcpAttribute__value--enum--other", function wEnumCheckOtherInputClick() {
                $(this).trigger("change");
            }).on("change" + this.eventNamespace, ".dcpAttribute__value--enum--other", function wEnumCheckOtherInputChange() {
                var $label = $(this).closest(".dcpAttribute__value--enumlabel");
                var $input = $label.find(".dcpAttribute__value--edit");
                var $hasEmpty;
                var $checkbox = $label.find("input[type=checkbox]");

                $input.val($(this).val());

                $hasEmpty = _.some($(this).closest(".dcpAttribute__value--enumbuttons").find(".dcpAttribute__value--enum--other"), function wEnum_findEmptyOther(item) {
                    return $(item).val() === "";
                });

                if (!$hasEmpty) {
                    var $newOne = $label.clone();
                    var uuid = _.uniqueId("enum");
                    $newOne.find("input[type=checkbox]").attr("id", uuid);
                    $newOne.find("label").attr("for", uuid);
                    // add new input if no one free found
                    $label.parent().append($newOne);
                    $newOne.find("input").val("").prop("checked", false);

                    if (!$checkbox.prop("checked")) {
                        $label.find("label").trigger("click");
                    }
                }
                // resend change trigger because this hook is call before the checkbox onchange event
                $checkbox.trigger("change");
            }).on("keyup" + this.eventNamespace, ".dcpAttribute__value--enum--other", function wEnumCheckOtherInputKeyReturn(event) {
                var code = event.keyCode ? event.keyCode : event.which;
                if (code === 13 || code === 10) {
                    $(this).blur(); // Change event will be triggered
                }
            });
        },
        singleDropdown: function wEnumSingleDropdown() {
            var kendoOptions = this.getKendoOptions();
            var kddl;
            this.element.append(Mustache.render(this._getTemplate('write') || "", this.options));
            this.kendoWidget = this.element.find(".dcpAttribute__value--edit");
            kddl = this.kendoWidget.kendoDropDownList(kendoOptions).data("kendoDropDownList");
            this.kendoWidgetObject = this.kendoWidget.data("kendoDrobDownList");
            kddl.list.find(".k-list-optionlabel").addClass("placeholder--clear");
        },
        multipleSelect: function wEnumMultipleSelect() {
            var kendoOptions = this.getKendoOptions();
            this.element.append(Mustache.render(this._getTemplate('write') || "", this.options));
            this.kendoWidget = this.element.find(".dcpAttribute__value--edit");
            this.kendoWidget.kendoMultiSelect(kendoOptions);
            this.kendoWidgetObject = this.kendoWidget.data("kendoMultiSelect");
        },

        singleCombobox: function wEnumSingleCombobox() {
            var kendoOptions = this.getKendoOptions();
            var kddl;
            var currentWidget = this;

            this.element.append(Mustache.render(this._getTemplate('write') || "", this.options));
            this.kendoWidget = this.element.find(".dcpAttribute__value--edit");

            kddl = this.kendoWidget.kendoComboBox(kendoOptions).data("kendoComboBox");

            this.kendoWidgetObject = kddl;
            if (this.options.renderOptions.useSourceUri) {
                if (this.options.attributeValue.value === null) {
                    //kddl.dataSource.data([]);
                    kddl.value('');
                } else {
                    kddl.dataSource.data([this.options.attributeValue]);
                    kddl.value(this.options.attributeValue.value);
                }
            } else {
                if (this.options.attributeValue.value) {
                    kddl.value(this.options.attributeValue.value);
                }
            }
            this.element.on("click" + this.eventNamespace, ".dcpAttribute__content__button--delete", function wEnumDeleteFilter() {
                currentWidget.setError(null);
                kddl.dataSource.filter({});
                kddl.value('');
            });
        },

        /**
         *Set new value to widget
         * @param value value {value:...., displayValue} or array of {value:...., displayValue}
         * @param event
         */
        setValue: function wEnumSetValue(value, event) {
            var kddl, newValues;
            var currentWidget = this;
            if (this.options.renderOptions.editDisplay === "bool") {
                // This display has only 2 values and cannot be set to null
                if (value.value === null) {
                    if (this.options.enumValues[0]) {
                        value = this.options.enumValues[0];
                    }
                }
            }
            this._super(value, event);
            if (this.getMode() === "write") {
                if (this._isMultiple()) {
                    switch (this.options.renderOptions.editDisplay) {
                        case "autoCompletion":
                        case "list":
                            kddl = this.kendoWidget.data("kendoMultiSelect");
                            newValues = _.map(value, function wEnum_findValues(val) {
                                if (!currentWidget.options.renderOptions.useSourceUri) {
                                    if (!kddl.dataSource.get(val.value)) {
                                        kddl.dataSource.add(val);
                                    }
                                }
                                return val.value;
                            });
                            if (!_.isEqual(kddl.value(), newValues)) {
                                this.flashElement();
                                if (this.options.renderOptions.useSourceUri) {
                                    if (newValues.length > 0) {
                                        _.each(value, function wEnumCompleteExists(singleValue) {
                                            singleValue.exists = singleValue.exists !== false;
                                        });
                                        kddl.dataSource.data(value);
                                    }
                                }
                                kddl.value(newValues);
                            }
                            break;

                        case "horizontal":
                        case "vertical":
                            this.getContentElements().each(function wEnum_findValues() {
                                var $this = $(this);
                                var inputValue = $this.val();

                                var isIn = _.some(value, function wEnum_isIn(x) {
                                    //noinspection JSHint
                                    return x.value == inputValue;
                                });
                                if (isIn) {
                                    $this.prop("checked", true);
                                    $this.closest(".dcpAttribute__value--enumlabel").addClass("selected");
                                } else {
                                    $this.prop("checked", false);
                                    $this.closest(".dcpAttribute__value--enumlabel").removeClass("selected");
                                }
                            });

                            this.element.find(".dcpAttribute__value--enumlabel--text").tooltip("hide");
                            break;
                        default:
                            throw new Error("Unknow Enum mode : " + this.options.renderOptions.editDisplay);

                    }
                } else {
                    switch (this.options.renderOptions.editDisplay) {
                        case "autoCompletion":
                            kddl = this.kendoWidget.data("kendoComboBox");
                            if (!_.isEqual(kddl.value(), value.value)) {
                                this.flashElement();

                                if (value.value !== null) {
                                    if (this.options.renderOptions.useSourceUri) {
                                        kddl.dataSource.data([value]);
                                    } else {
                                        if (!kddl.dataSource.get(value.value)) {
                                            kddl.dataSource.add(value);
                                        }
                                    }
                                    this.setError(null);
                                    kddl.value(value.value);
                                } else {
                                    kddl.value('');
                                }
                            }
                            break;
                        case "list":
                            kddl = this.kendoWidget.data("kendoDropDownList");

                            if (!_.isEqual(kddl.value(), value.value || "")) {
                                this.flashElement();
                                if (!kddl.dataSource.get(value.value)) {
                                    kddl.dataSource.add(value);
                                }

                                // kendo need empty string (not null) to clear input
                                kddl.value(value.value || "");
                            }
                            break;
                        case "bool":
                            this.getContentElements().each(function wEnum_parseElements() {
                                var $this = $(this);
                                var isOn;
                                //noinspection JSHint
                                if ($this.data("togglevalue").toString() === value.value) {
                                    if (!$this.hasClass("selected")) {
                                        if ($this.hasClass("on")) {
                                            isOn = true;
                                            $this.removeClass("on").addClass("off");
                                        } else if ($this.hasClass("off")) {
                                            $this.removeClass("off").addClass("on");
                                            isOn = false;
                                        }
                                        $this.addClass("selected").removeClass("unselected");

                                        _.defer(function wEnumAnimateBool() {
                                            if (isOn === true) {
                                                $this.addClass("on").removeClass("off");
                                            } else {
                                                $this.addClass("off").removeClass("on");
                                            }
                                        });
                                    }
                                } else {
                                    $this.removeClass("selected").addClass("unselected");
                                }
                            });
                            this.element.find(".dcpAttribute__value--enumlabel").tooltip("hide");

                            break;
                        case "horizontal":
                        case "vertical":
                            this.getContentElements().each(function wEnum_parseElements() {
                                var $this = $(this);
                                //noinspection JSHint
                                if ($this.val() == value.value) {
                                    $this.prop("checked", true);
                                    $this.closest(".dcpAttribute__value--enumlabel").addClass("selected");
                                } else {
                                    $this.prop("checked", false);
                                    $this.closest(".dcpAttribute__value--enumlabel").removeClass("selected");
                                }
                            });

                            this.element.find(".dcpAttribute__value--enumlabel--text").tooltip("hide");
                            break;
                        default:
                            throw new Error("Unknow Enum mode : " + this.options.renderOptions.editDisplay);

                    }
                }
            } else {
                this._super(value, event);
                this.redraw();
            }
        },
        /**
         * method use for transport multiselect widget
         * @param options
         */
        autocompleteRequestEnum: function wEnumAutocompleteRequestEnum(options) {
            var requestData = {},
                scope = this;

            if (options.data.filter && options.data.filter.filters && options.data.filter.filters.length > 0) {
                requestData.keyword = options.data.filter.filters[0].value;
                requestData.operator = options.data.filter.filters[0].operator;
            }
            if (this.options.renderOptions.orderBy) {
                requestData.orderBy = this.options.renderOptions.orderBy;
            }

            if (!this.options.sourceUri) {
                throw new Error("Enum : sourceUri must be defined if renderOption useSourceUri is set to true");
            }
            $.ajax({
                type: "GET",
                url: this.options.sourceUri,
                data: requestData,
                dataType: "json",
                success: function wEnum_onAutoCompleteSuccess(result) {
                    var info = [];
                    _.each(result.data.enumItems, function wEnum_analyzeResult(enumItem) {
                        info.push({
                            value: enumItem.key,
                            displayValue: enumItem.label || '',
                            exists: enumItem.exists !== false
                        });
                    });
                    if (!scope._isMultiple()) {
                        if (scope.options.attributeValue.value !== null) {
                            if (!_.contains(_.pluck(info, "value"), scope.options.attributeValue.value)) {
                                if (scope.options.attributeValue.displayValue === scope.options.attributeValue.value) {
                                    scope.options.attributeValue.displayValue = Mustache.render(scope.options.labels.displayOtherChoice, scope.options.attributeValue);
                                }
                                info.push(scope.options.attributeValue);
                            }
                        }
                    } else {
                        _.each(scope.options.attributeValue, function wEnumAddOtherInUri(singleValue) {
                            var hasValue = _.some(info, function wEnumVerifyValue(singleInfo) {
                                return singleInfo.value === singleValue.value;
                            });
                            if (!hasValue) {
                                info.push(singleValue);
                            }
                        });
                    }

                    // notify the data source that the request succeeded
                    options.success(info);
                },
                error: function wEnum_onAutoCompleteError(result) {
                    // notify the data source that the request failed
                    options.error(result);
                }
            });
        },
        /**
         * Get kendo option from normal options and from renderOptions.kendoNumeric
         * @returns {*}
         */
        getKendoOptions: function wEnumGetKendoOptions() {
            var scope = this,
                source = null,
                kendoOptions = {},
                defaultOptions = {};

            if (this._isMultiple()) {

                source = this.getMultipleEnumData();

                defaultOptions = {
                    dataTextField: "displayValue",
                    dataValueField: "value",
                    clearButton: false,
                    dataSource: this.options.renderOptions.useSourceUri ? source.data : new kendo.data.DataSource({
                        data: source.data,
                        schema: { model: { id: "value" } }
                    }),
                    placeholder: this.options.renderOptions.placeHolder,
                    value: source.selectedValues,

                    change: function wEnum_onChange(event) {
                        event.preventDefault(); // no fire change event
                        // set in case of delete item

                        var kdData = _.toArray(scope.kendoWidget.data("kendoMultiSelect").dataItems());
                        var newValues = [];
                        _.each(kdData, function wEnum_pushNewValues(val) {
                            newValues.push({
                                value: val.value,
                                displayValue: val.displayValue,
                                exists: val.exists !== false
                            });
                        });
                        scope.setValue(newValues, event);
                    },
                    open: function wEnum_open(event) {
                        _.bind(scope._kOpen, scope, event, this)();
                    },
                    /**
                     * When other input is in list do not autoclose list to enter a new value
                     * @param event
                     */
                    close: function wEnum_multipleClose(event) {
                        _.bind(scope._kClose, scope, event, this)();
                    }
                };

                if (_.isObject(scope.options.renderOptions.kendoMultiSelectConfiguration)) {
                    kendoOptions = scope.options.renderOptions.kendoMultiSelectConfiguration;
                }
            } else {
                source = this.getSingleEnumData();

                defaultOptions = {
                    /*valuePrimitive: true,*/
                    dataTextField: "displayValue",
                    dataValueField: "value",
                    clearButton: false,
                    optionLabel: {
                        displayValue: this.options.renderOptions.placeHolder + ' ',
                        value: '',
                        exists: true
                    },
                    optionLabelTemplate: '<span class="placeholder">#: displayValue #</span>',
                    dataSource: this.options.renderOptions.useSourceUri ? source.data : new kendo.data.DataSource({
                        data: source.data,
                        schema: { model: { id: "value" } }
                    }),
                    index: source.index < 0 ? undefined : source.index,
                    autoBind: false,

                    change: function wEnum_onChange(event) {
                        if (this.value() && this.selectedIndex === -1) {
                            scope.setError(scope.options.labels.invalidEntry);
                            scope._getFocusInput().each(function wEnum_onChange() {
                                this.focus();
                            });
                        } else {
                            scope.setError(null);

                            var newValue = { value: this.value(), displayValue: this.text() };
                            scope.setValue(newValue, event);
                        }
                    },
                    dataBound: function wEnum_dataBound() {
                        if (scope.options.renderOptions.useFirstChoice && scope.options.attributeValue.value === null) {
                            // Set to first enum item if empty
                            var firstItem = this.dataSource.at(0);
                            if (firstItem) {
                                scope.setValue({ value: firstItem.value, displayValue: firstItem.displayValue });
                            }
                        }
                    },
                    open: function wEnum_open(event) {
                        _.bind(scope._kOpen, scope, event, this)();
                    },
                    /**
                     * When other input is in list do not autoclose list to enter a new value
                     * @param event
                     */
                    close: function wEnum_close(event) {
                        _.bind(scope._kClose, scope, event, this)();
                    }
                };

                if (this.options.renderOptions.editDisplay === "autoCompletion") {

                    defaultOptions.index = -1;
                    defaultOptions.value = this.options.attributeValue.value;
                    defaultOptions.placeholder = this.options.renderOptions.placeHolder;

                    if (_.isObject(scope.options.renderOptions.kendoComboBoxConfiguration)) {
                        kendoOptions = scope.options.renderOptions.kendoComboBoxConfiguration;
                    }
                } else {

                    if (_.isObject(scope.options.renderOptions.kendoDropDownConfiguration)) {
                        kendoOptions = scope.options.renderOptions.kendoDropDownConfiguration;
                    }
                }
            }

            if (scope.options.renderOptions.useOtherChoice === true) {
                // add "other" input in header list
                defaultOptions.headerTemplate = $('<div><div class="dcpAttribute__value--enum-other"><div class="input-group dcpAttribute__value--enum-other-content">' + '<input class="form-control" type="text" placeholder="' + scope.options.labels.chooseAnotherChoice + '"/>' + '<span class="input-group-btn"><button class="btn btn-primary dcpAttribute__value--enum-other-select">' + scope.options.labels.selectAnotherChoice + '</button></span> ' + '</div></div></div>').html();
            }

            if (this.options.renderOptions.useSourceUri) {
                defaultOptions.dataSource = {
                    data: source.data,
                    index: source.index,
                    // type: "json",
                    serverFiltering: true,
                    minLength: 0,
                    transport: {
                        read: _.bind(scope.autocompleteRequestEnum, scope)
                    }
                };
            }
            return _.extend(defaultOptions, kendoOptions);
        },

        _kSelectOther: function wEnumkSelect(event, kWidget, newValue) {
            kWidget.dataSource.filter({});
            if (this._isMultiple()) {
                var kdData = _.toArray(kWidget.dataItems());
                var newValues = [];

                _.each(kdData, function wEnum_pushNewValues(val) {
                    newValues.push({
                        value: val.value,
                        displayValue: val.displayValue,
                        exists: val.exists
                    });
                });

                newValues.push({
                    value: newValue,
                    exists: false,
                    displayValue: Mustache.render(this.options.labels.displayOtherChoice, { value: newValue })
                });

                this.setValue(newValues, event);
            } else {
                this.setValue({
                    value: newValue,
                    exists: false,
                    displayValue: Mustache.render(this.options.labels.displayOtherChoice, { value: newValue })
                }, event);
            }

            $(".dcpAttribute__value--enum-other input").blur();
            kWidget.close();
        },

        /**
         * When other input is in list do not autoclose list to enter a new value
         * @param event
         * @param kWidget kendo widget
         */
        _kClose: function wEnumkClose(event, kWidget) {
            if (this.options.renderOptions.useOtherChoice === true) {
                var $otherInput = kWidget.ul.closest(".k-list-container").find(".dcpAttribute__value--enum-other");
                if ($otherInput.data("dcpEnumOtherFirstClose") !== false || $otherInput.find("input").is(":focus")) {
                    event.preventDefault();
                    $otherInput.data("dcpEnumOtherFirstClose", false);
                }
            }
        },

        _kOpen: function wEnumkOpen(event, kWidget) {
            var scope = this;
            /**
             * Special events for "other" choice input
             */
            if (this.options.renderOptions.useOtherChoice === true) {
                var $container = kWidget.ul.closest(".k-list-container");
                var $otherInput = $container.find(".dcpAttribute__value--enum-other");

                if ($otherInput.length === 1 && $otherInput.data("dcpEnumOtherInitialized") !== true) {
                    $otherInput.data("dcpEnumOtherInitialized", true);
                    $otherInput.find(".dcpAttribute__value--enum-other-select").prop("disabled", true);
                    $container.prepend($otherInput);

                    $otherInput.on("click" + this.eventNamespace, "input",
                    /**
                     * Apply setValue and close list when confirm button is clicked
                     * @param event
                     */
                    function wEnumSetOtherClick(event) {
                        event.preventDefault();
                        $(this).focus();
                        $(this).data("dcpEnumOtherHasFocus", true);
                    });
                    $container.on("click" + this.eventNamespace, "li.k-item",
                    /**
                     * Force close for "normal" choice because autoclose is disabled
                     */
                    function wEnumItemClick() {
                        var $input = $container.find(".dcpAttribute__value--enum-other input");
                        $input.blur();
                        kWidget.close();
                    });

                    $otherInput.on("keyup" + this.eventNamespace, "input",
                    /**
                     * Apply setValue and close list when return key is pressed
                     * @param event
                     */
                    function wEnumSetOtherKeyPress(event) {
                        var code = event.keyCode ? event.keyCode : event.which;
                        var $input = $container.find(".dcpAttribute__value--enum-other input");
                        var newValue = $input.val();
                        if (code === 13 || code === 10) {
                            if (newValue) {
                                _.bind(scope._kSelectOther, scope, event, kWidget, newValue)();
                            }
                        } else {
                            kWidget.search(newValue);
                        }
                        $otherInput.find(".dcpAttribute__value--enum-other-select").prop("disabled", !newValue);
                    });

                    $otherInput.on("click" + this.eventNamespace, ".dcpAttribute__value--enum-other-select", function wEnumSetOtherClick(event) {
                        var $input = $container.find(".dcpAttribute__value--enum-other input");
                        var newValue = $input.val();
                        if (newValue) {
                            _.bind(scope._kSelectOther, scope, event, kWidget, newValue)();
                        }
                    });
                }

                $container.find(".dcpAttribute__value--enum-other").data("dcpEnumOtherFirstClose", true);
            }
        },

        close: function wEnum_close() {
            if (this.kendoWidget && this.kendoWidget.data("kendoDropDownList")) {
                this.kendoWidget.data("kendoDropDownList").close();
            }
            if (this.kendoWidget && this.kendoWidget.data("kendoComboBox")) {
                this.kendoWidget.data("kendoComboBox").close();
            }
            if (this.kendoWidget && this.kendoWidget.data("kendoMultiSelect")) {
                this.kendoWidget.data("kendoMultiSelect").close();
            }
            return this._super();
        },

        getType: function wEnum_getType() {
            return "enum";
        },

        _destroy: function wEnum_destroy() {
            if (this.kendoWidget && this.kendoWidget.data("kendoDropDownList")) {
                this.kendoWidget.data("kendoDropDownList").destroy();
            }
            if (this.kendoWidget && this.kendoWidget.data("kendoComboBox")) {
                this.kendoWidget.data("kendoComboBox").destroy();
            }
            if (this.kendoWidget && this.kendoWidget.data("kendoMultiSelect")) {
                this.kendoWidget.data("kendoMultiSelect").destroy();
            }
            this._super();
        }

    });

    return $.fn.dcpEnum;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/attributes/file/wFile.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/text/wText.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //noinspection JSUnresolvedVariable
        factory(window.jQuery, window._, window.Mustache);
    }
})(window, function wFileWidget($, _, Mustache) {
    'use strict';

    //noinspection JSUnusedLocalSymbols

    $.widget("dcp.dcpFile", $.dcp.dcpText, {

        uploadingFiles: 0, // file upload in progress
        options: {
            type: "file",
            renderOptions: {
                contentDisposition: false,
                htmlLink: {},
                placeHolder: "Click to upload file"
            },
            labels: {
                dropFileHere: "Drop file here",
                tooltipLabel: "Choose file",
                downloadLabel: "Download file",
                recording: "Recording",
                transferring: "Transferring",
                kiloByte: "kB",
                byte: "B"
            }
        },

        _initDom: function wFileInitDom() {
            var visibleInput;
            if (this.getMode() === "read") {
                var urlSep = '?';
                if (this.options.attributeValue.url) {
                    if (!this.options.renderOptions.htmlLink.url) {
                        if (this.options.attributeValue.url) {
                            urlSep = this.options.attributeValue.url.indexOf('?') >= 0 ? "&" : "?";
                            if (this.options.renderOptions.contentDisposition === "inline") {
                                this.options.attributeValue.url = this.options.attributeValue.url.replace('&inline=no', '');
                                this.options.attributeValue.url += urlSep + 'inline=yes';
                            } else {
                                this.options.attributeValue.url = this.options.attributeValue.url.replace('&inline=yes', '');
                                this.options.attributeValue.url += urlSep + 'inline=no';
                            }
                        }
                        this.options.renderOptions.htmlLink.url = this.options.attributeValue.url;

                        if (!this.options.renderOptions.htmlLink.title) {
                            this.options.renderOptions.htmlLink.title = this.options.attributeValue.displayValue;
                            if (this.options.attributeValue.size >= 1024) {
                                this.options.renderOptions.htmlLink.title += '<br/>(' + Math.round(this.options.attributeValue.size / 1024) + ' ' + this.options.labels.kiloByte + ')';
                            } else {
                                this.options.renderOptions.htmlLink.title += '<br/>(' + this.options.attributeValue.size + ' ' + this.options.labels.byte + ')';
                            }
                        }
                    }
                }
            }
            if (this.options.renderOptions.mimeIconSize) {
                if (["0", "0x0", "x0"].indexOf(this.options.renderOptions.mimeIconSize) !== -1) {
                    this.options.attributeValue.icon = null;
                } else {
                    var reSize = /sizes\/([^\/]+)/;
                    this.options.attributeValue.icon = this.options.attributeValue.icon.replace(reSize, "sizes/" + this.options.renderOptions.mimeIconSize);
                }
            }
            this._super();
            if (this.getMode() === "write") {
                visibleInput = this.element.find("input[type=text]");
                visibleInput.attr("title", this.options.labels.tooltipLabel);
                visibleInput.attr("placeholder", this.options.renderOptions.placeHolder);
                this.element.find(".dcpAttribute__content__button--file").attr("title", this.options.labels.downloadLabel);

                visibleInput.tooltip({
                    trigger: "hover",
                    placement: "bottom",
                    container: ".dcpDocument"
                });
                this.element.find("input[type=file]").attr("fileValue", this.options.attributeValue.value || null);
            }
        },

        _initEvent: function wFileInitEvent() {
            var currentWidget = this;
            if (this.getMode() === "write") {
                this._initUploadEvent();
            }

            // Add trigger when try to download file
            this.element.on("click." + this.eventNamespace, '.dcpAttribute__content__link', function wFileClickDownload(event) {
                currentWidget._trigger("downloadFile", event, {
                    $el: currentWidget.element,
                    index: currentWidget._getIndex()
                });
            });

            this._super();
        },

        _initChangeEvent: function wFileInitChangeEvent() {
            // set by widget if no autocomplete
            if (this.options.hasAutocomplete) {
                this._super();
            }
        },

        _initUploadEvent: function wFileInitUploadEvent() {
            var currentWidget = this;
            var inputFile = this.element.find("input[type=file]");
            var inputText = this.element.find(".dcpAttribute__value");
            var fileUrl = this.options.attributeValue.url;

            if (fileUrl) {
                this.element.on("click" + this.eventNamespace, ".dcpAttribute__content__button--file", function wFileOnButtonClickr(event) {
                    var isNotPrevented = currentWidget._trigger("downloadFile", event, {
                        $el: currentWidget.element,
                        index: currentWidget._getIndex()
                    });
                    if (isNotPrevented) {
                        var url = fileUrl,
                            $base = $("base");

                        if (isNotPrevented) {
                            if ($base.length > 0) {
                                // For IE : Not honor base href in this case
                                url = $base.attr("href") + url;
                            }
                            window.open(url);
                        }
                    }
                });
            } else {
                this.element.find(".dcpAttribute__content__button--file").attr("disabled", "disabled");
            }

            if (!_.isUndefined(window.FormData)) {
                this.element.on("dragenter" + this.eventNamespace, ".dcpAttribute__dragTarget", function wFileOnDragEnter(event) {
                    inputText.val(currentWidget.options.attributeValue.displayValue);
                    event.stopPropagation();
                    event.preventDefault();
                });
                this.element.on("dragover" + this.eventNamespace, ".dcpAttribute__dragTarget", function wFileOnDragOver(event) {
                    inputText.val(currentWidget.options.labels.dropFileHere);
                    event.stopPropagation();
                    event.preventDefault();
                    currentWidget.element.addClass("dcpAttribute__value--dropzone");
                });
                this.element.on("dragleave" + this.eventNamespace, ".dcpAttribute__dragTarget", function wFileOnLeave(event) {
                    inputText.val(currentWidget.options.attributeValue.displayValue);
                    event.stopPropagation();
                    event.preventDefault();
                    currentWidget.element.removeClass("dcpAttribute__value--dropzone");
                });

                this.element.on("drop" + this.eventNamespace, ".dcpAttribute__dragTarget", function wFileOnDrop(event) {
                    inputText.val(currentWidget.options.attributeValue.displayValue);
                    currentWidget.element.removeClass("dcpAttribute__value--dropzone");
                    event.stopPropagation();
                    event.preventDefault();

                    var dt = event.originalEvent.dataTransfer;
                    var files = dt.files;
                    if (files.length > 0) {
                        currentWidget.uploadFile(files[0]);
                    }
                });

                this.element.on("click" + this.eventNamespace, ".dcpAttribute__value", function wFileOnClick() {
                    inputFile.trigger("click");
                });

                this.element.on("keydown" + this.eventNamespace, ".dcpAttribute__value", function wFileFilterKeys(event) {
                    if (event.keyCode !== 9 && event.keyCode !== 32 && event.keyCode !== 13) {
                        event.preventDefault();
                    }
                });
                this.element.on("keyup" + this.eventNamespace, ".dcpAttribute__value", function wFileSelectKeys(event) {
                    if (event.keyCode !== 9) {
                        event.preventDefault();
                        if (event.keyCode === 32 || event.keyCode === 13) {
                            inputFile.trigger("click");
                        }
                    }
                });

                this.element.on("change" + this.eventNamespace, "input[type=file]", function wFileChange() /*event*/{
                    if (this.files && this.files.length > 0) {
                        currentWidget.uploadFile(this.files[0]);
                    }
                });
            } else {
                this.addOldBrowserForm();

                this.element.on("change" + this.eventNamespace, "input[type=file]", function wFileChangeOld() /*event*/{
                    currentWidget.uploadFileForm();
                });
            }
        },

        getWidgetValue: function wFilegetWidgetValue() {
            var $inputFile = this.element.find("input[type=file]");
            return $inputFile.attr("fileValue") || null;
        },

        /**
         * Add real form and iframe for browsers without FormData
         */
        addOldBrowserForm: function wFileAddOldBrowserForm() {
            var inputFile = this.element.find("input[type=file]");
            var inputText = this.element.find(".dcpAttribute__value");
            var inputId = inputFile.attr("id");
            var fileTarget = "fileupload" + inputId + '-' + this.options.index;
            var originalText = inputText.val();
            var scope = this;
            var formHtml = '<form id="form{{id}}" target="{{target}}" method="POST" enctype="multipart/form-data" action="api/v1/temporaryFiles/?alt=html">' + '</form><iframe style="display:none" name="{{target}}"></iframe>';
            $(Mustache.render(formHtml || "", { id: inputId, target: fileTarget })).insertAfter(inputFile);

            var container = '<div class="dcpFile__form"/>';

            $(container).insertAfter(inputText).append(inputText);

            this.element.find("form").append(inputFile).css("display", "inline");

            this.element.find(".dcpFile__form").append(this.element.find("form"));

            inputFile.show();
            this.element.addClass("dcpFile--old-browser");

            inputFile.attr("title", inputText.attr("data-original-title"));
            inputFile.tooltip({
                trigger: "hover",
                placement: "bottom",
                container: ".dcpDocument"
            });
            this.element.find("iframe").on("load", function wFileLoad() {
                if ($(this).contents().find("textarea").length === 0) {
                    // fake load when insert iframe
                    return;
                }
                var response = JSON.parse($(this).contents().find("textarea").val());

                if (response.exceptionMessage) {
                    _.each(response.messages, function wFileMessages(errorMessage) {

                        $('body').trigger("notification", {
                            htmlMessage: errorMessage.contentHtml,
                            message: errorMessage.contentText,

                            type: errorMessage.type
                        });
                    });
                } else {
                    var dataFile = response.data.file;
                    scope.setValue({
                        value: dataFile.reference,
                        size: dataFile.size,
                        fileName: dataFile.fileName,
                        displayValue: dataFile.fileName,
                        creationDate: dataFile.cdate,
                        thumbnail: dataFile.thumbnailUrl,
                        url: dataFile.downloadUrl,
                        icon: dataFile.iconUrl
                    });
                }

                inputText.val(originalText);
                inputText.removeClass("dcpAttribute__value--transferring");
                scope._setVisibilitySavingMenu("visible");
            });
        },

        /**
         * Condition before upload file
         * @param file
         * @returns {boolean}
         */
        uploadCondition: function wFileUploadCondition(file) {
            return true;
        },

        uploadFileForm: function wFileUploadFileForm() {
            var inputText = this.element.find(".dcpAttribute__value");

            var inputFile = this.element.find("input[type=file]");
            this._setVisibilitySavingMenu("disabled");

            inputText.addClass("dcpAttribute__value--transferring");
            inputText.val(this.options.labels.transferring + ' ' + inputFile.val().split(/[\\/]/).pop());
            this.element.find("form").submit();
        },

        uploadFile: function wFileUploadFile(firstFile) {
            var inputText = this.element.find(".dcpAttribute__value");
            var formData = new FormData();
            var newFileName = firstFile.name;
            var originalText = inputText.val();
            var originalBgColor = inputText.css("background-color");
            var currentWidget = this;
            var event = { prevent: false };
            var currentFileValue = this.options.attributeValue;
            var $inputFile = this.element.find("input[type=file]");

            if (!this.uploadCondition(firstFile)) {
                return;
            }

            var isNotPrevented = currentWidget._trigger("uploadfile", event, {
                $el: currentWidget.element,
                index: currentWidget._getIndex(),
                file: firstFile
            });
            if (!isNotPrevented) {
                return;
            }
            //currentWidget.setValue(currentFileValue);
            currentWidget.uploadingFiles++;
            formData.append('dcpFile', firstFile);
            $inputFile.prop("disabled", true);

            inputText.addClass("dcpAttribute__value--transferring");
            var infoBgColor = inputText.css("background-color");
            $.ajax({
                type: 'POST',
                url: "api/v1/temporaryFiles/",
                processData: false,
                contentType: false,
                cache: false,
                data: formData,

                xhr: function wFileXhrAddProgress() {
                    var xhrObject = $.ajaxSettings.xhr();
                    if (xhrObject.upload) {
                        xhrObject.upload.addEventListener('progress', function wFileProgress(event) {
                            var percent = 0;
                            var position = event.loaded || event.position;
                            var total = event.total;
                            if (event.lengthComputable) {
                                percent = Math.ceil(position / total * 100);
                            }
                            if (percent >= 100) {
                                inputText.val(currentWidget.options.labels.recording + ' ' + newFileName);
                                inputText.removeClass("dcpAttribute__value--transferring");
                                inputText.addClass("dcpAttribute__value--recording progress-bar active progress-bar-striped");
                                inputText.css("background", "");
                                inputText.css("background-image", "");
                            } else {
                                inputText.addClass("dcpAttribute__value--transferring");
                                inputText.val(currentWidget.options.labels.transferring + ' ' + newFileName);
                                inputText.css("background-color", "red");
                                inputText.css("background", "linear-gradient(to right," + infoBgColor + " 0%," + infoBgColor + " " + percent + "%," + originalBgColor + (percent + 1) + "%," + originalBgColor + " 100%) ");
                            }
                        }, false);
                    }
                    return xhrObject;
                }

            }).done(function wFileUploadDone(data) {
                var dataFile = data.data.file;
                var event = { prevent: false };
                var fileValue = {
                    value: dataFile.reference,
                    size: dataFile.size,
                    fileName: dataFile.fileName,
                    displayValue: dataFile.fileName,
                    creationDate: dataFile.cdate,
                    thumbnail: dataFile.thumbnailUrl,
                    url: dataFile.downloadUrl,
                    icon: dataFile.iconUrl
                };

                currentWidget.uploadingFiles--;

                currentWidget.setValue(fileValue);
                currentWidget._trigger("uploadfiledone", event, {
                    $el: currentWidget.element,
                    index: currentWidget._getIndex(),
                    file: fileValue
                });
            }).fail(function wFileUploadFail(data) {
                currentWidget.uploadingFiles--;
                currentWidget._trigger("uploadfiledone", event, {
                    $el: currentWidget.element,
                    index: currentWidget._getIndex(),
                    file: null
                });
                inputText.css("background-image", "url(" + currentWidget.options.attributeValue.icon + ')');
                var result = JSON.parse(data.responseText);
                if (result) {
                    _.each(result.messages, function wFileErrorMessages(errorMessage) {

                        $('body').trigger("notification", {
                            htmlMessage: errorMessage.contentHtml,
                            message: errorMessage.contentText,

                            type: errorMessage.type
                        });
                    });
                } else {
                    inputText.css("background", "");
                    $('body').trigger("notification", {
                        htmlMessage: 'File <b>' + firstFile.name + '</b> cannot be uploaded',
                        message: event.statusText,
                        type: "error"
                    });
                }
            }).always(function wFileUploadEnd() {
                $inputFile.prop("disabled", false);
                inputText.val(originalText);
                inputText.css("background", "");
                inputText.removeClass("progress-bar active progress-bar-striped dcpAttribute__value--transferring dcpAttribute__value--recording");
            });
        },

        /**
         * Modify value to widget and send notification to the view
         * @param value
         */
        setValue: function wFileSetValue(value) {
            var $inputFile = this.element.find("input[type=file]");
            // call wAttribute:::setValue() :send notification
            this._super(value);

            if (this.getMode() === "write" && this.uploadingFiles === 0) {
                this.redraw();
            }

            $inputFile.attr("fileValue", value ? value.value : null);
        },

        /**
         * Return the url of common link
         * @returns {*}
         */
        getLink: function wFileGetLink() {
            var link = this._super();
            if (this.options.attributeValue.url && (!link || !link.url)) {
                link.url = this.options.attributeValue.url;
            }

            return link;
        },

        getType: function wFileGetType() {
            return "file";
        }

    });

    return $.fn.dcpFile;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/attributes/htmltext/wHtmltext.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define, _super*/
(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/text/wText.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //noinspection JSUnresolvedVariable
        factory(window.jQuery, window._);
    }
})(window, function require_htmltext($, _) {
    'use strict';

    $.widget("dcp.dcpHtmltext", $.dcp.dcpText, {

        options: {
            type: "htmltext",
            renderOptions: {
                anchors: {
                    target: "_blank"
                },
                toolbar: 'Basic',
                height: '100px',
                toolbarStartupExpanded: true,
                ckEditorConfiguration: {},
                ckEditorAllowAllTags: false
            },
            locale: "en"
        },

        ckEditorInstance: null,

        _initDom: function wHtmltext_InitDom() {
            var currentWidget = this,
                bind_super = _.bind(this._super, this),
                bindInitEvent = _.bind(this._initEvent, this);
            try {
                this.popupWindows = {};
                if (this.getMode() === "write") {
                    (function wHtmltext_umdRequire(factory) {
                        if (true) {
                            __webpack_require__.e/* require.ensure */("documentCkEditor").then((function () {
                                __webpack_require__("./webpack/ckeditor.js");
                                factory();
                            }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
                        } else {
                            //noinspection JSUnresolvedVariable
                            factory();
                        }
                    })(function wHtmltext_initEditDom() {
                        var options = _.extend(currentWidget.ckOptions(), currentWidget.options.renderOptions.ckEditorConfiguration);
                        bind_super();
                        if (currentWidget.options.renderOptions.ckEditorAllowAllTags) {
                            // Allow all HTML tags
                            options.allowedContent = {
                                $1: {
                                    // Use the ability to specify elements as an object.
                                    elements: window.CKEDITOR.dtd,
                                    attributes: true,
                                    styles: true,
                                    classes: true
                                }
                            };
                            options.disallowedContent = 'script; *[on*]';
                        }
                        currentWidget.ckEditorInstance = currentWidget.getContentElements().ckeditor(options).editor;
                        currentWidget.options.attributeValue.value = currentWidget.ckEditorInstance.getData();
                        bindInitEvent();
                    });
                } else {
                    bind_super();
                }
            } catch (e) {
                if (window.dcp.logger) {
                    window.dcp.logger(e);
                } else {
                    console.error(e);
                }
            }
        },

        /**
         * Define option set for ckEditor widget
         * @returns {{language: string, contentsCss: string[], removePlugins: string, toolbarCanCollapse: boolean, entities: boolean, filebrowserImageBrowseUrl: string, filebrowserImageUploadUrl: string, toolbar_Full: *[], toolbar_Default: *[], toolbar_Simple: *[], toolbar_Basic: *[], removeButtons: string}}
         */
        ckOptions: function wHtmlTextCkOptions() {
            var locale = this.options.locale;
            var hrefBase = $("head base").attr("href") || ""; // no use document.baseURI because get complete url if no base href defined
            if (this.options.renderOptions.toolbar) {
                this.options.renderOptions.ckEditorConfiguration.toolbar = this.options.renderOptions.toolbar;
            }
            if (this.options.renderOptions.height) {
                this.options.renderOptions.ckEditorConfiguration.height = this.options.renderOptions.height;
            }
            if (!_.isUndefined(this.options.renderOptions.toolbarStartupExpanded)) {
                this.options.renderOptions.ckEditorConfiguration.toolbarStartupExpanded = this.options.renderOptions.toolbarStartupExpanded;
            }
            return {
                language: locale.substring(0, 2),
                contentsCss: ['css/a4/document/ckeditor.css'],
                removePlugins: 'elementspath', // no see HTML path elements
                toolbarCanCollapse: true,
                entities: false, // no use HTML entities
                baseHref: hrefBase,
                filebrowserImageBrowseUrl: hrefBase + '?sole=Y&app=FDL&action=CKIMAGE',
                filebrowserImageUploadUrl: hrefBase + '?sole=Y&app=FDL&action=CKUPLOAD',
                toolbar_Full: [{
                    name: 'document',
                    items: ['Sourcedialog', '-', 'NewPage', 'DocProps', 'Preview', 'Print', '-', 'Templates']
                }, {
                    name: 'clipboard',
                    items: ['Cut', 'Copy', 'Paste', 'PasteText', 'PasteFromWord', '-', 'Undo', 'Redo']
                }, { name: 'editing', items: ['Find', 'Replace', '-', 'SelectAll', '-'] }, {
                    name: 'forms',
                    items: ['Form', 'Checkbox', 'Radio', 'TextField', 'Textarea', 'Select', 'Button', 'ImageButton', 'HiddenField']
                }, '/', {
                    name: 'basicstyles',
                    items: ['Bold', 'Italic', 'Underline', 'Strike', 'Subscript', 'Superscript', '-', 'RemoveFormat']
                }, {
                    name: 'paragraph',
                    items: ['NumberedList', 'BulletedList', '-', 'Outdent', 'Indent', '-', 'Blockquote', 'CreateDiv', '-', 'JustifyLeft', 'JustifyCenter', 'JustifyRight', 'JustifyBlock', '-', 'BidiLtr', 'BidiRtl']
                }, { name: 'links', items: ['Link', 'Unlink'] }, {
                    name: 'insert',
                    items: ['Image', 'Table', 'HorizontalRule', 'Smiley', 'SpecialChar', 'PageBreak', 'Iframe']
                }, '/', { name: 'styles', items: ['Styles', 'Format', 'Font', 'FontSize'] }, { name: 'colors', items: ['TextColor', 'BGColor'] }, { name: 'tools', items: ['Maximize', 'ShowBlocks', '-', 'About'] }],
                toolbar_Default: [{ name: 'document', items: ['Sourcedialog'] }, {
                    name: 'clipboard',
                    items: ['Cut', 'Copy', 'Paste', 'PasteText', 'PasteFromWord', '-', 'Undo', 'Redo']
                }, { name: 'editing', items: ['Find', 'Replace', '-', 'SelectAll'] }, {
                    name: 'basicstyles',
                    items: ['Bold', 'Italic', 'Underline', 'Strike', 'Subscript', 'Superscript', '-', 'RemoveFormat']
                }, {
                    name: 'paragraph',
                    items: ['NumberedList', 'BulletedList', '-', 'Outdent', 'Indent', '-', 'Blockquote', 'CreateDiv', '-', 'JustifyLeft', 'JustifyCenter', 'JustifyRight', 'JustifyBlock', '-', 'BidiLtr', 'BidiRtl']
                }, { name: 'links', items: ['Link', 'Unlink'] }, { name: 'insert', items: ['Image', 'Table', 'HorizontalRule', 'SpecialChar', 'PageBreak', 'Iframe'] }, { name: 'styles', items: ['Styles', 'Format', 'Font', 'FontSize'] }, { name: 'colors', items: ['TextColor', 'BGColor'] }, { name: 'tools', items: ['Maximize', 'ShowBlocks', '-', 'About'] }],
                toolbar_Simple: [{ name: 'document', items: [] }, { name: 'basicstyles', items: ['Bold', 'Italic', 'Underline', 'Strike', '-', 'RemoveFormat'] }, {
                    name: 'paragraph', items: ['NumberedList', 'BulletedList', '-', 'Outdent', 'Indent', '-', '-', 'JustifyLeft', 'JustifyCenter', 'JustifyRight', 'JustifyBlock']
                }, { name: 'links', items: ['Link', 'Unlink'] }, { name: 'insert', items: ['Image', 'Table', 'SpecialChar'] }, { name: 'styles', items: ['Format', 'FontSize'] }, { name: 'colors', items: ['TextColor', 'BGColor'] }, { name: 'tools', items: ['Maximize', 'Sourcedialog', '-', 'About'] }],
                toolbar_Basic: [{
                    name: 'links',
                    items: ['Bold', 'Italic', '-', 'NumberedList', 'BulletedList', '-', 'Link', 'Unlink', '-', 'Maximize', 'About']
                }],
                removeButtons: ""
            };
        },

        _initEvent: function _initEvent() {
            var currentWidget = this;
            this._super();
            if (this.ckEditorInstance) {
                this.ckEditorInstance.on("change", function wHtmltext_change() {
                    currentWidget.setValue({ value: this.getData() });
                });

                this.ckEditorInstance.on("focus", function wHtmltext_focus() {
                    var ktTarget = currentWidget.element.find(".input-group");
                    currentWidget.showInputTooltip(ktTarget);
                    currentWidget.element.find(".cke").addClass("k-state-focused");
                    currentWidget.element.closest(".dcpAttribute__content").addClass("dcpAttribute--focus");
                });

                this.ckEditorInstance.on("blur", function wHtmltext_blur() {
                    var ktTarget = currentWidget.element.find(".input-group");
                    currentWidget.hideInputTooltip(ktTarget);
                    currentWidget.element.find(".cke").removeClass("k-state-focused");
                    currentWidget.element.closest(".dcpAttribute__content").removeClass("dcpAttribute--focus");
                });

                this.ckEditorInstance.on("instanceReady", function wHtmltext_loaded() {
                    currentWidget._trigger("widgetReady");
                });

                this.element.on("postMoved" + this.eventNamespace, function wHtmlTextOnPostMoved(event, eventData) {
                    if (eventData && eventData.to === currentWidget.options.index) {
                        currentWidget.redraw();
                    }
                });
            }

            //If we are not in CKEDITOR mode, we take care of anchor and redirect it
            if (this.getMode() !== "write") {
                this.element.on("click." + this.eventNamespace, 'a:not([href^="#action/"]):not([data-action])', function wHtmlAnchorClick(event) {
                    var internalEvent = { prevent: false },
                        anchor = this,
                        $anchor = $(this),
                        isNotPrevented,
                        anchorsConfig,
                        anchorsTarget,
                        wFeature = '',
                        href,
                        dcpWindow;

                    if (event.stopPropagation) {
                        event.stopPropagation();
                    }
                    event.preventDefault();

                    anchorsConfig = _.extend({}, currentWidget.options.renderOptions.anchors);

                    isNotPrevented = currentWidget._trigger("anchorClick", internalEvent, {
                        $el: currentWidget.element,
                        index: currentWidget._getIndex(),
                        options: {
                            anchor: anchor,
                            anchorsConfig: anchorsConfig
                        }
                    });
                    if (isNotPrevented) {
                        var $base = $("base");
                        var isAbsUrl = new RegExp('^(?:[a-z]+:)?//', 'i');

                        anchorsTarget = anchorsConfig.target || "_blank";
                        href = anchor.href;

                        if ($anchor.attr("href") && $anchor.attr("href").substring(0, 1) === "#") {
                            href = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port : '') + (window.location.pathname ? window.location.pathname : '/') + (window.location.search ? window.location.search : '') + $anchor.attr("href");
                        }

                        switch (anchorsTarget) {
                            case "_dialog":
                                if (currentWidget.popupWindows[href]) {
                                    dcpWindow = currentWidget.popupWindows[href];
                                } else {
                                    dcpWindow = $('<div/>').appendTo('body').dcpWindow({
                                        width: anchorsConfig.windowWidth,
                                        height: anchorsConfig.windowHeight,
                                        modal: anchorsConfig.modal,
                                        content: href,
                                        iframe: true
                                    });

                                    currentWidget.popupWindows[href] = dcpWindow;
                                    dcpWindow.data('dcpWindow').kendoWindow().center();
                                }
                                dcpWindow.data('dcpWindow').open();
                                break;
                            case "_self":
                                // For IE : Not honor base href in this case
                                if (!isAbsUrl.test(href)) {
                                    window.location.href = $base.attr("href") + href;
                                } else {
                                    window.location.href = href;
                                }
                                break;
                            default:
                                if (anchorsConfig.windowWidth || anchorsConfig.windowHeight) {
                                    if (anchorsConfig.windowWidth) {
                                        wFeature += "width=" + parseInt(anchorsConfig.windowWidth, 10) + ",";
                                    }
                                    if (anchorsConfig.windowHeight) {
                                        wFeature += "height=" + parseInt(anchorsConfig.windowHeight, 10) + ",";
                                    }
                                    wFeature += "resizable=yes,scrollbars=yes";
                                }
                                if (!isAbsUrl.test(href)) {
                                    href = $base.attr("href") + href;
                                }
                                window.open(href, anchorsTarget, wFeature);
                                break;
                        }
                    }
                });
            }
        },
        /**
         * Define inputs for focus
         * @protected
         */
        _getFocusInput: function wHtmltext_getFocusInput() {
            return this.element;
        },
        /**
         * No use parent change
         */
        _initChangeEvent: function wHtmltext_initChangeEvent() {},

        getWidgetValue: function wHtmltext_getWidgetValue() {
            return this.getContentElements().val();
        },

        /**
         * Change the value of the widget
         * @param value
         */
        setValue: function wHtmltextSetValue(value) {
            value = _.clone(value);
            if (value.value === null) {
                // ckEditor restore original value if set to null
                value.value = '';
            }
            if (_.has(value, "value") && !_.has(value, "displayValue")) {
                value.displayValue = value.value;
            }
            if (this.getMode() === "write") {
                // Flash element only
                var originalValue = this.ckEditorInstance.getData();
                // : explicit lazy equal

                //noinspection JSHint
                if (originalValue.trim() != value.value.trim()) {

                    // Modify value only if different
                    this.getContentElements().val(value.value);
                    this.flashElement(this.element.find('iframe'));
                }
            } else if (this.getMode() === "read") {
                this.getContentElements().html(value.displayValue);
            } else {
                throw new Error("Attribute " + this.options.id + " unknown mode " + this.getMode());
            }

            // call wAttribute::setValue()
            $.dcp.dcpAttribute.prototype.setValue.call(this, value);
        },

        getType: function wHtmltext_getType() {
            return "htmltext";
        },

        _destroy: function wHtmlTextDestroy() {
            var currentWidget = this;
            if (this.ckEditorInstance && this.ckEditorInstance.destroy) {
                if (this.ckEditorInstance.status === "loaded" || this.ckEditorInstance.status === "ready") {
                    this.ckEditorInstance.destroy();
                    _.defer(function wHtmltext_deferDestroy() {
                        currentWidget._destroy();
                    });
                    return;
                } else if (this.ckEditorInstance.status === "unloaded") {
                    this.ckEditorInstance.on("loaded", function wHtmltext_loaded() {
                        currentWidget._destroy();
                    });
                    return;
                }
            }
            _.each(this.popupWindows, function wHtmltextDestroyPopup(pWindow) {
                pWindow.data('dcpWindow').destroy();
            });
            this._super();
        },

        /**
         * Trigger a ready event when widget is render
         */
        _triggerReady: function wAttributeReady() {
            if (this.getMode() !== "write") {
                this._super();
            }
        }

    });

    return $.fn.dcpHtmltext;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/attributes/image/wImage.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/file/wFile.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //noinspection JSUnresolvedVariable
        factory(window.jQuery, window.Mustache);
    }
})(window, function wImageWidget($, Mustache) {
    'use strict';

    $.widget("dcp.dcpImage", $.dcp.dcpFile, {

        options: {
            type: "image",
            labels: {
                dropFileHere: "Drop image here",
                placeHolder: "Click to upload an image",
                tooltipLabel: "Choose image",
                downloadLabel: "Download the image"
            },
            renderOptions: {
                thumbnailSize: "100x100"
            }
        },

        _initDom: function wImageInitDom() {
            if (this.getMode() === "read") {
                if (this.options.attributeValue.url) {
                    if (!this.options.renderOptions.htmlLink.url) {
                        if (this.options.renderOptions.thumbnailSize) {
                            var reSize = /sizes\/([^\/]+)/;
                            this.options.attributeValue.thumbnail = this.options.attributeValue.thumbnail.replace(reSize, "sizes/" + this.options.renderOptions.thumbnailSize) + ".png";
                        } else if (!this.options.renderOptions.thumbnailSize) {
                            this.options.attributeValue.thumbnail = this.options.attributeValue.url;
                        }
                    }
                }
            }
            if (this.options.attributeValue.thumbnail) {
                this.options.attributeValue.hash = this.options.attributeValue.creationDate.replace(/[ :-]/g, "");
                this.options.attributeValue.thumbnail += '?c=' + this.options.attributeValue.hash;
            }
            this._super();
        },

        _initEvent: function wFileInitEvent() {
            this._super();
            if (this.getMode() === "read") {
                this._initDisplayEvent();
            }
        },

        _initDisplayEvent: function wImageinitDisplayEvent() {
            var scope = this;
            var htmlLink = this.getLink();
            this.element.off("click");
            this.element.on("click" + this.eventNamespace, '.dcpAttribute__content__link', function wImageClick(event) {

                if (htmlLink.target === "_dialog") {
                    event.preventDefault();
                    var index = $(this).data("index");
                    var bdw = $('<div class="dcpImage-window"><img class="img-responsive" src="' + $(this).attr("href") + '"/></div>');
                    $('body').append(bdw);
                    // $(this).attr("href"),
                    var dw = bdw.kendoWindow({
                        title: scope.options.attributeValue.displayValue,
                        width: htmlLink.windowWidth,
                        height: htmlLink.windowHeight,
                        iframe: false,
                        actions: ["Maximize", "Close"]
                    });

                    dw.data("kendoWindow").center().open();
                }
            });
        },

        /**
         * Condition before upload file
         * @returns {boolean}
         */
        uploadCondition: function wImageUploadCondition(file) {
            if (file.type.substr(0, 5) !== "image") {
                this.setError("Invalid image file");
                return false;
            }
            this.setError(null);
            return true;
        },

        getType: function wImageGetType() {
            return "image";
        }

    });

    return $.fn.dcpImage;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/attributes/int/wInt.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/text/wText.js"), __webpack_require__("./node_modules/kendo-ui-core/js/cultures/kendo.culture.fr-FR.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //noinspection JSUnresolvedVariable
        factory(window.jQuery, window._, window.Mustache);
    }
})(window, function requireWint($, _, Mustache) {
    'use strict';

    $.widget("dcp.dcpInt", $.dcp.dcpText, {

        options: {
            type: "int",

            renderOptions: {
                kendoNumericConfiguration: {},
                max: null,
                min: null,
                numberFormat: 'n0'
            },
            labels: {
                decreaseLabel: "Decrease value",
                increaseLabel: "Increase value"
            }
        },
        /**
         * The kendoNumericTextBox widget instance
         */
        kendoWidget: null,

        _initDom: function wIntInitDom() {
            this.element.addClass("dcpAttribute__content");
            this.element.attr("data-type", this.getType());
            this.element.attr("data-attrid", this.options.id);
            if (parseFloat(this.options.attributeValue.displayValue) === parseFloat(this.options.attributeValue.value)) {
                this.options.attributeValue.displayValue = this.formatNumber(this.options.attributeValue.value);
            }

            if (this.getMode() === "read") {
                if (this.options.renderOptions.format) {
                    this.options.attributeValue.formatValue = Mustache.render(this.options.renderOptions.format || "", this.options.attributeValue);
                }
            }

            //noinspection JSPotentiallyInvalidConstructorUsage,JSAccessibilityCheck
            $.dcp.dcpAttribute.prototype._initDom.apply(this, []);

            this.kendoWidget = this.element.find(".dcpAttribute__value--edit");
            if (this.kendoWidget) {
                if (this.options.hasAutocomplete) {
                    this.activateAutocomplete(this.kendoWidget);
                } else {
                    this._activateNumber(this.kendoWidget);
                }
            }

            if (this.element.find(".dcpAttribute__content__buttons button").length === 0) {
                this.element.find(".k-numeric-wrap").addClass("dcpAttribute__content__nobutton");
            }
        },

        _initChangeEvent: function wIntInitChangeEvent() {
            // set by widget if no autocomplete
            if (this.options.hasAutocomplete) {
                this._super();
            }
        },

        setValue: function wIntSetValue(value) {
            // this._super.(value);
            // Don't call dcpText::setValue()

            value = _.clone(value);

            if (_.has(value, "value") && !_.has(value, "displayValue")) {
                value.displayValue = this.formatNumber(value.value);
            } else {
                if (parseFloat(value.displayValue) === parseFloat(value.value)) {
                    value.displayValue = this.formatNumber(value.value);
                }
            }

            //noinspection JSPotentiallyInvalidConstructorUsage
            $.dcp.dcpAttribute.prototype.setValue.apply(this, [value]);

            if (this.getMode() === "write") {
                var originalValue = this.kendoWidget.data("kendoNumericTextBox").value();
                // : explicit lazy equal
                //noinspection JSHint
                if (originalValue != value.value) {
                    this.kendoWidget.data("kendoNumericTextBox").value(value.value);
                    // Modify value only if different
                    this.flashElement();
                }
            } else {
                if (this.getMode() === "read") {
                    this.getContentElements().text(value.displayValue);
                } else {
                    throw new Error("Attribute " + this.options.id + " unkown mode " + this.getMode());
                }
            }
        },

        _activateNumber: function wIntActivateNumber(inputValue) {
            var kendoWidget,
                currentCSSClass = inputValue.attr("class");
            inputValue.removeClass(currentCSSClass);
            //force display inline-block for work with kendo
            inputValue.css("display", "inline-block");
            kendoWidget = inputValue.kendoNumericTextBox(this.getKendoNumericOptions());
            kendoWidget.closest(".k-widget").addClass(currentCSSClass);
            return kendoWidget;
        },

        formatNumber: function wIntFormatNumber(value) {
            try {
                value = kendo.toString(value, this.getKendoNumericOptions().format);
            } catch (e) {
                if (window.dcp.logger) {
                    window.dcp.logger(e);
                } else {
                    console.error(e);
                }
                console.error("Unable to format the number " + e);
            }
            return value;
        },

        /**
         * Get kendo option from normal options and from renderOptions.kendoNumeric
         * @returns {*}
         */
        getKendoNumericOptions: function wIntGetKendoNumericOptions() {
            var scope = this,
                kendoOptions = {},
                defaultOptions = {
                decimals: 0,
                downArrowText: scope.options.labels.decreaseLabel,
                upArrowText: scope.options.labels.increaseLabel,
                format: scope.options.renderOptions.numberFormat,
                max: scope.options.renderOptions.max,
                min: scope.options.renderOptions.min,
                change: function wIntGetKendoNumericOptions_onChange() {
                    // Need to set by widget to honor decimals option
                    scope.setValue({ value: this.value() });
                }
            };
            if (_.isObject(scope.options.renderOptions.kendoNumericConfiguration)) {
                kendoOptions = scope.options.renderOptions.kendoNumericConfiguration;
            }

            return _.extend(defaultOptions, kendoOptions);
        },

        getType: function wIntGetType() {
            return "int";
        },

        testValue: function wIntTestValue(value) {
            this._super(value);
            if (!_.isNumber(value.value)) {
                throw new Error("The value must be a number for (attrid : " + this.options.id + ")");
            }
        },

        _destroy: function _destroy() {
            if (this.kendoWidget && this.kendoWidget.data("kendoNumericTextBox")) {
                this.kendoWidget.data("kendoNumericTextBox").destroy();
            }
            this._super();
        }

    });

    return $.fn.dcpInt;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/attributes/label/wLabel.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/widget.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //noinspection JSUnresolvedVariable
        factory(window.jQuery, window._, window.Mustache);
    }
})(window, function requireDcpLabel($, _, Mustache) {
    'use strict';

    $.widget("dcp.dcpLabel", {
        options: {
            renderOptions: {
                helpLinkIdentifier: 0
            },
            labels: {
                helpTitle: "Info"
            }
        },
        _create: function wLabel_create() {
            this._initDom();
            this._initActionClickEvent();
        },

        _initDom: function wLabel_initDom() {
            this.element.addClass("dcpAttribute__label control-label dcpLabel");
            this.element.append(Mustache.render(this._getTemplate() || "", this.options));
            if (this.options.renderOptions && this.options.renderOptions.attributeLabel) {
                this.setLabel(this.options.renderOptions.attributeLabel);
            }
        },

        /**
         * Init event for #action/ links
         *
         * @protected
         */
        _initActionClickEvent: function wAttributeInitActionClickEvent() {
            var scopeWidget = this;

            this.element.on("click." + this.eventNamespace, 'a[href^="#action/"], a[data-action], button[data-action]', function wAttributeActionClick(event) {
                var $this = $(this),
                    action,
                    options,
                    eventOptions;

                event.preventDefault();
                if (event.stopPropagation) {
                    event.stopPropagation();
                }

                action = $this.data('action') || $this.attr("href");
                options = action.substring(8).split(":");
                eventOptions = {
                    target: event.target,
                    index: -1,
                    eventId: options.shift(),
                    options: options
                };

                scopeWidget._trigger("externalLinkSelected", event, eventOptions);
                return this;
            });
        },

        setLabel: function wLabelSetLabel(label) {
            this.element.find("label").text(label);
        },

        setError: function wLabelSetError(message) {
            if (message) {
                this.element.addClass("has-error");
            } else {
                this.element.removeClass("has-error");
            }
        },

        _getTemplate: function wLabel_getTemplate() {
            if (this.options.templates && this.options.templates.label) {
                return this.options.templates.label;
            }
            if (window.dcp && window.dcp.templates && window.dcp.templates.label) {
                return window.dcp.templates.label;
            }
            throw new Error("Unknown label template ");
        }
    });

    return $.fn.dcpLabel;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/attributes/longtext/wLongtext.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/text/wText.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //noinspection JSUnresolvedVariable
        factory(window.jQuery, window._);
    }
})(window, function requireDcpLongText($, _) {
    'use strict';

    $.widget("dcp.dcpLongtext", $.dcp.dcpText, {

        options: {
            type: "longtext",
            renderOptions: {
                displayedLineNumber: 5
            }
        },

        _initDom: function dcpLongtext_initDom() {
            var maxDisplayedLine = this.options.renderOptions.displayedLineNumber;

            this._super();
            this._maxLinesNumber(maxDisplayedLine);
        },

        _initEvent: function dcpLongtext_initEvent() {
            if (this.getMode() === "write") {
                this._initAutoFit();
            }
            this._super();
        },

        _maxLinesNumber: function dcpLongtext_maxLinesNumber(lineNumber) {
            lineNumber = parseInt(lineNumber, 10);
            if (lineNumber > 0) {
                var scope = this;
                _.defer(function dcpLongtext_deferComputeSize() {
                    var $element = scope.getContentElements();
                    var delta = parseFloat($element.css("padding-top")) + parseFloat($element.css("padding-bottom"));
                    var lineH = $element.css("line-height");
                    // In IE9 , the result is just a number without unit
                    if (lineH) {
                        if (lineH.indexOf("px") > 0) {
                            $element.css("max-height", lineNumber * parseFloat(lineH) + delta + "px");
                        } else {
                            $element.css("max-height", lineNumber * 1.1 + "em");
                        }
                    }
                });
            }
        },
        /**
         * Define inputs for focus
         * @protected
         */
        _getFocusInput: function dcpLongtext_getFocusInput() {
            return this.element.find('textarea[name="' + this.options.id + '"]');
        },

        _fitToContent: function dcpLongtext_fitToContent($element) {

            var delta = parseFloat($element.css("padding-top")) + parseFloat($element.css("padding-bottom")),
                element = $element.get(0),
                maxHeight = parseFloat($element.css("max-height"));
            if (element && element.scrollHeight > element.clientHeight) {

                $element.height(element.scrollHeight - delta + 1);
                if (maxHeight > 0) {
                    if (element.scrollHeight > maxHeight) {
                        $element.css("resize", "none");
                    } else {
                        $element.css("resize", "");
                    }
                }
            }
        },

        _initAutoFit: function dcpLongtext_initAutoFit() {
            var scope = this;
            _.defer(function dcpLongtext_computeSize() {
                scope._fitToContent(scope.getContentElements());
            });
            this.getContentElements().on("keyup" + this.eventNamespace, function dcpLongtext_keyUpUpdateSize(event) {
                scope._fitToContent($(this));
            }).on("focus" + this.eventNamespace, function dcpLongtext_focusUpdateSize(event) {
                scope._fitToContent($(this));
            });

            this.element.on("show" + this.eventNamespace, function dcpLongtext_showUpdateSize(event) {
                scope._fitToContent(scope.getContentElements());
            });
        },

        getType: function dcpLongtext_getType() {
            return "longtext";
        }

    });

    return $.fn.dcpLongtext;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/attributes/money/wMoney.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/double/wDouble.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //noinspection JSUnresolvedVariable
        factory(window.jQuery);
    }
})(window, function require_money($) {
    'use strict';

    $.widget("dcp.dcpMoney", $.dcp.dcpDouble, {

        options: {
            type: "money",
            renderOptions: {
                currency: '€',
                numberFormat: '#,#.00'
            }
        },

        /**
         * Get kendo option from normal options and from renderOptions.kendoNumeric
         * @returns {*}
         */
        getKendoNumericOptions: function wMoneyGetKendoNumericOptions() {
            var options = this._super(); // get from wDouble
            if (this.options.renderOptions.currency) {
                // view decimal precision
                switch (this.options.locale.substr(0, 2)) {
                    case 'en':
                    case 'ga':
                        // Ireland Irish
                        // currency before
                        options.format = this.options.renderOptions.currency.replace('$', '\\$') + options.format;
                        break;
                    default:
                        options.format += ' ' + this.options.renderOptions.currency.replace('$', '\\$');
                }
            }

            return options;
        },

        getType: function wMoneyGetType() {
            return "money";
        }

    });

    return $.fn.dcpMoney;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/attributes/password/wPassword.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/
(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/text/wText.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //noinspection JSUnresolvedVariable
        factory(window.jQuery);
    }
})(window, function wPassword($) {
    'use strict';

    $.widget("dcp.dcpPassword", $.dcp.dcpText, {

        options: {
            type: "password",

            renderOptions: {
                hideValue: '*****'
            },
            labels: {}
        },

        _initDom: function wasswordInitDom() {
            if (this.options.attributeValue.value) {
                this.options.attributeValue.displayValue = this.options.renderOptions.hideValue;
            }

            this._super();
            if (this.getMode() === "write") {
                this._getFocusInput().attr("type", "password");
            }
        },
        /**
         * Hide password to displayValue
         * @param value
         */
        setValue: function wpasswordSetValue(value) {
            if (value.value) {
                value.displayValue = this.options.renderOptions.hideValue;
            }

            this._super(value);
        },
        getType: function wIntGetType() {
            return "password";
        }
    });

    return $.fn.dcpPassword;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/attributes/text/wText.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/wAttribute.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //noinspection JSUnresolvedVariable
        factory(window.jQuery, window._, window.Mustache);
    }
})(window, function wText($, _, Mustache) {
    'use strict';

    $.widget("dcp.dcpText", $.dcp.dcpAttribute, {

        options: {
            type: "text",
            renderOptions: {
                maxLength: 0, // char max length
                placeHolder: '',
                format: "",
                kendoAutoCompleteConfiguration: {
                    filter: "contains",
                    minLength: 1,
                    template: '<div class="dcpAutocomplete"><span class="k-state-default">#= data.title#</span>' + '#if (data.message) {#' + '<div class="dcpAutocomplete--#= data.message.type#">#: data.message.contentText# #= data.message.contentHtml#</div>' + '#}# </div>'
                }
            }
        },

        kendoWidget: null,

        _initDom: function wTextInitDom() {
            if (this.getMode() === "read") {
                if (this.options.renderOptions.format) {
                    this.options.attributeValue.formatValue = Mustache.render(this.options.renderOptions.format || "", this.options.attributeValue);
                }
            }

            this._super();
            this.kendoWidget = this.element.find(".dcpAttribute__value--edit");
            if (this.kendoWidget && this.options.hasAutocomplete) {
                this.activateAutocomplete(this.kendoWidget);
            } else {
                if (this.getType() === "text") {
                    this.kendoWidget.addClass("k-textbox");
                }
            }
        },

        _initEvent: function wTextInitEvent() {
            if (this.getMode() === "write") {
                this._initChangeEvent();
            }
            this._super();
        },

        _initChangeEvent: function wTextInitChangeEvent() {
            var currentWidget = this;
            if (this.getMode() === "write") {
                this.getContentElements().on("change" + this.eventNamespace, function wTextChangeElement() {
                    var newValue = _.clone(currentWidget.options.attributeValue);
                    newValue.value = $(this).val();
                    newValue.displayValue = newValue.value;
                    currentWidget.setValue(newValue);
                });
            }
        },

        /**
         * Just to be apply in normal input help
         * @param inputValue
         */
        activateAutocomplete: function activateAutocomplete(inputValue) {
            var currentWidget = this;
            var systemOption = {
                dataTextField: "title",
                dataSource: {
                    // type: "json",

                    serverFiltering: true,
                    transport: {
                        read: function mapAutoActivated(options) {
                            options.data.index = currentWidget._getIndex();
                            return currentWidget.options.autocompleteRequest.call(null, options);
                        }
                    }
                },
                filtering: function wTextFiltering(e) {
                    // space search is used to force new search
                    if (e.filter.value === " ") {
                        e.filter.value = '';
                    }
                },
                select: function kendoAutocompleteSelect(event) {
                    var valueIndex = currentWidget._getIndex();
                    var dataItem = this.dataSource.at(event.item.index());
                    //The object returned by dataSource.at are internal kendo object so I clean it with toJSON
                    if (dataItem.toJSON) {
                        dataItem = dataItem.toJSON();
                    }
                    event.preventDefault(); // no fire change event
                    currentWidget._trigger("changeattrsvalue", event, { dataItem: dataItem, valueIndex: valueIndex });
                }
            };

            inputValue.kendoAutoComplete(_.extend({}, this.options.renderOptions.kendoAutoCompleteConfiguration, systemOption));
            this.element.on("click" + this.eventNamespace, '.dcpAttribute__value--autocomplete--button', function wTextClickAutoComplete(event) {
                event.preventDefault();
                inputValue.data("kendoAutoComplete").search(' '); // use space search
            });
            this.element.find('.dcpAttribute__value--autocomplete--button[title]').tooltip({
                html: true,
                container: this.element
            }).each(function wTextInitLinkTooltip() {
                $(this).data("bs.tooltip").tip().addClass("dcpAttribute__autocomplete");
            });
        },

        /**
         * Modify value to widget and send notification to the view
         * @param value
         */
        setValue: function wTextSetValue(value) {

            var originalValue;

            value = _.clone(value);

            if (_.has(value, "value") && !_.has(value, "displayValue")) {
                value.displayValue = value.value;
            }
            this._super(value);

            originalValue = this.getWidgetValue();

            if (this.getMode() === "write") {
                // : explicit lazy equal
                if (value.value === null && originalValue === '') {
                    originalValue = null;
                }
                if (originalValue !== value.value) {
                    // Modify value only if different
                    this.getContentElements().val(value.value);
                    this.flashElement();
                }
            } else if (this.getMode() === "read") {
                this.redraw();
            } else {
                throw new Error("Attribute " + this.options.id + " unkown mode " + this.getMode());
            }
        },

        getType: function getType() {
            return "text";
        },

        _destroy: function _destroy() {
            //Destroy autocomplete if activated
            if (this.kendoWidget && this.kendoWidget.data("kendoAutoComplete")) {
                this.kendoWidget.data("kendoAutoComplete").destroy();
            }
            this._super();
        }

    });

    return $.fn.dcpText;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/attributes/time/wTime.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/date/wDate.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //noinspection JSUnresolvedVariable
        factory(window.jQuery, window._);
    }
})(window, function ($, _) {
    'use strict';

    $.widget("dcp.dcpTime", $.dcp.dcpDate, {

        options: {
            type: "time",
            renderOptions: {
                kendoTimeConfiguration: {
                    timeDataFormat: ["HH:mm", "HH:mm:ss"]
                }
            }
        },

        kendoWidgetClass: "kendoTimePicker",

        _initDom: function wTimeInitDom() {
            if (this.options.renderOptions.kendoTimeConfiguration.format) {
                this.options.attributeValue.displayValue = this.formatDate(this.parseDate(this.options.attributeValue.value));
            }
            this._super();
        },

        _activateDate: function wTimeActivateDate(inputValue) {
            var scope = this;
            var kOptions = this.getKendoOptions();

            kOptions.change = function () {
                // only valid date are setted
                // wrong date are set by blur event
                var isoDate = scope.convertDateToPseudoIsoString(this.value());
                // Need to set by widget to use raw date

                scope.setValue({ value: isoDate, displayValue: inputValue.val() });
            };
            inputValue.kendoTimePicker(kOptions);
            this._controlDate(inputValue);
            if (this.options.attributeValue && this.options.attributeValue.value) {
                this.setValue(this.options.attributeValue);
            }
        },

        setValue: function wTimeSetValue(value) {
            var originalValue;

            value = _.clone(value);

            if (_.has(value, "value") && !_.has(value, "displayValue")) {
                value.displayValue = this.formatDate(this.parseDate(value.value));
            }

            $.dcp.dcpAttribute.prototype.setValue.call(this, value);

            if (this.getMode() === "write") {
                originalValue = this.convertDateToPseudoIsoString(this.kendoWidget.data(this.kendoWidgetClass).value());
                // : explicit lazy equal
                //noinspection JSHint
                if (originalValue != value.value) {
                    if (value.value) {
                        this.kendoWidget.data(this.kendoWidgetClass).value(value.value);
                    } else {
                        this.getContentElements().val('');
                    }
                    // Modify value only if different
                    this.flashElement();
                }
            } else if (this.getMode() === "read") {
                this.getContentElements().text(value.displayValue);
            } else {
                throw new Error("Attribute " + this.options.id + " unkown mode " + this.getMode());
            }
        },

        getValue: function wTimeGetValue() {
            var value = this._super();
            if (value.value && _.isDate(value.value)) {
                value.value = this.convertDateToPseudoIsoString(value.value);
            }
            return value;
        },

        convertDateToPseudoIsoString: function wTimeConvertDateToPseudoIsoString(date) {
            if (_.isDate(date)) {
                return this.padNumber(date.getHours()) + ':' + this.padNumber(date.getMinutes());
            }
            return '';
        },

        formatDate: function wTimeFormatDate(value) {
            if (this.options.renderOptions.kendoTimeConfiguration.format) {
                return kendo.toString(value, this.options.renderOptions.kendoTimeConfiguration.format);
            }
            return kendo.toString(value, "T");
        },

        parseDate: function wTimeParseDate(value) {
            return kendo.parseDate(value, this.options.renderOptions.kendoTimeConfiguration.timeDataFormat);
        },

        /**
         * Get kendo option from normal options and from renderOptions.kendoNumeric
         * @returns {*}
         */
        getKendoOptions: function wTimegetKendoOptions() {
            var scope = this,
                kendoOptions = {},
                defaultOptions = {
                min: this.options.minDate
            };

            if (_.isObject(scope.options.renderOptions.kendoTimeConfiguration)) {
                kendoOptions = scope.options.renderOptions.kendoTimeConfiguration;
            }

            return _.extend(defaultOptions, kendoOptions);
        },

        getType: function getType() {
            return "time";
        }

    });

    return $.fn.dcpTime;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/attributes/timestamp/wTimestamp.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/attributes/date/wDate.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //noinspection JSUnresolvedVariable
        factory(window.jQuery);
    }
})(window, function requireTimestamp($) {
    'use strict';

    $.widget("dcp.dcpTimestamp", $.dcp.dcpDate, {

        options: {
            type: "timestamp",
            minDate: new Date(1700, 0, 1),
            renderOptions: {
                kendoDateConfiguration: {
                    timeFormat: "HH:mm", //24 hours format
                    parseFormats: ["yyyy-MM-dd HH:mm:ss", "yyyy-MM-ddTHH:mm:ss", "yyyy-MM-ddTHH:mm"],
                    format: null
                }
            }
        },

        kendoWidgetClass: "kendoDateTimePicker",

        _initDom: function wTimeStampInitDom() {
            if (this.options.attributeValue.value) {
                // Add T (iso date) if not set

                this.options.attributeValue.value = this.replaceAt(this.options.attributeValue.value, 10, 'T');
            }
            this._super();
        },

        replaceAt: function wTimeStampReplaceAt(s, n, t) {
            return s.substring(0, n) + t + s.substring(n + 1);
        },

        setValue: function wTimeStampSetValue(value) {
            if (value.value) {
                // Add T (iso date) if not set
                value.value = this.replaceAt(value.value, 10, 'T');
            }
            this._super(value);
        },

        _activateDate: function wTimeStamp_activateDate(inputValue) {
            var currentWidget = this;
            var kendoOptions = this.getKendoOptions();
            kendoOptions.change = function wTimeStamp_onChange() {
                if (this.value() !== null) {
                    // only valid date are setted
                    // wrong date are set by blur event
                    var isoDate = currentWidget.convertDateToPseudoIsoString(this.value());
                    // Need to set by widget to use raw date
                    currentWidget.setValue({ value: isoDate, displayValue: inputValue.val() });
                }
            };
            inputValue.kendoDateTimePicker(kendoOptions);

            this._controlDate(inputValue);
        },

        convertDateToPseudoIsoString: function wTimeStamp_convertDateToPseudoIsoString(dateObject) {
            if (dateObject && (typeof dateObject === 'undefined' ? 'undefined' : _typeof(dateObject)) === "object") {
                return dateObject.getFullYear() + '-' + this.padNumber(dateObject.getMonth() + 1) + '-' + this.padNumber(dateObject.getDate()) + 'T' + this.padNumber(dateObject.getHours()) + ':' + this.padNumber(dateObject.getMinutes()) + ':' + this.padNumber(dateObject.getSeconds());
            }
            return '';
        },

        formatDate: function wTimeStamp_formatDate(value) {
            if (this.options.renderOptions.kendoDateConfiguration.format) {
                return kendo.toString(value, this.options.renderOptions.kendoDateConfiguration.format);
            }
            return kendo.toString(value, "g");
        },

        getType: function wTimeStamp_getType() {
            return "timestamp";
        }

    });

    return $.fn.dcpTimestamp;
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/attributes/wAttribute.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/

(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/widget.js"), __webpack_require__("./node_modules/bootstrap/js/src/tooltip.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        //noinspection JSUnresolvedVariable
        factory(window.jQuery, window._, window.Mustache);
    }
})(window, function wAttributeWidget($, _, Mustache) {
    'use strict';

    $.widget("dcp.dcpAttribute", {

        options: {
            eventPrefix: "dcpAttribute",
            id: null,
            type: "abstract",
            mode: "read",
            index: -1,
            labels: {
                deleteAttributeNames: "",
                deleteLabel: "",
                closeErrorMessage: "Close message"
            },
            template: null,
            deleteButton: false,
            renderOptions: {
                displayDeleteButton: true
            },
            locale: "fr_FR"
        },

        /**
         * Redraw element with updated values
         */
        redraw: function wAttributeRedraw() {
            this.element.find("[aria-describedby*='tooltip']").tooltip("hide");
            this.element.empty();
            this._initDom();
            this.element.off(this.eventNamespace);
            this._initEvent();
            return this;
        },

        /**
         * Verify if a common link option is set
         *
         * @returns boolean
         */
        hasLink: function hasLink() {
            return Boolean(this.options.renderOptions && this.options.renderOptions.htmlLink && this.options.renderOptions.htmlLink.url);
        },
        /**
         * Return the url of link
         * @returns string
         */
        getLink: function wAttributeGetLink() {
            if (this.options.renderOptions && this.options.renderOptions.htmlLink) {
                return this.options.renderOptions.htmlLink;
            }
            return null;
        },

        /**
         * Flash the element to attract user attention
         *
         * @param currentElement
         */
        flashElement: function wAttributeFlashElement(currentElement) {
            if (!currentElement) {
                currentElement = this.element;
            }
            currentElement.addClass('dcpAttribute__value--flash');
            _.delay(function wAttributeFlashDelay() {
                currentElement.removeClass('dcpAttribute__value--flash').addClass('dcpAttribute__value--endflash');
                _.delay(function wAttributeFlashSecondDelay() {
                    currentElement.removeClass('dcpAttribute__value--endflash');
                }, 600);
            }, 10);
        },

        /**
         * Display tooltip an error message
         *
         * @param message string or array of [{message:, index:}, ...]
         */
        setError: function wAttributeSetError(message) {
            var kt;
            var scope = this;
            if (message) {
                var messages;
                if (!_.isArray(message)) {
                    messages = [{ message: message, index: -1 }];
                } else {
                    messages = _.toArray(message);
                }
                _.each(messages, function wAttributeSetErrorMsg(indexMessage) {
                    if (indexMessage.index === -1 || scope.element.closest('tr').data("line") === indexMessage.index) {
                        scope.element.addClass("has-error");
                        // need to use sub element because tooltip add a div after element
                        scope.element.find(".input-group").tooltip({
                            placement: "bottom",
                            html: true,
                            animation: false,
                            container: scope.element.parent(), //".dcpDocument",// no use scope.element because when item is in the bottom of the page a scrollbar can appear
                            title: function wAttributeSetErrorTitle() {
                                var rawMessage = $('<div/>').text(indexMessage.message).html();
                                return '<div>' + '<span title="' + scope.options.labels.closeErrorMessage + '" class="btn fa fa-times button-close-error">&nbsp;</span>' + rawMessage + '</div>';
                            },
                            trigger: "manual"
                        }).one("shown.bs.tooltip", function wErrorTooltip() {
                            var tipElement = $(this).data("bs.tooltip").tip;
                            if (tipElement) {
                                $(tipElement).addClass("has-error");
                            }
                        });
                        scope.element.data("hasErrorTooltip", true);
                        scope.element.find(".input-group").tooltip("show");
                        // Need to refresh to update position after possible change on element value
                        _.delay(function wAttributeSetErrorDelay() {
                            var $input = scope.element.find(".input-group");
                            //$input.tooltip("hide").tooltip("show");
                        }, 1);
                    }
                });
            } else {
                this.element.removeClass("has-error");
                if (this.element.data("hasErrorTooltip")) {
                    // No use destroy because the destruction is deferred
                    kt = this.element.find(".input-group");
                    kt.tooltip("hide").data("bs.tooltip", null);
                    this.element.data("hasErrorTooltip", false);
                }
            }
        },

        /**
         * Get the type of the widget
         *
         * @returns {string}
         */
        getType: function getType() {
            return this.options.type;
        },

        /**
         * Get the mode of the widget
         *
         * @returns {string} Read|Write
         */
        getMode: function getMode() {
            if (this.options.mode !== "read" && this.options.mode !== "write" && this.options.mode !== "hidden") {
                throw new Error("Attribute " + this.option.id + " have unknown mode " + this.options.mode);
            }
            return this.options.mode;
        },

        /**
         * Return the value stored in the wiget
         *
         * @returns {*|number|.options.attributeValue}
         */
        getValue: function wAttributegetValue() {
            return this.options.attributeValue;
        },

        /**
         * Identify the input where is the raw value
         * @returns {*}
         */
        getContentElements: function wAttributeGetContentElements() {
            return this.element.find('.dcpAttribute__value[name="' + this.options.id + '"]');
        },

        /**
         * Return the value of something
         *
         *
         * @returns {*}
         */
        getWidgetValue: function getWidgetValue() {
            return this.getContentElements().val();
        },
        /**
         * Set options.attributeValue element and trigger the view
         *
         * @param value
         * @param event
         */
        setValue: function wAttributeSetValue(value, event) {
            this._checkValue(value);

            var isEqual = false;

            if (this._isMultiple()) {
                isEqual = _.toArray(this.options.attributeValue).length === value.length;
                if (isEqual) {

                    isEqual = _.isEqual(this.options.attributeValue, value);
                }
            } else {
                isEqual = _.isEqual(this.options.attributeValue.value, value.value);
            }
            if (!isEqual) {
                this.options.attributeValue = value;

                this._trigger("change", event, {
                    id: this.options.id,
                    value: this.getValue(),
                    index: this._getIndex()
                });
            }
        },

        /**
         * Show the input tooltip
         * @param  ktTarget DOMElement
         *
         * @return dcp.dcpAttribute
         */
        hideInputTooltip: function wAttributeHideInputTooltip(ktTarget) {
            var $ktTarger = $(ktTarget).closest(".input-group");
            if ($ktTarger.data("hasTooltip")) {
                $ktTarger.tooltip("hide");
            }
            return this;
        },

        /**
         * Show the input tooltip
         * @param  ktTarget DOMElement
         *
         * @return dcp.dcpAttribute
         */
        showInputTooltip: function showInputTooltip(ktTarget) {
            var scope = this;

            if (scope.options.renderOptions.inputHtmlTooltip) {
                var $ktTarger = $(ktTarget).closest(".input-group");
                var kt = $ktTarger.data("hasTooltip");

                if (!kt) {
                    $ktTarger.tooltip({
                        trigger: "manual",
                        html: true,
                        title: scope.options.renderOptions.inputHtmlTooltip,
                        placement: "bottom"
                    }).on("shown.bs.tooltip", function wErrorTooltip() {
                        var tipElement = $(this).data("bs.tooltip").tip;
                        if (tipElement) {
                            $(tipElement).addClass("dcpAttribute__editlabel");
                        }
                    });;
                    $ktTarger.data("hasTooltip", true);
                }
                $ktTarger.tooltip("show");
            }
            return this;
        },

        /**
         * Close the attribute if open
         *
         * @returns {dcp.dcpAttribute}
         */
        close: function wAttribute_close() {
            return this;
        },

        /**
         * Create the widget
         * @private
         */
        _create: function _create() {
            var scope = this;
            //If no id is provided one id generated
            if (this.options.id === null) {
                this.options.id = _.uniqueId("widget_" + this.getType());
            }

            if (_.isUndefined(this.options.attributeValue) || this.options.attributeValue === null) {
                if (this._isMultiple()) {
                    this.options.attributeValue = [];
                } else {
                    this.options.attributeValue = {
                        "value": null,
                        displayValue: ""
                    };
                }
            }
            if (this.options.helpOutputs) {
                this.options.hasAutocomplete = true;
            }

            if (this.options.renderOptions && this.options.renderOptions.buttons) {
                // Add index for template to identify buttons
                this.options.renderOptions.buttons = _.map(this.options.renderOptions.buttons, function wAttributeOptionMap(val, index) {
                    val.renderHtmlContent = Mustache.render(val.htmlContent || "", scope.options.attributeValue);
                    val.index = index;
                    return val;
                });
            }
            this.options.emptyValue = _.bind(this._getEmptyValue, this);
            this.options.hadButtons = this._hasButtons();
            if (this.options.renderOptions && this.options.renderOptions.labels) {
                this.options.labels = _.extend(this.options.labels, this.options.renderOptions.labels);
            }

            if (this.options.renderOptions && this.options.renderOptions.displayDeleteButton === false) {
                this.options.deleteButton = false;
            }
            if (this.getMode() !== "hidden") {
                this._initDom();
                this._initEvent();
            }

            this._triggerReady();
        },

        /**
         * Destroy the widget
         *
         * Suppress widget defined events and delete added dom
         *
         * @private
         */
        _destroy: function _destroy() {
            this.element.removeClass("dcpAttribute__content");
            this.element.removeAttr("data-type");
            this.element.removeAttr("data-attrid");
            this.element.empty();
            this._trigger("destroy");
            this._super();
        },

        /**
         * Init the DOM of the template
         *
         * @protected
         */
        _initDom: function wAttributeInitDom() {
            var htmlLink = this.getLink();
            var scopeWidget = this;
            this._initMainElementClass();
            if (htmlLink) {
                // Add render Url and title on links
                var originalEscape = Mustache.escape;

                if (this._isMultiple()) {
                    this.options.attributeValues = _.map(this.options.attributeValue, function wAttributeLinkMultiple(val, index) {
                        var urlIndex = index;
                        Mustache.escape = encodeURIComponent;
                        scopeWidget._completeRevisionData(val);
                        if (scopeWidget.options.index >= 0) {
                            // Use index of row prior to index of multiple value
                            urlIndex = scopeWidget.options.index;
                        }

                        if (htmlLink.urls && htmlLink.urls[urlIndex]) {
                            val.renderUrl = Mustache.render(htmlLink.urls[urlIndex], val);
                        } else {
                            val.renderUrl = Mustache.render(htmlLink.url || "", val);
                        }
                        Mustache.escape = originalEscape;
                        val.renderTitle = Mustache.render(htmlLink.title || "", val);
                        val.index = index;
                        return val;
                    });
                } else {
                    Mustache.escape = encodeURIComponent;
                    this._completeRevisionData(this.options.attributeValue);
                    if (htmlLink.urls && htmlLink.urls[this.options.index]) {
                        this.options.renderOptions.htmlLink.renderUrl = Mustache.render(htmlLink.urls[this.options.index], this.options.attributeValue);
                    } else {
                        this.options.renderOptions.htmlLink.renderUrl = Mustache.render(htmlLink.url || "", this.options.attributeValue);
                    }
                    Mustache.escape = originalEscape;
                    this.options.renderOptions.htmlLink.renderTitle = Mustache.render(htmlLink.title || "", this.options.attributeValue);
                }
            }
            this.element.append(Mustache.render(this._getTemplate(this.options.mode) || "", this.options));

            if (this.element.find(".dcpAttribute__content__buttons button").length === 0) {
                this.element.find(".dcpAttribute__content__buttons").hide();
                this.element.find(".dcpAttribute__value").addClass("dcpAttribute__content__nobutton");
            }
        },

        /**
         * Add revision extra data to render link
         * @param data
         * @private
         */
        _completeRevisionData: function wAttribute_completeRevisionData(data) {
            data.isRevision = data.revision !== -1 && data.revision !== null && !_.isUndefined(data.revision);
            if (data.isRevision) {
                if (data.revision.state) {
                    data.revisionTarget = "state:" + data.revision.state;
                } else {
                    data.revisionTarget = data.revision;
                }
            }
        },

        /**
         * Init the DOM of the template
         *
         * @public
         */
        _initMainElementClass: function wAttributeInitMainElementClass() {
            this.element.addClass("dcpAttribute__content");
            this.element.attr("data-type", this.getType());
            this.element.attr("data-attrid", this.options.id);
        },
        /**
         * Init the events
         *
         * @protected
         */
        _initEvent: function _initEvent() {
            if (this.getMode() === "write") {
                this._initDeleteEvent();
                this._initButtonsEvent();
                this._initFocusEvent();
                this._initMoveEvent();
            }
            if (this.getMode() === "read") {
                this._initButtonsEvent();
                this._initActionClickEvent();
                this._initLinkEvent();
            }
            this._initErrorEvent();
            return this;
        },

        /**
         * Init the focus event for tooltips (only for write attr)
         *
         * @protected
         */
        _initFocusEvent: function wAttributeInitFocusEvent() {
            if (this.options.renderOptions && this.options.renderOptions.inputHtmlTooltip) {
                var scope = this;

                var inputTargetFilter = ".dcpAttribute__value";
                this._getFocusInput().on("focus" + this.eventNamespace, function wAttributeFocus(event) {
                    var ktTarget = $(event.currentTarget).closest(inputTargetFilter);
                    scope.showInputTooltip(ktTarget);
                });
                this._getFocusInput().on("blur." + this.eventNamespace, function wAttributeBlur(event) {
                    var ktTarget = $(event.currentTarget).closest(inputTargetFilter);
                    scope.hideInputTooltip(ktTarget);
                });
            }
            this._getFocusInput().on("focus" + this.eventNamespace, function wAttributeFocus(event) {
                var $content = $(event.currentTarget).closest(".dcpAttribute__content");
                $content.addClass("dcpAttribute--focus");
            });
            this._getFocusInput().on("blur" + this.eventNamespace, function wAttributeFocus(event) {
                var $content = $(event.currentTarget).closest(".dcpAttribute__content");
                $content.removeClass("dcpAttribute--focus");
            });

            return this;
        },
        /**
         * Reindex widget when a move is performed in an array
         *
         * @protected
         */
        _initMoveEvent: function wAttributeInitFocusEvent() {
            var scope = this;
            if (this.options.index !== -1) {
                this.element.on("postMoved" + this.eventNamespace, function wAttributeinitMoveEvent() {
                    var domLine = scope.element.closest('tr').data('line');
                    if (!_.isUndefined(domLine)) {
                        scope.options.index = domLine;
                    }
                });
            }
            return this;
        },
        /**
         * Init the events associated to buttons (only for write attributes)
         *
         * @protected
         */
        _initButtonsEvent: function _initButtonsEvent() {
            var currentWidget = this;
            this.element.on("click" + this.eventNamespace, ".dcpAttribute__content__button--extra", function wAttributeButtonClick(event) {
                var buttonsConfig = currentWidget.options.renderOptions.buttons;
                var $button = $(this);
                var buttonIndex = $button.data("index");
                var buttonConfig = buttonsConfig[buttonIndex];
                var wFeature = '';

                if (buttonConfig && buttonConfig.url) {
                    var originalEscape = Mustache.escape;
                    Mustache.escape = encodeURIComponent;
                    var url = Mustache.render(buttonConfig.url || "", currentWidget.options.attributeValue);
                    Mustache.escape = originalEscape;

                    if (buttonConfig.target !== "_dialog") {
                        var $base = $("base");
                        var isAbsUrl = new RegExp('^(?:[a-z]+:)?//', 'i');

                        if (buttonConfig && (buttonConfig.windowWidth || buttonConfig.windowHeight)) {
                            if (buttonConfig.windowWidth) {
                                wFeature += "width=" + parseInt(buttonConfig.windowWidth, 10) + ",";
                            }
                            if (buttonConfig.windowHeight) {
                                wFeature += "height=" + parseInt(buttonConfig.windowHeight, 10) + ",";
                            }
                            wFeature += "resizable=yes,scrollbars=yes";
                        }
                        if (!isAbsUrl.test(url)) {
                            // For IE : Not honor base href in this case
                            url = $base.attr("href") + url;
                        }
                        window.open(url, buttonConfig.target, wFeature);
                    } else {
                        var $bdw = $('<div/>');
                        $('body').append($bdw);
                        var renderTitle = Mustache.render(buttonConfig.windowTitle || "", currentWidget.options.attributeValue);
                        var dw = $bdw.dcpWindow({
                            title: renderTitle,
                            width: buttonConfig.windowWidth,
                            height: buttonConfig.windowHeight,
                            content: url,
                            iframe: true
                        }).data('dcpWindow');
                        dw.kendoWindow().center();
                        dw.open();
                    }
                }

                currentWidget._trigger("click", event, {
                    id: currentWidget.option.id,
                    value: currentWidget.options.attributeValue,
                    index: currentWidget._getIndex()
                });
            });
            this.element.tooltip({
                selector: ".dcpAttribute__content__buttons button",
                placement: "top",
                trigger: "hover",
                html: true,
                title: function wAttributeGetButtonTitle() {
                    var title = $(this).data("title");
                    var attrValue = currentWidget.getValue();
                    return Mustache.render(title || "", attrValue);
                },
                container: this.element.parent()
            });

            return this;
        },

        /**
         * Init events for delete button on error tooltip
         *
         * @protected
         */
        _initErrorEvent: function wAttributeInitErrotEvent() {
            var scope = this;
            // tooltip is created in same parent
            this.element.parent().on("click" + this.eventNamespace, ".button-close-error", function closeError() /*event*/{
                if (scope.element.data("hasErrorTooltip")) {
                    scope.element.find(".input-group").tooltip("hide");
                    scope.element.data("hasErrorTooltip", false);
                }
            });
        },
        /**
         * Init events for delete button (only for write attributes)
         *
         * @protected
         */
        _initDeleteEvent: function wAttributeInitDeleteEvent() {
            var currentWidget = this;

            // Compose delete button title
            var $deleteButton = this.element.find(".dcpAttribute__content__button--delete");
            var titleDelete;
            if (this.options.labels.deleteLabel) {
                titleDelete = this.options.labels.deleteLabel;
            } else {
                titleDelete = $deleteButton.attr('title');
                titleDelete += this.options.labels.deleteAttributeNames;
            }
            $deleteButton.attr('title', titleDelete);

            this.element.on("click" + this.eventNamespace, ".dcpAttribute__content__button--delete", function destroyTable(event) {
                currentWidget._trigger("delete", event, {
                    index: currentWidget._getIndex(),
                    id: currentWidget.options.id
                });
                // main input is focuses after deletion
                _.defer(function wAttributeDeferDelete() {
                    currentWidget.element.find("input").focus();
                });
            });
            return this;
        },
        /**
         * Init event for #action/ links
         *
         * @protected
         */
        _initActionClickEvent: function wAttributeInitActionClickEvent() {
            var scopeWidget = this;

            this.element.on("click." + this.eventNamespace, 'a[href^="#action/"], a[data-action], button[data-action]', function wAttributeActionClick(event) {
                var $this = $(this),
                    action,
                    options,
                    eventOptions;

                event.preventDefault();
                if (event.stopPropagation) {
                    event.stopPropagation();
                }

                action = $this.data('action') || $this.attr("href");
                options = action.substring(8).split(":");
                eventOptions = {
                    target: event.target,
                    index: scopeWidget._getIndex(),
                    eventId: options.shift(),
                    options: options
                };

                scopeWidget._trigger("externalLinkSelected", event, eventOptions);
                return this;
            });
        },
        /**
         * Init event when a hyperlink is associated to the attribute
         *
         * @protected
         */
        _initLinkEvent: function wAttributeInitLinkEvent() {
            var htmlLink = this.getLink();
            var scopeWidget = this;

            if (htmlLink) {
                this.element.on("click." + this.eventNamespace, '.dcpAttribute__content__link', function wAttributeAttributeClick(event) {

                    var $this = $(this),
                        renderTitle,
                        index,
                        $dialogDiv,
                        dpcWindow,
                        href = $this.attr("href");

                    if (href.substring(0, 8) !== "#action/" && !$this.data("action")) {
                        if (htmlLink.target === "_dialog") {
                            event.preventDefault();

                            index = $(this).data("index");
                            if (typeof index !== "undefined" && index !== null) {
                                renderTitle = Mustache.render(htmlLink.windowTitle || "", scopeWidget.options.attributeValue[index]);
                            } else {
                                renderTitle = Mustache.render(htmlLink.windowTitle || "", scopeWidget.options.attributeValue);
                            }

                            $dialogDiv = $('<div/>');
                            $('body').append($dialogDiv);

                            dpcWindow = $dialogDiv.dcpWindow({
                                title: renderTitle,
                                width: htmlLink.windowWidth,
                                height: htmlLink.windowHeight,
                                content: href,
                                iframe: true
                            });

                            dpcWindow.data('dcpWindow').kendoWindow().center();
                            dpcWindow.data('dcpWindow').open();
                        }
                    }
                });

                this.element.find('.dcpAttribute__content__link[title]').tooltip({
                    placement: "top",
                    container: this.element.parent(),
                    html: true,
                    trigger: "hover"
                }).each(function wAttributeInitLinkTooltip() {
                    if ($(this).data("bs.tooltip").tip) {
                        $(this).data("bs.tooltip").tip().addClass("dcpAttribute__linkvalue");
                    }
                });
            }
            return this;
        },

        /**
         * Get input that can handle focus class
         *
         * For the display of the focus class (in helpers)
         *
         * @return jquery elements
         *
         * @protected
         */
        _getFocusInput: function wAttributeFocusInput() {
            return this.element.find('input[name="' + this.options.id + '"]');
        },

        /**
         * Return the index of the attributes (for attribute in a widget array)
         *
         * @returns int
         * @protected
         */
        _getIndex: function _getIndex() {
            if (this.options.index !== -1) {
                this.options.index = this.element.closest('.dcpArray__content__line').data('line');
            }
            return this.options.index;
        },

        /**
         * Return the empty value (default value if the attribute is empty)
         *
         * @returns {*}
         * @private
         */
        _getEmptyValue: function _getEmptyValue() {
            if (_.isEmpty(this.options.attributeValue) || this.options.attributeValue.value === null) {
                if (this.options.renderOptions && this.options.renderOptions.showEmptyContent) {
                    return this.options.renderOptions.showEmptyContent === true ? " " : this.options.renderOptions.showEmptyContent;
                }
                return "";
            }
            return "";
        },

        /**
         * Get the template of the current attribute
         *
         * The template can be in the options or in a global var of dcp namespace (initiated by require for widget)
         *
         * @param key
         * @returns string
         * @private
         */
        _getTemplate: function _getTemplate(key) {
            if (this.options.templates && this.options.templates[key]) {
                return this.options.templates[key];
            }
            if (window.dcp && window.dcp.templates && window.dcp.templates[this.getType()] && window.dcp.templates[this.getType()][key]) {
                return window.dcp.templates[this.getType()][key];
            }
            if (window.dcp && window.dcp.templates && window.dcp.templates["default"] && window.dcp.templates["default"][key]) {
                return window.dcp.templates["default"][key];
            }
            throw new Error("Unknown template  " + key + "/" + this.options.type + " for " + this.options.id);
        },

        /**
         * Test if the value of the setValue is correct
         *
         * @param value
         * @returns {boolean}
         */
        _checkValue: function wAttributeTestValue(value) {
            //noinspection JSHint
            if (this._isMultiple()) {// jshint ignore:line
                // TODO : Verify each array entry
                // jscs:disable disallowEmptyBlocks
            } else {
                // jscs:enable disallowEmptyBlocks
                if (!_.isObject(value) || !_.has(value, "value") || !_.has(value, "displayValue")) {
                    throw new Error("The value must be an object with value and displayValue properties (attrid id :" + this.options.id + ")");
                }
            }
            return true;
        },
        /**
         * Check if the attribute is multiple
         *
         * @returns boolean
         * @public
         */
        _isMultiple: function _isMultiple() {
            return this.options.options && this.options.options.multiple === "yes";
        },

        /**
         * Check if the widget has buttons
         *
         * Used by template for rendering options
         *
         * @returns boolean
         */
        _hasButtons: function wAttributeHasButtons() {
            if (this.getMode() === "write") {
                return this.options.hasAutocomplete || this.options.deleteButton || this.options.renderOptions && this.options.renderOptions.buttons && true;
            } else {
                return this.options.renderOptions && this.options.renderOptions.buttons && true;
            }
        },
        /**
         * Trigger a ready event when widget is render
         */
        _triggerReady: function wAttributeReady() {
            this._trigger("widgetReady");
        },

        /**
         * Trigger an event that should disable save menu on document
         *
         * @param visibility
         * @private
         */
        _setVisibilitySavingMenu: function wAttribute_DisableSavingMenu(visibility) {
            var event = { prevent: false };
            this._trigger("changeattrmenuvisibility", event, {
                id: "save",
                onlyIfVisible: true,
                visibility: visibility
            });
            this._trigger("changeattrmenuvisibility", event, {
                id: "saveAndClose",
                onlyIfVisible: true,
                visibility: visibility
            });
            this._trigger("changeattrmenuvisibility", event, {
                id: "createAndClose",
                onlyIfVisible: true,
                visibility: visibility
            });
            this._trigger("changeattrmenuvisibility", event, {
                id: "create",
                onlyIfVisible: true,
                visibility: visibility
            });
        }

    });
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/documentController/documentController.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/* global define, console */
!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/backbone/backbone.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/routers/router.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/models/mDocument.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/controllerObjects/attributeInterface.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/controllerObjects/menuInterface.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/controllerObjects/transitionInterface.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/document/vDocument.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/models/mTransition.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/views/workflow/vTransition.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/models/mMenu.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/i18n/documentCatalog.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/widget.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/window/wConfirm.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/window/wLoading.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/window/wNotification.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function documentController($, _, Backbone, Router, DocumentModel, AttributeInterface, MenuInterface, TransitionInterface, DocumentView, TransitionModel, TransitionView, MenuModel, i18n) {
    'use strict';

    var ErrorModelNonInitialized = function ErrorModelNonInitialized(message) {
        this.name = "ErrorModelNonInitialized";
        this.message = message || "The widget model is not initialized, use fetchDocument to initialise it.";
        this.stack = new Error().stack;
    };
    ErrorModelNonInitialized.prototype = Object.create(Error.prototype);
    ErrorModelNonInitialized.prototype.constructor = ErrorModelNonInitialized;

    var eventList = ["beforeRender", "ready", "change", "displayMessage", "displayError", "validate", "attributeBeforeRender", "attributeReady", "attributeHelperSearch", "attributeHelperResponse", "attributeHelperSelect", "attributeArrayChange", "actionClick", "attributeAnchorClick", "beforeClose", "close", "beforeSave", "afterSave", "attributeDownloadFile", "attributeUploadFile", "attributeUploadFileDone", "beforeDelete", "afterDelete", "beforeRestore", "afterRestore", "failTransition", "successTransition", "beforeDisplayTransition", "afterDisplayTransition", "beforeTransition", "beforeTransitionClose", "destroy", "attributeCreateDialogDocumentBeforeSetFormValues", "attributeCreateDialogDocumentBeforeSetTargetValue", "attributeCreateDialogDocumentReady", "attributeCreateDialogDocumentBeforeClose", "attributeCreateDialogDocumentBeforeDestroy"];

    $.widget("dcp.documentController", {

        options: {
            eventPrefix: "document",
            initid: null,
            viewId: undefined,
            revision: undefined,
            constraintList: [],
            eventListener: [],
            _model: null,
            activatedConstraint: {},
            activatedEventListener: {},
            _initializedModel: false,
            _initializedView: false
        },

        /**
         * Create widget
         * @private
         */
        _create: function documentController_create() {
            this.options.constraintList = {};
            this.options.eventListener = {};
            this.activatedConstraint = {};
            this.activatedEventListener = {};
            this._initializedModel = false;
            this._initializedView = false;
            this._customClientData = {};
            if (!this.options.initid) {
                console.log("Widget initialised without document");
                return;
            }
            this._initializeWidget({}, this.options.customClientData);
            this._super();
        },
        /**
         * tryToDestroy the widget
         *
         * @return Promise
         */
        tryToDestroy: function documentController_tryToDestroy() {
            var currentWidget = this;
            return new Promise(function documentController_promiseDestroy(resolve, reject) {
                var event = { prevent: false };
                if (!currentWidget._model) {
                    resolve();
                    return;
                }
                if (currentWidget._model && currentWidget._model.isModified() && !window.confirm(currentWidget._model.get("properties").get("title") + "\n" + i18n.___("The form has been modified without saving, do you want to close it ?", "ddui"))) {
                    reject("Unable to destroy because user refuses it");
                    return;
                }
                currentWidget._triggerControllerEvent("beforeClose", event, currentWidget._model.getServerProperties());
                if (event.prevent) {
                    reject("Unable to destroy because before close refuses it");
                    return;
                }
                resolve();
            });
        },
        /**
         * Delete the widget
         * @private
         */
        _destroy: function documentController_destroy() {
            this._triggerControllerEvent("destroy", this.getProperties());
            this.options.constraintList = {};
            this.options.eventListener = {};
            this.activatedConstraint = {};
            this.activatedEventListener = {};
            this._initializedModel = false;
            this._initializedView = false;
            this.element.removeData("document");
            if (this._model) {
                this._model.trigger("destroy");
            }
            this._trigger("destroy");
            this._super();
        },

        /**
         * Initialize the widget
         *
         * Create Model, initView
         *
         * @param options object {"success": fct, "error", fct}
         * @param customClientData object
         *
         * @private
         */
        _initializeWidget: function documentController_initializeWidget(options, customClientData) {
            var promise,
                currentWidget = this,
                initializeSuccess = function documentController_initializeSuccess() {
                currentWidget._initializedModel = true;
            };
            options = options || {};
            this._initExternalElements();
            this._initModel(this._getModelValue());
            this._initView();
            if (options.success) {
                options.success = _.wrap(options.success, function documentController_fetchSuccess(success) {
                    initializeSuccess.apply(this, _.rest(arguments));
                    return success.apply(this, _.rest(arguments));
                });
            }
            if (customClientData) {
                this._model._customClientData = customClientData;
            }
            promise = this._model.fetchDocument(this._getModelValue(), options);
            if (!options.success) {
                promise.then(initializeSuccess);
            }

            this._initRouter({ useHistory: !this.options.noRouter });

            return promise;
        },

        /**
         * Return essential element of the current document
         *
         * @returns {Object}
         * @private
         */
        _getModelValue: function documentController_getModelValue() {
            return _.pick(this.options, "initid", "viewId", "revision");
        },

        /**
         * Generate the dom where the view is inserted
         * @private
         */
        _initDom: function documentController_initDom() {
            var $document = this.element.find(".dcpDocument");
            if (!this.$document || $document.length === 0) {
                this.element.append('<div class="dcpDocument"></div>');
                this.$document = this.element.find(".dcpDocument");
            }
        },

        /**
         * Init the model and bind the events
         *
         * @param initialValue
         * @returns DocumentModel
         * @private
         */
        _initModel: function documentController_initModel(initialValue) {
            var model;

            //Don't reinit the model
            if (!this._model) {
                model = new DocumentModel(initialValue);
                this._model = model;
                this._initModelEvents();
            } else {
                this._reinitModel();
            }
            return model;
        },

        /**
         * Init the view and bind the events
         *
         * @returns {DocumentView}
         * @private
         */
        _initView: function documentController_initView() {
            var documentView;
            ///Don't reinit view
            if (!this.view) {
                this._initDom();
                documentView = new DocumentView({ model: this._model, el: this.$document[0] });
                this.view = documentView;
                this._initViewEvents();
            }
            return this.view;
        },

        /**
         * Clear and reinit the model with current widget values
         *
         * @private
         */
        _reinitModel: function documentController_reinitModel() {
            this._model.set(this._getModelValue());
        },

        /**
         * Init the external elements (loading bar and notification widget)
         * @private
         */
        _initExternalElements: function documentController_initExternalElements() {
            this.$loading = $(".dcpLoading").dcpLoading();
            this.$notification = $('body').dcpNotification(window.dcp.notifications); // active notification
        },

        /**
         * Bind the model event
         *
         * Re-trigger the event
         *
         * @private
         */
        _initModelEvents: function documentController_initEvents() {
            var currentWidget = this;
            this._model.listenTo(this._model, "invalid", function documentController_triggerShowInvalid(model, error) {
                var result = currentWidget._triggerControllerEvent("displayError", currentWidget.getProperties(), error);
                if (result) {
                    currentWidget.$notification.dcpNotification("showError", error);
                }
            });
            this._model.listenTo(this._model, "showError", function documentController_triggerShowError(error) {
                var result = currentWidget._triggerControllerEvent("displayError", currentWidget.getProperties(), error);
                if (result) {
                    currentWidget.$notification.dcpNotification("showError", error);
                }
            });
            this._model.listenTo(this._model, "showMessage", function documentController_triggerShowMessage(msg) {
                var result = currentWidget._triggerControllerEvent("displayMessage", currentWidget.getProperties(), msg);
                if (result) {
                    currentWidget.$notification.dcpNotification("show", msg.type, msg);
                }
            });
            this._model.listenTo(this._model, "sync", function documentController_triggerSync() {
                currentWidget._initializedModel = true;
                currentWidget.options.initid = currentWidget._model.id;
                currentWidget.options.viewId = currentWidget._model.get("viewId");
                currentWidget.options.revision = currentWidget._model.get("revision");
                currentWidget.element.data("document", currentWidget._getModelValue());
                currentWidget._initActivatedConstraint();
                currentWidget._initActivatedEventListeners({ launchReady: false });
            });
            this._model.listenTo(this._model, "beforeRender", function documentController_triggerBeforeRender(event) {
                event.prevent = !currentWidget._triggerControllerEvent("beforeRender", currentWidget.getProperties(), currentWidget._model.getModelProperties());
            });
            this._model.listenTo(this._model, "beforeClose", function documentController_triggerBeforeClose(event, nextDocument, customClientData) {
                if (currentWidget._initializedView !== false) {
                    event.prevent = !currentWidget._triggerControllerEvent("beforeClose", currentWidget.getProperties(), nextDocument, customClientData);
                }
            });
            this._model.listenTo(this._model, "close", function documentController_triggerClose(oldProperties) {
                if (currentWidget._initializedView !== false) {
                    currentWidget._triggerControllerEvent("close", currentWidget.getProperties(), oldProperties);
                }
                currentWidget._initializedView = false;
            });
            this._model.listenTo(this._model, "getCustomClientData", function documentController_triggerAddCustomData() {
                try {
                    currentWidget._model._customClientData = currentWidget.getCustomClientData();
                } catch (e) {}
            });
            this._model.listenTo(this._model, "beforeSave", function documentController_triggerBeforeSave(event, customClientData) {
                event.prevent = !currentWidget._triggerControllerEvent("beforeSave", currentWidget.getProperties(), currentWidget._model.getModelProperties(), customClientData);
            });
            this._model.listenTo(this._model, "afterSave", function documentController_triggerAfterSave(oldProperties) {
                currentWidget._triggerControllerEvent("afterSave", currentWidget.getProperties(), oldProperties);
            });
            this._model.listenTo(this._model, "beforeRestore", function documentController_triggerBeforeRestore(event) {
                event.prevent = !currentWidget._triggerControllerEvent("beforeRestore", currentWidget.getProperties());
            });
            this._model.listenTo(this._model, "afterRestore", function documentController_triggerAfterRestore(oldProperties) {
                currentWidget._triggerControllerEvent("afterRestore", currentWidget.getProperties(), oldProperties);
            });
            this._model.listenTo(this._model, "beforeDelete", function documentController_triggerBeforeDelete(event, customClientData) {
                event.prevent = !currentWidget._triggerControllerEvent("beforeDelete", currentWidget.getProperties(), currentWidget._model.getModelProperties(), customClientData);
            });
            this._model.listenTo(this._model, "afterDelete", function documentController_triggerAfterDelete(oldProperties) {
                currentWidget._triggerControllerEvent("afterDelete", currentWidget.getProperties(), oldProperties);
            });
            this._model.listenTo(this._model, "validate", function documentController_triggerValidate(event) {
                event.prevent = !currentWidget._triggerControllerEvent("validate", currentWidget.getProperties());
            });
            this._model.listenTo(this._model, "changeValue", function documentController_triggerChangeValue(options) {
                try {
                    var currentAttribute = currentWidget.getAttribute(options.attributeId),
                        index = 0,
                        values = currentAttribute.getValue("all"),
                        mAttribute = currentWidget._getAttributeModel(options.attributeId);
                    if (mAttribute.getParent().get("type") !== "array") {
                        index = -1;
                    } else {
                        _.find(values.current, function documentController_valueIsModified(currentValue) {
                            var result,
                                previous = values.previous[index];
                            if (!previous) {
                                index++;
                                return true;
                            }
                            if (_.isArray(currentValue)) {
                                currentValue = currentValue.join(",");
                            }
                            currentValue = _.has(currentValue, "value") ? currentValue.value : currentValue;
                            if (_.isArray(previous)) {
                                previous = previous.join(",");
                            }
                            previous = _.has(previous, "value") ? previous.value : previous;
                            result = previous !== currentValue;
                            index++;
                            return result;
                        });
                        index--;
                    }
                    currentWidget._triggerAttributeControllerEvent("change", currentAttribute, currentWidget.getProperties(), currentAttribute, currentAttribute.getValue("all"), index);
                } catch (error) {
                    if (!(error instanceof ErrorModelNonInitialized)) {
                        console.error(error);
                    }
                }
            });
            this._model.listenTo(this._model, "beforeAttributeRender", function documentController_triggerAttributeRender(event, attributeId, $el, index) {
                try {
                    var currentAttribute = currentWidget.getAttribute(attributeId);
                    event.prevent = !currentWidget._triggerAttributeControllerEvent("attributeBeforeRender", currentAttribute, currentWidget.getProperties(), currentAttribute, $el, index);
                } catch (error) {
                    if (!(error instanceof ErrorModelNonInitialized)) {
                        console.error(error);
                    }
                }
            });
            this._model.listenTo(this._model, "attributeRender", function documentController_triggerAttributeRender(attributeId, $el, index) {
                try {
                    var currentAttribute = currentWidget.getAttribute(attributeId);
                    currentWidget._triggerAttributeControllerEvent("attributeReady", currentAttribute, currentWidget.getProperties(), currentAttribute, $el, index);
                } catch (error) {
                    if (!(error instanceof ErrorModelNonInitialized)) {
                        console.error(error);
                    }
                }
            });
            this._model.listenTo(this._model, "arrayModified", function documentController_triggerArrayModified(options) {
                try {
                    var currentAttribute = currentWidget.getAttribute(options.attributeId);
                    currentWidget._triggerAttributeControllerEvent("attributeArrayChange", currentAttribute, currentWidget.getProperties(), currentAttribute, options.type, options.options);
                } catch (error) {
                    if (!(error instanceof ErrorModelNonInitialized)) {
                        console.error(error);
                    }
                }
            });
            this._model.listenTo(this._model, "internalLinkSelected", function documentController_triggerInternalLinkSelected(event, options) {
                event.prevent = !currentWidget._triggerControllerEvent("actionClick", currentWidget.getProperties(), options);
            });
            this._model.listenTo(this._model, "downloadFile", function documentController_triggerDownloadFile(event, attrid, options) {
                try {
                    var currentAttribute = currentWidget.getAttribute(attrid);
                    event.prevent = !currentWidget._triggerControllerEvent("attributeDownloadFile", currentWidget.getProperties(), currentAttribute, options.$el, options.index);
                } catch (error) {
                    if (!(error instanceof ErrorModelNonInitialized)) {
                        console.error(error);
                    }
                }
            });
            this._model.listenTo(this._model, "uploadFile", function documentController_triggerUploadFile(event, attrid, options) {
                try {
                    var currentAttribute = currentWidget.getAttribute(attrid);
                    event.prevent = !currentWidget._triggerControllerEvent("attributeUploadFile", currentWidget.getProperties(), currentAttribute, options.$el, options.index, {
                        file: options.file,
                        hasUploadingFiles: currentWidget._model.hasUploadingFile()

                    });
                } catch (error) {
                    if (!(error instanceof ErrorModelNonInitialized)) {
                        console.error(error);
                    }
                }
            });
            this._model.listenTo(this._model, "uploadFileDone", function documentController_triggerUploadFile(event, attrid, options) {
                try {
                    var currentAttribute = currentWidget.getAttribute(attrid);
                    event.prevent = !currentWidget._triggerControllerEvent("attributeUploadFileDone", currentWidget.getProperties(), currentAttribute, options.$el, options.index, {
                        file: options.file,
                        hasUploadingFiles: currentWidget._model.hasUploadingFile()
                    });
                } catch (error) {
                    if (!(error instanceof ErrorModelNonInitialized)) {
                        console.error(error);
                    }
                }
            });
            this._model.listenTo(this._model, "helperSearch", function documentController_triggerHelperSearch(event, attrid, options) {
                try {
                    var currentAttribute = currentWidget.getAttribute(attrid);
                    event.prevent = !currentWidget._triggerAttributeControllerEvent("attributeHelperSearch", currentAttribute, currentWidget.getProperties(), currentAttribute, options);
                } catch (error) {
                    if (!(error instanceof ErrorModelNonInitialized)) {
                        console.error(error);
                    }
                }
            });
            this._model.listenTo(this._model, "helperResponse", function documentController_triggerHelperResponse(event, attrid, options) {
                try {
                    var currentAttribute = currentWidget.getAttribute(attrid);
                    event.prevent = !currentWidget._triggerAttributeControllerEvent("attributeHelperResponse", currentAttribute, currentWidget.getProperties(), currentAttribute, options);
                } catch (error) {
                    if (!(error instanceof ErrorModelNonInitialized)) {
                        console.error(error);
                    }
                }
            });
            this._model.listenTo(this._model, "helperSelect", function documentController_triggerHelperSelect(event, attrid, options) {
                try {
                    var currentAttribute = currentWidget.getAttribute(attrid);
                    event.prevent = !currentWidget._triggerAttributeControllerEvent("attributeHelperSelect", currentAttribute, currentWidget.getProperties(), currentAttribute, options);
                } catch (error) {
                    if (!(error instanceof ErrorModelNonInitialized)) {
                        console.error(error);
                    }
                }
            });

            // listener to prevent default actions when anchorClick is triggered
            this._model.listenTo(this._model, "anchorClick", function documentController_triggerHelperSelect(event, attrid, options) {
                try {
                    var currentAttribute = currentWidget.getAttribute(attrid);
                    event.prevent = !currentWidget._triggerAttributeControllerEvent("attributeAnchorClick", currentAttribute, currentWidget.getProperties(), currentAttribute, options.$el, options.index, options.options);
                } catch (error) {
                    if (!(error instanceof ErrorModelNonInitialized)) {
                        console.error(error);
                    }
                }
            });

            // Generic listener for addCreateDocumentButton docid render option
            this._model.listenTo(this._model, "createDialogListener", function documentController_triggercreateDialogDocumentOpen(event, attrid, options) {
                try {
                    var currentAttribute = currentWidget.getAttribute(attrid);
                    var triggername = "attributeCreateDialogDocument";
                    // Uppercase first letter
                    triggername += options.triggerId.charAt(0).toUpperCase() + options.triggerId.slice(1);

                    event.prevent = !currentWidget._triggerAttributeControllerEvent(triggername, currentAttribute, currentWidget.getProperties(), currentAttribute, options);
                } catch (error) {
                    if (!(error instanceof ErrorModelNonInitialized)) {
                        console.error(error);
                    }
                }
            });
            this._model.listenTo(this._model, "constraint", function documentController_triggerConstraint(attribute, constraintController) {
                try {
                    var currentAttribute = currentWidget.getAttribute(attribute),
                        currentModel = currentWidget.getProperties(),
                        $element = $(currentWidget.element),
                        addConstraint = function documentController_addConstraint(currentConstraint) {
                        if (_.isString(currentConstraint)) {
                            constraintController.addConstraintMessage(currentConstraint);
                        }
                        if (_.isObject(currentConstraint) && currentConstraint.message && _.isNumber(currentConstraint.index)) {
                            constraintController.addConstraintMessage(currentConstraint.message, currentConstraint.index);
                        }
                    };
                    _.each(currentWidget.activatedConstraint, function triggerCurrentConstraint(currentConstraint) {
                        try {
                            if (currentConstraint.attributeCheck.apply($element, [currentAttribute, currentModel])) {
                                var response = currentConstraint.constraintCheck.call($element, currentModel, currentAttribute, currentAttribute.getValue("all"));
                                if (_.isArray(response)) {
                                    _.each(response, addConstraint);
                                } else {
                                    addConstraint(response);
                                }
                            }
                        } catch (e) {
                            console.error(e);
                        }
                    });
                } catch (error) {
                    if (!(error instanceof ErrorModelNonInitialized)) {
                        console.error(error);
                    }
                }
            });
            this._model.listenTo(this._model, "showTransition", _.bind(currentWidget._initAndDisplayTransition, this));
            this._model.listenTo(this._model, "beforeParse", _.bind(function deleteCustomClient() {
                //Suppress customClientData after a sucessful transaction
                try {
                    currentWidget.getCustomClientData(true);
                } catch (e) {}
            }, this));
        },

        /**
         * Bind the view
         * Re-trigger the events
         *
         * @private
         */
        _initViewEvents: function documentController_initViewEvents() {
            var currentWidget = this;
            this.view.on("cleanNotification", function documentController_triggerCleanNotification() {
                currentWidget.$notification.dcpNotification("clear");
            });
            this.view.on('loading', function documentController_triggerLoading(data, nbItem) {
                currentWidget.$loading.dcpLoading('setPercent', data);
                if (nbItem) {
                    currentWidget.$loading.dcpLoading('setNbItem', nbItem);
                }
            });
            this.view.on('loaderShow', function documentController_triggerLoaderShow(text, pc) {
                console.time("xhr+render document view");
                currentWidget.$loading.dcpLoading('show', text, pc);
            });
            this.view.on('loaderHide', function documentController_triggerHide() {
                currentWidget.$loading.dcpLoading('hide');
            });
            this.view.on('partRender', function documentController_triggerPartRender() {
                currentWidget.$loading.dcpLoading('addItem');
            });
            this.view.on('renderDone', function documentController_triggerRenderDone() {
                console.timeEnd("xhr+render document view");
                currentWidget.$loading.dcpLoading("setPercent", 100);
                currentWidget.$loading.dcpLoading("setLabel", null);
                currentWidget._initializedView = true;
                currentWidget._triggerControllerEvent("ready", currentWidget.getProperties());
                _.delay(function documentController_endRender() {
                    currentWidget.$loading.dcpLoading("hide", true);
                    console.timeEnd('main');
                });
            });
            this.view.on("showMessage", function documentController_triggerShowMessage(message) {
                var result = currentWidget._triggerControllerEvent("displayMessage", currentWidget.getProperties(), message);
                if (result) {
                    currentWidget.$notification.dcpNotification("show", message.type, message);
                }
            });
            this.view.on("showSuccess", function documentController_triggerShowSuccess(message) {
                var result = currentWidget._triggerControllerEvent("displayMessage", currentWidget.getProperties(), message);
                if (result) {
                    currentWidget.$notification.dcpNotification("showSuccess", message);
                }
            });
            this.view.on("reinit", function documentController_triggerReinit() {
                currentWidget._initModel(currentWidget._getModelValue());
                currentWidget._initView();
                currentWidget._model.fetchDocument();
            });
        },

        /**
         * Init the pushstate router
         *
         * @private
         */
        _initRouter: function documentController_initRouter(config) {
            if (this.router) {
                return this.router;
            }
            try {
                if (window.history && history.pushState) {
                    Backbone.history.start({ pushState: true });
                } else {
                    //For browser without API history
                    Backbone.history.start();
                }
            } catch (e) {
                console.error(e);
            }
            this.router = new Router({
                document: this._model,
                useHistory: !config || config.useHistory
            });
        },

        /**
         * Init and display the change state pop-up
         *
         * @param nextState
         * @param transition
         * @param values
         * @param withoutInterface
         * @param reinitOptions
         */
        _initAndDisplayTransition: function documentController_initAndDisplayTransition(nextState, transition, values, withoutInterface, reinitOptions) {
            var $target = $('<div class="dcpTransition"/>'),
                transitionElements = {},
                currentWidget = this,
                result,
                transitionInterface,
                documentServerProperties = this.getProperties();

            return new Promise(function documentController_changeStatePromise(resolve, reject) {
                result = !currentWidget._triggerControllerEvent("beforeDisplayChangeState", currentWidget.getProperties(), new TransitionInterface(null, $target, nextState, transition));
                if (result) {
                    reject();
                    return this;
                }

                //Init transition model
                transitionElements.model = new TransitionModel({
                    documentId: currentWidget._model.id,
                    documentModel: currentWidget._model,
                    state: nextState,
                    transition: transition
                });

                //Init transition view
                if (withoutInterface !== true) {
                    transitionElements.view = new TransitionView({
                        model: transitionElements.model,
                        el: $target
                    });
                }

                transitionInterface = new TransitionInterface(transitionElements.model, $target, nextState, transition);

                if (transitionElements.view) {
                    //Propagate afterDisplayChange on renderDone
                    transitionElements.view.once("renderTransitionWindowDone", function documentController_propagateAfter() {
                        currentWidget._triggerControllerEvent("afterDisplayTransition", currentWidget.getProperties(), transitionInterface);
                    });
                }

                //Propagate the beforeTransition
                transitionElements.model.listenTo(transitionElements.model, "beforeChangeState", function documentController_propagateBeforeTransition(event) {
                    event.prevent = !currentWidget._triggerControllerEvent("beforeTransition", currentWidget.getProperties(), transitionInterface);
                });

                //Propagate the beforeTransitionClose
                transitionElements.model.listenTo(transitionElements.model, "beforeChangeStateClose", function documentController_propagateTransitionClose(event) {
                    event.prevent = !currentWidget._triggerControllerEvent("beforeTransitionClose", currentWidget.getProperties(), transitionInterface);
                });

                transitionElements.model.listenTo(transitionElements.model, "showError", function documentController_propagateTransitionError(error) {
                    event.prevent = !currentWidget._triggerControllerEvent("failTransition", currentWidget.getProperties(), transitionInterface, error);
                    reject({ documentProperties: documentServerProperties });
                });

                transitionElements.model.listenTo(transitionElements.model, 'success', function documentController_TransitionSuccess(messages) {
                    if (transitionElements.view) {
                        transitionElements.view.$el.hide();
                        currentWidget.view.once("renderDone", function documentController_transitionRender() {
                            transitionElements.view.remove();
                            _.each(messages, function documentController_parseMessage(message) {
                                currentWidget.view.trigger("showMessage", message);
                            });
                        });
                    }

                    //delete the pop up when the render of the pop up is done
                    currentWidget._triggerControllerEvent("successTransition", currentWidget.getProperties(), transitionInterface);

                    reinitOptions = reinitOptions || { revision: -1 };
                    if (!_.has(reinitOptions, "revision")) {
                        reinitOptions.revision = -1;
                    }

                    //Reinit the main model with last revision
                    currentWidget.reinitDocument(reinitOptions).then(function documentController_reinitDone() {
                        resolve({ documentProperties: documentServerProperties });
                    }, function documentController_reinitFail() {
                        reject({ documentProperties: documentServerProperties });
                    });
                });

                transitionElements.model.listenTo(currentWidget._model, "sync", function documentController_TransitionClose() {
                    this.trigger("close");
                });

                transitionElements.model.fetch({
                    "success": function transitionModel_setDefaultValues() {
                        if (values) {
                            transitionElements.model.setValues(values);
                        }
                        if (withoutInterface === true) {
                            transitionElements.model._loadDocument(transitionElements.model).then(function documentController_TransitionSave() {
                                transitionElements.model.save({}, {
                                    success: function transitionModel_afterSave() {
                                        transitionElements.model.trigger("success");
                                        resolve({ documentProperties: documentServerProperties });
                                    },
                                    error: function transitionModel_error() {
                                        reject({ documentProperties: documentServerProperties });
                                    }
                                });
                            }).catch(function transitionModel_error() {
                                reject({ documentProperties: documentServerProperties });
                            });
                        } else {
                            transitionElements.model._loadDocument(transitionElements.model).then(function documentController_TransitionDisplay() {
                                transitionElements.model.trigger("dduiDocumentReady");
                            }).catch(function transitionModel_error() {
                                reject({ documentProperties: documentServerProperties });
                            });
                        }
                    },
                    "error": function transitionModel_error(theModel, response, options) {
                        var errorTxt = { title: "Transition Error" };
                        if (options && options.errorThrown) {
                            errorTxt.message = options.errorThrown;
                        }
                        currentWidget.$notification.dcpNotification("showError", errorTxt);
                        transitionElements.model.trigger("showError", errorTxt);
                    }
                });
            });
        },

        /**
         * Get a backbone model of an attribute
         *
         * @param attributeId
         * @returns {*}
         */
        _getAttributeModel: function documentController_getAttributeModel(attributeId) {
            var attributes = this._model.get("attributes");
            var attribute;
            if (!attributes) {
                throw new Error('Attribute models not initialized yet : The attribute "' + attributeId + '" cannot be found.');
            }
            attribute = this._model.get("attributes").get(attributeId);
            if (!attribute) {
                return undefined;
            }
            return attribute;
        },

        _getMenuModel: function documentController_getMenuModel(menuId) {
            var menus = this._model.get("menus");
            ;
            var menu = menus.get(menuId);
            if (!menu && menus) {
                menus.each(function documentControllerGetMenuIterate(itemMenu) {
                    if (itemMenu.get("content")) {
                        _.each(itemMenu.get("content"), function documentControllerGetSubMenuIterate(subMenu) {
                            if (subMenu.id === menuId) {
                                menu = new MenuModel(subMenu);
                            }
                        });
                    }
                });
            }
            return menu;
        },

        /**
         * Get all rendered attributes with their root dom node
         *
         * @returns {*}
         */
        _getRenderedAttributes: function documentController_getRenderedAttributes() {
            return this._model.get("attributes").chain().map(function documentController_getRenderedAttribute(currentAttribute) {
                return {
                    "view": currentAttribute.haveView(),
                    "id": currentAttribute.id
                };
            }).filter(function documentController_suppressNoView(currentAttribut) {
                return currentAttribut.view.haveView;
            }).value();
        },

        /**
         * Get max index of an array
         *
         * @param attributeArray
         * @returns {*}
         */
        _getMaxIndex: function documentController_getMaxIndex(attributeArray) {
            return _.size(attributeArray.get("content").max(function documentController_getMax(currentAttr) {
                return _.size(currentAttr.get("attributeValue"));
            }).get("attributeValue"));
        },

        /**
         * Activate constraint on the current document
         * Used on the fetch of a new document
         *
         */
        _initActivatedConstraint: function documentController_initActivatedConstraint() {
            var currentDocumentProperties = this.getProperties(),
                currentWidget = this;
            this.activatedConstraint = {};
            _.each(this.options.constraintList, function documentController_getActivatedConstraint(currentConstraint) {
                if (currentConstraint.documentCheck.call($(currentWidget.element), currentDocumentProperties)) {
                    currentWidget.activatedConstraint[currentConstraint.name] = currentConstraint;
                }
            });
        },

        /**
         * Activate events on the current document
         * Used on the fetch of a new document
         */
        _initActivatedEventListeners: function documentController_initActivatedEvents(options) {
            var currentDocumentProperties = this.getProperties(),
                currentWidget = this;
            options = options || {};
            this.activatedEventListener = {};
            _.each(this.options.eventListener, function documentController_getActivatedEvent(currentEvent) {
                if (!_.isFunction(currentEvent.documentCheck)) {
                    currentWidget.activatedEventListener[currentEvent.name] = currentEvent;
                    return;
                }
                if (currentEvent.documentCheck.call($(currentWidget.element), currentDocumentProperties)) {
                    currentWidget.activatedEventListener[currentEvent.name] = currentEvent;
                }
            });
            //Trigger new added ready event
            if (this._initializedView !== false && options.launchReady !== false) {
                this._triggerControllerEvent("ready", currentDocumentProperties);
                _.each(this._getRenderedAttributes(), function documentController_triggerRenderedAttributes(currentAttribute) {
                    var objectAttribute = currentWidget.getAttribute(currentAttribute.id);
                    currentWidget._triggerAttributeControllerEvent("attributeReady", currentAttribute, currentDocumentProperties, objectAttribute, currentAttribute.view.elements);
                });
            }
        },

        /**
         * Add new event and autotrigger already done event for ready
         *
         * @param newEvent
         */
        _addAndInitNewEvents: function documentController_addAndInitNewEvents(newEvent) {
            var currentDocumentProperties,
                currentWidget = this,
                event,
                uniqueName,
                $element = $(currentWidget.element);
            uniqueName = (newEvent.externalEvent ? "external_" : "internal_") + newEvent.name;
            this.options.eventListener[uniqueName] = newEvent;

            if (!this._initializedModel) {
                //early event model is not ready (no trigger, or current register possible)
                return this;
            }
            currentDocumentProperties = this.getProperties();
            // Check if the event is for the current document
            if (!_.isFunction(newEvent.documentCheck) || newEvent.documentCheck.call($element, currentDocumentProperties)) {
                this.activatedEventListener[newEvent.name] = newEvent;
                // Check if we need to manually trigger this callback (late registered : only for ready events)
                if (this._initializedView !== false) {
                    if (newEvent.eventType === "ready") {
                        event = $.Event(newEvent.eventType);
                        event.target = currentWidget.element;
                        try {
                            // add element as function context
                            newEvent.eventCallback.call($element, event, currentDocumentProperties);
                        } catch (e) {
                            console.error(e);
                        }
                    }
                    if (newEvent.eventType === "attributeReady") {
                        event = $.Event(newEvent.eventType);
                        event.target = currentWidget.element;
                        _.each(this._getRenderedAttributes(), function documentController_triggerRenderedAttributes(currentAttribute) {
                            var objectAttribute = currentWidget.getAttribute(currentAttribute.id);
                            if (!_.isFunction(newEvent.attributeCheck) || newEvent.attributeCheck.apply($element, [objectAttribute])) {
                                try {
                                    // add element as function context
                                    newEvent.eventCallback.call($element, event, currentDocumentProperties, objectAttribute, currentAttribute.view.elements);
                                } catch (e) {
                                    console.error(e);
                                }
                            }
                        });
                    }
                }
            }
        },

        /**
         * Trigger attribute event
         *
         * Similar at trigger document event with a constraint on attribute
         *
         * @param eventName
         * @param attributeInternalElement
         * @returns {boolean}
         */
        _triggerAttributeControllerEvent: function documentController_triggerAttributeControllerEvent(eventName, attributeInternalElement) {
            var currentWidget = this,
                args = Array.prototype.slice.call(arguments, 2),
                event = $.Event(eventName),
                externalEventArgument,
                $element = $(currentWidget.element);
            event.target = currentWidget.element;
            // internal event trigger
            args.unshift(event);
            _.chain(this.activatedEventListener).filter(function documentController__filterUsableEvents(currentEvent) {
                // Check by eventType (only call callback with good eventType)
                if (currentEvent.eventType === eventName) {
                    //Check with attributeCheck if the function exist
                    if (!_.isFunction(currentEvent.attributeCheck)) {
                        return true;
                    }
                    return currentEvent.attributeCheck.apply($element, [attributeInternalElement, currentWidget.getProperties()]);
                }
                return false;
            }).each(function documentController_applyCallBack(currentEvent) {
                try {
                    currentEvent.eventCallback.apply($element, args);
                } catch (e) {
                    if (window.dcp && window.dcp.logger) {
                        window.dcp.logger(e);
                    } else {
                        console.error(e);
                    }
                }
            });
            externalEventArgument = Array.prototype.slice.call(arguments, 0);
            externalEventArgument.splice(1, 1);
            currentWidget._triggerExternalEvent.apply(currentWidget, externalEventArgument);
            return !event.isDefaultPrevented();
        },

        /**
         * Trigger a controller event
         * That kind of event are only for this widget
         *
         * @param eventName
         * @returns {boolean}
         */
        _triggerControllerEvent: function documentController_triggerControllerEvent(eventName) {
            var currentWidget = this,
                args = Array.prototype.slice.call(arguments, 1),
                event = $.Event(eventName);
            event.target = currentWidget.element;
            // internal event trigger
            args.unshift(event);
            _.chain(this.activatedEventListener).filter(function documentController_getEventName(currentEvent) {
                return currentEvent.eventType === eventName;
            }).each(function documentController_triggerAnEvent(currentEvent) {
                try {
                    currentEvent.eventCallback.apply($(currentWidget.element), args);
                } catch (e) {
                    if (window.dcp.logger) {
                        window.dcp.logger(e);
                    } else {
                        console.error(e);
                    }
                }
            });
            currentWidget._triggerExternalEvent.apply(currentWidget, arguments);
            return !event.isDefaultPrevented();
        },

        /**
         * Trigger event as jQuery standard events (all events are prefixed by document)
         *
         * @param type
         */
        _triggerExternalEvent: function documentController_triggerExternalEvent(type) {
            var currentWidget = this,
                args = Array.prototype.slice.call(arguments, 1),
                event = $.Event(type);
            //prepare argument for widget event trigger (we want type, event, data)
            // add the eventObject
            args.unshift(event);
            // add the type
            args.unshift(type);
            // concatenate other argument in one element (to respect widget pattern)
            args[2] = args.slice(2);
            // suppress other arguments (since they have been concatened)
            args = args.slice(0, 3);
            //trigger external event
            currentWidget._trigger.apply(currentWidget, args);
        },

        /**
         * Check if event name is valid
         *
         * @param eventName string
         * @private
         */
        _checkEventName: function documentController_checkEventName(eventName) {
            if (_.isString(eventName) && (eventName.indexOf("custom:") === 0 || _.find(eventList, function documentController_CheckEventType(currentEventType) {
                return currentEventType === eventName;
            }))) {
                return true;
            }
            throw new Error("The event type " + eventName + " is not known. It must be one of " + eventList.sort().join(" ,"));
        },

        /**
         * Check if the view is initialized
         *
         * @private
         */
        _checkInitialisedView: function documentController_checkInitialised() {
            if (!this._initializedView) {
                throw new ErrorModelNonInitialized("The widget view is not initialized, use fetchDocument to initialise it.");
            }
        },

        /**
         * Check if the model is initialized
         *
         * @private
         */
        _checkInitialisedModel: function documentController_checkInitialisedModel() {
            if (!this._initializedModel) {
                throw new ErrorModelNonInitialized();
            }
        },

        _registerOutputPromise: function documentController_registerOutputPromise(documentPromise, options) {
            var currentWidget = this;
            return new Promise(function documentController_reinitPromise(resolve, reject) {
                documentPromise.then(function documentController_reinitDone(values) {
                    if (options && _.isFunction(options.success)) {
                        try {
                            if (window.console.warn) {
                                window.console.warn("Callback \"success\" is deprecated use promise instead");
                            }
                            options.success.call($(currentWidget.element), values.documentProperties || {}, currentWidget.getProperties());
                        } catch (exception) {
                            if (window.dcp.logger) {
                                window.dcp.logger(exception);
                            } else {
                                console.error(exception);
                            }
                        }
                    }
                    resolve({
                        element: $(currentWidget.element),
                        previousDocument: values.documentProperties || {},
                        nextDocument: currentWidget.getProperties()
                    });
                }, function documentController_reinitFail(values) {
                    var errorArguments = values.arguments;
                    var errorMessage = { contentText: "Undefined error" };

                    if (values.arguments) {
                        try {
                            if (errorArguments && errorArguments[1] && errorArguments[1].responseJSON) {
                                errorMessage = errorArguments[1].responseJSON.messages[0];
                            }
                        } catch (e) {}
                        if (errorArguments && errorArguments[0] && errorArguments[0].eventPrevented) {
                            errorMessage = { contentText: "Event prevented" };
                        }
                        if (errorArguments && errorArguments[0] && errorArguments[0].errorMessage) {
                            errorMessage = errorArguments[0].errorMessage;
                        }
                    }
                    if (options && _.isFunction(options.error)) {
                        try {
                            if (window.console.warn) {
                                window.console.warn("Callback \"error\" is deprecated use promise instead");
                            }
                            options.error.call($(currentWidget.element), values.documentProperties || {}, null, errorMessage);
                        } catch (exception) {
                            window.dcp.logger(exception);
                        }
                    }
                    reject({
                        element: $(currentWidget.element),
                        previousDocument: values.documentProperties || {},
                        nextDocument: null,
                        errorMessage: errorMessage
                    });
                });
            });
        },

        /***************************************************************************************************************
         * External function
         **************************************************************************************************************/
        /**
         * Reinit the current document (close it and re-open it) : keep the same view, revision, etc...
         *
         * @param values object {"initid" : int, "revision" : int, "viewId" : string, "customClientData" : mixed}
         * @param options object {"success": fct, "error", fct}
         */
        reinitDocument: function documentControllerReinitDocument(values, options) {
            var properties = this.getProperties();
            this._checkInitialisedModel();
            values = values || {};

            //Reinit model with server values
            _.defaults(values, { revision: properties.revision, viewId: properties.viewId, initid: properties.initid });

            return this.fetchDocument(values, options);
        },

        /**
         * Fetch a new document
         * @param values object {"initid" : int, "revision" : int, "viewId" : string, "customClientData" : mixed}
         * @param options object {"success": fct, "error", fct}
         */
        fetchDocument: function documentControllerFetchDocument(values, options) {
            var documentPromise, callBackPromise;
            var currentWidget = this;
            values = _.isUndefined(values) ? {} : values;
            options = options || {};

            if (!_.isObject(values)) {
                throw new Error('Fetch argument must be an object {"initid":, "revision": , "viewId": }');
            }

            if (!values.initid) {
                throw new Error('initid argument is mandatory');
            }

            if (!isNaN(values.initid)) {
                // Convert to numeric initid is possible
                values.initid = parseInt(values.initid);
            }

            // Use default values when fetch another document
            _.defaults(values, { revision: -1, viewId: "!defaultConsultation" });
            _.defaults(options, { force: false });

            _.each(_.pick(values, "initid", "revision", "viewId"), function dcpDocument_setNewOptions(value, key) {
                currentWidget.options[key] = value;
            });

            if (!this._model) {
                documentPromise = this._initializeWidget(options, values.customClientData);
            } else {
                if (values.customClientData) {
                    this._model._customClientData = values.customClientData;
                }

                if (this._model.isModified() && options.force === false) {
                    callBackPromise = this._model._promiseCallback();
                    this._model.trigger("loadDocument", this._getModelValue(), {
                        success: callBackPromise.success,
                        error: callBackPromise.error
                    });
                    documentPromise = callBackPromise.promise;
                } else {
                    documentPromise = this._model.fetchDocument(this._getModelValue());
                }
            }
            return this._registerOutputPromise(documentPromise, options);
        },

        /**
         * Save the current document
         * Reload the interface in the same mode
         * @param options object {"success": fct, "error", fct, "customClientData" : mixed}
         *
         */
        saveDocument: function documentControllerSave(options) {
            var documentPromise;
            options = options || {};
            this._checkInitialisedModel();
            if (options.customClientData) {
                this._model._customClientData = options.customClientData;
            }
            documentPromise = this._model.saveDocument();
            return this._registerOutputPromise(documentPromise, options);
        },

        /**
         * Change the workflow state of the document
         *
         * @param parameters
         * @param reinitOptions
         * @param options
         */
        changeStateDocument: function documentController_changeStateDocument(parameters, reinitOptions, options) {
            var documentPromise;
            this._checkInitialisedModel();
            if (!_.isObject(parameters)) {
                throw new Error('changeStateDocument first argument must be an object {"nextState":, "transition": , "values":, "unattended":, "" }');
            }
            if (!_.isString(parameters.nextState) || !_.isString(parameters.transition)) {
                throw new Error('nextState and transition arguments are mandatory');
            }
            documentPromise = this._initAndDisplayTransition(parameters.nextState, parameters.transition, parameters.values || null, parameters.unattended || false, reinitOptions);
            return this._registerOutputPromise(documentPromise, options);
        },

        /**
         * Delete the current document
         * Reload the interface in the same mode
         * @param options object {"success": fct, "error", fct, "customClientData" : mixed}
         */
        deleteDocument: function documentControllerDelete(options) {
            var documentPromise;
            options = options || {};
            this._checkInitialisedModel();
            if (options.customClientData) {
                this._model._customClientData = options.customClientData;
            }
            documentPromise = this._model.deleteDocument();
            return this._registerOutputPromise(documentPromise, options);
        },

        /**
         * Restore the current document
         * Reload the interface in the same mode
         * @param options object {"success": fct, "error", fct, "customClientData" : mixed}
         */
        restoreDocument: function documentControllerRestore(options) {
            var documentPromise;
            options = options || {};
            this._checkInitialisedModel();
            if (options.customClientData) {
                this._model._customClientData = options.customClientData;
            }
            documentPromise = this._model.restoreDocument();
            return this._registerOutputPromise(documentPromise, options);
        },

        /**
         * Get a property value
         *
         * @param property
         * @returns {*}
         */
        getProperty: function documentControllerGetDocumentProperty(property) {
            this._checkInitialisedModel();
            if (property === "isModified") {
                return this._model.isModified();
            }
            return this._model.getServerProperties()[property];
        },

        /**
         * Get all the properties
         * @returns {*}
         */
        getProperties: function documentControllerGetDocumentProperties() {
            var properties,
                ready = true;
            try {
                this._checkInitialisedModel();
            } catch (e) {
                ready = false;
                properties = {
                    "notLoaded": true
                };
            }
            if (ready) {
                properties = this._model.getServerProperties();
                properties.isModified = this._model.isModified();
                properties.url = window.location.href;
            }

            return properties;
        },

        /**
         * Check if an attribute exist
         *
         * @param attributeId
         * @return {boolean}
         */
        hasAttribute: function documentController_hasAttribute(attributeId) {
            this._checkInitialisedModel();
            var attribute = this._model.get("attributes").get(attributeId);
            return !!attribute;
        },

        /**
         * Get the attribute interface object
         *
         * @param attributeId
         * @returns AttributeInterface
         */
        getAttribute: function documentControllerGetAttribute(attributeId) {
            this._checkInitialisedModel();
            var attributeModel = this._getAttributeModel(attributeId);
            if (!attributeModel) {
                return undefined;
            }
            return new AttributeInterface(this._getAttributeModel(attributeId));
        },

        /**
         * Get all the attributes of the current document
         *
         * @returns [AttributeInterface]
         */
        getAttributes: function documentControllerGetAttributes() {
            this._checkInitialisedModel();
            return this._model.get("attributes").map(function documentController_mapAttribute(currentAttribute) {
                return new AttributeInterface(currentAttribute);
            });
        },

        /**
         * Check if a menu exist
         *
         * @param menuId
         * @return {boolean}
         */
        hasMenu: function documentController_hasMenu(menuId) {
            this._checkInitialisedModel();
            var menu = this._getMenuModel(menuId);
            return !!menu;
        },

        /**
         * Get the menu interface object
         *
         * @param menuId
         * @returns MenuInterface
         */
        getMenu: function documentControllerGetMenu(menuId) {
            this._checkInitialisedModel();
            var menu = this._getMenuModel(menuId);
            if (!menu) {
                return null;
            }
            return new MenuInterface(menu);
        },

        /**
         * Get all the menu of the current document
         *
         * @returns [MenuInterface]
         */
        getMenus: function documentControllerGetMenus() {
            this._checkInitialisedModel();
            return this._model.get("menus").map(function documentController_mapMenu(currentMenu) {
                return new MenuInterface(currentMenu);
            });
        },

        /**
         * Get an attribute value
         *
         * @param attributeId
         * @param type string (current|previous|initial|all) what kind of value (default : current)
         * @returns {*}
         */
        getValue: function documentControllerGetValue(attributeId, type) {
            var attribute;
            this._checkInitialisedModel();
            var attributeModel = this._getAttributeModel(attributeId);
            if (!attributeModel) {
                return null;
            }
            attribute = new AttributeInterface(attributeModel);
            return attribute.getValue(type);
        },

        /**
         * Get all the values
         *
         * @returns {*|{}}
         */
        getValues: function documentControllerGetValues() {
            this._checkInitialisedModel();
            return this._model.getValues();
        },

        /**
         * Get customData from render view model
         * @returns {*}
         */
        getCustomServerData: function documentControllerGetServerCustomData() {
            this._checkInitialisedModel();
            return this._model.get("customServerData");
        },
        /**
         * Add customData from render view model
         * @returns {*}
         */
        addCustomClientData: function documentControllerAddCustomClientData(documentCheck, value) {
            var currentWidget = this;
            this._checkInitialisedModel();
            //First case no data, so documentCheck is data
            if (_.isUndefined(value)) {
                value = documentCheck;
                documentCheck = {};
            }
            //Second case documentCheck is a function and data is object
            if (_.isFunction(documentCheck) && _.isObject(value)) {
                documentCheck = { "documentCheck": documentCheck };
            }
            //Third case documentCheck is an object and data is object => check if documentCheck property exist
            if (_.isObject(value) && _.isObject(documentCheck)) {
                documentCheck = _.defaults(documentCheck, {
                    "documentCheck": function clientCustomOK() {
                        return true;
                    },
                    once: true
                });
            } else {
                throw new Error("Constraint must be an value or a function and a value");
            }
            //Register the customClientData
            _.each(value, function documentControllerAddCustomClientDataEach(currentValue, currentKey) {
                currentWidget._customClientData[currentKey] = {
                    "value": currentValue,
                    "documentCheck": documentCheck.documentCheck,
                    "once": documentCheck.once
                };
            });
        },
        /**
         * Get customData from render view model
         * @returns {*}
         */
        setCustomClientData: function documentControllerSetCustomClientData(documentCheck, value) {
            console.error("this function (setCustomClientData) is deprecated");
            return this.addCustomClientData(documentCheck, value);
        },
        /**
         * Get customData from render view model
         * @returns {*}
         */
        getCustomClientData: function documentControllerSetCustomClientData(deleteOnce) {
            var values = {},
                currentWidget = this,
                $element,
                properties,
                newCustomData = {};
            this._checkInitialisedModel();
            properties = this.getProperties();
            $element = $(currentWidget.element);
            _.each(currentWidget._customClientData, function analyzeCustomClient(currentCustom, key) {
                if (currentCustom.documentCheck.call($element, properties)) {
                    values[key] = currentCustom.value;
                    if (deleteOnce === true && !currentCustom.once) {
                        newCustomData[key] = currentCustom;
                    }
                } else {
                    if (deleteOnce === true) {
                        newCustomData[key] = currentCustom;
                    }
                }
            });
            if (deleteOnce === true) {
                currentWidget._customClientData = newCustomData;
            }
            return values;
        },

        /**
         * Delete a custom data
         * @returns {*}
         */
        removeCustomClientData: function documentControllerRemoveCustomClientData(key) {
            if (this._customClientData[key]) {
                delete this._customClientData[key];
            }
            return this;
        },
        /**
         * Set a value
         * Trigger a change event
         *
         * @param attributeId string attribute identifier
         * @param value object { "value" : *, "displayValue" : *}
         * @returns {*}
         */
        setValue: function documentControllerSetValue(attributeId, value) {
            this._checkInitialisedModel();
            var attributeModel = this._getAttributeModel(attributeId);
            if (!attributeModel) {
                throw new Error("Unable to find attribute " + attributeId);
            }
            var attributeInterface = new AttributeInterface(attributeModel);
            var index;
            var currentValueLength;
            var i;

            if (attributeModel.getParent().get("type") === "array") {
                attributeInterface.setValue(value, true); // Just verify value conditions
                if (!_.isArray(value)) {
                    index = value.index;
                } else {
                    index = value.length - 1;
                }
                currentValueLength = attributeInterface.getValue().length;

                // Add new necessary rows before set value
                for (i = currentValueLength; i <= index; i++) {
                    this.appendArrayRow(attributeModel.getParent(), {});
                }
            }
            return attributeInterface.setValue(value);
        },

        /**
         * Add a row to an array
         *
         * @param attributeId string attribute array
         * @param values object { "attributeId" : { "value" : *, "displayValue" : * }, ...}
         */
        appendArrayRow: function documentControllerAddArrayRow(attributeId, values) {
            this._checkInitialisedModel();
            var attribute = this._getAttributeModel(attributeId);

            if (!attribute) {
                throw new Error("Unable to find attribute " + attributeId);
            }

            if (attribute.get("type") !== "array") {
                throw new Error("Attribute " + attributeId + " must be an attribute of type array");
            }
            if (!_.isObject(values)) {
                throw new Error("Values must be an object where each properties is an attribute of the array for " + attributeId);
            }
            attribute.get("content").each(function documentController_addACell(currentAttribute) {
                var newValue = values[currentAttribute.id];
                var currentValue = currentAttribute.getValue();
                if (_.isUndefined(newValue)) {
                    // Set default value if no value defined
                    currentAttribute.createIndexedValue(currentValue.length, false, _.isEmpty(values));
                } else {
                    newValue = _.defaults(newValue, { value: "", displayValue: newValue.value });
                    currentAttribute.addValue(newValue);
                }
            });
        },

        /**
         * Add a row before another row
         *
         * @param attributeId string attribute array
         * @param values object { "attributeId" : { "value" : *, "displayValue" : * }, ...}
         * @param index int index of the row
         */
        insertBeforeArrayRow: function documentControllerInsertBeforeArrayRow(attributeId, values, index) {
            this._checkInitialisedModel();
            var attribute = this._getAttributeModel(attributeId),
                maxValue;
            if (!attribute) {
                throw new Error("Unable to find attribute " + attributeId);
            }
            if (attribute.get("type") !== "array") {
                throw new Error("Attribute " + attributeId + " must be an attribute of type array");
            }
            if (!_.isObject(values)) {
                throw new Error("Values must be an object where each properties is an attribute of the array for " + attributeId);
            }
            maxValue = this._getMaxIndex(attribute);
            if (index < 0 || index > maxValue) {
                throw new Error("Index must be between 0 and " + maxValue);
            }
            attribute.get("content").each(function documentController_addACell(currentAttribute) {
                var currentValue = values[currentAttribute.id];
                if (!_.isUndefined(currentValue)) {
                    currentValue = _.defaults(currentValue, { value: "", displayValue: currentValue.value });
                } else {
                    currentValue = currentAttribute.attributes.defaultValue;
                    if (!currentValue) {
                        currentValue = { value: "", displayValue: "" };
                    }
                }
                currentAttribute.addIndexedValue(currentValue, index);
            });
        },

        /**
         * Remove an array row
         * @param attributeId string attribute array
         * @param index int index of the row
         */
        removeArrayRow: function documentControllerRemoveArrayRow(attributeId, index) {
            this._checkInitialisedModel();
            var attribute = this._getAttributeModel(attributeId),
                maxIndex;
            if (!attribute) {
                throw new Error("Unable to find attribute " + attributeId);
            }
            if (attribute.get("type") !== "array") {
                throw Error("Attribute " + attributeId + " must be an attribute of type array");
            }
            maxIndex = this._getMaxIndex(attribute) - 1;
            if (index < 0 || index > maxIndex) {
                throw Error("Index must be between 0 and " + maxIndex + " for " + attributeId);
            }
            attribute.get("content").each(function documentController_removeACell(currentAttribute) {
                currentAttribute.removeIndexValue(index);
            });
            attribute.removeIndexedLine(index);
        },

        /**
         * Add a constraint to the widget
         *
         * @param options object { "name" : string, "documentCheck": function}
         * @param callback function callback called when the event is triggered
         * @returns {*}
         */
        addConstraint: function documentControlleraddConstraint(options, callback) {
            var currentConstraint,
                currentWidget = this,
                uniqueName;
            if (_.isUndefined(callback) && _.isFunction(options)) {
                callback = options;
                options = {};
            }
            if (_.isObject(options) && _.isUndefined(callback)) {
                if (!options.name) {
                    throw new Error("When a constraint is initiated with a single object, this object needs to have the name property ".JSON.stringify(options));
                }
            } else {
                _.defaults(options, {
                    "documentCheck": function documentController_defaultDocumentCheck() {
                        return true;
                    },
                    "attributeCheck": function documentController_defaultAttributeCheck() {
                        return true;
                    },
                    "constraintCheck": callback,
                    "name": _.uniqueId("constraint"),
                    "externalConstraint": false,
                    "once": false
                });
            }
            currentConstraint = options;
            if (!_.isFunction(currentConstraint.constraintCheck)) {
                throw new Error("An event need a callback");
            }
            //If constraint is once : wrap it an callback that execute callback and delete it
            if (currentConstraint.once === true) {
                currentConstraint.eventCallback = _.wrap(currentConstraint.constraintCheck, function documentController_onceWrapper(callback) {
                    try {
                        callback.apply(this, _.rest(arguments));
                    } catch (e) {
                        console.error(e);
                    }
                    currentWidget.removeConstraint(currentConstraint.name, currentConstraint.externalConstraint);
                });
            }
            uniqueName = (currentConstraint.externalConstraint ? "external_" : "internal_") + currentConstraint.name;
            this.options.constraintList[uniqueName] = currentConstraint;
            this._initActivatedConstraint();
            return currentConstraint.name;
        },

        /**
         * List the constraint of the widget
         *
         * @returns {*}
         */
        listConstraints: function documentControllerListConstraint() {
            return this.options.constraintList;
        },

        /**
         * Remove a constraint of the widget
         *
         * @param constraintName
         * @param allKind
         * @returns {*}
         */
        removeConstraint: function documentControllerRemoveConstraint(constraintName, allKind) {
            var removed = [],
                newConstraintList,
                constraintList,
                testRegExp = new RegExp("\\" + constraintName + "$");
            // jscs:disable disallowImplicitTypeConversion
            allKind = !!allKind;
            // jscs:enable disallowImplicitTypeConversion
            newConstraintList = _.filter(this.options.constraintList, function documentController_removeConstraint(currentConstrait) {
                if ((allKind || !currentConstrait.externalConstraint) && (currentConstrait.name === constraintName || testRegExp.test(currentConstrait.name))) {
                    removed.push(currentConstrait);
                    return false;
                }
                return true;
            });
            constraintList = {};
            _.each(newConstraintList, function documentController_rebuildConstraintList(currentConstraint) {
                var uniqueName = (currentConstraint.externalConstraint ? "external_" : "internal_") + currentConstraint.name;
                constraintList[uniqueName] = currentConstraint;
            });
            this.options.constraintList = constraintList;
            this._initActivatedConstraint();
            return removed;
        },

        /**
         * Add an event to the widget
         *
         * @param eventType string kind of event
         * @param options object { "name" : string, "documentCheck": function}
         * @param callback function callback called when the event is triggered
         * @returns {*|Window.options.name}
         */
        addEventListener: function documentControllerAddEvent(eventType, options, callback) {
            var currentEvent,
                currentWidget = this;
            //options is not mandatory and the callback can be the second parameters
            if (_.isUndefined(callback) && _.isFunction(options)) {
                callback = options;
                options = {};
            }
            // the first parameters can be the final object (chain removeEvent and addEvent)
            if (_.isObject(eventType) && _.isUndefined(options) && _.isUndefined(callback)) {
                currentEvent = eventType;
                if (!currentEvent.name) {
                    throw new Error("When an event is initiated with a single object, this object needs to have the name property " + JSON.stringify(currentEvent));
                }
            } else {
                currentEvent = _.defaults(options, {
                    "name": _.uniqueId("event_" + eventType),
                    "eventType": eventType,
                    "eventCallback": callback,
                    "externalEvent": false,
                    "once": false
                });
            }
            // the eventType must be one the list
            this._checkEventName(currentEvent.eventType);
            // callback is mandatory and must be a function
            if (!_.isFunction(currentEvent.eventCallback)) {
                throw new Error("An event needs a callback that is a function");
            }
            //If event is once : wrap it an callback that execute event and delete it
            if (currentEvent.once === true) {
                currentEvent.eventCallback = _.wrap(currentEvent.eventCallback, function documentController_onceWrapper(callback) {
                    currentWidget.removeEventListener(currentEvent.name, currentEvent.externalEvent);
                    try {
                        callback.apply(this, _.rest(arguments));
                    } catch (e) {
                        console.error(e);
                    }
                });
            }
            this._addAndInitNewEvents(currentEvent);
            // return the name of the event
            return currentEvent.name;
        },

        /**
         * List of the events of the current widget
         *
         * @returns {*}
         */
        listEventListeners: function documentControllerListEvents() {
            return this.options.eventListener;
        },

        /**
         * Remove an event of the current widget
         *
         * @param eventName string can be an event name or a namespace
         * @param allKind remove internal/external events
         * @returns {*}
         */
        removeEventListener: function documentControllerRemoveEvent(eventName, allKind) {
            var removed = [],
                testRegExp = new RegExp("\\" + eventName + "$"),
                newList,
                eventList;
            // jscs:disable
            allKind = !!allKind;
            // jscs:enable
            newList = _.filter(this.options.eventListener, function documentController_removeCurrentEvent(currentEvent) {
                if ((allKind || !currentEvent.externalEvent) && (currentEvent.name === eventName || testRegExp.test(currentEvent.name))) {
                    removed.push(currentEvent);
                    return false;
                }
                return true;
            });
            eventList = {};
            _.each(newList, function documentController__rebuildEventList(currentEvent) {
                var uniqueName = (currentEvent.externalEvent ? "external_" : "internal_") + currentEvent.name;
                eventList[uniqueName] = currentEvent;
            });
            this.options.eventListener = eventList;
            this._initActivatedEventListeners({ "launchReady": false });
            return removed;
        },

        /**
         * Trigger an event
         *
         * @param eventName
         */
        triggerEvent: function documentController_triggerEvent(eventName) {
            this._checkInitialisedModel();
            this._checkEventName(eventName);
            return this._triggerControllerEvent.apply(this, arguments);
        },

        /**
         * Hide a visible attribute
         *
         * @param attributeId
         */
        hideAttribute: function documentControllerHideAttribute(attributeId) {
            this._checkInitialisedView();
            var attributeModel = this._getAttributeModel(attributeId);
            if (!attributeModel) {
                console.log("Unable find and hide the attribute " + attributeId);
                return;
            }
            attributeModel.trigger("hide");
        },
        /**
         * show a visible attribute (previously hidden)
         *
         * @param attributeId
         */
        showAttribute: function documentControllerShowAttribute(attributeId) {
            this._checkInitialisedView();
            var attributeModel = this._getAttributeModel(attributeId);
            if (!attributeModel) {
                console.log("Unable find and show the attribute " + attributeId);
                return;
            }
            attributeModel.trigger("show");
        },

        /**
         * Display a message to the user
         *
         * @param message
         */
        showMessage: function documentControllerShowMessage(message) {
            this._checkInitialisedView();
            if (_.isString(message)) {
                message = {
                    type: "info",
                    message: message
                };
            }
            if (_.isObject(message)) {
                message = _.defaults(message, {
                    type: "info"
                });
            }
            this.$notification.dcpNotification("show", message.type, message);
        },

        /**
         * Display loading bar
         *
         * @param message
         * @param px
         */
        maskDocument: function documentController(message, px) {
            this.$loading.dcpLoading('show');
            if (message) {
                this.$loading.dcpLoading('setTitle', message);
            }
            if (px) {
                this.$loading.dcpLoading('setPercent', px);
            }
        },

        /**
         * Hide loading bar
         */
        unmaskDocument: function documentController_unmaskDocument(force) {
            this.$loading.dcpLoading('hide', force);
        },

        /**
         * Add an error message to an attribute
         *
         * @param attributeId
         * @param message
         * @param index
         */
        setAttributeErrorMessage: function documentControllersetAttributeErrorMessage(attributeId, message, index) {
            this._checkInitialisedView();
            var attributeModel = this._getAttributeModel(attributeId);
            if (!attributeModel) {
                console.log("Unable find and show the attribute " + attributeId);
                return;
            }
            attributeModel.setErrorMessage(message, index);
        },

        /**
         * Clean the error message of an attribute
         *
         * @param attributeId
         * @param index
         */
        cleanAttributeErrorMessage: function documentControllercleanAttributeErrorMessage(attributeId, index) {
            this._checkInitialisedView();
            var attributeModel = this._getAttributeModel(attributeId);
            if (!attributeModel) {
                console.log("Unable find and show the attribute " + attributeId);
                return;
            }
            attributeModel.setErrorMessage(null, index);
        },

        injectCSS: function documentController_injectCSS(cssToInject) {
            this._checkInitialisedView();
            if (!_.isArray(cssToInject) && !_.isString(cssToInject)) {
                throw new Error("The css to inject must be an array string or a string");
            }
            if (_.isString(cssToInject)) {
                cssToInject = [cssToInject];
            }

            this._model.injectCSS(cssToInject);
        },

        injectJS: function documentController_injectCSS(jsToInject) {
            this._checkInitialisedView();
            if (!_.isArray(jsToInject) && !_.isString(jsToInject)) {
                throw new Error("The js to inject must be an array string or a string");
            }
            if (_.isString(jsToInject)) {
                jsToInject = [jsToInject];
            }

            return this._model.injectJS(jsToInject);
        }

    });

    return $.fn.documentController;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/history/wHistory.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/widget.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/history/wRevisionDiff.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/window/wDialog.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function require_whistory($, _, Mustache) {
    'use strict';

    $.widget("dcp.dcpDocumentHistory", $.dcp.dcpDialog, {
        options: {
            documentId: 0,
            window: {
                modal: true,
                title: "Document history"
            },
            labels: {
                version: "Version",
                revision: "Rev",
                state: "State",
                activity: "Activity",
                owner: "Owner",
                code: "Code",
                date: "Date",
                diff: "Diff",
                level: "Level",
                message: "Message",
                pastRevision: "",
                showDetail: "Show details",
                hideDetail: "Hide details",
                showNotice: "Show notices",
                hideNotice: "Hide notices",
                noOneNotice: "No one notices",
                filterMessages: "Filter messages",
                linkRevision: "See revision number #",
                historyTitle: "History for {{title}}",
                loading: "Loading ...",
                revisionDiffLabels: {}
            }
        },
        htmlCaneva: function dcpDocumentHistoryhtmlCaneva() {
            return '<table class="history-main"><thead>' + '<tr class="history-header">' + '<th class="history-header--date"/>' + '<th class="history-header--message"/>' + '<th class="history-header--owner"/>' + '<th class="history-header--version"/>' + '<th class="history-header--revision"/>' + '<th class="history-header--code"/>' + '<th class="history-header--level"/>' + '<th class="history-header--diff"/>' + '</tr>' + '</thead></table>';
        },

        element: null,
        _create: function dcpDocumentHistory_create() {
            var widget = this,
                $widget = $(this);

            this.element.html(this.htmlCaneva());
            __webpack_require__.e/* require.ensure */("ensureDatatables").then((function dcpDocumentWHistory_initTable() {
                __webpack_require__("./node_modules/datatables.net-bs4/css/dataTables.bootstrap4.css");
                __webpack_require__("./node_modules/datatables.net/js/jquery.dataTables.js");
                widget._initDatatable();
            }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);

            this.element.data("dcpDocumentHistory", this);

            this._super();

            this.element.on("click" + this.eventNamespace, ".history-button-showdetail", function whistoryShowDetail() {
                var noticeButton = widget.element.find(".history-button-shownotice");
                var noticeShowed = noticeButton.data("showNotice");
                if ($widget.data("showDetail")) {
                    $widget.data("showDetail", false);
                    $widget.data("showNotice", false);
                    $(this).text(widget.options.labels.showDetail).removeClass("btn-primary");
                    widget.element.find(".history-comment").hide();

                    noticeButton.attr("disabled", "disabled").removeClass("btn-primary").text(widget.options.labels.showNotice);
                } else {
                    $widget.data("showDetail", true);
                    widget.element.find(".history-comment").show();
                    if (!noticeShowed) {
                        widget.element.find(".history-level--notice").hide();
                    }
                    $(this).text(widget.options.labels.hideDetail).addClass("btn-primary");
                    noticeButton.removeAttr("disabled");
                }
            });
            this.element.on("click" + this.eventNamespace, ".history-button-shownotice", function whistoryShowNotice() {
                var $notices = widget.element.find(".history-level--notice");
                if ($widget.data("showNotice")) {
                    $widget.data("showNotice", false);
                    $(this).text(widget.options.labels.showNotice).removeClass("btn-primary");
                    widget.element.find(".history-level--notice").hide();
                } else {
                    $widget.data("showNotice", true);
                    if ($notices.length > 0) {
                        $notices.show();
                        $(this).text(widget.options.labels.hideNotice).addClass("btn-primary");
                    } else {

                        $(this).text(widget.options.labels.noOneNotice);
                    }
                }
            });
            this.element.on("click" + this.eventNamespace, ".history-diff-input", function whistoryShowDiff() {
                var selectedDiff = widget.element.find(".history-diff-input:checked");

                if (selectedDiff.length === 2) {
                    widget.element.find(".history-diff-input:not(:checked)").attr("disabled", "disabled");
                    var $diffTarget = $('<div class="revision-diff"/>');
                    var diffWidget = $diffTarget.dcpRevisionDiff({
                        documentId: widget.options.documentId,
                        firstRevision: $(selectedDiff.get(1)).data("revision"),
                        secondRevision: $(selectedDiff.get(0)).data("revision"),
                        window: {
                            width: "70%",
                            height: "70%",
                            title: widget.options.labels.revisionDiffLabels.title
                        },
                        labels: widget.options.labels.revisionDiffLabels
                    }).data("dcpRevisionDiff");

                    diffWidget.open();
                } else if (selectedDiff.length < 2) {
                    widget.element.find(".history-diff-input").removeAttr("disabled", "disabled");
                }
            });

            this.element.on("click" + this.eventNamespace, "a[data-document-id]", function whistoryShowDocument(event) {
                var docid = $widget.data("document-id");
                if (docid) {
                    event.preventDefault();
                    widget.element.trigger("viewRevision", {
                        initid: docid,
                        revision: parseInt($widget.data("revision"))
                    });
                }
            });
        },

        _fillDataTable: function dcpDocumentHistory_fillDataTable(data) {
            var myData = [];

            this.dialogWindow.setOptions({
                title: Mustache.render(this.options.labels.historyTitle, data.data.history[0].properties)
            });

            _.each(data.data.history, function whistoryFillRevision(revisionInfo) {
                myData.push({
                    "version": revisionInfo.properties.version,
                    "revision": revisionInfo.properties.revision,
                    "code": '',
                    "level": 'revision',
                    "message": revisionInfo.properties,
                    "owner": revisionInfo.properties.owner.title,
                    "date": revisionInfo.properties.revisionDate,
                    "diff": 1,
                    "color": revisionInfo.properties.state.color,
                    "DT_RowClass": "history-level--revision"
                });
                _.each(revisionInfo.messages, function whistoryFillMessage(message) {
                    myData.push({
                        "version": '',
                        "revision": '',
                        "code": message.code,
                        "level": message.level,
                        "message": message.comment,
                        "owner": message.uname,
                        "date": message.date,
                        "diff": 0,
                        "DT_RowClass": "history-comment history-level--" + message.level + (revisionInfo.properties.status === "fixed" ? " history-comment--fixed" : "")
                    });
                });
            });

            return myData;
        },

        _initDatatable: function dcpDocumentHistory_initDatatable() {

            var historyWidget = this;
            this.element.find('.history-main').dataTable({
                "autoWidth": false,
                "ordering": false,
                "dom": "<'history-head'<'history-buttons'>f>rtip",
                "paging": false,
                // "scrollY": "200px",
                "scrollCollapse": false,
                "info": false,
                "language": {
                    "search": " ",
                    "loadingRecords": this.options.labels.loading
                },
                "columns": [{
                    data: "date",
                    name: "date",
                    title: historyWidget.options.labels.date,
                    className: "history-date",
                    "render": function whistoryRenderDate(data) {
                        var theDate = new Date(data.substr(0, 10));
                        // The time is not manage by date because each navigator defer with timezone
                        return kendo.toString(theDate, "D") + ' ' + data.substr(11, 8);
                    }
                }, {
                    data: "message",
                    name: "message",
                    title: historyWidget.options.labels.message,
                    className: "history-message",
                    render: function whistoryRenderMessage(data) {
                        if (_.isObject(data)) {
                            if (data.state.reference) {

                                return '<div class="history-state"><span class="history-state-color" style="background-color:' + data.state.color + '" >&nbsp;</span>' + '<span class="history-state-label">' + (data.status === "fixed" ? data.state.stateLabel : data.state.activity) + '</span></div>';
                            }
                            return $("<div/>").text(data.title).html();
                        } else {
                            return $("<div/>").text(data).html();
                        }
                    }
                }, {
                    data: "owner",
                    name: "owner",
                    title: historyWidget.options.labels.owner,
                    className: "history-owner",
                    render: function whistoryEncodeMessage(data) {
                        return $("<div/>").text(data).html();
                    }
                }, {
                    data: "version",
                    name: "version",
                    title: historyWidget.options.labels.version,
                    className: "history-version",
                    visible: false,
                    render: function whistoryEncodeMessage(data) {
                        return $("<div/>").text(data).html();
                    }
                }, {
                    data: "revision",
                    name: "revision",
                    title: historyWidget.options.labels.revision,
                    className: "history-revision",
                    render: function whistoryRenderRevision(data) {
                        if (data !== '') {
                            return '<a class="history-revision-link btn btn-default" href="api/v1/documents/' + historyWidget.options.documentId + '/revisions/' + data + '.html"' + 'data-document-id="' + historyWidget.options.documentId + '" ' + 'data-revision="' + data + '"' + '>' + historyWidget.options.labels.linkRevision.replace('#', data) + '</a>';
                        } else {
                            return data;
                        }
                    }
                }, {
                    data: "code",
                    name: "code",
                    title: historyWidget.options.labels.code,
                    className: "history-code",
                    visible: false,
                    render: function whistoryEncodeMessage(data) {
                        return $("<div/>").text(data).html();
                    }
                }, {
                    data: "level",
                    name: "level",
                    title: historyWidget.options.labels.level,
                    className: "history-level",
                    visible: false,
                    render: function whistoryEncodeMessage(data) {
                        return $("<div/>").text(data).html();
                    }
                }, {
                    data: "diff",
                    name: "diff",
                    title: historyWidget.options.labels.diff,
                    className: "history-diff",
                    render: function whistoryRenderDiff(data, renderType, allData) {

                        if (data === 1) {
                            return '<input class="history-diff-input" data-revision="' + allData.revision + '" type="checkbox"/>';
                        } else {
                            return '';
                        }
                    }
                }],

                "drawCallback": function whistorydrawCallback() {

                    var noticeShowed = historyWidget.element.find(".history-button-shownotice").data("showNotice");
                    var detailShowed = historyWidget.element.find(".history-button-showdetail").data("showDetail");

                    if (detailShowed) {
                        historyWidget.element.find(".history-comment").show();
                        if (!noticeShowed) {
                            historyWidget.element.find(".history-level--notice").hide();
                        }
                    } else {
                        historyWidget.element.find(".history-comment").hide();
                    }
                },

                "initComplete": function whistoryinitComplete() {
                    var api = this.api();
                    var data = api.rows({ page: 'current' }).data();
                    // Output the data for the visible rows to the browser's console

                    // show version if not null in one row
                    var showVersion = false;
                    var showState = false;
                    var onlyOneRevision = true;
                    for (var i = 0; i < data.length; i++) {
                        if (data[i].version) {
                            showVersion = true;
                        }
                        if (data[i].revision > 0) {
                            onlyOneRevision = false;
                        }
                        if (data[i].message && data[i].message.state && data[i].message.state.reference) {
                            showState = true;
                        }
                    }
                    if (onlyOneRevision) {
                        //api.column("revision:name").visible(!onlyOneRevision);
                        historyWidget.element.find(".history-diff-input").attr("disabled", "disabled");
                    }

                    if (showVersion) {
                        api.column("version:name").visible(true);
                    }
                    if (showState) {
                        // Change Label
                        historyWidget.element.find(".history-header--message").html(historyWidget.options.labels.activity);
                    }
                    var fixedRevisionRow = historyWidget.element.find(".history-level--revision").get(1);
                    if (fixedRevisionRow) {
                        var trHead = historyWidget.element.find(".history-header").clone();
                        $('<tr class="history-separator"><td class="history-separator-cell" colspan="' + $(trHead).find('th').length + '"><span>' + historyWidget.options.labels.pastRevision + '</span>' + '</td></tr>').insertBefore(fixedRevisionRow);
                        $(trHead).insertBefore(fixedRevisionRow);
                        if (showState) {
                            $($(".history-header--message").get(1)).html(historyWidget.options.labels.state);
                        }
                    }
                    historyWidget.element.find(".history-comment").hide();
                    historyWidget.element.find(".odd").removeClass("odd");
                    historyWidget.element.find(".even").removeClass("even");
                    historyWidget.element.find(".dataTables_filter input").addClass("form-control form-control-sm");

                    if (historyWidget.element.find('.history-button-shownotice').length === 0) {
                        var $buttons = historyWidget.element.find(".history-buttons");

                        $buttons.append($('<button class="history-button-showdetail btn btn-secondary btn-sm" >' + historyWidget.options.labels.showDetail + '</button>'));
                        $buttons.append($('<button disabled="disabled" class="history-button-shownotice btn btn-outline-secondary btn-sm" >' + historyWidget.options.labels.showNotice + '</button>'));

                        historyWidget.element.find(".dataTables_filter input").attr("placeholder", historyWidget.options.labels.filterMessages);
                    }
                },

                "ajax": function whistory_getData(data, callback) {

                    $.getJSON("api/v1/documents/" + historyWidget.options.documentId + '/history/').done(function whistory_getDataDone(response) {
                        var tableData = historyWidget._fillDataTable(response);
                        callback({ data: tableData });
                    }).fail(function whistory_getDataFail(response) {
                        var result = JSON.parse(response.responseText);
                        _.each(result.messages, function whistory_getDataParseMessage(error) {
                            if (error.code === "CRUD0219" && error.uri) {
                                // redirect with the good trash uri
                                $.getJSON(error.uri.replace('.json', '') + '/history/').done(function whistory_getDataRedirect(response) {
                                    var tableData = historyWidget._fillDataTable(response);
                                    callback({ data: tableData });
                                }).fail(function whistory_getDataFail(response) {
                                    var result = JSON.parse(response.responseText);
                                    _.each(result.messages, function whistory_getDataFailParseMessage(error) {
                                        if (error.type === "error") {
                                            $('body').trigger("notification", {
                                                type: error.type,
                                                message: error.contentText
                                            });
                                        }
                                    });
                                    console.error("fail", response);
                                });
                            } else if (error.type === "error") {
                                $('body').trigger("notification", {
                                    type: error.type,
                                    message: error.contentText
                                });
                            }
                        });
                        console.error("fail", response);
                    });
                }
            }).addClass('table table-condensed table-bordered table-hover');
        },

        _destroy: function dcpDocumentHistory_destroy() {
            var $history = this.element.find('.history-main');

            if ($history.DataTable) {
                $history.DataTable().destroy();
            }
            this._super();
        }

    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/history/wRevisionDiff.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/widget.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/window/wDialog.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function require_revisiondiff($, _, Mustache) {
    'use strict';

    $.widget("dcp.dcpRevisionDiff", $.dcp.dcpDialog, {
        options: {
            documentId: 0,
            firstRevision: 0,
            secondRevision: 0,
            window: {
                modal: true,
                animation: {
                    open: {
                        effects: "fade:in",
                        duration: 1000
                    }, close: {
                        effects: "fade:out",
                        duration: 1000
                    }
                },
                actions: ["Maximize", "Close"],
                visible: false,
                height: "300px",
                width: "500px",
                title: "Document difference"
            },
            labels: {
                "first": "First document",
                "second": "Second document",
                "attributeId": "Attribute id",
                "attributeLabel": "Attribute label",
                "documentHeader": '"{{title}}"  (Revision : {{revision}}). <br/>Created on <em>{{revdate}}</em>',
                "filterMessages": "Filter data",
                "showOnlyDiff": "Show only differences",
                "showAll": "Show all"
            }
        },
        firstDocument: null,
        secondDocument: null,

        _create: function dcpRevisionDiff__create() {
            var currentWidget = this,
                $widget = $(this);

            this.element.html(this.htmlCaneva());
            __webpack_require__.e/* require */("ensureDatatables"/* duplicate */).then(function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__("./node_modules/datatables.net/js/jquery.dataTables.js")]; (function dcpDocumentWHistory_initTable() {
                __webpack_require__("./node_modules/datatables.net-bs4/css/dataTables.bootstrap4.css");
                __webpack_require__("./node_modules/datatables.net/js/jquery.dataTables.js");
                currentWidget._initDatatable();
            }.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}).catch("ensureDatatables".bind(this));

            this.element.data("dcpRevisionDiff", this);

            this._super();

            this.element.on("click" + this.eventNamespace, ".revision-diff-button-showonlydiff", function dcpRevisionDiff_showDiff() {
                if ($widget.data("showOnlyDiff")) {
                    $widget.data("showOnlyDiff", false);
                    $(this).text(currentWidget.options.labels.showOnlyDiff).removeClass("btn-primary");
                    currentWidget.element.find(".revision-diff-equal").show();
                } else {
                    $widget.data("showOnlyDiff", true);
                    currentWidget.element.find(".revision-diff-equal").hide();
                    $(this).text(currentWidget.options.labels.showAll).addClass("btn-primary");
                }
            });
        },

        htmlCaneva: function dcpRevisionDiff_htmlCaneva() {
            return '<table class="revision-diff-main"><thead>' + '<tr class="revision-diff-header">' + '<th class="revision-diff-header--attribute-id"/>' + '<th class="revision-diff-header--attribute-label"/>' + '<th class="revision-diff-header--first"/>' + '<th class="revision-diff-header--second"/>' + '</tr>' + '</thead></table>';
        },
        _initDatatable: function dcpRevisionDiff__initDatatable() {

            var revisionDiffWidget = this;
            this.element.find('.revision-diff-main').dataTable({
                "autoWidth": false,
                "ordering": false,
                "paging": false,
                "dom": "<'revision-head'<'revision-diff-buttons'>f>rtip",
                // "scrollY": "200px",
                "scrollCollapse": false,
                "info": false,
                "language": {
                    "search": " "
                },
                "columns": [{
                    data: "attributeId",
                    name: "attributeId",
                    title: revisionDiffWidget.options.labels.attributeId,
                    className: "revision-diff-attributeid",
                    visible: false
                }, {
                    data: "attributeLabel",
                    name: "attributeLabel",
                    title: revisionDiffWidget.options.labels.attributeLabel,
                    className: "revision-diff-attributelabel"

                }, {
                    data: "first",
                    name: "first",
                    title: revisionDiffWidget.options.labels.first,
                    className: "revision-diff-first",
                    render: function dcpRevisionDiff_renderFirst(data) {
                        if (_.isArray(data)) {
                            return _.pluck(data, 'displayValue').join(', ');
                        } else {
                            return data.displayValue;
                        }
                    }
                }, {
                    data: "second",
                    name: "second",
                    title: revisionDiffWidget.options.labels.second,
                    className: "revision-diff-second",
                    render: function dcpRevisionDiff_renderSecond(data) {
                        if (_.isArray(data)) {
                            return _.pluck(data, 'displayValue').join(', ');
                        } else {
                            return data.displayValue;
                        }
                    }
                }],

                "initComplete": function dcpRevisionDiff_initComplete() {
                    var api = this.api();
                    // var data = api.rows({page: 'current'}).data();
                    // Output the data for the visible rows to the browser's console
                    $(api.columns('first:name').header()).html(revisionDiffWidget._getDocHeader(revisionDiffWidget.firstDocument));
                    $(api.columns('second:name').header()).html(revisionDiffWidget._getDocHeader(revisionDiffWidget.secondDocument));
                    revisionDiffWidget.element.find(".dataTables_filter input").attr("placeholder", revisionDiffWidget.options.labels.filterMessages);

                    revisionDiffWidget.element.find(".dataTables_filter input").addClass("form-control form-control-sm");

                    var firstHeadCell = revisionDiffWidget.element.find(".revision-diff-buttons");
                    if (firstHeadCell.find('.revision-diff-button-showonlydiff').length === 0) {
                        firstHeadCell.append($('<button class="revision-diff-button-showonlydiff btn btn-secondary btn-sm" >' + revisionDiffWidget.options.labels.showOnlyDiff + '</button>'));
                    }
                },

                "ajax": function dcpRevisionDiff_getData(data, callback) {
                    var myData = [];

                    $.getJSON("api/v1/documents/" + revisionDiffWidget.options.documentId + "/revisions/" + revisionDiffWidget.options.firstRevision + ".json?fields=family.structure,document.properties.revdate,document.properties.revision,document.attributes").done(function dcpRevisionDiff_getDataDone(data1) {
                        revisionDiffWidget.firstDocument = data1.data.revision;
                        $.getJSON("api/v1/documents/" + revisionDiffWidget.options.documentId + "/revisions/" + revisionDiffWidget.options.secondRevision + ".json?fields=document.properties.revdate,document.properties.revision,document.attributes").done(function dcpRevisionDiff_getRevisionDone(data2) {
                            revisionDiffWidget.secondDocument = data2.data.revision;
                            _.each(data1.data.revision.attributes, function dcpRevisionDiff_analyzeAttribute(firstValue, index) {
                                var secondValue = data2.data.revision.attributes[index];
                                myData.push({
                                    attributeId: index,
                                    attributeLabel: revisionDiffWidget._findAttributeLabel(data1.data.family.structure, index),
                                    first: firstValue,
                                    second: secondValue,
                                    "DT_RowClass": revisionDiffWidget.isEqualAttributeValue(firstValue, secondValue) ? "revision-diff-equal" : "revision-diff-not-equal"
                                });
                            });
                            callback({ data: myData });
                        }).fail(function dcpRevisionDiff_getRevisionFail(xhr) {
                            var result = JSON.parse(xhr.responseText);
                            window.alert(result.exceptionMessage);
                        });
                    }).fail(function dcpRevisionDiff_getDataFail(xhr) {
                        var result = JSON.parse(xhr.responseText);
                        window.alert(result.exceptionMessage);
                    });
                }

            }).addClass('table table-condensed table-bordered table-hover');
        },

        isEqualAttributeValue: function dcpRevisionDiff_isEqualAttributeValue(v1, v2) {
            if (_.isEqual(v1, v2)) {
                return true;
            }

            if (_.isArray(v1) && _.isArray(v2)) {
                var values1 = _.pluck(v1, "value");
                var values2 = _.pluck(v2, "value");
                return _.isEqual(values1, values2);
            }
            return false;
        },

        _findAttributeLabel: function wRevisionDiffFindAttributeLabel(structure, aid) {
            var scope = this;
            var label = null;
            _.some(structure, function dcpRevisionDiff_analyzeAttribute(attributInfo, attributId) {
                if (attributId === aid) {
                    label = attributInfo.label;
                    return true;
                }
                if (_.isObject(attributInfo.content)) {
                    var contentLabel = scope._findAttributeLabel(attributInfo.content, aid);

                    if (contentLabel !== null) {
                        label = contentLabel;
                        return true;
                    }
                }
                return false;
            });
            return label;
        },

        _getDocHeader: function wRevisionDiffGetDocHeader(documentStructure) {
            var documentHeader = this.options.labels.documentHeader;
            return Mustache.render(documentHeader || "", documentStructure.properties);
        },

        _destroy: function _destroy() {
            var $history = this.element.find('.revision-diff-main');

            if ($history.DataTable) {
                $history.DataTable().destroy();
            }
            this._super();
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/menu/wMenu.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/i18n/documentCatalog.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/widget.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function wMenu($, _, Mustache, i18n) {
    'use strict';

    $.widget("dcp.dcpMenu", {

        options: {
            eventPrefix: "dcpmenu"
        },

        kendoMenuWidget: null,
        _create: function wMenuCreate() {
            this._tooltips = [];
            this.popupWindows = [];
            this._initStructure();
        },

        _initStructure: function wMenuInitStructure() {
            var $content,
                $mainElement,
                scopeWidget = this;
            //InitDom
            $mainElement = $(Mustache.render(this._getTemplate("menu") || "", _.extend({ uuid: this.uuid }, this.options)));
            $content = $mainElement.find(".menu__content");
            this._insertMenuContent(this.options.menus, $content);
            this.element.append($mainElement);
            //Init kendo widget
            $content.kendoMenu({
                openOnClick: true,
                closeOnClick: true,

                select: function wMenuSelect(event) {
                    var $menuElement = $(event.item),
                        eventContent,
                        $elementA,
                        href,
                        configMenu,
                        confirmText,
                        confirmOptions,
                        confirmDcpWindow,
                        target,
                        targetOptions,
                        dcpWindow,
                        $bodyDiv,
                        wFeature = '';

                    // Use specific select only for terminal items
                    if (!$menuElement.hasClass("menu__element--item")) {
                        return;
                    }
                    $elementA = $(event.item).find('a');
                    href = $elementA.data('url');
                    //noinspection JSHint
                    if (href != '') {
                        //Display confirm message
                        if ($elementA.hasClass("menu--confirm")) {
                            confirmText = Mustache.render($elementA.data('confirm-message') || "", scopeWidget.options);

                            configMenu = $menuElement.data("menuConfiguration");
                            confirmOptions = configMenu.confirmationOptions || {};
                            confirmDcpWindow = $('body').dcpConfirm({
                                title: Mustache.render(confirmOptions.title || "", scopeWidget.options),
                                width: confirmOptions.windowWidth,
                                height: confirmOptions.windowHeight,
                                messages: {
                                    okMessage: Mustache.render(confirmOptions.confirmButton || "", scopeWidget.options),
                                    cancelMessage: Mustache.render(confirmOptions.cancelButton || "", scopeWidget.options),
                                    htmlMessage: confirmText,
                                    textMessage: ''
                                },
                                confirm: function wMenuConfirm() {
                                    $elementA.removeClass('menu--confirm');
                                    $elementA.trigger("click");
                                    $elementA.addClass('menu--confirm');
                                },
                                templateData: scopeWidget.options
                            });

                            scopeWidget.popupWindows.push(confirmDcpWindow.data('dcpWindow'));

                            confirmDcpWindow.data('dcpWindow').open();
                        } else {
                            scopeWidget.element.data("menu-opening", false);
                            //if href is event kind propagate event instead of default behaviour
                            if (href.substring(0, 8) === "#action/") {
                                event.preventDefault();
                                if (event.stopPropagation) {
                                    event.stopPropagation();
                                }
                                eventContent = href.substring(8).split(":");
                                scopeWidget._trigger("externalLinkSelected", event, {
                                    target: event.target || event.item,
                                    eventId: eventContent.shift(),
                                    options: eventContent
                                });
                            } else {
                                var $base = $("base");
                                var isAbsUrl = new RegExp('^(?:[a-z]+:)?//', 'i');

                                target = $elementA.attr("target") || '_self';

                                if ($elementA.attr("href") && $elementA.attr("href").substring(0, 1) === "#") {
                                    href = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port : '') + (window.location.pathname ? window.location.pathname : '/') + (window.location.search ? window.location.search : '') + $elementA.attr("href");
                                }

                                if (target === "_self") {
                                    // For IE : Not honor base href in this case

                                    if (!isAbsUrl.test(href)) {
                                        window.location.href = $base.attr("href") + href;
                                    } else {
                                        window.location.href = href;
                                    }
                                } else {
                                    configMenu = $menuElement.data("menuConfiguration");
                                    targetOptions = configMenu.targetOptions || {};
                                    if (target === "_dialog") {
                                        $bodyDiv = $('<div/>');
                                        $('body').append($bodyDiv);
                                        dcpWindow = $bodyDiv.dcpWindow({
                                            title: Mustache.render(targetOptions.title || "", window.dcp.documentData),
                                            width: targetOptions.windowWidth,
                                            height: targetOptions.windowHeight,
                                            modal: targetOptions.modal,
                                            content: href,
                                            iframe: true
                                        });

                                        scopeWidget.popupWindows.push(dcpWindow.data('dcpWindow'));
                                        dcpWindow.data('dcpWindow').kendoWindow().center();
                                        dcpWindow.data('dcpWindow').open();
                                    } else {
                                        if (targetOptions && (targetOptions.windowWidth || targetOptions.windowHeight)) {
                                            if (targetOptions.windowWidth) {
                                                wFeature += "width=" + parseInt(targetOptions.windowWidth, 10) + ",";
                                            }
                                            if (targetOptions.windowHeight) {
                                                wFeature += "height=" + parseInt(targetOptions.windowHeight, 10) + ",";
                                            }
                                            wFeature += "resizable=yes,scrollbars=yes";
                                        }
                                        if (!isAbsUrl.test(href)) {
                                            // For IE : Not honor base href in this case
                                            href = $base.attr("href") + href;
                                        }
                                        window.open(href, target, wFeature);
                                    }
                                }
                            }
                        }
                    }
                },
                deactivate: function wMenuDeactivate(event) {
                    var $menuElement = $(event.item);

                    // Use for reopen for Dynamic menu
                    if ($menuElement.data("menu-openAgain")) {
                        $menuElement.data("menu-openAgain", false);
                        $menuElement.data("menu-noQuery", true);
                        $content.data("kendoMenu").open($menuElement);
                    }
                },
                open: function wMenuOpen(event) {

                    var $menuElement = $(event.item);

                    // Due to iOs artefact, an resize event is send, so need to inhibated during opening menu
                    scopeWidget.element.data("menu-opening", true);
                    $menuElement.data("bodyWidth", $('body').width());

                    if (!$menuElement.hasClass("menu__element--item")) {
                        var menuUrl = $menuElement.data("menu-url");
                        if (menuUrl) {
                            // Open Dynamic menu : request server to get menu contents
                            if (!$menuElement.data("menu-noQuery")) {
                                var loading = $menuElement.find(".menu__loading");

                                if (loading.length > 0) {
                                    // record initial loading item
                                    $menuElement.data("menu-loading", loading);
                                }

                                // Display loading first
                                if (loading.length === 0 && $menuElement.data("menu-loading")) {
                                    $menuElement.find(".listmenu__content").html('').append($menuElement.data("menu-loading"));
                                }

                                // Get subMenu
                                $.get(menuUrl, function wMenuDone(response) {
                                    var data = response.data;
                                    $menuElement.find(".listmenu__content").html('');

                                    scopeWidget._insertMenuContent(data.content, $menuElement.find(".listmenu__content"), scopeWidget, $menuElement);
                                    $menuElement.kendoMenu({
                                        openOnClick: true,
                                        closeOnClick: true
                                    });

                                    if (parseInt($menuElement.find(".k-animation-container").css("left")) !== 0 && parseInt($menuElement.find(".k-animation-container").css("right")) !== 0) {
                                        // Need to close and reopen to adjust position menu because content has changed
                                        $menuElement.data("menu-openAgain", true);
                                        $content.data("kendoMenu").close($menuElement);
                                    }
                                }).fail(function wMenuFail(data) {
                                    try {
                                        var errorMessage = data.responseText;
                                        $menuElement.find(".listmenu__content").html($('<div/>').text(errorMessage).addClass("menu--error"));
                                    } catch (e) {
                                        if (window.dcp.logger) {
                                            window.dcp.logger(e);
                                        } else {
                                            console.error(e);
                                        }
                                    }
                                });
                            }
                            $menuElement.data("menu-noQuery", false);
                        }
                    }
                },
                activate: function wMenuActivate(event) {
                    // Correct Kendo position list when scrollbar is displayed
                    var $menuElement = $(event.item);
                    var $container = $menuElement.find(".k-animation-container");

                    var bodyWidth = $menuElement.data("bodyWidth");
                    var menuWidth = $menuElement.outerWidth();
                    var menuLeft = $menuElement.offset().left;
                    var listWidth = $container.outerWidth();
                    var listLeft = $container.offset().left;

                    // The first condition is for iOS because no scroll window exists
                    if ($("body").width() > bodyWidth || window.document.documentElement.scrollHeight > window.document.documentElement.clientHeight) {

                        // If the list menu is out of the body box, need to move it to the right
                        if (listLeft + listWidth > bodyWidth) {
                            $container.css("left", "auto").css("right", menuLeft - bodyWidth + menuWidth + "px");
                        }
                    }

                    _.delay(function wMenuOpenDelay() {
                        // Due to iOs artefact, an resize event is send, so need to inhibated during opening menu
                        scopeWidget.element.data("menu-opening", false);
                    }, 2000);
                }
            });

            this.element.find(".menu--left").last().addClass("menu--lastLeft");
            /**
             * Fix menu when no see header
             */
            $(window).off("scroll.ddui"); // reset

            if (this.element.prop("nodeName").toUpperCase() === "NAV") {
                $(window).on("scroll.ddui", function wMenuScroll() {
                    if ($(window).scrollTop() > $mainElement.position().top) {
                        if (!$mainElement.data("isFixed")) {
                            $mainElement.data("isFixed", "1");
                            $mainElement.parent().addClass("menu--fixed");
                            $(window.document).trigger("redrawErrorMessages");
                        }
                    } else {
                        if ($mainElement.data("isFixed")) {
                            $mainElement.data("isFixed", null);
                            $mainElement.parent().removeClass("menu--fixed");
                            $(window.document).trigger("redrawErrorMessages");
                        }
                    }
                });
            }
            /**
             * Responsive Menu
             */
            this.kendoMenuWidget = $content.data("kendoMenu");
            this.kendoMenuWidget.append([{
                text: i18n.___("Other", "UImenu") + '<span class="menu--count" />',
                cssClass: "menu__element  menu_element--hamburger ",
                encoded: false, // Allows use of HTML for item text
                items: [] // List items
            }]);
            $(window).on("resize.dcpMenu", _.bind(this.inhibitBarMenu, this));
            $(window).on("resize.dcpMenu", _.debounce(_.bind(this.updateResponsiveMenu, this), 100, false));
        },

        inhibitBarMenu: function wMenuInhibitBarMenu() {
            var widgetMenu = this;
            if (!widgetMenu.element.data("menu-opening") && this.element.css("overflow") !== "hidden") {
                this.element.find("li.k-state-border-down").each(function wMenuInhibitBarMenuClose() {
                    widgetMenu.kendoMenuWidget.close($(this));
                });
            }
        },

        /**
         * Get scrollbar width by adding a element
         * @returns {number|*}
         */
        getScrollBarWidth: function wMenugetScrollBarWidth() {
            if (!this.scrollBarWidth) {
                var inner = document.createElement('p');
                inner.style.width = "100%";
                inner.style.height = "200px";

                var outer = document.createElement('div');
                outer.style.position = "absolute";
                outer.style.top = "0px";
                outer.style.left = "0px";
                outer.style.visibility = "hidden";
                outer.style.width = "200px";
                outer.style.height = "150px";
                outer.style.overflow = "hidden";
                outer.appendChild(inner);

                document.body.appendChild(outer);
                var w1 = inner.offsetWidth;
                outer.style.overflow = 'scroll';
                var w2 = inner.offsetWidth;
                if (w1 === w2) {
                    w2 = outer.clientWidth;
                }

                document.body.removeChild(outer);
                this.scrollBarWidth = w1 - w2;
            }

            return this.scrollBarWidth;
        },

        /**
         * Move menu to hamburger which can be displayed in same line menu
         */
        updateResponsiveMenu: function wMenuHideResponsiveMenu() {
            var barMenu = this.element;
            var $itemMenu = barMenu.find("ul.k-menu > .menu__element:not(.menu--important,.menu_element--hamburger)");
            var $importantItemMenu = barMenu.find("ul.k-menu > .menu__element.menu--important");
            var newHiddens = [];
            var currentWidth = 0;
            var visibleWidth = 0;
            var freeWidth = 0;
            var barmenuWidth = barMenu.width() - 2;
            var kendoMenu = this.kendoMenuWidget;
            var $hamburger = $(".menu_element--hamburger");
            var hiddenItemsCount;
            var visibleItemCount;
            var $hiddenItems = $($hamburger.find("ul").get(0)).find("> li.k-item");
            var hiddenLeft = $hiddenItems.length;

            if (barMenu.data("menu-opening")) {
                // Cannot redraw menu while menu is open because kendo failure occurs in touch device
                return;
            }
            this.inhibitBarMenu();
            $importantItemMenu.each(function wMenuComputeBarmenuWidth() {
                barmenuWidth -= $(this).outerWidth();
            });

            barmenuWidth -= $hamburger.outerWidth();

            // When no scrollbar need to add hypothetic scrollbar width because no event to refresh when scrollbar appear
            if (window.document.documentElement.scrollHeight <= window.document.documentElement.clientHeight) {
                barmenuWidth -= this.getScrollBarWidth(); // Supposed that scrollbar width is max 20px
            }

            visibleItemCount = $itemMenu.length;
            // Detect free menu available width  and record menu items which not contains to bar menu
            $itemMenu.each(function wMenuComputeWidth() {
                currentWidth += $(this).outerWidth();
                if (currentWidth > barmenuWidth) {
                    $(this).data("original-width", $(this).outerWidth());
                    newHiddens.push(this);
                } else {
                    visibleWidth += $(this).outerWidth();
                }
                visibleItemCount--;
            });

            freeWidth = barmenuWidth - visibleWidth;

            if (hiddenLeft === 0 && newHiddens.length === 1) {
                // Special case for the last hidden may visible if hamburger is hide
                if ($(newHiddens[0]).outerWidth() < freeWidth + $hamburger.outerWidth()) {
                    newHiddens = [];
                }
            }

            // Move each new hidden menu to hamburger
            _.each(newHiddens.reverse(), function wMenuItemToHamburger(item) {
                // Prepend new menu to hamburger
                if ($hamburger.find("li.k-item").length === 0) {
                    kendoMenu.append($(item), $hamburger);
                } else {
                    kendoMenu.insertBefore($(item), $($hamburger.find("li.k-item").get(0)));
                }
            });
            // No new hidden menu so ...
            if (newHiddens.length === 0) {
                // May be show hidden menu
                $hiddenItems = $($hamburger.find("ul").get(0)).find("> li.k-item");
                hiddenLeft = $hiddenItems.length;
                $hiddenItems.each(function wMenuItemFromHamburger() {
                    if (freeWidth > 0) {
                        if (hiddenLeft === 1) {
                            freeWidth += $hamburger.width();
                        }
                        currentWidth = $(this).data("original-width");

                        // If available width show move at initial place (right of the hamburger)
                        if (currentWidth < freeWidth) {
                            kendoMenu.insertBefore($(this), $hamburger);
                            freeWidth -= $(this).outerWidth();
                        } else {
                            freeWidth = -1; // stop test
                        }
                    }
                });
            }

            // Number of items in hamburger
            hiddenItemsCount = $($hamburger.find("ul").get(0)).find("> li.k-item").length;

            // No view hamburger if empty
            if (hiddenItemsCount === 0) {
                $hamburger.hide();
            }

            // See sub-menu count
            // $hamburger.find(".menu--count").text(hiddenItemsCount);

            // View hamburger if not empty
            if (newHiddens.length > 0) {
                $hamburger.show();
            }

            // Restore css set by other resize callback
            barMenu.css("overflow", "").css("max-height", "");
        },

        _insertMenuContent: function wMenuInsertMenuContent(menus, $content, currentWidget, scopeMenu) {
            var subMenu;
            var hasBeforeContent = false;
            currentWidget = currentWidget || this;

            if (scopeMenu) {
                // Add fake before content if at least one element has before content to align all items
                _.each(menus, function wMenuInsertMenuContentfake(currentMenu) {
                    if (currentMenu.iconUrl || currentMenu.beforeContent) {
                        hasBeforeContent = true;
                    }
                });
                if (hasBeforeContent) {
                    _.each(menus, function wMenuInsertMenuContentBeforeContent(currentMenu) {
                        if (!currentMenu.iconUrl && !currentMenu.beforeContent) {
                            if (currentMenu.type !== "separatorMenu") {
                                currentMenu.beforeContent = ' ';
                            }
                        }
                    });
                }
            }

            _.each(menus, function wMenuInsertMenuContentSet(currentMenu) {
                var $currentMenu;
                if (currentMenu.visibility === "hidden") {
                    return;
                }
                currentMenu.htmlAttr = [];
                _.each(currentMenu.htmlAttributes, function wMenuInsertMenuContentSetHtml(attrValue, attrId) {
                    if (attrId === "class") {
                        currentMenu.cssClass = attrValue;
                    } else {
                        currentMenu.htmlAttr.push({ "attrId": attrId, "attrValue": attrValue });
                    }
                    if (currentMenu.htmlLabel) {
                        // reRender for variable labels
                        currentMenu.htmlLabel = Mustache.render(currentMenu.htmlLabel || "", { document: currentWidget.options.document });
                    }
                    if (currentMenu.label) {
                        // reRender for variable labels
                        currentMenu.label = Mustache.render(currentMenu.label || "", { document: currentWidget.options.document });
                    }
                    if (currentMenu.tooltipLabel) {
                        // reRender for variable labels
                        currentMenu.tooltipLabel = Mustache.render(currentMenu.tooltipLabel || "", { document: currentWidget.options.document });
                    }
                });

                currentMenu.contentLabel = currentMenu.htmlLabel || currentMenu.label;
                currentMenu.disabled = currentMenu.visibility === 'disabled';
                if (currentMenu.type === "listMenu") {
                    subMenu = "listMenu";

                    $currentMenu = $(Mustache.render(currentWidget._getTemplate(subMenu) || "", currentMenu));
                    currentWidget._insertMenuContent(currentMenu.content || "", $currentMenu.find(".listmenu__content"), currentWidget, currentMenu);
                } else {
                    if (currentMenu.type === "dynamicMenu") {
                        subMenu = "dynamicMenu";
                        if (currentMenu.url) {
                            currentMenu.document = currentWidget.options.document;
                            currentMenu.url = Mustache.render(currentMenu.url || "", currentMenu);
                        }
                        $currentMenu = $(Mustache.render(currentWidget._getTemplate(subMenu) || "", currentMenu));
                    } else {
                        currentMenu.document = currentWidget.options.document;
                        if (currentMenu.url) {
                            currentMenu.url = Mustache.render(currentMenu.url || "", currentMenu);
                        }
                        $currentMenu = $(Mustache.render(currentWidget._getTemplate(currentMenu.type) || "", currentMenu));
                    }
                }
                if (currentMenu.tooltipLabel) {
                    currentWidget._tooltips.push($currentMenu.tooltip({
                        trigger: "hover",
                        html: currentMenu.tooltipHtml,
                        placement: currentMenu.tooltipPlacement ? currentMenu.tooltipPlacement : "bottom",
                        container: ".dcpDocument__menu"
                    }));
                }
                if (currentMenu.important) {
                    $currentMenu.addClass("menu--important");
                }
                $currentMenu.data("menuConfiguration", currentMenu);
                $content.append($currentMenu);
            });
        },

        _getTemplate: function wMenuTemplate(name) {
            if (this.options.templates && this.options.templates.menu && this.options.templates.menu[name]) {
                return this.options.templates.menu[name];
            }
            if (window.dcp.templates && window.dcp.templates.menu && window.dcp.templates.menu[name]) {
                return window.dcp.templates.menu[name];
            }
            throw new Error("Menu unknown template " + name);
        },

        _destroy: function wMenuDestroy() {
            var kendoWidget = this.element.find(".menu__content").data("kendoMenu");
            if (kendoWidget) {
                kendoWidget.destroy();
            }
            $(window).off(".dcpMenu");
            _.each(this.popupWindows, function wMenuDestroyPopup(pWindow) {
                pWindow.destroy();
            });

            _.each(this._tooltips, function wMenuDestroyTooltip(currentTooltip) {
                currentTooltip.tooltip("dispose");
            });
            this.element.empty();
            this._super();
        }

    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/properties/wProperties.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/widget.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/window/wDialog.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function require_wProperties($, _, Mustache) {
    'use strict';

    $.widget("dcp.dcpDocumentProperties", $.dcp.dcpDialog, {
        options: {
            documentId: 0,
            window: {
                modal: true,
                title: "Document properties"
            },
            labels: {
                identifier: "Identifier",
                title: "Title",
                logicalName: "Logical name",
                revision: "Revision number",
                version: "Version",
                family: "Family",
                lockedBy: "Locked by",
                createdBy: "Created by",
                notLocked: "Not locked",
                confidential: "Confidential",
                notConfidential: "Not confidential",
                creationDate: "Creation date",
                lastModificationDate: "Last modification date",
                lastAccessDate: "Last access date",
                profil: "Profil",
                profilReference: "Profil reference",
                viewController: "View controller",
                propertiesTitle: "Properties of {{title}}",
                property: "Property",
                propertyValue: "Value",
                workflow: "Workflow",
                activity: "Activity"
            }
        },
        documentProperties: null,
        htmlCaneva: function wProperties_htmlCaneva() {
            return '<table class="properties-main table table-condensed table-hover"><thead>' + '<tr class="properties-header">' + '<th class="properties-header--description">{{labels.property}}</th>' + '<th class="properties-header--value">{{labels.propertyValue}}</th>' + '</tr></thead>' + '<tbody>' + '<tr><td class="properties-description">{{labels.title}}</td><td class="properties-value">{{title}}</td></tr>' + '<tr><td class="properties-description">{{labels.identifier}}</td><td class="properties-value">{{initid}}</td></tr>' + '<tr><td class="properties-description">{{labels.logicalName}}</td><td class="properties-value">{{name}}</td></tr>' + '<tr><td class="properties-description">{{labels.revision}}</td><td class="properties-value">{{revision}}</td></tr>' + '<tr><td class="properties-description">{{labels.version}}</td><td class="properties-value">{{version}}</td></tr>' + '<tr><td class="properties-separator" colspan="2"></td></tr>' + '<tr><td class="properties-description">{{labels.workflow}}</td><td class="properties-value"><a  data-document-id="{{workflow.id}}" href="api/v1/documents/{{workflow.id}}.html">{{#workflow.icon}}<img src="{{workflow.icon}}"/>{{/workflow.icon}}{{workflow.title}}</a></td></tr>' + '<tr><td class="properties-description">{{labels.activity}}</td><td class="properties-value">{{#state.reference}}<div class="properties-value-statecolor" style="background-color:{{state.color}}"/>{{state.displayValue}}{{/state.reference}}</td></tr>' + '<tr><td class="properties-description">{{labels.family}}</td><td class="properties-value"><a data-document-id="{{family.id}}" href="api/v1/documents/{{family.id}}.html"><img src="{{family.icon}}"/>{{family.title}}</a><br/><div class="properties-value--famname">{{family.name}}</div></td></tr>' + '<tr><td class="properties-separator" colspan="2"></td></tr>' + '<tr><td class="properties-description">{{labels.createdBy}}</td><td class="properties-value"><a data-document-id="{{createdBy.id}}" href="api/v1/documents/{{createdBy.id}}.html"><img src="{{createdBy.icon}}"/>{{createdBy.title}}</a></td></tr>' + '<tr><td class="properties-description">{{labels.lockedBy}}</td><td class="properties-value">' + '{{#security.lock.lockedBy.id}}' + '<a data-document-id="{{security.lock.lockedBy.id}}" href="api/v1/documents/{{security.lock.lockedBy.id}}.html"><img src="{{security.lock.lockedBy.icon}}"/>{{security.lock.lockedBy.title}}</a>' + '{{/security.lock.lockedBy.id}}' + '{{^security.lock.lockedBy.id}}{{labels.notLocked}}{{/security.lock.lockedBy.id}}' + '</td></tr>' + '<tr><td class="properties-description">{{labels.confidential}}</td><td class="properties-value">' + '{{#confidential}}' + '{{labels.confidential}}' + '{{/confidential}}' + '{{^confidential}}{{labels.notConfidential}}{{/confidential}}' + '</td></tr>' + '<tr><td class="properties-separator" colspan="2"></td></tr>' + '<tr><td class="properties-description">{{labels.creationDate}}</td><td class="properties-value">{{#formatDate}}{{creationDate}}{{/formatDate}}</td></tr>' + '<tr><td class="properties-description">{{labels.lastModificationDate}}</td><td class="properties-value">{{#formatDate}}{{lastModificationDate}}{{/formatDate}}</td></tr>' + '<tr><td class="properties-description">{{labels.lastAccessDate}}</td><td class="properties-value">{{#formatDate}}{{lastAccessDate}}{{/formatDate}}</td></tr>' + '<tr><td class="properties-separator" colspan="2"></td></tr>' + '<tr><td class="properties-description">{{labels.profil}}</td><td class="properties-value"><a data-document-id="{{security.profil.id}}" href="api/v1/documents/{{security.profil.id}}.html">{{#security.profil.icon}}<img src="{{security.profil.icon}}"/>{{/security.profil.icon}}{{security.profil.title}}</a></td></tr>' + '<tr><td class="properties-description">{{labels.profilReference}}</td><td class="properties-value"><a data-document-id="{{security.profil.reference.id}}" href="api/v1/documents/{{security.profil.reference.id}}.html">{{#security.profil.reference.icon}}<img src="{{security.profil.reference.icon}}"/>{{/security.profil.reference.icon}}{{security.profil.reference.title}}</a></td></tr>' + '<tr><td class="properties-description">{{labels.viewController}}</td><td class="properties-value"><a data-document-id="{{viewController.id}}" href="api/v1/documents/{{viewController.id}}.html">{{#viewController.icon}}<img src="{{viewController.icon}}"/>{{/viewController.icon}}{{viewController.title}}</a></td></tr>' + '</tbody></table>';
        },

        _create: function wProperties__create() {
            var scope = this;

            this._displayProperties();

            this._super();

            this.element.data("dcpDocumentProperties", this);
            this.element.on("click" + this.eventNamespace, "a[data-document-id]", function wProperties_bindClick(event) {
                var docid = $(this).data("document-id");
                if (docid) {
                    event.preventDefault();
                    scope.element.trigger("viewDocument", docid);
                }
            });
        },

        _displayProperties: function wPropertiesGetProperties() {
            var scope = this;
            $.getJSON("api/v1/documents/" + this.options.documentId + ".json?fields=document.properties.all").done(function wProperties_done(data) {
                var info;
                scope.documentProperties = data.data.document.properties;
                info = _.extend(scope.documentProperties, { labels: scope.options.labels });
                info.formatDate = function wProperties_formatDate() {
                    return function wProperties_formatDate2(text, render) {
                        return kendo.toString(new Date(render(text).replace(' ', 'T')), "G");
                    };
                };
                scope.element.html(Mustache.render(scope.htmlCaneva() || "", info));
                //scope.dialogWindow.center();

                scope.dialogWindow.setOptions({
                    title: Mustache.render(scope.options.labels.propertiesTitle, data.data.document.properties)
                });
            }).fail(function wProperties_fail(xhr) {
                var result = JSON.parse(xhr.responseText);
                window.alert(result.exceptionMessage);
            });
        }

    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/widget.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/*global define*/

(function umdRequire(root, factory) {
    'use strict';

    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\"")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {
        factory(window.jQuery);
    }
})(window, function documentCatalog(jQuery) {
    "use strict";

    var ErrorNoSuchMethod = function widget_ErrorNoSuchMethod(message) {
        this.name = 'noSuchMethodError';
        this.message = message || 'No such method for current widget instance';
    };

    ErrorNoSuchMethod.prototype = Object.create(Error.prototype);
    ErrorNoSuchMethod.prototype.constructor = ErrorNoSuchMethod;

    (function widget_init($, undefined) {

        var widgetUuid = 0,
            slice = Array.prototype.slice,
            _cleanData = $.cleanData;
        $.cleanData = function widget_cleanData(elems) {
            var events,
                elem = null,
                i;
            for (i = 0, elem; (elem = elems[i]) != null; i++) {
                // jshint ignore:line
                try {
                    // Only trigger remove when necessary to save time
                    events = $._data(elem, "events");
                    if (events && events.remove) {
                        $(elem).triggerHandler("remove");
                    }
                } catch (e) {}
            }
            _cleanData(elems);
        };

        $.widget = function widget_initWidget(name, Base, prototype) {
            var fullName,
                existingConstructor,
                Constructor,
                basePrototype,

            // proxiedPrototype allows the provided prototype to remain unmodified
            // so that it can be used as a mixin for multiple widgets (#8876)
            proxiedPrototype = {},
                namespace = name.split(".")[0];

            name = name.split(".")[1];
            fullName = namespace + "-" + name;

            if (!prototype) {
                prototype = Base;
                Base = $.Widget;
            }

            if ($.isArray(prototype)) {
                prototype = $.extend.apply(null, [{}].concat(prototype));
            }

            // create selector for plugin
            // $.expr[ ":" ] is deprecated with jQuery 3.0.0+ in favor of $.expr.pseudos
            // $.expr[ ":" ][ fullName.toLowerCase() ] = function widget_createSelector(elem) {
            //     return Boolean($(elem).data(fullName));
            // };
            $.expr.pseudos[fullName.toLowerCase()] = function widget_createSelector(elem) {
                return Boolean($(elem).data(fullName));
            };

            $[namespace] = $[namespace] || {};
            existingConstructor = $[namespace][name];
            Constructor = $[namespace][name] = function widget_Constructor(options, element) {
                // allow instantiation without "new" keyword
                if (!this._createWidget) {
                    return new Constructor(options, element);
                }

                // allow instantiation without initializing for simple inheritance
                // must use "new" keyword (the code above always passes args)
                if (arguments.length) {
                    this._createWidget(options, element);
                }
            };
            // extend with the existing constructor to carry over any static properties
            $.extend(Constructor, existingConstructor, {
                version: prototype.version,
                // copy the object used to create the prototype in case we need to
                // redefine the widget later
                _proto: $.extend({}, prototype),
                // track widgets that inherit from this widget in case this widget is
                // redefined after a widget inherits from it
                _childConstructors: []
            });

            basePrototype = new Base();
            // we need to make the options hash a property directly on the new instance
            // otherwise we'll modify the options hash on the prototype that we're
            // inheriting from
            basePrototype.options = $.widget.extend({}, basePrototype.options);
            $.each(prototype, function widget_proxiedElements(prop, value) {
                if (!$.isFunction(value)) {
                    proxiedPrototype[prop] = value;
                    return;
                }
                proxiedPrototype[prop] = function widget_proxiedProperties() {
                    var _super = function widget_super() {
                        return Base.prototype[prop].apply(this, arguments);
                    },
                        _superApply = function widget_superApply(args) {
                        return Base.prototype[prop].apply(this, args);
                    };
                    return function widget_proxied() {
                        var __super = this._super,
                            __superApply = this._superApply,
                            returnValue;

                        this._super = _super;
                        this._superApply = _superApply;

                        returnValue = value.apply(this, arguments);

                        this._super = __super;
                        this._superApply = __superApply;

                        return returnValue;
                    };
                }();
            });
            Constructor.prototype = $.widget.extend(basePrototype, {}, proxiedPrototype, {
                constructor: Constructor,
                namespace: namespace,
                widgetName: name,
                widgetFullName: fullName
            });

            // If this widget is being redefined then we need to find all widgets that
            // are inheriting from it and redefine all of them so that they inherit from
            // the new version of this widget. We're essentially trying to replace one
            // level in the prototype chain.
            if (existingConstructor) {
                $.each(existingConstructor._childConstructors, function widget_existingConstructor(i, child) {
                    var childPrototype = child.prototype;

                    // redefine the child widget using the same prototype that was
                    // originally used, but inherit from the new version of the base
                    $.widget(childPrototype.namespace + "." + childPrototype.widgetName, Constructor, child._proto);
                });
                // remove the list of existing child constructors from the old constructor
                // so the old child constructors can be garbage collected
                delete existingConstructor._childConstructors;
            } else {
                Base._childConstructors.push(Constructor);
            }

            $.widget.bridge(name, Constructor);

            return Constructor;
        };

        $.widget.extend = function widget_extend(target) {
            var input = slice.call(arguments, 1),
                inputIndex = 0,
                inputLength = input.length,
                key,
                value;
            for (; inputIndex < inputLength; inputIndex++) {
                for (key in input[inputIndex]) {
                    // jshint ignore:line
                    //noinspection JSUnfilteredForInLoop
                    value = input[inputIndex][key];
                    if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
                        // Clone objects
                        if ($.isPlainObject(value)) {
                            target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) :
                            // Don't extend strings, arrays, etc. with objects
                            $.widget.extend({}, value);
                            // Copy everything else by reference
                        } else {
                            target[key] = value;
                        }
                    }
                }
            }
            return target;
        };

        $.widget.bridge = function widget_bridge(name, Object) {
            var fullName = Object.prototype.widgetFullName || name;
            $.fn[name] = function widget_callElement(options) {
                var isMethodCall = typeof options === "string",
                    args = slice.call(arguments, 1),
                    returnValue = this;

                // allow multiple hashes to be passed on init
                options = !isMethodCall && args.length ? $.widget.extend.apply(null, [options].concat(args)) : options;

                if (isMethodCall) {
                    this.each(function widget_eachMethodCall() {
                        var methodValue,
                            instance = $(this).data(fullName);
                        if (options === "instance") {
                            returnValue = instance;
                            return false;
                        }
                        if (!instance) {
                            return $.error("cannot call methods on " + name + " prior to initialization; " + "attempted to call method '" + options + "'");
                        }
                        if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                            throw new ErrorNoSuchMethod("no such method '" + options + "' for " + name + " widget instance");
                        }
                        methodValue = instance[options].apply(instance, args);
                        if (methodValue !== instance && methodValue !== undefined) {
                            returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
                            return false;
                        }
                    });
                } else {

                    // Allow multiple hashes to be passed on init
                    if (args.length) {
                        options = $.widget.extend.apply(null, [options].concat(args));
                    }

                    this.each(function widget_eachDataCall() {
                        var instance = $(this).data(fullName);
                        if (instance) {
                            instance.option(options || {})._init();
                        } else {
                            $(this).data(fullName, new Object(options, this));
                        }
                    });
                }

                return returnValue;
            };
        };

        $.Widget = function widget_Widget() /* options, element */{};
        $.Widget._childConstructors = [];

        $.Widget.prototype = {
            widgetName: "widget",
            defaultElement: "<div>",
            options: {
                classes: {},
                disabled: false,
                eventPrefix: null,
                // callbacks
                create: null
            },
            _createWidget: function widget_createWidget(options, element) {
                element = $(element || this.defaultElement || this)[0];
                this.element = $(element);
                this.uuid = widgetUuid++;
                this.eventNamespace = "." + this.widgetName + this.uuid;
                this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);

                this.bindings = $();
                this.classesElementLookup = {};
                if (this.options.eventPrefix === null) {
                    this.options.eventPrefix = this.widgetName;
                }

                if (element !== this) {
                    $(element).data(this.widgetFullName, this);
                    this._on(true, this.element, {
                        remove: function widget_remove(event) {
                            if (event.target === element) {
                                this.destroy();
                            }
                        }
                    });
                    this.document = $(element.style ?
                    // element within the document
                    element.ownerDocument :
                    // element is window or document
                    element.document || element);
                    this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
                }
                this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);

                this._create();

                if (this.options.disabled) {
                    this._setOptionDisabled(this.options.disabled);
                }

                this._trigger("create", null, this._getCreateEventData());
                this._init();
            },
            _getCreateOptions: function widget_getCreateOptions() {
                return {};
            },
            _getCreateEventData: $.noop,
            _create: $.noop,
            _init: $.noop,

            destroy: function widget_destroy() {
                var that = this;

                this._destroy();
                $.each(this.classesElementLookup, function widget_destroyClass(key, value) {
                    that._removeClass(value, key);
                });

                // We can probably remove the unbind calls in 2.0
                // all event bindings should go through this._on()
                this.element.off(this.eventNamespace).removeData(this.widgetFullName);
                this.widget().off(this.eventNamespace).removeAttr("aria-disabled");

                // Clean up events and states
                this.bindings.off(this.eventNamespace);
            },
            _destroy: $.noop,

            widget: function widget_widget() {
                return this.element;
            },

            option: function widget_option(key, value) {
                var options = key,
                    parts,
                    curOption,
                    i;

                if (arguments.length === 0) {
                    // don't return a reference to the internal hash
                    return $.widget.extend({}, this.options);
                }

                if (typeof key === "string") {
                    // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                    options = {};
                    parts = key.split(".");
                    key = parts.shift();
                    if (parts.length) {
                        curOption = options[key] = $.widget.extend({}, this.options[key]);
                        for (i = 0; i < parts.length - 1; i++) {
                            curOption[parts[i]] = curOption[parts[i]] || {};
                            curOption = curOption[parts[i]];
                        }
                        key = parts.pop();
                        if (arguments.length === 1) {
                            return curOption[key] === undefined ? null : curOption[key];
                        }
                        curOption[key] = value;
                    } else {
                        if (arguments.length === 1) {
                            return this.options[key] === undefined ? null : this.options[key];
                        }
                        options[key] = value;
                    }
                }

                this._setOptions(options);

                return this;
            },
            _setOptions: function widget__setOptions(options) {
                var key;

                for (key in options) {
                    // jshint ignore:line
                    //noinspection JSUnfilteredForInLoop
                    this._setOption(key, options[key]);
                }

                return this;
            },
            _setOption: function widget__setOption(key, value) {
                this.options[key] = value;

                return this;
            },

            _setOptionClasses: function widget__setOptionClasses(value) {
                var classKey, elements, currentElements;

                for (classKey in value) {
                    // jshint ignore:line
                    //noinspection JSUnfilteredForInLoop
                    currentElements = this.classesElementLookup[classKey];
                    //noinspection JSUnfilteredForInLoop
                    if (value[classKey] === this.options.classes[classKey] || !currentElements || !currentElements.length) {
                        continue;
                    }

                    // We are doing this to create a new jQuery object because the _removeClass() call
                    // on the next line is going to destroy the reference to the current elements being
                    // tracked. We need to save a copy of this collection so that we can add the new classes
                    // below.
                    elements = $(currentElements.get());
                    //noinspection JSUnfilteredForInLoop
                    this._removeClass(currentElements, classKey);

                    // We don't use _addClass() here, because that uses this.options.classes
                    // for generating the string of classes. We want to use the value passed in from
                    // _setOption(), this is the new value of the classes option which was passed to
                    // _setOption(). We pass this value directly to _classes().
                    //noinspection JSUnfilteredForInLoop
                    elements.addClass(this._classes({
                        element: elements,
                        keys: classKey,
                        classes: value,
                        add: true
                    }));
                }
            },

            _classes: function widget__classes(options) {
                var full = [];
                var that = this,
                    processClassString;

                options = $.extend({
                    element: this.element,
                    classes: this.options.classes || {}
                }, options);

                processClassString = function widget_processClassString(classes, checkOption) {
                    var current, i;
                    for (i = 0; i < classes.length; i++) {
                        current = that.classesElementLookup[classes[i]] || $();
                        if (options.add) {
                            // unique is deprecated in jQuery 3.0.0+ renamed to uniqueSort
                            var jqueryVersion = +$().jquery.split('.')[0];
                            if (jqueryVersion >= 3) {
                                current = $($.uniqueSort(current.get().concat(options.element.get())));
                            } else {
                                current = $($.unique(current.get().concat(options.element.get())));
                            }
                        } else {
                            current = $(current.not(options.element).get());
                        }
                        that.classesElementLookup[classes[i]] = current;
                        full.push(classes[i]);
                        if (checkOption && options.classes[classes[i]]) {
                            full.push(options.classes[classes[i]]);
                        }
                    }
                };

                if (options.keys) {
                    processClassString(options.keys.match(/\S+/g) || [], true);
                }
                if (options.extra) {
                    processClassString(options.extra.match(/\S+/g) || []);
                }

                return full.join(" ");
            },

            _removeClass: function widget__removeClass(element, keys, extra) {
                return this._toggleClass(element, keys, extra, false);
            },

            _addClass: function widget__addClass(element, keys, extra) {
                return this._toggleClass(element, keys, extra, true);
            },

            _toggleClass: function widget__toggleClass(element, keys, extra, add) {
                add = typeof add === "boolean" ? add : extra;
                var shift = typeof element === "string" || element === null,
                    options = {
                    extra: shift ? keys : extra,
                    keys: shift ? element : keys,
                    element: shift ? this.element : element,
                    add: add
                };
                options.element.toggleClass(this._classes(options), add);
                return this;
            },

            _on: function widget__on(suppressDisabledCheck, element, handlers) {
                var delegateElement,
                    instance = this;

                // no suppressDisabledCheck flag, shuffle arguments
                if (typeof suppressDisabledCheck !== "boolean") {
                    handlers = element;
                    element = suppressDisabledCheck;
                    //suppressDisabledCheck = false;
                }

                // no element argument, shuffle and use this.element
                if (!handlers) {
                    handlers = element;
                    element = this.element;
                    delegateElement = this.widget();
                } else {
                    // accept selectors, DOM elements
                    element = delegateElement = $(element);
                    this.bindings = this.bindings.add(element);
                }

                $.each(handlers, function widget_iterateHandler(event, handler) {
                    var handlerProxy = function handlerProxy() {
                        // allow widgets to customize the disabled handling
                        // - disabled as an array instead of boolean
                        // - disabled class as method for disabling individual parts
                        return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
                    };

                    // copy the guid so direct unbinding works
                    if (typeof handler !== "string") {
                        handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
                    }

                    var match = event.match(/^(\w+)\s*(.*)$/),
                        eventName = match[1] + instance.eventNamespace,
                        selector = match[2];
                    // delegate is deprecated in jQuery 3.0.0+ in favor of on method
                    var jqueryVersion = +$().jquery.split('.')[0];
                    if (selector) {
                        if (jqueryVersion >= 3) {
                            delegateElement.on(eventName, selector, handlerProxy);
                        } else {
                            delegateElement.delegate(selector, eventName, handlerProxy);
                        }
                    } else {
                        // bind is deprecated in jQuery 3.0.0+ in favor of on method
                        if (jqueryVersion >= 3) {
                            element.on(eventName, handlerProxy);
                        } else {
                            element.bind(eventName, handlerProxy);
                        }
                    }
                });
            },

            _off: function widget__off(element, eventName) {
                eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
                element.unbind(eventName).undelegate(eventName);
            },

            _delay: function widget__delay(handler, delay) {
                var handlerProxy = function handlerProxy() {
                    return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
                };

                var instance = this;
                return setTimeout(handlerProxy, delay || 0);
            },

            _trigger: function widget__trigger(type, event, data) {
                var prop,
                    orig,
                    callback = this.options[type];

                data = data || {};
                event = $.Event(event);
                event.type = this.options.eventPrefix ? this.options.eventPrefix + type : type;
                event.type = event.type.toLocaleLowerCase();
                // the original event may come from any element
                // so we need to reset the target on the new event
                event.target = this.element[0];

                // copy original event properties over to the new event
                orig = event.originalEvent;
                if (orig) {
                    for (prop in orig) {
                        // jshint ignore:line
                        if (!(prop in event)) {
                            //noinspection JSUnfilteredForInLoop
                            event[prop] = orig[prop];
                        }
                    }
                }

                this.element.trigger(event, data);
                return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());
            }
        };
    })(jQuery);
});

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/window/wConfirm.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./node_modules/mustache/mustache.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/window/wWindow.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function wConfirm($, _, Mustache) {
    'use strict';

    $.widget("dcp.dcpConfirm", $.dcp.dcpWindow, {

        options: {
            modal: true,
            templateData: {
                templates: {
                    window: {
                        confirm: '<div class="confirm--body"> <div class="confirm--content">  <div>{{messages.textMessage}}</div><div>{{{messages.htmlMessage}}}</div> </div> <div class="confirm--buttons"> <button class="button--cancel" type="button">{{messages.cancelMessage}}</button> <button class="button--ok k-primary" type="button">{{messages.okMessage}}</button> </div> </div>'
                    }
                }
            },
            messages: {
                textMessage: 'Are you sure ?',
                htmlMessage: '',
                okMessage: "Ok",
                cancelMessage: "Cancel"
            },
            cancel: function wConfirmCancel() {},

            confirm: function wConfirmConfirm() {},
            actions: ["Close"],
            height: "150px"

        },

        _create: function wConfirmCreate() {
            var scope = this;
            var scoppedCancel = _.bind(this.options.cancel, this);
            this.options.close = scoppedCancel;
            this.options.templateData.messages = this.options.messages || [];
            this.currentWidget = $(Mustache.render(this._getWindowTemplate('confirm') || "", this.options.templateData));
            this.element.append(this.currentWidget);
            this.currentWidget.kendoWindow(this.options);
            this.currentWidget.data("kendoWindow").center();

            this.currentWidget.find('.button--cancel').kendoButton({
                click: function wConfirmCancelClick() {
                    scoppedCancel();
                    scope.destroy();
                }
            });

            var scoppedConfirm = _.bind(this.options.confirm, this);

            this.currentWidget.find('.button--ok').kendoButton({
                click: function wConfirmOkClick() {
                    scoppedConfirm();
                    scope.destroy();
                }
            });

            this.element.data("dcpWindow", this);
        }

    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/window/wDialog.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/widget.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function wDialog($, _) {
    'use strict';

    $.widget("dcp.dcpDialog", {
        options: {
            window: {
                modal: true,
                actions: ["Maximize", "Close"],
                visible: false,
                height: "300px",
                width: "500px",
                title: "-"
            },
            maximizeWidth: 768 // Limit in px to open with maximize
        },

        dialogWindow: null,

        _create: function dcpDialog_create() {
            var currentWidget = this;
            this.element.data("dcpDialog", this);
            if (!this.options.window.close) {
                this.options.window.close = function dcpDialog_onclose() {
                    _.defer(_.bind(currentWidget.destroy, currentWidget));
                };
            } else {
                this.options.window.close = _.wrap(this.options.window.close, function dcpDialog_closeWrap(close, argument) {
                    var event = arguments[1];
                    close.apply(this, _.rest(arguments));
                    if (!event.isDefaultPrevented()) {
                        _.defer(_.bind(currentWidget.destroy, currentWidget));
                    }
                });
            }

            if ($(window).width() <= this.options.maximizeWidth) {
                this.options.window.width = "auto";
                this.options.window.heigth = "auto";
            }
            this.dialogWindow = this.element.kendoWindow(this.options.window).data("kendoWindow");
        },

        open: function dcpDialog_Open() {
            var kWindow = this.dialogWindow;
            if ($(window).width() <= this.options.maximizeWidth) {
                kWindow.setOptions({
                    actions: ["Close"],
                    animation: false
                });

                kWindow.open();
                _.delay(function wDialogMaximize() {
                    kWindow.maximize(); // Need to defer to wait window to be really opened
                }, 100);
            } else {
                kWindow.setOptions({
                    actions: this.options.window.actions
                });
                kWindow.center();
                kWindow.open();
            }
        },

        close: function dcpDialog_close() {
            var kendoWindow = this.dialogWindow;
            if (kendoWindow) {
                kendoWindow.close();
            }
        },

        _destroy: function dcpDialog_destroy() {
            if (this.element && this.dialogWindow && this.element.data("kendoWindow")) {
                this.dialogWindow.destroy();
                this.dialogWindow = null;
            } else {
                this._super();
            }
        }

    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/window/wLoading.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/widget.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function ($, _) {
    'use strict';

    $.widget("dcp.dcpLoading", {
        pc: 0,
        rest: 0,
        restItem: 0,
        currentWidget: null,
        doneItems: 0,
        original: null,

        _create: function dcpLoading_create() {
            this.stack = 0;
            this.initBar = this.element.find(".progress");
            this.$title = this.element.find(".dcpLoading--title");
            this.$header = this.element.find(".dcpLoading--header");
        },

        reset: function dcpLoadingReset() {
            this.initBar.show();
        },

        setTitle: function dcpLoadingsetTitle(val) {
            this.element.find('.dcpLoading--title').html(val);
        },

        isDisplayed: function dcpLoadingIsDisplayed() {
            return this.stack > 0;
        },

        hide: function dcpLoadinghide(force) {
            this.stack -= 1;
            if (!force && this.stack > 0) {
                return this;
            }
            this.stack = 0;
            this.element.hide();
            this.element.removeClass("dcpLoading--hide");
            this.setPercent(0);
        },

        show: function dcpLoadingshow(text, pc) {
            this.stack += 1;
            if (text) {
                this.setLabel(text);
            }
            if (pc) {
                this.setPercent(pc);
            }
            this.element.show();
            this.$header.show().removeClass("dcpLoading--hide");
        },

        setLabel: function dcpLoadingsetLabel(text) {
            if (text) {
                this.$title.text(text);
            } else {
                this.$header.addClass("dcpLoading--hide");
            }
        },

        setPercent: function dcpLoadingsetPercent(pc) {
            var $initbar = this.initBar.find(".progress-bar");
            var rpc = Math.round(pc);
            this.pc = pc;
            if (window && window.requestAnimationFrame) {
                window.requestAnimationFrame(function () {
                    $initbar.css("width", rpc + '%');
                });
            }
        },

        setNbItem: function dcpLoadingSetNbItem(restItem) {
            this.rest = 100 - this.pc;
            this.restItem = restItem;
        },

        addItem: function dcpLoadingAddItem(number) {
            number = number || 1;
            number = parseInt(number, 10);
            this.doneItems += number;
            var pv = this.rest / this.restItem * number;
            this.setPercent(this.pc + pv);
        },

        _destroy: function dcpLoading_destroy() {
            this._trigger("destroy");
            this._super();
        }

    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/window/wNotification.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("external \"jQuery\""), __webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/widget.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function wNotification($, _) {
    'use strict';

    $.widget("dcp.dcpNotification", {

        options: {
            // animation:false,
            autoHideAfter: 5000,
            appendTo: "#dcpNotificationContainer",
            position: {
                top: 60, // override by notification.less
                right: 100
            },
            templates: [{
                type: "error",
                template: '<div class="dcpNotification--content dcpNotification--error">' + '<span class="dcpNotification--symbol fa-stack fa-lg"><span class="fa fa-bolt"></span></span>' + '<div class="dcpNotification--message"><h1>#: title #</h1>' + '<p>#: message #</p><p> #= htmlMessage #</p></div></div>'
            }, {
                type: "warning",
                template: '<div class="dcpNotification--content dcpNotification--warning">' + '<span class="dcpNotification--symbol fa-stack fa-lg"><span class="fa fa-warning fa-inverse"></span></span>' + '<div class="dcpNotification--message"><h1>#: title #</h1>' + '<p>#: message #</p><p> #= htmlMessage #</p></div></div>'
            }, {
                type: "info",
                template: '<div class="dcpNotification--content dcpNotification--info">' + '<span class="dcpNotification--symbol fa-stack fa-lg"><span class="fa fa-info fa-inverse fa-flip-horizontal"></span></span>' + '<div class="dcpNotification--message"><h1>#: title #</h1>' + '<p>#: message #</p><p> #= htmlMessage #</p></div></div>'
            }, {
                type: "notice",
                template: '<div class="dcpNotification--content dcpNotification--notice">' + '<span class="dcpNotification--symbol fa-stack fa-lg"><span class="fa fa-info fa-inverse fa-flip-horizontal"></span></span>' + '<div class="dcpNotification--message"><h1>#: title #</h1>' + '<p>#: message #</p><p> #= htmlMessage #</p></div></div>'
            }, {
                type: "success",
                template: '<div class="dcpNotification--content dcpNotification--info">' + '<span class="dcpNotification--symbol fa-stack fa-lg"><span class="fa fa-check fa-inverse"></span></span>' + '<div class="dcpNotification--message"><h1>#: title #</h1>' + '<p>#: message #</p><p> #= htmlMessage #</p></div></div>'
            }],

            labels: {
                moreButton: "View more ...",
                moreWindowTitle: "Notification"
            }
        },
        notificationElement: null,

        _create: function wNotificationCreate() {
            var scope = this;
            this.notificationElement = $('<div class="dcpNotification--widget" />');

            this.element.append($('<div id="dcpNotificationContainer" class="dcpNotifications"/>'));
            this.element.append(this.notificationElement);

            this.options.show = _.bind(this.showMore, this);
            this.notificationElement.kendoNotification(this.options);

            this.element.on("notification", function wNotificationOn(event, data) {
                scope.show(data.type, data);
            });
        },

        showMore: function wNotificationShowMessage(event) {
            var $boxMessage = event.element;
            var $message = $boxMessage.find(".dcpNotification--message");
            var $more;
            var widgetNotification = this;

            if ($message.prop("scrollHeight") > $message.height()) {
                $more = $('<div class="dcpNotification--more"/>').text(this.options.labels.moreButton);
                $boxMessage.append($more);
                $more.on("click", function wNotificationClickMode(event) {
                    var $clone = $boxMessage.clone();
                    var cloneWindow;

                    if (widgetNotification.cloneWindow) {
                        widgetNotification.cloneWindow.destroy();
                        widgetNotification.cloneWindow = null;
                    }
                    $boxMessage.append($clone);
                    $clone.find(".dcpNotification--more").remove();
                    $clone.find(".dcpNotification--message").prepend($clone.find(".dcpNotification--symbol"));
                    event.stopPropagation();
                    cloneWindow = $clone.kendoWindow({
                        title: widgetNotification.options.labels.moreWindowTitle,
                        width: "400px"
                    }).data("kendoWindow");
                    cloneWindow.center();
                    widgetNotification.cloneWindow = cloneWindow;
                });
            }
        },

        show: function wNotificationShow(type, options) {
            options.title = options.title || '';
            options.message = options.message || '';
            options.htmlMessage = options.htmlMessage || '';
            if ($.inArray(type, ["error", "info", "warning", "success", "notice"]) === -1) {
                type = "info";
            }
            this.notificationElement.data("kendoNotification").show({
                title: options.title,
                message: options.message,
                htmlMessage: options.htmlMessage // @TODO NEED TO CLEAN HTML TO PREVENT XSS
            }, type);
        },

        showError: function wNotificationShowError(options) {
            this.show("error", options);
        },

        showInfo: function wNotificationShowInfo(options) {
            this.show("info", options);
        },

        showWarning: function wNotificationShowWarning(options) {
            this.show("warning", options);
        },

        showSuccess: function wNotificationShowSuccess(options) {
            this.show("success", options);
        },

        clear: function wNotificationClear() {
            this.notificationElement.kendoNotification("hide");
            if (this.cloneWindow) {
                this.cloneWindow.destroy();
                this.cloneWindow = null;
            }
        }

    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "./src/Apps/DOCUMENT/IHM/widgets/window/wWindow.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__("./node_modules/underscore/underscore.js"), __webpack_require__("external \"jQuery\""), __webpack_require__("./src/Apps/DOCUMENT/IHM/widgets/widget.js")], __WEBPACK_AMD_DEFINE_RESULT__ = function wWindow(_, $) {
    'use strict';

    $.widget("dcp.dcpWindow", {
        intervalId: 0,
        options: {
            animation: {
                open: {
                    effects: "fade:in",
                    duration: 1000
                }, close: {
                    effects: "fade:out",
                    duration: 1000
                }
            },
            actions: ["Maximize", "Close"],
            visible: false,
            height: "300px",
            width: "400px",
            /**
             * Try to add iframe title if no title is set
             */
            open: function wWindowOpen() {
                if (!this.options.title) {
                    try {
                        var kendoWindow = this;
                        var iframeTitle = this.element.find('iframe').contents().find("title").html();
                        if (typeof iframeTitle === "undefined") {
                            _.defer(function wWindowOpenSetTitle() {
                                var currentTitle = "";
                                var $content = kendoWindow.element.find('iframe').contents();
                                kendoWindow.element.find('iframe').on("load", function wWindowOpenSetTitleNow() {
                                    try {
                                        var $scopeWindow = $(this);
                                        var $content = $scopeWindow.contents();

                                        kendoWindow.setOptions({
                                            title: currentTitle
                                        });
                                        $content.find("body").addClass("window-dialog");
                                    } catch (exp) {}
                                });

                                // Verify if need to change title every seconds
                                kendoWindow.intervalId = window.setInterval(function wWindowOpenSetTitleIsChanged() {
                                    try {
                                        $content = kendoWindow.element.find('iframe').contents();
                                        var newTitle = $content.find("title").html();
                                        var currentIcon = $content.find('link[rel="shortcut icon"]').attr("href");

                                        if (newTitle) {
                                            $content.find("body").addClass("window-dialog");
                                            if (currentIcon) {
                                                newTitle = '<img src="' + currentIcon + '" /> ' + newTitle;
                                            }
                                            if (newTitle !== currentTitle) {
                                                currentTitle = newTitle;
                                                $(kendoWindow.element).closest(".k-window").find(".k-window-title").html(newTitle);
                                            }
                                        }
                                    } catch (exp) {}
                                }, 1000);
                            });
                        } else {
                            kendoWindow.setOptions({
                                title: $(this).contents().find("title").html()
                            });
                        }
                    } catch (exp) {}
                }
            },
            close: function wWindowClose() {
                window.clearInterval(this.intervalId);
            },
            destroy: function wWindowDestroy() {
                window.clearInterval(this.intervalId);
            }
        },

        currentWidget: null,
        _create: function wWindowCreate() {
            this.currentWidget = $('<div class="dialog-window"/>');
            this.element.append(this.currentWidget);
            this.element.data("dcpWindow", this);

            this.currentWidget.kendoWindow(this.options);
        },

        _getWindowTemplate: function wWindowCreate_getWindowTemplate(templateId) {
            if (this.options.templateData && this.options.templateData.templates && this.options.templateData.templates.window && this.options.templateData.templates.window[templateId]) {
                return this.options.templateData.templates.window[templateId];
            }
            if (window.dcp && window.dcp.templates && window.dcp.templates.window && window.dcp.templates.window[templateId]) {
                return window.dcp.templates.window[templateId];
            }
            throw new Error("Unknown window template  " + templateId);
        },
        destroy: function wWindowDestroy() {
            window.clearInterval(this.intervalId);
            if (this.currentWidget && this.currentWidget.data("kendoWindow")) {
                this.currentWidget.data("kendoWindow").destroy();
            }
            this._super();
        },
        open: function wWindowopen() {
            this.currentWidget.data("kendoWindow").open();
        },
        close: function wWindowClose() {
            window.clearInterval(this.intervalId);
            this.currentWidget.data("kendoWindow").close();
        },
        kendoWindow: function wWindowkendoWindow() {
            return this.currentWidget.data("kendoWindow");
        }
    });
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

/***/ }),

/***/ "external \"jQuery\"":
/***/ (function(module, exports) {

module.exports = jQuery;

/***/ }),

/***/ "external \"kendo\"":
/***/ (function(module, exports) {

module.exports = kendo;

/***/ })

/******/ });
//# sourceMappingURL=mainSmartElement.js.map