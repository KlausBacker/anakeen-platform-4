/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/Anakeen/smartStructures/dev/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ({

/***/ "04065e00ab361f322eef":
/*!**************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.treeview.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1339);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 1003:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! jquery */ \"127c8cf59f228bb01a21\");\n\n/***/ }),\n\n/***/ 1013:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.data */ \"f78db54954381e284430\");\n\n/***/ }),\n\n/***/ 1338:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.treeview.draganddrop */ \"52de5ccd30df4e157d32\");\n\n/***/ }),\n\n/***/ 1339:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(jQuery) {(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1013), __webpack_require__(1338) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: \"treeview\",\n\t    name: \"TreeView\",\n\t    category: \"web\",\n\t    description: \"The TreeView widget displays hierarchical data in a traditional tree structure,with support for interactive drag-and-drop operations.\",\n\t    depends: [ \"data\" ],\n\t    features: [{\n\t        id: \"treeview-dragging\",\n\t        name: \"Drag & Drop\",\n\t        description: \"Support for drag & drop\",\n\t        depends: [ \"treeview.draganddrop\" ]\n\t    }]\n\t};\n\n\t/*jshint eqnull: true */\n\t(function($, undefined){\n\t    var kendo = window.kendo,\n\t        ui = kendo.ui,\n\t        data = kendo.data,\n\t        extend = $.extend,\n\t        template = kendo.template,\n\t        isArray = $.isArray,\n\t        Widget = ui.Widget,\n\t        HierarchicalDataSource = data.HierarchicalDataSource,\n\t        proxy = $.proxy,\n\t        keys = kendo.keys,\n\t        NS = \".kendoTreeView\",\n\t        TEMP_NS = \".kendoTreeViewTemp\",\n\t        SELECT = \"select\",\n\t        CHECK = \"check\",\n\t        NAVIGATE = \"navigate\",\n\t        EXPAND = \"expand\",\n\t        CHANGE = \"change\",\n\t        ERROR = \"error\",\n\t        CHECKED = \"checked\",\n\t        INDETERMINATE = \"indeterminate\",\n\t        COLLAPSE = \"collapse\",\n\t        DRAGSTART = \"dragstart\",\n\t        DRAG = \"drag\",\n\t        DROP = \"drop\",\n\t        DRAGEND = \"dragend\",\n\t        DATABOUND = \"dataBound\",\n\t        CLICK = \"click\",\n\t        UNDEFINED = \"undefined\",\n\t        KSTATEHOVER = \"k-state-hover\",\n\t        KTREEVIEW = \"k-treeview\",\n\t        VISIBLE = \":visible\",\n\t        NODE = \".k-item\",\n\t        STRING = \"string\",\n\t        ARIACHECKED = \"aria-checked\",\n\t        ARIASELECTED = \"aria-selected\",\n\t        ARIADISABLED = \"aria-disabled\",\n\t        DISABLED = \"k-state-disabled\",\n\t        TreeView,\n\t        subGroup, nodeContents, nodeIcon,\n\t        spriteRe,\n\t        bindings = {\n\t            text: \"dataTextField\",\n\t            url: \"dataUrlField\",\n\t            spriteCssClass: \"dataSpriteCssClassField\",\n\t            imageUrl: \"dataImageUrlField\"\n\t        },\n\t        isJQueryInstance = function(obj) {\n\t            return (obj instanceof kendo.jQuery) || (obj instanceof window.jQuery);\n\t        },\n\t        isDomElement = function (o){\n\t            return (\n\t                typeof HTMLElement === \"object\" ? o instanceof HTMLElement : //DOM2\n\t                o && typeof o === \"object\" && o.nodeType === 1 && typeof o.nodeName === STRING\n\t            );\n\t        };\n\n\t    function contentChild(filter) {\n\t        return function(node) {\n\t            var result = node.children(\".k-animation-container\");\n\n\t            if (!result.length) {\n\t                result = node;\n\t            }\n\n\t            return result.children(filter);\n\t        };\n\t    }\n\n\t    function templateNoWith(code) {\n\t        return kendo.template(code, { useWithBlock: false });\n\t    }\n\n\t    subGroup = contentChild(\".k-group\");\n\t    nodeContents = contentChild(\".k-group,.k-content\");\n\t    nodeIcon = function(node) {\n\t        return node.children(\"div\").children(\".k-icon\");\n\t    };\n\n\t    function checkboxes(node) {\n\t        return node.find(\".k-checkbox-wrapper:first input[type=checkbox]\");\n\t    }\n\n\t    function insertAction(indexOffset) {\n\t        return function (nodeData, referenceNode) {\n\t            referenceNode = referenceNode.closest(NODE);\n\n\t            var group = referenceNode.parent(),\n\t                parentNode;\n\n\t            if (group.parent().is(\"li\")) {\n\t                parentNode = group.parent();\n\t            }\n\n\t            return this._dataSourceMove(nodeData, group, parentNode, function (dataSource, model) {\n\t                var referenceItem = this.dataItem(referenceNode);\n\t                var referenceNodeIndex = referenceItem ? referenceItem.parent().indexOf(referenceItem) : referenceNode.index();\n\n\t                return this._insert(dataSource.data(), model, referenceNodeIndex + indexOffset);\n\t            });\n\t        };\n\t    }\n\n\t    spriteRe = /k-sprite/;\n\n\t    function moveContents(node, container) {\n\t        var tmp;\n\n\t        while (node && node.nodeName.toLowerCase() != \"ul\") {\n\t            tmp = node;\n\t            node = node.nextSibling;\n\n\t            if (tmp.nodeType == 3) {\n\t                tmp.nodeValue = $.trim(tmp.nodeValue);\n\t            }\n\n\t            if (spriteRe.test(tmp.className)) {\n\t                container.insertBefore(tmp, container.firstChild);\n\t            } else {\n\t                container.appendChild(tmp);\n\t            }\n\t        }\n\t    }\n\n\t    function updateNodeHtml(node) {\n\t        var wrapper = node.children(\"div\"),\n\t            group = node.children(\"ul\"),\n\t            toggleButton = wrapper.children(\".k-icon\"),\n\t            checkbox = node.children(\"input[type=checkbox]\"),\n\t            innerWrapper = wrapper.children(\".k-in\");\n\n\t        if (node.hasClass(\"k-treeview\")) {\n\t            return;\n\t        }\n\n\t        if (!wrapper.length) {\n\t            wrapper = $(\"<div />\").prependTo(node);\n\t        }\n\n\t        if (!toggleButton.length && group.length) {\n\t            toggleButton = $(\"<span class='k-icon' />\").prependTo(wrapper);\n\t        } else if (!group.length || !group.children().length) {\n\t            toggleButton.remove();\n\t            group.remove();\n\t        }\n\n\t        if (checkbox.length) {\n\t            $(\"<span class='k-checkbox-wrapper' />\").appendTo(wrapper).append(checkbox);\n\t        }\n\n\t        if (!innerWrapper.length) {\n\t            innerWrapper = node.children(\"a\").eq(0).addClass(\"k-in k-link\");\n\n\t            if (!innerWrapper.length) {\n\t                innerWrapper = $(\"<span class='k-in' />\");\n\t            }\n\n\t            innerWrapper.appendTo(wrapper);\n\n\t            if (wrapper.length) {\n\t                moveContents(wrapper[0].nextSibling, innerWrapper[0]);\n\t            }\n\t        }\n\t    }\n\n\t    TreeView = kendo.ui.DataBoundWidget.extend({\n\t        init: function (element, options) {\n\t            var that = this,\n\t                inferred = false,\n\t                hasDataSource = options && !!options.dataSource,\n\t                list;\n\n\t            if (isArray(options)) {\n\t                options = { dataSource: options };\n\t            }\n\n\t            if (options && typeof options.loadOnDemand == UNDEFINED && isArray(options.dataSource)) {\n\t                options.loadOnDemand = false;\n\t            }\n\n\t            Widget.prototype.init.call(that, element, options);\n\n\t            element = that.element;\n\t            options = that.options;\n\n\t            that._dataSourceUids = {};\n\n\t            list = (element.is(\"ul\") && element) ||\n\t                   (element.hasClass(KTREEVIEW) && element.children(\"ul\"));\n\n\t            inferred = !hasDataSource && list.length;\n\n\t            if (inferred) {\n\t                options.dataSource.list = list;\n\t            }\n\n\t            that._animation();\n\n\t            that._accessors();\n\n\t            that._templates();\n\n\t            // render treeview if it's not already rendered\n\t            if (!element.hasClass(KTREEVIEW)) {\n\t                that._wrapper();\n\n\t                if (list) {\n\t                    that.root = element;\n\t                    that._group(that.wrapper);\n\t                }\n\t            } else {\n\t                // otherwise just initialize properties\n\t                that.wrapper = element;\n\t                that.root = element.children(\"ul\").eq(0);\n\t            }\n\n\t            that._tabindex();\n\n\t            that.wrapper.attr(\"role\", \"tree\");\n\n\t            that._dataSource(inferred);\n\n\t            that._attachEvents();\n\n\t            that._dragging();\n\n\t            if (!inferred) {\n\t                if (options.autoBind) {\n\t                    that._progress(true);\n\t                    that.dataSource.fetch();\n\t                }\n\t            } else {\n\t                that._syncHtmlAndDataSource();\n\t            }\n\n\t            if (options.checkboxes && options.checkboxes.checkChildren) {\n\t                that.updateIndeterminate();\n\t            }\n\n\t            if (that.element[0].id) {\n\t                that._ariaId = kendo.format(\"{0}_tv_active\", that.element[0].id);\n\t            }\n\n\t            kendo.notify(that);\n\t        },\n\n\t        _attachEvents: function() {\n\t            var that = this,\n\t                clickableItems = \".k-in:not(.k-state-selected,.k-state-disabled)\",\n\t                MOUSEENTER = \"mouseenter\";\n\n\t            that.wrapper\n\t                .on(MOUSEENTER + NS, \".k-in.k-state-selected\", function(e) { e.preventDefault(); })\n\t                .on(MOUSEENTER + NS, clickableItems, function () { $(this).addClass(KSTATEHOVER); })\n\t                .on(\"mouseleave\" + NS, clickableItems, function () { $(this).removeClass(KSTATEHOVER); })\n\t                .on(CLICK + NS, clickableItems, proxy(that._click, that))\n\t                .on(\"dblclick\" + NS, \".k-in:not(.k-state-disabled)\", proxy(that._toggleButtonClick, that))\n\t                .on(CLICK + NS, \".k-i-expand,.k-i-collapse\", proxy(that._toggleButtonClick, that))\n\t                .on(\"keydown\" + NS, proxy(that._keydown, that))\n\t                .on(\"keypress\" + NS, proxy(that._keypress, that))\n\t                .on(\"focus\" + NS, proxy(that._focus, that))\n\t                .on(\"blur\" + NS, proxy(that._blur, that))\n\t                .on(\"mousedown\" + NS, \".k-in,.k-checkbox-wrapper :checkbox,.k-i-expand,.k-i-collapse\", proxy(that._mousedown, that))\n\t                .on(\"change\" + NS, \".k-checkbox-wrapper :checkbox\", proxy(that._checkboxChange, that))\n\t                .on(\"click\" + NS, \".checkbox-span\", proxy(that._checkboxLabelClick, that))\n\t                .on(\"click\" + NS, \".k-request-retry\", proxy(that._retryRequest, that))\n\t                .on(\"click\" + NS, \".k-link.k-state-disabled\", function(e) { e.preventDefault(); })\n\t                .on(\"click\" + NS, function(e) {\n\t                    if (!$(e.target).is(\":kendoFocusable\")) {\n\t                        that.focus();\n\t                    }\n\t                });\n\t        },\n\n\t        _checkboxLabelClick: function(e) {\n\t            var checkbox = $(e.target.previousSibling);\n\n\t            if (checkbox.is(\"[disabled]\")) {\n\t                return;\n\t            }\n\n\t            checkbox.prop('checked', !checkbox.prop('checked'));\n\t            checkbox.trigger('change');\n\t        },\n\n\t        _syncHtmlAndDataSource: function (root, dataSource) {\n\t            root = root || this.root;\n\t            dataSource = dataSource || this.dataSource;\n\t            var data = dataSource.view(),\n\t                uidAttr = kendo.attr(\"uid\"),\n\t                expandedAttr = kendo.attr(\"expanded\"),\n\t                checkboxesEnabled = this.options.checkboxes,\n\t                items = root.children(\"li\"),\n\t                i,\n\t                item,\n\t                dataItem,\n\t                uid,\n\t                itemCheckbox;\n\n\t            for (i = 0; i < items.length; i++) {\n\t                dataItem = data[i];\n\t                uid = dataItem.uid;\n\t                item = items.eq(i);\n\t                item.attr(\"role\", \"treeitem\")\n\t                    .attr(uidAttr, uid)\n\t                    .attr(ARIASELECTED, item.hasClass(\"k-state-selected\"));\n\n\t                dataItem.expanded = item.attr(expandedAttr) === \"true\";\n\n\t                if (checkboxesEnabled) {\n\t                    itemCheckbox = checkboxes(item);\n\t                    dataItem.checked = itemCheckbox.prop(CHECKED);\n\t                    itemCheckbox.attr(\"id\", \"_\" + uid);\n\t                    itemCheckbox.next(\".k-checkbox-label\").attr(\"for\", \"_\" + uid);\n\t                }\n\n\t                this._syncHtmlAndDataSource(item.children(\"ul\"), dataItem.children);\n\t            }\n\t        },\n\n\t        _animation: function() {\n\t            var options = this.options,\n\t                animationOptions = options.animation,\n\t                hasCollapseAnimation = animationOptions.collapse && \"effects\" in animationOptions.collapse,\n\t                collapse = extend({}, animationOptions.expand, animationOptions.collapse);\n\n\t            if (!hasCollapseAnimation) {\n\t                collapse = extend(collapse, {reverse: true});\n\t            }\n\n\t            if (animationOptions === false) {\n\t                animationOptions = {\n\t                    expand: { effects: {} },\n\t                    collapse: { hide: true, effects: {} }\n\t                };\n\t            }\n\n\t            animationOptions.collapse = extend(collapse, {hide: true});\n\t            options.animation = animationOptions;\n\t        },\n\n\t        _dragging: function() {\n\t            var enabled = this.options.dragAndDrop;\n\t            var dragging = this.dragging;\n\n\t            if (enabled && !dragging) {\n\t                var widget = this;\n\n\t                this.dragging = new ui.HierarchicalDragAndDrop(this.element, {\n\t                    reorderable: true,\n\t                    $angular: this.options.$angular,\n\t                    autoScroll: this.options.autoScroll,\n\t                    filter: \"div:not(.k-state-disabled) .k-in\",\n\t                    allowedContainers: \".k-treeview\",\n\t                    itemSelector: \".k-treeview .k-item\",\n\t                    hintText: proxy(this._hintText, this),\n\t                    contains: function(source, destination) {\n\t                        return $.contains(source, destination);\n\t                    },\n\t                    dropHintContainer: function(item) {\n\t                        return item;\n\t                    },\n\t                    itemFromTarget: function(target) {\n\t                        var item = target.closest(\".k-top,.k-mid,.k-bot\");\n\t                        return {\n\t                            item: item,\n\t                            content: target.closest(\".k-in\"),\n\t                            first: item.hasClass(\"k-top\"),\n\t                            last: item.hasClass(\"k-bot\")\n\t                        };\n\t                    },\n\t                    dropPositionFrom: function(dropHint) {\n\t                        return dropHint.prevAll(\".k-in\").length > 0 ? \"after\" : \"before\";\n\t                    },\n\t                    dragstart: function(source) {\n\t                        return widget.trigger(DRAGSTART, { sourceNode: source[0] });\n\t                    },\n\t                    drag: function(options) {\n\t                        widget.trigger(DRAG, {\n\t                            originalEvent: options.originalEvent,\n\t                            sourceNode: options.source[0],\n\t                            dropTarget: options.target[0],\n\t                            pageY: options.pageY,\n\t                            pageX: options.pageX,\n\t                            statusClass: options.status,\n\t                            setStatusClass: options.setStatus\n\t                        });\n\t                    },\n\t                    drop: function(options) {\n\t                        var dropTarget = $(options.dropTarget);\n\t                        var navigationTarget = dropTarget.closest(\"a\");\n\n\t                        if(navigationTarget && navigationTarget.attr(\"href\")) {\n\t                            widget._tempPreventNavigation(navigationTarget);\n\t                        }\n\n\t                        return widget.trigger(DROP, {\n\t                            originalEvent: options.originalEvent,\n\t                            sourceNode: options.source,\n\t                            destinationNode: options.destination,\n\t                            valid: options.valid,\n\t                            setValid: function(state) {\n\t                                this.valid = state;\n\t                                options.setValid(state);\n\t                            },\n\t                            dropTarget: options.dropTarget,\n\t                            dropPosition: options.position\n\t                        });\n\t                    },\n\t                    dragend: function(options) {\n\t                        var source = options.source;\n\t                        var destination = options.destination;\n\t                        var position = options.position;\n\n\t                        function triggerDragEnd(source) {\n\t                            if (widget.options.checkboxes && widget.options.checkboxes.checkChildren) {\n\t                                widget.updateIndeterminate();\n\t                            }\n\n\t                            widget.trigger(DRAGEND, {\n\t                                originalEvent: options.originalEvent,\n\t                                sourceNode: source && source[0],\n\t                                destinationNode: destination[0],\n\t                                dropPosition: position\n\t                            });\n\t                        }\n\n\t                        // perform reorder / move\n\t                        // different handling is necessary because append might be async in remote bound tree\n\t                        if (position == \"over\") {\n\t                            widget.append(source, destination, triggerDragEnd);\n\t                        } else {\n\t                            if (position == \"before\") {\n\t                                source = widget.insertBefore(source, destination);\n\t                            } else if (position == \"after\") {\n\t                                source = widget.insertAfter(source, destination);\n\t                            }\n\n\t                            triggerDragEnd(source);\n\t                        }\n\t                    }\n\t                });\n\t            } else if (!enabled && dragging) {\n\t                dragging.destroy();\n\t                this.dragging = null;\n\t            }\n\t        },\n\n\t        _tempPreventNavigation: function(node) {\n\t            node.on(CLICK + NS + TEMP_NS, function (ev) {\n\t                ev.preventDefault();\n\t                node.off(CLICK + NS + TEMP_NS);\n\t            });\n\t        },\n\n\t        _hintText: function(node) {\n\t            return this.templates.dragClue({\n\t                item: this.dataItem(node),\n\t                treeview: this.options\n\t            });\n\t        },\n\n\t        _templates: function() {\n\t            var that = this,\n\t                options = that.options,\n\t                fieldAccessor = proxy(that._fieldAccessor, that);\n\n\t            if (options.template && typeof options.template == STRING) {\n\t                options.template = template(options.template);\n\t            } else if (!options.template) {\n\t                options.template = templateNoWith(\n\t                    \"# var text = \" + fieldAccessor(\"text\") + \"(data.item); #\" +\n\t                    \"# if (typeof data.item.encoded != 'undefined' && data.item.encoded === false) {#\" +\n\t                        \"#= text #\" +\n\t                    \"# } else { #\" +\n\t                        \"#: text #\" +\n\t                    \"# } #\"\n\t                );\n\t            }\n\n\t            that._checkboxes();\n\n\t            that.templates = {\n\t                wrapperCssClass: function (group, item) {\n\t                    var result = \"k-item\",\n\t                        index = item.index;\n\n\t                    if (group.firstLevel && index === 0) {\n\t                        result += \" k-first\";\n\t                    }\n\n\t                    if (index == group.length-1) {\n\t                        result += \" k-last\";\n\t                    }\n\n\t                    return result;\n\t                },\n\t                cssClass: function(group, item) {\n\t                    var result = \"\",\n\t                        index = item.index,\n\t                        groupLength = group.length - 1;\n\n\t                    if (group.firstLevel && index === 0) {\n\t                        result += \"k-top \";\n\t                    }\n\n\t                    if (index === 0 && index != groupLength) {\n\t                        result += \"k-top\";\n\t                    } else if (index == groupLength) {\n\t                        result += \"k-bot\";\n\t                    } else {\n\t                        result += \"k-mid\";\n\t                    }\n\n\t                    return result;\n\t                },\n\t                textClass: function(item, isLink) {\n\t                    var result = \"k-in\";\n\n\t                    if (isLink) {\n\t                        result += \" k-link\";\n\t                    }\n\n\t                    if (item.enabled === false) {\n\t                        result += \" k-state-disabled\";\n\t                    }\n\n\t                    if (item.selected === true) {\n\t                        result += \" k-state-selected\";\n\t                    }\n\n\t                    return result;\n\t                },\n\t                toggleButtonClass: function(item) {\n\t                    var result = \"k-icon\";\n\n\t                    if (item.expanded !== true) {\n\t                        result += \" k-i-expand\";\n\t                    } else {\n\t                        result += \" k-i-collapse\";\n\t                    }\n\n\t                    return result;\n\t                },\n\t                groupAttributes: function(group) {\n\t                    var attributes = \"\";\n\n\t                    if (!group.firstLevel) {\n\t                        attributes = \"role='group'\";\n\t                    }\n\n\t                    return attributes + (group.expanded !== true ? \" style='display:none'\" : \"\");\n\t                },\n\t                groupCssClass: function(group) {\n\t                    var cssClass = \"k-group\";\n\n\t                    if (group.firstLevel) {\n\t                        cssClass += \" k-treeview-lines\";\n\t                    }\n\n\t                    return cssClass;\n\t                },\n\t                dragClue: templateNoWith(\n\t                    \"#= data.treeview.template(data) #\"\n\t                ),\n\t                group: templateNoWith(\n\t                    \"<ul role='group' class='#= data.r.groupCssClass(data.group) #'#= data.r.groupAttributes(data.group) #>\" +\n\t                        \"#= data.renderItems(data) #\" +\n\t                    \"</ul>\"\n\t                ),\n\t                itemContent: templateNoWith(\n\t                    \"# var imageUrl = \" + fieldAccessor(\"imageUrl\") + \"(data.item); #\" +\n\t                    \"# var spriteCssClass = \" + fieldAccessor(\"spriteCssClass\") + \"(data.item); #\" +\n\t                    \"# if (imageUrl) { #\" +\n\t                        \"<img class='k-image' alt='' src='#= imageUrl #'>\" +\n\t                    \"# } #\" +\n\n\t                    \"# if (spriteCssClass) { #\" +\n\t                        \"<span class='k-sprite #= spriteCssClass #' />\" +\n\t                    \"# } #\" +\n\n\t                    \"#= data.treeview.template(data) #\"\n\t                ),\n\t                itemElement: templateNoWith(\n\t                    \"# var item = data.item, r = data.r; #\" +\n\t                    \"# var url = \" + fieldAccessor(\"url\") + \"(item); #\" +\n\t                    \"<div class='#= r.cssClass(data.group, item) #'>\" +\n\t                        \"# if (item.hasChildren) { #\" +\n\t                            \"<span class='#= r.toggleButtonClass(item) #'/>\" +\n\t                        \"# } #\" +\n\n\t                        \"# if (data.treeview.checkboxes) { #\" +\n\t                            \"<span class='k-checkbox-wrapper' role='presentation'>\" +\n\t                                \"#= data.treeview.checkboxes.template(data) #\" +\n\t                            \"</span>\" +\n\t                        \"# } #\" +\n\n\t                        \"# var tag = url ? 'a' : 'span'; #\" +\n\t                        \"# var textAttr = url ? ' href=\\\\'' + url + '\\\\'' : ''; #\" +\n\n\t                        \"<#=tag# class='#= r.textClass(item, !!url) #'#= textAttr #>\" +\n\t                            \"#= r.itemContent(data) #\" +\n\t                        \"</#=tag#>\" +\n\t                    \"</div>\"\n\t                ),\n\t                item: templateNoWith(\n\t                    \"# var item = data.item, r = data.r; #\" +\n\t                    \"<li role='treeitem' class='#= r.wrapperCssClass(data.group, item) #'\" +\n\t                        kendo.attr(\"uid\") + \"='#= item.uid #' \" +\n\t                        \"aria-checked='#= item.checked ? \\\"true\\\" : \\\"false\\\" #' \" +\n\t                        \"aria-selected='#= item.selected ? \\\"true\\\" : \\\"false\\\" #' \" +\n\t                        \"#=item.enabled === false ? \\\"aria-disabled='true'\\\" : ''#\" +\n\t                        \"aria-expanded='#= item.expanded ? \\\"true\\\" : \\\"false\\\" #' \" +\n\t                        \"data-expanded='#= item.expanded ? \\\"true\\\" : \\\"false\\\" #' \" +\n\t                    \">\" +\n\t                        \"#= r.itemElement(data) #\" +\n\t                    \"</li>\"\n\t                ),\n\t                loading: templateNoWith(\n\t                    \"<div class='k-icon k-i-loading' /> #: data.messages.loading #\"\n\t                ),\n\t                retry: templateNoWith(\n\t                    \"#: data.messages.requestFailed # \" +\n\t                    \"<button class='k-button k-request-retry'>#: data.messages.retry #</button>\"\n\t                )\n\t            };\n\t        },\n\n\t        items: function() {\n\t            return this.element.find(\".k-item > div:first-child\");\n\t        },\n\n\t        setDataSource: function(dataSource) {\n\t            var options = this.options;\n\n\t            options.dataSource = dataSource;\n\n\t            this._dataSourceUids = {};\n\n\t            this._dataSource();\n\n\t            if (options.checkboxes && options.checkboxes.checkChildren) {\n\t                this.dataSource.one(\"change\", $.proxy(this.updateIndeterminate, this, null));\n\t            }\n\n\t            if (this.options.autoBind) {\n\t                this.dataSource.fetch();\n\t            }\n\t        },\n\n\t        _bindDataSource: function() {\n\t            this._refreshHandler = proxy(this.refresh, this);\n\t            this._errorHandler = proxy(this._error, this);\n\n\t            this.dataSource.bind(CHANGE, this._refreshHandler);\n\t            this.dataSource.bind(ERROR, this._errorHandler);\n\t        },\n\n\t        _unbindDataSource: function() {\n\t            var dataSource = this.dataSource;\n\n\t            if (dataSource) {\n\t                dataSource.unbind(CHANGE, this._refreshHandler);\n\t                dataSource.unbind(ERROR, this._errorHandler);\n\t            }\n\t        },\n\n\t        _dataSource: function(silentRead) {\n\t            var that = this,\n\t                options = that.options,\n\t                dataSource = options.dataSource;\n\n\t            function recursiveRead(data) {\n\t                for (var i = 0; i < data.length; i++) {\n\t                    data[i]._initChildren();\n\n\t                    data[i].children.fetch();\n\n\t                    recursiveRead(data[i].children.view());\n\t                }\n\t            }\n\n\t            dataSource = isArray(dataSource) ? { data: dataSource } : dataSource;\n\n\t            that._unbindDataSource();\n\n\t            if (!dataSource.fields) {\n\t                dataSource.fields = [\n\t                    { field: \"text\" },\n\t                    { field: \"url\" },\n\t                    { field: \"spriteCssClass\" },\n\t                    { field: \"imageUrl\" }\n\t                ];\n\t            }\n\n\t            that.dataSource = dataSource = HierarchicalDataSource.create(dataSource);\n\n\t            if (silentRead) {\n\t                dataSource.fetch();\n\n\t                recursiveRead(dataSource.view());\n\t            }\n\n\t            that._bindDataSource();\n\t        },\n\n\t        events: [\n\t            DRAGSTART,\n\t            DRAG,\n\t            DROP,\n\t            DRAGEND,\n\n\t            DATABOUND,\n\n\t            EXPAND,\n\t            COLLAPSE,\n\t            SELECT,\n\t            CHANGE,\n\t            NAVIGATE,\n\t            CHECK\n\t        ],\n\n\t        options: {\n\t            name: \"TreeView\",\n\t            dataSource: {},\n\t            animation: {\n\t                expand: {\n\t                    effects: \"expand:vertical\",\n\t                    duration: 200\n\t                }, collapse: {\n\t                    duration: 100\n\t                }\n\t            },\n\t            messages: {\n\t                loading: \"Loading...\",\n\t                requestFailed: \"Request failed.\",\n\t                retry: \"Retry\"\n\t            },\n\t            dragAndDrop: false,\n\t            checkboxes: false,\n\t            autoBind: true,\n\t            autoScroll: false,\n\t            loadOnDemand: true,\n\t            template: \"\",\n\t            dataTextField: null\n\t        },\n\n\t        _accessors: function() {\n\t            var that = this,\n\t                options = that.options,\n\t                i, field, textField,\n\t                element = that.element;\n\n\t            for (i in bindings) {\n\t                field = options[bindings[i]];\n\t                textField = element.attr(kendo.attr(i + \"-field\"));\n\n\t                if (!field && textField) {\n\t                    field = textField;\n\t                }\n\n\t                if (!field) {\n\t                    field = i;\n\t                }\n\n\t                if (!isArray(field)) {\n\t                    field = [field];\n\t                }\n\n\t                options[bindings[i]] = field;\n\t            }\n\t        },\n\n\t        // generates accessor function for a given field name, honoring the data*Field arrays\n\t        _fieldAccessor: function(fieldName) {\n\t            var fieldBindings = this.options[bindings[fieldName]],\n\t                count = fieldBindings.length,\n\t                result = \"(function(item) {\";\n\n\t            if (count === 0) {\n\t                result += \"return item['\" + fieldName + \"'];\";\n\t            } else {\n\t                result += \"var levels = [\" +\n\t                            $.map(fieldBindings, function(x) {\n\t                                return \"function(d){ return \" + kendo.expr(x) + \"}\";\n\t                            }).join(\",\") + \"];\";\n\n\t                result += \"return levels[Math.min(item.level(), \" + count + \"-1)](item)\";\n\t            }\n\n\t            result += \"})\";\n\n\t            return result;\n\t        },\n\n\t        setOptions: function(options) {\n\t            Widget.fn.setOptions.call(this, options);\n\n\t            this._animation();\n\n\t            this._dragging();\n\n\t            this._templates();\n\t        },\n\n\t        _trigger: function (eventName, node) {\n\t            return this.trigger(eventName, {\n\t                node: node.closest(NODE)[0]\n\t            });\n\t        },\n\n\t        _setChecked: function(datasource, value) {\n\t            if (!datasource || !$.isFunction(datasource.view)) {\n\t                return;\n\t            }\n\n\t            for (var i = 0, nodes = datasource.view(); i < nodes.length; i++) {\n\t                if(nodes[i].enabled !== false){\n\t                    this._setCheckedValue(nodes[i], value);\n\t                }\n\n\t                if (nodes[i].children) {\n\t                    this._setChecked(nodes[i].children, value);\n\t                }\n\t            }\n\t        },\n\n\t        _setCheckedValue: function (node, value){\n\t            node[CHECKED] = value;\n\t        },\n\n\t        _setIndeterminate: function(node) {\n\t            var group = subGroup(node),\n\t                siblings, length,\n\t                all = true,\n\t                i;\n\n\t            if (!group.length) {\n\t                return;\n\t            }\n\n\t            siblings = checkboxes(group.children());\n\n\t            length = siblings.length;\n\n\t            if (!length) {\n\t                return;\n\t            } else if (length > 1) {\n\t                for (i = 1; i < length; i++) {\n\t                    if (siblings[i].checked != siblings[i-1].checked ||\n\t                        siblings[i].indeterminate || siblings[i-1].indeterminate) {\n\t                        all = false;\n\t                        break;\n\t                    }\n\t                }\n\t            } else {\n\t                all = !siblings[0].indeterminate;\n\t            }\n\n\t            node.attr(ARIACHECKED, all ? siblings[0].checked : \"mixed\");\n\n\t            return checkboxes(node)\n\t                .data(INDETERMINATE, !all)\n\t                .prop(INDETERMINATE, !all)\n\t                .prop(CHECKED, all && siblings[0].checked);\n\t        },\n\n\t        updateIndeterminate: function(node) {\n\t            // top-down update of inital indeterminate state for all nodes\n\t            node = node || this.wrapper;\n\n\t            var subnodes = subGroup(node).children();\n\t            var i;\n\t            var checkbox;\n\t            var dataItem;\n\n\t            if (subnodes.length) {\n\t                for (i = 0; i < subnodes.length; i++) {\n\t                    this.updateIndeterminate(subnodes.eq(i));\n\t                }\n\n\t                if (node.is(\".k-treeview\")) {\n\t                    return;\n\t                }\n\n\t                checkbox = this._setIndeterminate(node);\n\n\t                dataItem = this.dataItem(node);\n\n\t                if (checkbox && checkbox.prop(CHECKED)) {\n\t                    dataItem.checked = true;\n\t                } else {\n\t                    if (dataItem) {\n\t                        delete dataItem.checked;\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _bubbleIndeterminate: function(node, skipDownward) {\n\t            // bottom-up setting of indeterminate state of parent nodes\n\t            if (!node.length) {\n\t                return;\n\t            }\n\n\t            if (!skipDownward) {\n\t                //update the indeterminate state of the node itself\n\t                this.updateIndeterminate(node);\n\t            }\n\n\t            var parentNode = this.parent(node),\n\t                checkbox;\n\n\t            if (parentNode.length) {\n\t                this._setIndeterminate(parentNode);\n\n\t                checkbox = parentNode.children(\"div\").find(\".k-checkbox-wrapper input[type=checkbox]\");\n\n\t                this._skip = true;\n\t                if (checkbox.prop(INDETERMINATE) === false) {\n\t                    this.dataItem(parentNode).set(CHECKED, checkbox.prop(CHECKED));\n\t                } else {\n\t                    // delete this.dataItem(parentNode).checked;\n\t                    this.dataItem(parentNode).set(CHECKED, false);\n\t                }\n\n\t                this._skip = false;\n\n\t                this._bubbleIndeterminate(parentNode, true);\n\t            }\n\t        },\n\n\t        _checkboxChange: function(e) {\n\t            var checkbox = $(e.target);\n\t            var isChecked = checkbox.prop(CHECKED);\n\t            var node = checkbox.closest(NODE);\n\t            var dataItem = this.dataItem(node);\n\n\t            if (this._preventChange) {\n\t                return;\n\t            }\n\n\t            if (dataItem.checked != isChecked) {\n\t                dataItem.set(CHECKED, isChecked);\n\t                node.attr(ARIACHECKED, isChecked);\n\t                this._trigger(CHECK, node);\n\t            }\n\t        },\n\n\t        _toggleButtonClick: function (e) {\n\t            var node = $(e.currentTarget).closest(NODE);\n\n\t            if (node.is(\"[aria-disabled='true']\")) {\n\t                return;\n\t            }\n\n\t            this.toggle(node);\n\t        },\n\n\t        _mousedown: function(e) {\n\t            var that = this;\n\t            var currentTarget = $(e.currentTarget);\n\t            var node = $(e.currentTarget).closest(NODE);\n\t            var browser = kendo.support.browser;\n\n\t            if (node.is(\"[aria-disabled='true']\")) {\n\t                return;\n\t            }\n\n\t            //IE does not trigger change for indeterminate checkboxes\n\t            if ((browser.msie || browser.edge) && currentTarget.is(\":checkbox\")) {\n\t                if (currentTarget.prop(INDETERMINATE)) {\n\t                    that._preventChange = false;\n\n\t                    currentTarget.prop(CHECKED, !currentTarget.prop(CHECKED));\n\t                    currentTarget.trigger(CHANGE);\n\n\t                    currentTarget.on(CLICK + NS, function (e) {\n\t                        e.preventDefault();\n\t                    });\n\n\t                    that._preventChange = true;\n\t                } else {\n\t                    currentTarget.off(CLICK + NS);\n\t                    that._preventChange = false;\n\t                }\n\t            }\n\n\t            that._clickTarget = node;\n\t            that.current(node);\n\t        },\n\n\t        _focusable: function (node) {\n\t            return node && node.length && node.is(\":visible\") && !node.find(\".k-in:first\").hasClass(DISABLED);\n\t        },\n\n\t        _focus: function() {\n\t            var current = this.select(),\n\t                clickTarget = this._clickTarget;\n\n\t            // suppress initial focus state on touch devices (until keyboard is used)\n\t            if (kendo.support.touch) {\n\t                return;\n\t            }\n\n\t            if (clickTarget && clickTarget.length) {\n\t                current = clickTarget;\n\t            }\n\n\t            if (!this._focusable(current)) {\n\t                current = this.current();\n\t            }\n\n\t            if (!this._focusable(current)) {\n\t                current = this._nextVisible($());\n\t            }\n\n\t            this.current(current);\n\t        },\n\n\t        focus: function() {\n\t            var wrapper = this.wrapper,\n\t                scrollContainer = wrapper[0],\n\t                containers = [],\n\t                offsets = [],\n\t                documentElement = document.documentElement,\n\t                i;\n\n\t            do {\n\t                scrollContainer = scrollContainer.parentNode;\n\n\t                if (scrollContainer.scrollHeight > scrollContainer.clientHeight) {\n\t                    containers.push(scrollContainer);\n\t                    offsets.push(scrollContainer.scrollTop);\n\t                }\n\t            } while (scrollContainer != documentElement);\n\n\t            wrapper.focus();\n\n\t            for (i = 0; i < containers.length; i++) {\n\t                containers[i].scrollTop = offsets[i];\n\t            }\n\t        },\n\n\t        _blur: function() {\n\t            this.current().find(\".k-in:first\").removeClass(\"k-state-focused\");\n\t        },\n\n\t        _enabled: function(node) {\n\t            return !node.children(\"div\").children(\".k-in\").hasClass(DISABLED);\n\t        },\n\n\t        parent: function(node) {\n\t            var wrapperRe = /\\bk-treeview\\b/,\n\t                itemRe = /\\bk-item\\b/,\n\t                result,\n\t                skipSelf;\n\n\t            if (typeof node == STRING) {\n\t                node = this.element.find(node);\n\t            }\n\n\t            if (!isDomElement(node)) {\n\t                node = node[0];\n\t            }\n\n\t            skipSelf = itemRe.test(node.className);\n\n\t            do {\n\t                node = node.parentNode;\n\n\t                if (itemRe.test(node.className)) {\n\t                    if (skipSelf) {\n\t                        result = node;\n\t                    } else {\n\t                        skipSelf = true;\n\t                    }\n\t                }\n\t            } while (!wrapperRe.test(node.className) && !result);\n\n\t            return $(result);\n\t        },\n\n\t        _nextVisible: function(node) {\n\t            var that = this,\n\t                expanded = that._expanded(node),\n\t                result;\n\n\t            function nextParent(node) {\n\t                while (node.length && !node.next().length) {\n\t                    node = that.parent(node);\n\t                }\n\n\t                if (node.next().length) {\n\t                    return node.next();\n\t                } else {\n\t                    return node;\n\t                }\n\t            }\n\n\t            if (!node.length || !node.is(\":visible\")) {\n\t                result = that.root.children().eq(0);\n\t            } else if (expanded) {\n\t                result = subGroup(node).children().first();\n\n\t                // expanded node with no children\n\t                if (!result.length) {\n\t                    result = nextParent(node);\n\t                }\n\t            } else {\n\t                result = nextParent(node);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _previousVisible: function(node) {\n\t            var that = this,\n\t                lastChild,\n\t                result;\n\n\t            if (!node.length || node.prev().length) {\n\t                if (node.length) {\n\t                    result = node.prev();\n\t                } else {\n\t                    result = that.root.children().last();\n\t                }\n\n\t                while (that._expanded(result)) {\n\t                    lastChild = subGroup(result).children().last();\n\n\t                    if (!lastChild.length) {\n\t                        break;\n\t                    }\n\n\t                    result = lastChild;\n\t                }\n\t            } else {\n\t                result = that.parent(node) || node;\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _keydown: function(e) {\n\t            var that = this,\n\t                key = e.keyCode,\n\t                target,\n\t                focused = that.current(),\n\t                expanded = that._expanded(focused),\n\t                checkbox = focused.find(\".k-checkbox-wrapper:first :checkbox\"),\n\t                rtl = kendo.support.isRtl(that.element);\n\n\t            if (e.target != e.currentTarget) {\n\t                return;\n\t            }\n\n\t            if ((!rtl && key == keys.RIGHT) || (rtl && key == keys.LEFT)) {\n\t                if (expanded) {\n\t                    target = that._nextVisible(focused);\n\t                } else if (!focused.find(\".k-in:first\").hasClass(DISABLED)) {\n\t                    that.expand(focused);\n\t                }\n\t            } else if ((!rtl && key == keys.LEFT) || (rtl && key == keys.RIGHT)) {\n\t                if (expanded && !focused.find(\".k-in:first\").hasClass(DISABLED)) {\n\t                    that.collapse(focused);\n\t                } else {\n\t                    target = that.parent(focused);\n\n\t                    if (!that._enabled(target)) {\n\t                        target = undefined;\n\t                    }\n\t                }\n\t            } else if (key == keys.DOWN) {\n\t                target = that._nextVisible(focused);\n\t            } else if (key == keys.UP) {\n\t                target = that._previousVisible(focused);\n\t            } else if (key == keys.HOME) {\n\t                target = that._nextVisible($());\n\t            } else if (key == keys.END) {\n\t                target = that._previousVisible($());\n\t            } else if (key == keys.ENTER && !focused.find(\".k-in:first\").hasClass(DISABLED)) {\n\t                if (!focused.find(\".k-in:first\").hasClass(\"k-state-selected\")) {\n\t                    if (!that._trigger(SELECT, focused)) {\n\t                        that.select(focused);\n\t                    }\n\t                }\n\t            } else if (key == keys.SPACEBAR && checkbox.length) {\n\t                if(!focused.find(\".k-in:first\").hasClass(DISABLED)){\n\t                    checkbox.prop(CHECKED, !checkbox.prop(CHECKED))\n\t                        .data(INDETERMINATE, false)\n\t                        .prop(INDETERMINATE, false);\n\n\t                    that._checkboxChange({ target: checkbox });\n\t                }\n\t                target = focused;\n\t            }\n\n\t            if (target) {\n\t                e.preventDefault();\n\n\t                if (focused[0] != target[0]) {\n\t                    that._trigger(NAVIGATE, target);\n\t                    that.current(target);\n\t                }\n\t            }\n\t        },\n\n\t        _keypress: function (e) {\n\t            var that = this;\n\t            var delay = 300;\n\t            var selectedNode = that._getSelectedNode();\n\t            var matchToSelect;\n\n\t            if (e.keyCode === keys.ENTER || e.keyCode === keys.SPACEBAR) {\n\t                return;\n\t            }\n\n\t            if (!that._match) {\n\t                that._match = \"\";\n\t            }\n\n\t            that._match += String.fromCharCode(e.keyCode);\n\t            clearTimeout(that._matchTimer);\n\t            that._matchTimer = setTimeout(function() {\n\t                that._match = \"\";\n\t            }, delay);\n\n\t            matchToSelect = selectedNode &&\n\t                            that._matchNextByText(\n\t                                Array.prototype.indexOf.call(this.element.find(\".k-item\"),\n\t                                selectedNode[0]), that._match\n\t                            );\n\n\t            if (!matchToSelect) {\n\t                matchToSelect = that._matchNextByText(-1, that._match);\n\t            }\n\t            that.select(matchToSelect);\n\t        },\n\n\t        _matchNextByText: function(startIndex, text) {\n\t            return $(this.element).find(\".k-in\").filter(function(i, element) {\n\t                return (i > startIndex &&\n\t                        $(element).is(\":visible\") &&\n\t                        !$(element).hasClass(DISABLED) &&\n\t                        $(element).text().toLowerCase().indexOf(text) === 0);\n\t            }).closest(NODE)[0];\n\t        },\n\n\t        _click: function (e) {\n\t            var that = this,\n\t                node = $(e.currentTarget),\n\t                contents = nodeContents(node.closest(NODE)),\n\t                href = node.attr(\"href\"),\n\t                shouldNavigate;\n\n\t            if (href) {\n\t                shouldNavigate = href == \"#\" || href.indexOf(\"#\" + this.element.id + \"-\") >= 0;\n\t            } else {\n\t                shouldNavigate = contents.length && !contents.children().length;\n\t            }\n\n\t            if (shouldNavigate) {\n\t                e.preventDefault();\n\t            }\n\n\t            if (!node.hasClass(\".k-state-selected\") && !that._trigger(SELECT, node)) {\n\t                that.select(node);\n\t            }\n\t        },\n\n\t        _wrapper: function() {\n\t            var that = this,\n\t                element = that.element,\n\t                wrapper, root,\n\t                wrapperClasses = \"k-widget k-treeview\";\n\n\t            if (element.is(\"ul\")) {\n\t                wrapper = element.wrap('<div />').parent();\n\t                root = element;\n\t            } else {\n\t                wrapper = element;\n\t                root = wrapper.children(\"ul\").eq(0);\n\t            }\n\n\t            that.wrapper = wrapper.addClass(wrapperClasses);\n\t            that.root = root;\n\t        },\n\n\t        _getSelectedNode: function() {\n\t            return this.element.find(\".k-state-selected\").closest(NODE);\n\t        },\n\n\t        _group: function(item) {\n\t            var that = this,\n\t                firstLevel = item.hasClass(KTREEVIEW),\n\t                group = {\n\t                    firstLevel: firstLevel,\n\t                    expanded: firstLevel || that._expanded(item)\n\t                },\n\t                groupElement = item.children(\"ul\");\n\n\t            groupElement\n\t                .addClass(that.templates.groupCssClass(group))\n\t                .css(\"display\", group.expanded ? \"\" : \"none\");\n\n\t            that._nodes(groupElement, group);\n\t        },\n\n\t        _nodes: function(groupElement, groupData) {\n\t            var that = this,\n\t                nodes = groupElement.children(\"li\"),\n\t                nodeData;\n\n\t            groupData = extend({ length: nodes.length }, groupData);\n\n\t            nodes.each(function(i, node) {\n\t                node = $(node);\n\n\t                nodeData = { index: i, expanded: that._expanded(node) };\n\n\t                updateNodeHtml(node);\n\n\t                that._updateNodeClasses(node, groupData, nodeData);\n\n\t                // iterate over child nodes\n\t                that._group(node);\n\t            });\n\t        },\n\n\t        _checkboxes: function() {\n\t            var options = this.options;\n\t            var checkboxes = options.checkboxes;\n\t            var defaultTemplate;\n\n\t            if (checkboxes) {\n\t                defaultTemplate = \"<input type='checkbox' tabindex='-1' #= (item.enabled === false) ? 'disabled' : '' # #= item.checked ? 'checked' : '' #\";\n\n\n\t                if (checkboxes.name) {\n\t                    defaultTemplate += \" name='\" + checkboxes.name + \"'\";\n\t                }\n\n\t                defaultTemplate += \" id='_#= item.uid #' class='k-checkbox' /><span class='k-checkbox-label checkbox-span'></span>\";\n\n\t                checkboxes = extend({\n\t                    template: defaultTemplate\n\t                }, options.checkboxes);\n\n\t                if (typeof checkboxes.template == STRING) {\n\t                    checkboxes.template = template(checkboxes.template);\n\t                }\n\n\t                options.checkboxes = checkboxes;\n\t            }\n\t        },\n\n\t        _updateNodeClasses: function (node, groupData, nodeData) {\n\t            var wrapper = node.children(\"div\"),\n\t                group = node.children(\"ul\"),\n\t                templates = this.templates;\n\n\t            if (node.hasClass(\"k-treeview\")) {\n\t                return;\n\t            }\n\n\t            nodeData = nodeData || {};\n\t            nodeData.expanded = typeof nodeData.expanded != UNDEFINED ? nodeData.expanded : this._expanded(node);\n\t            nodeData.index = typeof nodeData.index != UNDEFINED ? nodeData.index : node.index();\n\t            nodeData.enabled = typeof nodeData.enabled != UNDEFINED ? nodeData.enabled : !wrapper.children(\".k-in\").hasClass(\"k-state-disabled\");\n\n\t            groupData = groupData || {};\n\t            groupData.firstLevel = typeof groupData.firstLevel != UNDEFINED ? groupData.firstLevel : node.parent().parent().hasClass(KTREEVIEW);\n\t            groupData.length = typeof groupData.length != UNDEFINED ? groupData.length : node.parent().children().length;\n\n\t            // li\n\t            node.removeClass(\"k-first k-last\")\n\t                .addClass(templates.wrapperCssClass(groupData, nodeData));\n\n\t            // div\n\t            wrapper.removeClass(\"k-top k-mid k-bot\")\n\t                   .addClass(templates.cssClass(groupData, nodeData));\n\n\t            // span / a\n\t            var textWrap = wrapper.children(\".k-in\");\n\t            var isLink = textWrap[0] && textWrap[0].nodeName.toLowerCase() == \"a\";\n\t            textWrap.removeClass(\"k-in k-link k-state-default k-state-disabled\")\n\t                .addClass(templates.textClass(nodeData, isLink));\n\n\t            // toggle button\n\t            if (group.length || node.attr(\"data-hasChildren\") == \"true\") {\n\t                wrapper.children(\".k-icon\").removeClass(\"k-i-expand k-i-collapse\")\n\t                    .addClass(templates.toggleButtonClass(nodeData));\n\n\t                group.addClass(\"k-group\");\n\t            }\n\t        },\n\n\n\t        _processNodes: function(nodes, callback) {\n\t            var that = this;\n\t            var items = that.element.find(nodes);\n\t            for (var i = 0; i < items.length; i++) {\n\t                callback.call(that, i, $(items[i]).closest(NODE));\n\t            }\n\t        },\n\n\t        dataItem: function(node) {\n\t            var uid = $(node).closest(NODE).attr(kendo.attr(\"uid\")),\n\t                dataSource = this.dataSource;\n\n\t            return dataSource && dataSource.getByUid(uid);\n\t        },\n\n\t        _dataItem: function(node) {\n\t            var uid = $(node).closest(NODE).attr(kendo.attr(\"uid\")),\n\t                dataSource = this.dataSource;\n\n\t            return dataSource && this._dataSourceUids[uid];\n\t        },\n\n\t        _insertNode: function(nodeData, index, parentNode, insertCallback, collapsed) {\n\t            var that = this,\n\t                group = subGroup(parentNode),\n\t                updatedGroupLength = group.children().length + 1,\n\t                childrenData,\n\t                groupData = {\n\t                    firstLevel: parentNode.hasClass(KTREEVIEW),\n\t                    expanded: !collapsed,\n\t                    length: updatedGroupLength\n\t                }, node, i, item, nodeHtml = \"\", firstChild, lastChild,\n\t                append = function(item, group) {\n\t                    item.appendTo(group);\n\t                };\n\n\t            for (i = 0; i < nodeData.length; i++) {\n\t                item = nodeData[i];\n\n\t                item.index = index + i;\n\n\t                nodeHtml += that._renderItem({\n\t                    group: groupData,\n\t                    item: item\n\t                });\n\t            }\n\n\t            node = $(nodeHtml);\n\n\t            if (!node.length) {\n\t                return;\n\t            }\n\n\t            that.angular(\"compile\", function(){\n\t                return {\n\t                    elements: node.get(),\n\t                    data: nodeData.map(function(item){\n\t                        return { dataItem: item };\n\t                    })\n\t                };\n\t            });\n\n\t            if (!group.length) {\n\t                group = $(that._renderGroup({\n\t                    group: groupData\n\t                })).appendTo(parentNode);\n\t            }\n\n\t            insertCallback(node, group);\n\n\t            if (parentNode.hasClass(\"k-item\")) {\n\t                updateNodeHtml(parentNode);\n\t                that._updateNodeClasses(parentNode, groupData, {expanded: !collapsed});\n\t            }\n\n\t            firstChild = node.prev().first();\n\t            lastChild = node.next().last();\n\n\t            that._updateNodeClasses(firstChild, {}, {expanded: firstChild.attr(\"data-expanded\")});\n\t            that._updateNodeClasses(lastChild, {}, {expanded: lastChild.attr(\"data-expanded\")});\n\n\t            // render sub-nodes\n\t            for (i = 0; i < nodeData.length; i++) {\n\t                item = nodeData[i];\n\n\t                if (item.hasChildren) {\n\t                    childrenData = item.children.data();\n\n\t                    if (childrenData.length) {\n\t                        that._insertNode(childrenData, item.index, node.eq(i), append, !item.expanded);\n\t                    }\n\t                }\n\t            }\n\n\t            return node;\n\t        },\n\n\t        _updateNodes: function(items, field) {\n\t            var that = this;\n\t            var i, node, nodeWrapper, item, isChecked, isCollapsed;\n\t            var context = { treeview: that.options, item: item };\n\t            var render = field != \"expanded\" && field != \"checked\";\n\n\t            function setCheckedState(root, state) {\n\t                root.find(\".k-checkbox-wrapper input[type=checkbox]:not([disabled])\")\n\t                    .prop(CHECKED, state)\n\t                    .data(INDETERMINATE, false)\n\t                    .prop(INDETERMINATE, false);\n\t            }\n\n\t            if (field == \"selected\") {\n\t                item = items[0];\n\n\t                node = that.findByUid(item.uid).find(\".k-in:first\")\n\t                        .removeClass(\"k-state-hover\")\n\t                        .toggleClass(\"k-state-selected\", item[field])\n\t                        .end();\n\n\t                if (item[field]) {\n\t                    that.current(node);\n\t                }\n\n\t                node.attr(ARIASELECTED, !!item[field]);\n\t            } else {\n\t                var elements = $.map(items, function(item) {\n\t                    return that.findByUid(item.uid).children(\"div\");\n\t                });\n\n\t                if (render) {\n\t                    that.angular(\"cleanup\", function() { return { elements: elements }; });\n\t                }\n\n\t                for (i = 0; i < items.length; i++) {\n\t                    context.item = item = items[i];\n\t                    nodeWrapper = elements[i];\n\t                    node = nodeWrapper.parent();\n\n\t                    if (render) {\n\t                        nodeWrapper.children(\".k-in\")\n\t                            .html(that.templates.itemContent(context));\n\t                    }\n\n\t                    if (field == CHECKED) {\n\t                        isChecked = item[field];\n\n\t                        setCheckedState(nodeWrapper, isChecked);\n\n\t                        node.attr(ARIACHECKED, isChecked);\n\n\t                        if (that.options.checkboxes.checkChildren) {\n\t                            setCheckedState(node.children(\".k-group\"), isChecked);\n\n\t                            that._setChecked(item.children, isChecked);\n\n\t                            if (that.parent(node).length) {\n\t                                that._bubbleIndeterminate(node);\n\t                            }\n\t                        }\n\t                    } else if (field == \"expanded\") {\n\t                        that._toggle(node, item, item[field]);\n\t                    } else if (field == \"enabled\") {\n\t                        node.find(\".k-checkbox-wrapper input[type=checkbox]\").prop(\"disabled\", !item[field]);\n\n\t                        isCollapsed = !nodeContents(node).is(VISIBLE);\n\n\t                        node.removeAttr(ARIADISABLED);\n\n\t                        if (!item[field]) {\n\t                            if (item.selected) {\n\t                                item.set(\"selected\", false);\n\t                            }\n\n\t                            if (item.expanded) {\n\t                                item.set(\"expanded\", false);\n\t                            }\n\n\t                            isCollapsed = true;\n\t                            node.attr(ARIASELECTED, false)\n\t                                .attr(ARIADISABLED, true);\n\t                        }\n\n\t                        that._updateNodeClasses(node, {}, { enabled: item[field], expanded: !isCollapsed });\n\t                    }\n\n\t                    if (nodeWrapper.length) {\n\t                        this.trigger(\"itemChange\", { item: nodeWrapper, data: item, ns: ui });\n\t                    }\n\t                }\n\n\t                if (render) {\n\t                    that.angular(\"compile\", function(){\n\t                        return {\n\t                            elements: elements,\n\t                            data: $.map(items, function(item) {\n\t                                return [{ dataItem: item }];\n\t                            })\n\t                        };\n\t                    });\n\t                }\n\t            }\n\t        },\n\n\t        _appendItems: function(index, items, parentNode) {\n\t            var group = subGroup(parentNode);\n\t            var children = group.children();\n\t            var collapsed = !this._expanded(parentNode);\n\n\t            if(this.element === parentNode){\n\t                var dataItems = this.dataSource.data();\n\t                var viewItems = this.dataSource.view();\n\t                var rootItems = viewItems.length < dataItems.length ? viewItems : dataItems;\n\t                index = rootItems.indexOf(items[0]);\n\t            } else if (items.length){\n\t                index = items[0].parent().indexOf(items[0]);\n\t            }\n\n\t            if (typeof index == UNDEFINED) {\n\t                index = children.length;\n\t            }\n\n\t            this._insertNode(items, index, parentNode, function(item, group) {\n\t                // insert node into DOM\n\t                if (index >= children.length) {\n\t                    item.appendTo(group);\n\t                } else {\n\t                    item.insertBefore(children.eq(index));\n\t                }\n\t            }, collapsed);\n\n\t            if (!collapsed) {\n\t                this._updateNodeClasses(parentNode, {}, {expanded: !collapsed});\n\t                subGroup(parentNode).css(\"display\", \"block\");\n\t            }\n\t        },\n\n\t        _refreshChildren: function(parentNode, items, index) {\n\t            var i, children, child;\n\t            var options = this.options;\n\t            var loadOnDemand = options.loadOnDemand;\n\t            var checkChildren = options.checkboxes && options.checkboxes.checkChildren;\n\n\t            subGroup(parentNode).empty();\n\n\t            if (!items.length) {\n\t                updateNodeHtml(parentNode);\n\t            } else {\n\t                this._appendItems(index, items, parentNode);\n\n\t                children = subGroup(parentNode).children();\n\n\t                if (loadOnDemand && checkChildren) {\n\t                    this._bubbleIndeterminate(children.last());\n\t                }\n\n\t                for (i = 0; i < children.length; i++) {\n\t                    child = children.eq(i);\n\t                    this.trigger(\"itemChange\", {\n\t                        item: child.children(\"div\"),\n\t                        data: items[i],\n\t                        ns: ui\n\t                    });\n\t                }\n\t            }\n\t        },\n\n\t        _refreshRoot: function(items) {\n\t            var groupHtml = this._renderGroup({\n\t                    items: items,\n\t                    group: {\n\t                        firstLevel: true,\n\t                        expanded: true\n\t                    }\n\t                });\n\n\t            if (this.root.length) {\n\t                this._angularItems(\"cleanup\");\n\n\t                var group = $(groupHtml);\n\n\t                this.root\n\t                    .attr(\"class\", group.attr(\"class\"))\n\t                    .html(group.html());\n\t            } else {\n\t                this.root = this.wrapper.html(groupHtml).children(\"ul\");\n\t            }\n\n\t            var elements = this.root.children(\".k-item\");\n\t            for (var i = 0; i < items.length; i++) {\n\t                this.trigger(\"itemChange\", {\n\t                    item: elements.eq(i),\n\t                    data: items[i],\n\t                    ns: ui\n\t                });\n\t            }\n\t            this._angularItems(\"compile\");\n\t        },\n\n\t        refresh: function(e) {\n\t            var node = e.node;\n\t            var action = e.action;\n\t            var items = e.items;\n\t            var parentNode = this.wrapper;\n\t            var options = this.options;\n\t            var loadOnDemand = options.loadOnDemand;\n\t            var checkChildren = options.checkboxes && options.checkboxes.checkChildren;\n\t            var i;\n\n\t            if (this._skip) {\n\t                return;\n\t            }\n\n\t            for (i = 0; i < items.length; i++) {\n\t                this._dataSourceUids[items[i].uid] = items[i];\n\t            }\n\n\t            if (e.field) {\n\t                if (!items[0] || !items[0].level) {\n\t                    return;\n\t                }\n\n\t                return this._updateNodes(items, e.field);\n\t            }\n\n\t            if (node) {\n\t                parentNode = this.findByUid(node.uid);\n\t                this._progress(parentNode, false);\n\t            }\n\n\t            if (checkChildren && action != \"remove\") {\n\t                var bubble = false;\n\n\t                for (i = 0; i < items.length; i++) {\n\t                    if (\"checked\" in items[i]) {\n\t                        bubble = true;\n\t                        break;\n\t                    }\n\t                }\n\n\t                if (!bubble && node && node.checked) {\n\t                    for (i = 0; i < items.length; i++) {\n\t                        items[i].checked = true;\n\t                    }\n\t                }\n\t            }\n\n\t            if (action == \"add\") {\n\t                this._appendItems(e.index, items, parentNode);\n\t            } else if (action == \"remove\") {\n\t                this._remove(this.findByUid(items[0].uid), false);\n\t            } else if (action == \"itemchange\") {\n\t                this._updateNodes(items);\n\t            } else if (action == \"itemloaded\") {\n\t                this._refreshChildren(parentNode, items, e.index);\n\t            } else {\n\t                this._refreshRoot(items);\n\t            }\n\n\t            if (action != \"remove\") {\n\t                for (i = 0; i < items.length; i++) {\n\t                    if (!loadOnDemand || items[i].expanded || items[i]._loaded) {\n\t                        items[i].load();\n\t                    }\n\t                }\n\t            }\n\n\t            this.trigger(DATABOUND, { node: node ? parentNode : undefined });\n\t            if (this.dataSource.filter() && this.options.checkboxes.checkChildren) {\n\t                this.updateIndeterminate(parentNode);\n\t            }\n\t        },\n\n\t        _error: function(e) {\n\t            var node = e.node && this.findByUid(e.node.uid);\n\t            var retryHtml = this.templates.retry({ messages: this.options.messages });\n\n\t            if (node) {\n\t                this._progress(node, false);\n\t                this._expanded(node, false);\n\t                nodeIcon(node).addClass(\"k-i-reload\");\n\t                e.node.loaded(false);\n\t            } else {\n\t                this._progress(false);\n\t                this.element.html(retryHtml);\n\t            }\n\t        },\n\n\t        _retryRequest: function(e) {\n\t            e.preventDefault();\n\n\t            this.dataSource.fetch();\n\t        },\n\n\t        expand: function (nodes) {\n\t            this._processNodes(nodes, function (index, item) {\n\t                this.toggle(item, true);\n\t            });\n\t        },\n\n\t        collapse: function (nodes) {\n\t            this._processNodes(nodes, function (index, item) {\n\t                this.toggle(item, false);\n\t            });\n\t        },\n\n\t        enable: function (nodes, enable) {\n\t            if (typeof nodes === \"boolean\") {\n\t                enable = nodes;\n\t                nodes = this.items();\n\t            } else {\n\t                enable = arguments.length == 2 ? !!enable : true;\n\t            }\n\n\t            this._processNodes(nodes, function (index, item) {\n\t                this.dataItem(item).set(\"enabled\", enable);\n\t            });\n\t        },\n\n\t        current: function(node) {\n\t            var that = this,\n\t                current = that._current,\n\t                element = that.element,\n\t                id = that._ariaId;\n\n\t            if (arguments.length > 0 && node && node.length) {\n\t                if (current) {\n\t                    if (current[0].id === id) {\n\t                        current.removeAttr(\"id\");\n\t                    }\n\n\t                    current.find(\".k-in:first\").removeClass(\"k-state-focused\");\n\t                }\n\n\t                current = that._current = $(node, element).closest(NODE);\n\n\t                current.find(\".k-in:first\").addClass(\"k-state-focused\");\n\n\t                id = current[0].id || id;\n\n\t                if (id) {\n\t                    that.wrapper.removeAttr(\"aria-activedescendant\");\n\t                    current.attr(\"id\", id);\n\t                    that.wrapper.attr(\"aria-activedescendant\", id);\n\t                }\n\n\t                return;\n\t            }\n\n\t            if (!current) {\n\t                current = that._nextVisible($());\n\t            }\n\n\t            return current;\n\t        },\n\n\t        select: function (node) {\n\t            var that = this,\n\t                element = that.element;\n\n\t            if (!arguments.length) {\n\t                return element.find(\".k-state-selected\").closest(NODE);\n\t            }\n\n\t            node = $(node, element).closest(NODE);\n\n\t            element.find(\".k-state-selected\").each(function() {\n\t                var dataItem = that.dataItem(this);\n\t                if (dataItem) {\n\t                    dataItem.set(\"selected\", false);\n\t                    delete dataItem.selected;\n\t                } else {\n\t                    $(this).removeClass(\"k-state-selected\");\n\t                }\n\t            });\n\n\t            if (node.length) {\n\t                that.dataItem(node).set(\"selected\", true);\n\t                that._clickTarget = node;\n\t            }\n\n\t            that.trigger(CHANGE);\n\t        },\n\n\t        _toggle: function(node, dataItem, expand) {\n\t            var options = this.options;\n\t            var contents = nodeContents(node);\n\t            var direction = expand ? \"expand\" : \"collapse\";\n\t            var loaded;\n\n\t            if (contents.data(\"animating\")) {\n\t                return;\n\t            }\n\n\t            loaded = dataItem && dataItem.loaded();\n\n\t            if (expand && !loaded) {\n\t                if (options.loadOnDemand) {\n\t                    this._progress(node, true);\n\t                }\n\n\t                contents.remove();\n\t                dataItem.load();\n\t            } else {\n\t                this._updateNodeClasses(node, {}, { expanded: expand });\n\n\t                if (!expand) {\n\t                    contents.css(\"height\", contents.height()).css(\"height\");\n\t                }\n\n\t                contents\n\t                    .kendoStop(true, true)\n\t                    .kendoAnimate(extend(\n\t                        { reset: true },\n\t                        options.animation[direction],\n\t                        { complete: function() {\n\t                            if (expand) {\n\t                                contents.css(\"height\", \"\");\n\t                            }\n\t                        } }\n\t                    ));\n\t            }\n\n\t        },\n\n\t        toggle: function (node, expand) {\n\t            node = $(node);\n\n\t            if (!nodeIcon(node).is(\".k-i-expand, .k-i-collapse\")) {\n\t                return;\n\t            }\n\n\t            if (arguments.length == 1) {\n\t                expand = !this._expanded(node);\n\t            }\n\n\t            this._expanded(node, expand);\n\t        },\n\n\t        destroy: function() {\n\t            var that = this;\n\n\t            Widget.fn.destroy.call(that);\n\n\t            that.wrapper.off(NS);\n\t            that.wrapper.find(\".k-checkbox-wrapper :checkbox\").off(NS);\n\n\t            that._unbindDataSource();\n\n\t            if (that.dragging) {\n\t                that.dragging.destroy();\n\t            }\n\n\t            that._dataSourceUids = {};\n\n\t            kendo.destroy(that.element);\n\n\t            that.root = that.wrapper = that.element = null;\n\t        },\n\n\t        _expanded: function(node, value, force) {\n\t            var expandedAttr = kendo.attr(\"expanded\");\n\t            var dataItem;\n\t            var expanded = value;\n\t            var direction = expanded ? \"expand\" : \"collapse\";\n\n\t            if (arguments.length == 1) {\n\t                dataItem = this._dataItem(node);\n\t                return node.attr(expandedAttr) === \"true\" || (dataItem && dataItem.expanded);\n\t            }\n\n\t            dataItem = this.dataItem(node);\n\n\t            if (nodeContents(node).data(\"animating\")) {\n\t                return;\n\t            }\n\n\t            if (force || !this._trigger(direction, node)) {\n\t                if (expanded) {\n\t                    node.attr(expandedAttr, \"true\");\n\t                    node.attr(\"aria-expanded\", \"true\");\n\t                } else {\n\t                    node.removeAttr(expandedAttr);\n\t                    node.attr(\"aria-expanded\", \"false\");\n\t                }\n\n\t                if (dataItem) {\n\t                    dataItem.set(\"expanded\", expanded);\n\t                    // necessary when expanding an item yields an error and the item is not expanded as a result\n\t                    expanded = dataItem.expanded;\n\t                }\n\t            }\n\t        },\n\n\t        _progress: function(node, showProgress) {\n\t            var element = this.element;\n\t            var loadingText = this.templates.loading({ messages: this.options.messages });\n\n\t            if (arguments.length == 1) {\n\t                showProgress = node;\n\n\t                if (showProgress) {\n\t                    element.html(loadingText);\n\t                } else {\n\t                    element.empty();\n\t                }\n\t            } else {\n\t                nodeIcon(node).toggleClass(\"k-i-loading\", showProgress).removeClass(\"k-i-reload\");\n\t            }\n\t        },\n\n\t        text: function (node, text) {\n\t            var dataItem = this.dataItem(node),\n\t                fieldBindings = this.options[bindings.text],\n\t                level = dataItem.level(),\n\t                length = fieldBindings.length,\n\t                field = fieldBindings[Math.min(level, length-1)];\n\n\t            if (text) {\n\t                dataItem.set(field, text);\n\t            } else {\n\t                return dataItem[field];\n\t            }\n\t        },\n\n\t        _objectOrSelf: function (node) {\n\t            return $(node).closest(\"[data-role=treeview]\").data(\"kendoTreeView\") || this;\n\t        },\n\n\t        _dataSourceMove: function(nodeData, group, parentNode, callback) {\n\t            var referenceDataItem,\n\t                destTreeview = this._objectOrSelf(parentNode || group),\n\t                destDataSource = destTreeview.dataSource;\n\t            var loadPromise = $.Deferred().resolve().promise();\n\n\t            if (parentNode && parentNode[0] != destTreeview.element[0]) {\n\t                referenceDataItem = destTreeview.dataItem(parentNode);\n\n\t                if (!referenceDataItem.loaded()) {\n\t                    destTreeview._progress(parentNode, true);\n\t                    loadPromise = referenceDataItem.load();\n\t                }\n\n\t                if (parentNode != this.root) {\n\t                    destDataSource = referenceDataItem.children;\n\n\t                    if (!destDataSource || !(destDataSource instanceof HierarchicalDataSource)) {\n\t                        referenceDataItem._initChildren();\n\t                        referenceDataItem.loaded(true);\n\t                        destDataSource = referenceDataItem.children;\n\t                    }\n\t                }\n\t            }\n\n\t            nodeData = this._toObservableData(nodeData);\n\n\t            return callback.call(destTreeview, destDataSource, nodeData, loadPromise);\n\t        },\n\n\t        _toObservableData: function(node) {\n\t            var dataItem = node, dataSource, uid;\n\n\t            if (isJQueryInstance(node) || isDomElement(node)) {\n\t                dataSource = this._objectOrSelf(node).dataSource;\n\t                uid = $(node).attr(kendo.attr(\"uid\"));\n\t                dataItem = dataSource.getByUid(uid);\n\n\t                if (dataItem) {\n\t                    dataItem = dataSource.remove(dataItem);\n\t                }\n\t            }\n\n\t            return dataItem;\n\t        },\n\n\t        _insert: function(data, model, index) {\n\t            if (!(model instanceof kendo.data.ObservableArray)) {\n\t                if (!isArray(model)) {\n\t                    model = [model];\n\t                }\n\t            } else {\n\t                // items will be converted to new Node instances\n\t                model = model.toJSON();\n\t            }\n\n\t            var parentNode = data.parent();\n\n\t            if (parentNode && parentNode._initChildren) {\n\t                parentNode.hasChildren = true;\n\t                parentNode._initChildren();\n\t            }\n\n\t            data.splice.apply(data, [ index, 0 ].concat(model));\n\n\t            return this.findByUid(data[index].uid);\n\t        },\n\n\t        insertAfter: insertAction(1),\n\n\t        insertBefore: insertAction(0),\n\n\t        append: function (nodeData, parentNode, success) {\n\t            var group = this.root;\n\n\t            if(parentNode && nodeData instanceof jQuery && parentNode[0] === nodeData[0]){\n\t                return;\n\t            }\n\n\t            parentNode = parentNode && parentNode.length ? parentNode : null;\n\n\t            if (parentNode) {\n\t                group = subGroup(parentNode);\n\t            }\n\n\t            return this._dataSourceMove(nodeData, group, parentNode, function (dataSource, model, loadModel) {\n\t                var inserted;\n\t                var that = this;\n\n\t                function add() {\n\t                    if (parentNode) {\n\t                        that._expanded(parentNode, true, true);\n\t                    }\n\n\t                    var data = dataSource.data(),\n\t                        index = Math.max(data.length, 0);\n\n\t                    return that._insert(data, model, index);\n\t                }\n\n\t                loadModel.done(function() {\n\t                    inserted = add();\n\t                    success = success || $.noop;\n\t                    success(inserted);\n\t                });\n\n\t                return inserted || null;\n\t            });\n\t        },\n\n\t        _remove: function (node, keepData) {\n\t            var that = this,\n\t                parentNode,\n\t                prevSibling, nextSibling;\n\n\t            node = $(node, that.element);\n\n\t            this.angular(\"cleanup\", function(){\n\t                return { elements: node.get() };\n\t            });\n\n\t            parentNode = node.parent().parent();\n\t            prevSibling = node.prev();\n\t            nextSibling = node.next();\n\n\t            node[keepData ? \"detach\" : \"remove\"]();\n\n\t            if (parentNode.hasClass(\"k-item\")) {\n\t                updateNodeHtml(parentNode);\n\t                that._updateNodeClasses(parentNode);\n\t            }\n\n\t            that._updateNodeClasses(prevSibling);\n\t            that._updateNodeClasses(nextSibling);\n\n\t            return node;\n\t        },\n\n\t        remove: function (node) {\n\t            var dataItem = this.dataItem(node);\n\t            if (dataItem) {\n\t                this.dataSource.remove(dataItem);\n\t            }\n\t        },\n\n\t        detach: function (node) {\n\t            return this._remove(node, true);\n\t        },\n\n\t        findByText: function(text) {\n\t            return $(this.element).find(\".k-in\").filter(function(i, element) {\n\t                return $(element).text() == text;\n\t            }).closest(NODE);\n\t        },\n\n\t        findByUid: function(uid) {\n\t            var items = this.element.find(\".k-item\");\n\t            var uidAttr = kendo.attr(\"uid\");\n\t            var result;\n\n\t            for (var i = 0; i < items.length; i++) {\n\t                if (items[i].getAttribute(uidAttr) == uid) {\n\t                    result = items[i];\n\t                    break;\n\t                }\n\t            }\n\n\t            return $(result);\n\t        },\n\n\t        expandPath: function(path, complete) {\n\t            var treeview = this;\n\t            var nodeIds = path.slice(0);\n\t            var callback = complete || $.noop;\n\n\t            function proceed() {\n\t                nodeIds.shift();\n\n\t                if (nodeIds.length) {\n\t                    expand(nodeIds[0]).then(proceed);\n\t                } else {\n\t                    callback.call(treeview);\n\t                }\n\t            }\n\n\t            function expand(id) {\n\t                var result = $.Deferred();\n\t                var node = treeview.dataSource.get(id);\n\n\t                if (node) {\n\t                    if (node.loaded()) {\n\t                        node.set(\"expanded\", true);\n\t                        result.resolve();\n\t                    } else {\n\t                        // manually show progress of the node\n\t                        // should be moved to `refresh`\n\t                        // if the datasource starts triggering a `requestStart` event for nodes\n\t                        treeview._progress(treeview.findByUid(node.uid), true);\n\n\t                        node.load().then(function() {\n\t                            node.set(\"expanded\", true);\n\t                            result.resolve();\n\t                        });\n\t                    }\n\t                } else {\n\t                    result.resolve();\n\t                }\n\n\t                return result.promise();\n\t            }\n\n\t            // expand async nodes\n\t            expand(nodeIds[0]).then(proceed);\n\t        },\n\n\t        _parentIds: function(node) {\n\t            var parent = node && node.parentNode();\n\t            var parents = [];\n\t            while (parent && parent.parentNode) {\n\t                parents.unshift(parent.id);\n\t                parent = parent.parentNode();\n\t            }\n\n\t            return parents;\n\t        },\n\n\t        expandTo: function(node) {\n\t            if (!(node instanceof kendo.data.Node)) {\n\t                node = this.dataSource.get(node);\n\t            }\n\n\t            var parents = this._parentIds(node);\n\n\t            this.expandPath(parents);\n\t        },\n\n\t        _renderItem: function (options) {\n\t            if (!options.group) {\n\t                options.group = {};\n\t            }\n\n\t            options.treeview = this.options;\n\n\t            options.r = this.templates;\n\n\t            return this.templates.item(options);\n\t        },\n\n\t        _renderGroup: function (options) {\n\t            var that = this;\n\n\t            options.renderItems = function(options) {\n\t                    var html = \"\",\n\t                        i = 0,\n\t                        items = options.items,\n\t                        len = items ? items.length : 0,\n\t                        group = options.group;\n\n\t                    group.length = len;\n\n\t                    for (; i < len; i++) {\n\t                        options.group = group;\n\t                        options.item = items[i];\n\t                        options.item.index = i;\n\t                        html += that._renderItem(options);\n\t                    }\n\n\t                    return html;\n\t                };\n\n\t            options.r = that.templates;\n\n\t            return that.templates.group(options);\n\t        }\n\t    });\n\n\t    ui.plugin(TreeView);\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1003)))\n\n/***/ })\n\n/******/ });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMDQwNjVlMDBhYjM2MWYzMjJlZWYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb2dyZXNzL2tlbmRvLXVpL2pzL2tlbmRvLnRyZWV2aWV3LmpzPzg2MzUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPVxuLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gMDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMzOSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFwiZGVmaW5lIGNhbm5vdCBiZSB1c2VkIGluZGlyZWN0XCIpOyB9O1xyXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDEwMDM6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwianF1ZXJ5XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMTAxMzpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2tlbmRvLmRhdGFcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMzM4OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4va2VuZG8udHJlZXZpZXcuZHJhZ2FuZGRyb3BcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMzM5OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihqUXVlcnkpIHsoZnVuY3Rpb24oZiwgZGVmaW5lKXtcblx0ICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFsgX193ZWJwYWNrX3JlcXVpcmVfXygxMDEzKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMzM4KSBdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZiksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgPyAoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblx0fSkoZnVuY3Rpb24oKXtcblxuXHR2YXIgX19tZXRhX18gPSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXHQgICAgaWQ6IFwidHJlZXZpZXdcIixcblx0ICAgIG5hbWU6IFwiVHJlZVZpZXdcIixcblx0ICAgIGNhdGVnb3J5OiBcIndlYlwiLFxuXHQgICAgZGVzY3JpcHRpb246IFwiVGhlIFRyZWVWaWV3IHdpZGdldCBkaXNwbGF5cyBoaWVyYXJjaGljYWwgZGF0YSBpbiBhIHRyYWRpdGlvbmFsIHRyZWUgc3RydWN0dXJlLHdpdGggc3VwcG9ydCBmb3IgaW50ZXJhY3RpdmUgZHJhZy1hbmQtZHJvcCBvcGVyYXRpb25zLlwiLFxuXHQgICAgZGVwZW5kczogWyBcImRhdGFcIiBdLFxuXHQgICAgZmVhdHVyZXM6IFt7XG5cdCAgICAgICAgaWQ6IFwidHJlZXZpZXctZHJhZ2dpbmdcIixcblx0ICAgICAgICBuYW1lOiBcIkRyYWcgJiBEcm9wXCIsXG5cdCAgICAgICAgZGVzY3JpcHRpb246IFwiU3VwcG9ydCBmb3IgZHJhZyAmIGRyb3BcIixcblx0ICAgICAgICBkZXBlbmRzOiBbIFwidHJlZXZpZXcuZHJhZ2FuZGRyb3BcIiBdXG5cdCAgICB9XVxuXHR9O1xuXG5cdC8qanNoaW50IGVxbnVsbDogdHJ1ZSAqL1xuXHQoZnVuY3Rpb24oJCwgdW5kZWZpbmVkKXtcblx0ICAgIHZhciBrZW5kbyA9IHdpbmRvdy5rZW5kbyxcblx0ICAgICAgICB1aSA9IGtlbmRvLnVpLFxuXHQgICAgICAgIGRhdGEgPSBrZW5kby5kYXRhLFxuXHQgICAgICAgIGV4dGVuZCA9ICQuZXh0ZW5kLFxuXHQgICAgICAgIHRlbXBsYXRlID0ga2VuZG8udGVtcGxhdGUsXG5cdCAgICAgICAgaXNBcnJheSA9ICQuaXNBcnJheSxcblx0ICAgICAgICBXaWRnZXQgPSB1aS5XaWRnZXQsXG5cdCAgICAgICAgSGllcmFyY2hpY2FsRGF0YVNvdXJjZSA9IGRhdGEuSGllcmFyY2hpY2FsRGF0YVNvdXJjZSxcblx0ICAgICAgICBwcm94eSA9ICQucHJveHksXG5cdCAgICAgICAga2V5cyA9IGtlbmRvLmtleXMsXG5cdCAgICAgICAgTlMgPSBcIi5rZW5kb1RyZWVWaWV3XCIsXG5cdCAgICAgICAgVEVNUF9OUyA9IFwiLmtlbmRvVHJlZVZpZXdUZW1wXCIsXG5cdCAgICAgICAgU0VMRUNUID0gXCJzZWxlY3RcIixcblx0ICAgICAgICBDSEVDSyA9IFwiY2hlY2tcIixcblx0ICAgICAgICBOQVZJR0FURSA9IFwibmF2aWdhdGVcIixcblx0ICAgICAgICBFWFBBTkQgPSBcImV4cGFuZFwiLFxuXHQgICAgICAgIENIQU5HRSA9IFwiY2hhbmdlXCIsXG5cdCAgICAgICAgRVJST1IgPSBcImVycm9yXCIsXG5cdCAgICAgICAgQ0hFQ0tFRCA9IFwiY2hlY2tlZFwiLFxuXHQgICAgICAgIElOREVURVJNSU5BVEUgPSBcImluZGV0ZXJtaW5hdGVcIixcblx0ICAgICAgICBDT0xMQVBTRSA9IFwiY29sbGFwc2VcIixcblx0ICAgICAgICBEUkFHU1RBUlQgPSBcImRyYWdzdGFydFwiLFxuXHQgICAgICAgIERSQUcgPSBcImRyYWdcIixcblx0ICAgICAgICBEUk9QID0gXCJkcm9wXCIsXG5cdCAgICAgICAgRFJBR0VORCA9IFwiZHJhZ2VuZFwiLFxuXHQgICAgICAgIERBVEFCT1VORCA9IFwiZGF0YUJvdW5kXCIsXG5cdCAgICAgICAgQ0xJQ0sgPSBcImNsaWNrXCIsXG5cdCAgICAgICAgVU5ERUZJTkVEID0gXCJ1bmRlZmluZWRcIixcblx0ICAgICAgICBLU1RBVEVIT1ZFUiA9IFwiay1zdGF0ZS1ob3ZlclwiLFxuXHQgICAgICAgIEtUUkVFVklFVyA9IFwiay10cmVldmlld1wiLFxuXHQgICAgICAgIFZJU0lCTEUgPSBcIjp2aXNpYmxlXCIsXG5cdCAgICAgICAgTk9ERSA9IFwiLmstaXRlbVwiLFxuXHQgICAgICAgIFNUUklORyA9IFwic3RyaW5nXCIsXG5cdCAgICAgICAgQVJJQUNIRUNLRUQgPSBcImFyaWEtY2hlY2tlZFwiLFxuXHQgICAgICAgIEFSSUFTRUxFQ1RFRCA9IFwiYXJpYS1zZWxlY3RlZFwiLFxuXHQgICAgICAgIEFSSUFESVNBQkxFRCA9IFwiYXJpYS1kaXNhYmxlZFwiLFxuXHQgICAgICAgIERJU0FCTEVEID0gXCJrLXN0YXRlLWRpc2FibGVkXCIsXG5cdCAgICAgICAgVHJlZVZpZXcsXG5cdCAgICAgICAgc3ViR3JvdXAsIG5vZGVDb250ZW50cywgbm9kZUljb24sXG5cdCAgICAgICAgc3ByaXRlUmUsXG5cdCAgICAgICAgYmluZGluZ3MgPSB7XG5cdCAgICAgICAgICAgIHRleHQ6IFwiZGF0YVRleHRGaWVsZFwiLFxuXHQgICAgICAgICAgICB1cmw6IFwiZGF0YVVybEZpZWxkXCIsXG5cdCAgICAgICAgICAgIHNwcml0ZUNzc0NsYXNzOiBcImRhdGFTcHJpdGVDc3NDbGFzc0ZpZWxkXCIsXG5cdCAgICAgICAgICAgIGltYWdlVXJsOiBcImRhdGFJbWFnZVVybEZpZWxkXCJcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGlzSlF1ZXJ5SW5zdGFuY2UgPSBmdW5jdGlvbihvYmopIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChvYmogaW5zdGFuY2VvZiBrZW5kby5qUXVlcnkpIHx8IChvYmogaW5zdGFuY2VvZiB3aW5kb3cualF1ZXJ5KTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGlzRG9tRWxlbWVudCA9IGZ1bmN0aW9uIChvKXtcblx0ICAgICAgICAgICAgcmV0dXJuIChcblx0ICAgICAgICAgICAgICAgIHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJvYmplY3RcIiA/IG8gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA6IC8vRE9NMlxuXHQgICAgICAgICAgICAgICAgbyAmJiB0eXBlb2YgbyA9PT0gXCJvYmplY3RcIiAmJiBvLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBvLm5vZGVOYW1lID09PSBTVFJJTkdcblx0ICAgICAgICAgICAgKTtcblx0ICAgICAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBjb250ZW50Q2hpbGQoZmlsdGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG5vZGUuY2hpbGRyZW4oXCIuay1hbmltYXRpb24tY29udGFpbmVyXCIpO1xuXG5cdCAgICAgICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gbm9kZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQuY2hpbGRyZW4oZmlsdGVyKTtcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiB0ZW1wbGF0ZU5vV2l0aChjb2RlKSB7XG5cdCAgICAgICAgcmV0dXJuIGtlbmRvLnRlbXBsYXRlKGNvZGUsIHsgdXNlV2l0aEJsb2NrOiBmYWxzZSB9KTtcblx0ICAgIH1cblxuXHQgICAgc3ViR3JvdXAgPSBjb250ZW50Q2hpbGQoXCIuay1ncm91cFwiKTtcblx0ICAgIG5vZGVDb250ZW50cyA9IGNvbnRlbnRDaGlsZChcIi5rLWdyb3VwLC5rLWNvbnRlbnRcIik7XG5cdCAgICBub2RlSWNvbiA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0ICAgICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbihcImRpdlwiKS5jaGlsZHJlbihcIi5rLWljb25cIik7XG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBjaGVja2JveGVzKG5vZGUpIHtcblx0ICAgICAgICByZXR1cm4gbm9kZS5maW5kKFwiLmstY2hlY2tib3gtd3JhcHBlcjpmaXJzdCBpbnB1dFt0eXBlPWNoZWNrYm94XVwiKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaW5zZXJ0QWN0aW9uKGluZGV4T2Zmc2V0KSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlRGF0YSwgcmVmZXJlbmNlTm9kZSkge1xuXHQgICAgICAgICAgICByZWZlcmVuY2VOb2RlID0gcmVmZXJlbmNlTm9kZS5jbG9zZXN0KE5PREUpO1xuXG5cdCAgICAgICAgICAgIHZhciBncm91cCA9IHJlZmVyZW5jZU5vZGUucGFyZW50KCksXG5cdCAgICAgICAgICAgICAgICBwYXJlbnROb2RlO1xuXG5cdCAgICAgICAgICAgIGlmIChncm91cC5wYXJlbnQoKS5pcyhcImxpXCIpKSB7XG5cdCAgICAgICAgICAgICAgICBwYXJlbnROb2RlID0gZ3JvdXAucGFyZW50KCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVNvdXJjZU1vdmUobm9kZURhdGEsIGdyb3VwLCBwYXJlbnROb2RlLCBmdW5jdGlvbiAoZGF0YVNvdXJjZSwgbW9kZWwpIHtcblx0ICAgICAgICAgICAgICAgIHZhciByZWZlcmVuY2VJdGVtID0gdGhpcy5kYXRhSXRlbShyZWZlcmVuY2VOb2RlKTtcblx0ICAgICAgICAgICAgICAgIHZhciByZWZlcmVuY2VOb2RlSW5kZXggPSByZWZlcmVuY2VJdGVtID8gcmVmZXJlbmNlSXRlbS5wYXJlbnQoKS5pbmRleE9mKHJlZmVyZW5jZUl0ZW0pIDogcmVmZXJlbmNlTm9kZS5pbmRleCgpO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0KGRhdGFTb3VyY2UuZGF0YSgpLCBtb2RlbCwgcmVmZXJlbmNlTm9kZUluZGV4ICsgaW5kZXhPZmZzZXQpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBzcHJpdGVSZSA9IC9rLXNwcml0ZS87XG5cblx0ICAgIGZ1bmN0aW9uIG1vdmVDb250ZW50cyhub2RlLCBjb250YWluZXIpIHtcblx0ICAgICAgICB2YXIgdG1wO1xuXG5cdCAgICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9IFwidWxcIikge1xuXHQgICAgICAgICAgICB0bXAgPSBub2RlO1xuXHQgICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcblxuXHQgICAgICAgICAgICBpZiAodG1wLm5vZGVUeXBlID09IDMpIHtcblx0ICAgICAgICAgICAgICAgIHRtcC5ub2RlVmFsdWUgPSAkLnRyaW0odG1wLm5vZGVWYWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoc3ByaXRlUmUudGVzdCh0bXAuY2xhc3NOYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZSh0bXAsIGNvbnRhaW5lci5maXJzdENoaWxkKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0bXApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiB1cGRhdGVOb2RlSHRtbChub2RlKSB7XG5cdCAgICAgICAgdmFyIHdyYXBwZXIgPSBub2RlLmNoaWxkcmVuKFwiZGl2XCIpLFxuXHQgICAgICAgICAgICBncm91cCA9IG5vZGUuY2hpbGRyZW4oXCJ1bFwiKSxcblx0ICAgICAgICAgICAgdG9nZ2xlQnV0dG9uID0gd3JhcHBlci5jaGlsZHJlbihcIi5rLWljb25cIiksXG5cdCAgICAgICAgICAgIGNoZWNrYm94ID0gbm9kZS5jaGlsZHJlbihcImlucHV0W3R5cGU9Y2hlY2tib3hdXCIpLFxuXHQgICAgICAgICAgICBpbm5lcldyYXBwZXIgPSB3cmFwcGVyLmNoaWxkcmVuKFwiLmstaW5cIik7XG5cblx0ICAgICAgICBpZiAobm9kZS5oYXNDbGFzcyhcImstdHJlZXZpZXdcIikpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICghd3JhcHBlci5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgd3JhcHBlciA9ICQoXCI8ZGl2IC8+XCIpLnByZXBlbmRUbyhub2RlKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoIXRvZ2dsZUJ1dHRvbi5sZW5ndGggJiYgZ3JvdXAubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHRvZ2dsZUJ1dHRvbiA9ICQoXCI8c3BhbiBjbGFzcz0nay1pY29uJyAvPlwiKS5wcmVwZW5kVG8od3JhcHBlcik7XG5cdCAgICAgICAgfSBlbHNlIGlmICghZ3JvdXAubGVuZ3RoIHx8ICFncm91cC5jaGlsZHJlbigpLmxlbmd0aCkge1xuXHQgICAgICAgICAgICB0b2dnbGVCdXR0b24ucmVtb3ZlKCk7XG5cdCAgICAgICAgICAgIGdyb3VwLnJlbW92ZSgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChjaGVja2JveC5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgJChcIjxzcGFuIGNsYXNzPSdrLWNoZWNrYm94LXdyYXBwZXInIC8+XCIpLmFwcGVuZFRvKHdyYXBwZXIpLmFwcGVuZChjaGVja2JveCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKCFpbm5lcldyYXBwZXIubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIGlubmVyV3JhcHBlciA9IG5vZGUuY2hpbGRyZW4oXCJhXCIpLmVxKDApLmFkZENsYXNzKFwiay1pbiBrLWxpbmtcIik7XG5cblx0ICAgICAgICAgICAgaWYgKCFpbm5lcldyYXBwZXIubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICBpbm5lcldyYXBwZXIgPSAkKFwiPHNwYW4gY2xhc3M9J2staW4nIC8+XCIpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaW5uZXJXcmFwcGVyLmFwcGVuZFRvKHdyYXBwZXIpO1xuXG5cdCAgICAgICAgICAgIGlmICh3cmFwcGVyLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgbW92ZUNvbnRlbnRzKHdyYXBwZXJbMF0ubmV4dFNpYmxpbmcsIGlubmVyV3JhcHBlclswXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIFRyZWVWaWV3ID0ga2VuZG8udWkuRGF0YUJvdW5kV2lkZ2V0LmV4dGVuZCh7XG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgaW5mZXJyZWQgPSBmYWxzZSxcblx0ICAgICAgICAgICAgICAgIGhhc0RhdGFTb3VyY2UgPSBvcHRpb25zICYmICEhb3B0aW9ucy5kYXRhU291cmNlLFxuXHQgICAgICAgICAgICAgICAgbGlzdDtcblxuXHQgICAgICAgICAgICBpZiAoaXNBcnJheShvcHRpb25zKSkge1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgZGF0YVNvdXJjZTogb3B0aW9ucyB9O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubG9hZE9uRGVtYW5kID09IFVOREVGSU5FRCAmJiBpc0FycmF5KG9wdGlvbnMuZGF0YVNvdXJjZSkpIHtcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMubG9hZE9uRGVtYW5kID0gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBXaWRnZXQucHJvdG90eXBlLmluaXQuY2FsbCh0aGF0LCBlbGVtZW50LCBvcHRpb25zKTtcblxuXHQgICAgICAgICAgICBlbGVtZW50ID0gdGhhdC5lbGVtZW50O1xuXHQgICAgICAgICAgICBvcHRpb25zID0gdGhhdC5vcHRpb25zO1xuXG5cdCAgICAgICAgICAgIHRoYXQuX2RhdGFTb3VyY2VVaWRzID0ge307XG5cblx0ICAgICAgICAgICAgbGlzdCA9IChlbGVtZW50LmlzKFwidWxcIikgJiYgZWxlbWVudCkgfHxcblx0ICAgICAgICAgICAgICAgICAgIChlbGVtZW50Lmhhc0NsYXNzKEtUUkVFVklFVykgJiYgZWxlbWVudC5jaGlsZHJlbihcInVsXCIpKTtcblxuXHQgICAgICAgICAgICBpbmZlcnJlZCA9ICFoYXNEYXRhU291cmNlICYmIGxpc3QubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIGlmIChpbmZlcnJlZCkge1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhU291cmNlLmxpc3QgPSBsaXN0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdGhhdC5fYW5pbWF0aW9uKCk7XG5cblx0ICAgICAgICAgICAgdGhhdC5fYWNjZXNzb3JzKCk7XG5cblx0ICAgICAgICAgICAgdGhhdC5fdGVtcGxhdGVzKCk7XG5cblx0ICAgICAgICAgICAgLy8gcmVuZGVyIHRyZWV2aWV3IGlmIGl0J3Mgbm90IGFscmVhZHkgcmVuZGVyZWRcblx0ICAgICAgICAgICAgaWYgKCFlbGVtZW50Lmhhc0NsYXNzKEtUUkVFVklFVykpIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX3dyYXBwZXIoKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKGxpc3QpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LnJvb3QgPSBlbGVtZW50O1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuX2dyb3VwKHRoYXQud3JhcHBlcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UganVzdCBpbml0aWFsaXplIHByb3BlcnRpZXNcblx0ICAgICAgICAgICAgICAgIHRoYXQud3JhcHBlciA9IGVsZW1lbnQ7XG5cdCAgICAgICAgICAgICAgICB0aGF0LnJvb3QgPSBlbGVtZW50LmNoaWxkcmVuKFwidWxcIikuZXEoMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGF0Ll90YWJpbmRleCgpO1xuXG5cdCAgICAgICAgICAgIHRoYXQud3JhcHBlci5hdHRyKFwicm9sZVwiLCBcInRyZWVcIik7XG5cblx0ICAgICAgICAgICAgdGhhdC5fZGF0YVNvdXJjZShpbmZlcnJlZCk7XG5cblx0ICAgICAgICAgICAgdGhhdC5fYXR0YWNoRXZlbnRzKCk7XG5cblx0ICAgICAgICAgICAgdGhhdC5fZHJhZ2dpbmcoKTtcblxuXHQgICAgICAgICAgICBpZiAoIWluZmVycmVkKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hdXRvQmluZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuX3Byb2dyZXNzKHRydWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuZGF0YVNvdXJjZS5mZXRjaCgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhhdC5fc3luY0h0bWxBbmREYXRhU291cmNlKCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAob3B0aW9ucy5jaGVja2JveGVzICYmIG9wdGlvbnMuY2hlY2tib3hlcy5jaGVja0NoaWxkcmVuKSB7XG5cdCAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZUluZGV0ZXJtaW5hdGUoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICh0aGF0LmVsZW1lbnRbMF0uaWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX2FyaWFJZCA9IGtlbmRvLmZvcm1hdChcInswfV90dl9hY3RpdmVcIiwgdGhhdC5lbGVtZW50WzBdLmlkKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGtlbmRvLm5vdGlmeSh0aGF0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2F0dGFjaEV2ZW50czogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcblx0ICAgICAgICAgICAgICAgIGNsaWNrYWJsZUl0ZW1zID0gXCIuay1pbjpub3QoLmstc3RhdGUtc2VsZWN0ZWQsLmstc3RhdGUtZGlzYWJsZWQpXCIsXG5cdCAgICAgICAgICAgICAgICBNT1VTRUVOVEVSID0gXCJtb3VzZWVudGVyXCI7XG5cblx0ICAgICAgICAgICAgdGhhdC53cmFwcGVyXG5cdCAgICAgICAgICAgICAgICAub24oTU9VU0VFTlRFUiArIE5TLCBcIi5rLWluLmstc3RhdGUtc2VsZWN0ZWRcIiwgZnVuY3Rpb24oZSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IH0pXG5cdCAgICAgICAgICAgICAgICAub24oTU9VU0VFTlRFUiArIE5TLCBjbGlja2FibGVJdGVtcywgZnVuY3Rpb24gKCkgeyAkKHRoaXMpLmFkZENsYXNzKEtTVEFURUhPVkVSKTsgfSlcblx0ICAgICAgICAgICAgICAgIC5vbihcIm1vdXNlbGVhdmVcIiArIE5TLCBjbGlja2FibGVJdGVtcywgZnVuY3Rpb24gKCkgeyAkKHRoaXMpLnJlbW92ZUNsYXNzKEtTVEFURUhPVkVSKTsgfSlcblx0ICAgICAgICAgICAgICAgIC5vbihDTElDSyArIE5TLCBjbGlja2FibGVJdGVtcywgcHJveHkodGhhdC5fY2xpY2ssIHRoYXQpKVxuXHQgICAgICAgICAgICAgICAgLm9uKFwiZGJsY2xpY2tcIiArIE5TLCBcIi5rLWluOm5vdCguay1zdGF0ZS1kaXNhYmxlZClcIiwgcHJveHkodGhhdC5fdG9nZ2xlQnV0dG9uQ2xpY2ssIHRoYXQpKVxuXHQgICAgICAgICAgICAgICAgLm9uKENMSUNLICsgTlMsIFwiLmstaS1leHBhbmQsLmstaS1jb2xsYXBzZVwiLCBwcm94eSh0aGF0Ll90b2dnbGVCdXR0b25DbGljaywgdGhhdCkpXG5cdCAgICAgICAgICAgICAgICAub24oXCJrZXlkb3duXCIgKyBOUywgcHJveHkodGhhdC5fa2V5ZG93biwgdGhhdCkpXG5cdCAgICAgICAgICAgICAgICAub24oXCJrZXlwcmVzc1wiICsgTlMsIHByb3h5KHRoYXQuX2tleXByZXNzLCB0aGF0KSlcblx0ICAgICAgICAgICAgICAgIC5vbihcImZvY3VzXCIgKyBOUywgcHJveHkodGhhdC5fZm9jdXMsIHRoYXQpKVxuXHQgICAgICAgICAgICAgICAgLm9uKFwiYmx1clwiICsgTlMsIHByb3h5KHRoYXQuX2JsdXIsIHRoYXQpKVxuXHQgICAgICAgICAgICAgICAgLm9uKFwibW91c2Vkb3duXCIgKyBOUywgXCIuay1pbiwuay1jaGVja2JveC13cmFwcGVyIDpjaGVja2JveCwuay1pLWV4cGFuZCwuay1pLWNvbGxhcHNlXCIsIHByb3h5KHRoYXQuX21vdXNlZG93biwgdGhhdCkpXG5cdCAgICAgICAgICAgICAgICAub24oXCJjaGFuZ2VcIiArIE5TLCBcIi5rLWNoZWNrYm94LXdyYXBwZXIgOmNoZWNrYm94XCIsIHByb3h5KHRoYXQuX2NoZWNrYm94Q2hhbmdlLCB0aGF0KSlcblx0ICAgICAgICAgICAgICAgIC5vbihcImNsaWNrXCIgKyBOUywgXCIuY2hlY2tib3gtc3BhblwiLCBwcm94eSh0aGF0Ll9jaGVja2JveExhYmVsQ2xpY2ssIHRoYXQpKVxuXHQgICAgICAgICAgICAgICAgLm9uKFwiY2xpY2tcIiArIE5TLCBcIi5rLXJlcXVlc3QtcmV0cnlcIiwgcHJveHkodGhhdC5fcmV0cnlSZXF1ZXN0LCB0aGF0KSlcblx0ICAgICAgICAgICAgICAgIC5vbihcImNsaWNrXCIgKyBOUywgXCIuay1saW5rLmstc3RhdGUtZGlzYWJsZWRcIiwgZnVuY3Rpb24oZSkgeyBlLnByZXZlbnREZWZhdWx0KCk7IH0pXG5cdCAgICAgICAgICAgICAgICAub24oXCJjbGlja1wiICsgTlMsIGZ1bmN0aW9uKGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISQoZS50YXJnZXQpLmlzKFwiOmtlbmRvRm9jdXNhYmxlXCIpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZm9jdXMoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2NoZWNrYm94TGFiZWxDbGljazogZnVuY3Rpb24oZSkge1xuXHQgICAgICAgICAgICB2YXIgY2hlY2tib3ggPSAkKGUudGFyZ2V0LnByZXZpb3VzU2libGluZyk7XG5cblx0ICAgICAgICAgICAgaWYgKGNoZWNrYm94LmlzKFwiW2Rpc2FibGVkXVwiKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgY2hlY2tib3gucHJvcCgnY2hlY2tlZCcsICFjaGVja2JveC5wcm9wKCdjaGVja2VkJykpO1xuXHQgICAgICAgICAgICBjaGVja2JveC50cmlnZ2VyKCdjaGFuZ2UnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3N5bmNIdG1sQW5kRGF0YVNvdXJjZTogZnVuY3Rpb24gKHJvb3QsIGRhdGFTb3VyY2UpIHtcblx0ICAgICAgICAgICAgcm9vdCA9IHJvb3QgfHwgdGhpcy5yb290O1xuXHQgICAgICAgICAgICBkYXRhU291cmNlID0gZGF0YVNvdXJjZSB8fCB0aGlzLmRhdGFTb3VyY2U7XG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gZGF0YVNvdXJjZS52aWV3KCksXG5cdCAgICAgICAgICAgICAgICB1aWRBdHRyID0ga2VuZG8uYXR0cihcInVpZFwiKSxcblx0ICAgICAgICAgICAgICAgIGV4cGFuZGVkQXR0ciA9IGtlbmRvLmF0dHIoXCJleHBhbmRlZFwiKSxcblx0ICAgICAgICAgICAgICAgIGNoZWNrYm94ZXNFbmFibGVkID0gdGhpcy5vcHRpb25zLmNoZWNrYm94ZXMsXG5cdCAgICAgICAgICAgICAgICBpdGVtcyA9IHJvb3QuY2hpbGRyZW4oXCJsaVwiKSxcblx0ICAgICAgICAgICAgICAgIGksXG5cdCAgICAgICAgICAgICAgICBpdGVtLFxuXHQgICAgICAgICAgICAgICAgZGF0YUl0ZW0sXG5cdCAgICAgICAgICAgICAgICB1aWQsXG5cdCAgICAgICAgICAgICAgICBpdGVtQ2hlY2tib3g7XG5cblx0ICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBkYXRhSXRlbSA9IGRhdGFbaV07XG5cdCAgICAgICAgICAgICAgICB1aWQgPSBkYXRhSXRlbS51aWQ7XG5cdCAgICAgICAgICAgICAgICBpdGVtID0gaXRlbXMuZXEoaSk7XG5cdCAgICAgICAgICAgICAgICBpdGVtLmF0dHIoXCJyb2xlXCIsIFwidHJlZWl0ZW1cIilcblx0ICAgICAgICAgICAgICAgICAgICAuYXR0cih1aWRBdHRyLCB1aWQpXG5cdCAgICAgICAgICAgICAgICAgICAgLmF0dHIoQVJJQVNFTEVDVEVELCBpdGVtLmhhc0NsYXNzKFwiay1zdGF0ZS1zZWxlY3RlZFwiKSk7XG5cblx0ICAgICAgICAgICAgICAgIGRhdGFJdGVtLmV4cGFuZGVkID0gaXRlbS5hdHRyKGV4cGFuZGVkQXR0cikgPT09IFwidHJ1ZVwiO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoY2hlY2tib3hlc0VuYWJsZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpdGVtQ2hlY2tib3ggPSBjaGVja2JveGVzKGl0ZW0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtLmNoZWNrZWQgPSBpdGVtQ2hlY2tib3gucHJvcChDSEVDS0VEKTtcblx0ICAgICAgICAgICAgICAgICAgICBpdGVtQ2hlY2tib3guYXR0cihcImlkXCIsIFwiX1wiICsgdWlkKTtcblx0ICAgICAgICAgICAgICAgICAgICBpdGVtQ2hlY2tib3gubmV4dChcIi5rLWNoZWNrYm94LWxhYmVsXCIpLmF0dHIoXCJmb3JcIiwgXCJfXCIgKyB1aWQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zeW5jSHRtbEFuZERhdGFTb3VyY2UoaXRlbS5jaGlsZHJlbihcInVsXCIpLCBkYXRhSXRlbS5jaGlsZHJlbik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2FuaW1hdGlvbjogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuXHQgICAgICAgICAgICAgICAgYW5pbWF0aW9uT3B0aW9ucyA9IG9wdGlvbnMuYW5pbWF0aW9uLFxuXHQgICAgICAgICAgICAgICAgaGFzQ29sbGFwc2VBbmltYXRpb24gPSBhbmltYXRpb25PcHRpb25zLmNvbGxhcHNlICYmIFwiZWZmZWN0c1wiIGluIGFuaW1hdGlvbk9wdGlvbnMuY29sbGFwc2UsXG5cdCAgICAgICAgICAgICAgICBjb2xsYXBzZSA9IGV4dGVuZCh7fSwgYW5pbWF0aW9uT3B0aW9ucy5leHBhbmQsIGFuaW1hdGlvbk9wdGlvbnMuY29sbGFwc2UpO1xuXG5cdCAgICAgICAgICAgIGlmICghaGFzQ29sbGFwc2VBbmltYXRpb24pIHtcblx0ICAgICAgICAgICAgICAgIGNvbGxhcHNlID0gZXh0ZW5kKGNvbGxhcHNlLCB7cmV2ZXJzZTogdHJ1ZX0pO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGFuaW1hdGlvbk9wdGlvbnMgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIGV4cGFuZDogeyBlZmZlY3RzOiB7fSB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGNvbGxhcHNlOiB7IGhpZGU6IHRydWUsIGVmZmVjdHM6IHt9IH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zLmNvbGxhcHNlID0gZXh0ZW5kKGNvbGxhcHNlLCB7aGlkZTogdHJ1ZX0pO1xuXHQgICAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IGFuaW1hdGlvbk9wdGlvbnM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kcmFnZ2luZzogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciBlbmFibGVkID0gdGhpcy5vcHRpb25zLmRyYWdBbmREcm9wO1xuXHQgICAgICAgICAgICB2YXIgZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nO1xuXG5cdCAgICAgICAgICAgIGlmIChlbmFibGVkICYmICFkcmFnZ2luZykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHdpZGdldCA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBuZXcgdWkuSGllcmFyY2hpY2FsRHJhZ0FuZERyb3AodGhpcy5lbGVtZW50LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVvcmRlcmFibGU6IHRydWUsXG5cdCAgICAgICAgICAgICAgICAgICAgJGFuZ3VsYXI6IHRoaXMub3B0aW9ucy4kYW5ndWxhcixcblx0ICAgICAgICAgICAgICAgICAgICBhdXRvU2Nyb2xsOiB0aGlzLm9wdGlvbnMuYXV0b1Njcm9sbCxcblx0ICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IFwiZGl2Om5vdCguay1zdGF0ZS1kaXNhYmxlZCkgLmstaW5cIixcblx0ICAgICAgICAgICAgICAgICAgICBhbGxvd2VkQ29udGFpbmVyczogXCIuay10cmVldmlld1wiLFxuXHQgICAgICAgICAgICAgICAgICAgIGl0ZW1TZWxlY3RvcjogXCIuay10cmVldmlldyAuay1pdGVtXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgaGludFRleHQ6IHByb3h5KHRoaXMuX2hpbnRUZXh0LCB0aGlzKSxcblx0ICAgICAgICAgICAgICAgICAgICBjb250YWluczogZnVuY3Rpb24oc291cmNlLCBkZXN0aW5hdGlvbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5jb250YWlucyhzb3VyY2UsIGRlc3RpbmF0aW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGRyb3BIaW50Q29udGFpbmVyOiBmdW5jdGlvbihpdGVtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgaXRlbUZyb21UYXJnZXQ6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRhcmdldC5jbG9zZXN0KFwiLmstdG9wLC5rLW1pZCwuay1ib3RcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGFyZ2V0LmNsb3Nlc3QoXCIuay1pblwiKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0OiBpdGVtLmhhc0NsYXNzKFwiay10b3BcIiksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0OiBpdGVtLmhhc0NsYXNzKFwiay1ib3RcIilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGRyb3BQb3NpdGlvbkZyb206IGZ1bmN0aW9uKGRyb3BIaW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkcm9wSGludC5wcmV2QWxsKFwiLmstaW5cIikubGVuZ3RoID4gMCA/IFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBkcmFnc3RhcnQ6IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2lkZ2V0LnRyaWdnZXIoRFJBR1NUQVJULCB7IHNvdXJjZU5vZGU6IHNvdXJjZVswXSB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGRyYWc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LnRyaWdnZXIoRFJBRywge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogb3B0aW9ucy5vcmlnaW5hbEV2ZW50LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlTm9kZTogb3B0aW9ucy5zb3VyY2VbMF0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wVGFyZ2V0OiBvcHRpb25zLnRhcmdldFswXSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VZOiBvcHRpb25zLnBhZ2VZLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZVg6IG9wdGlvbnMucGFnZVgsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNDbGFzczogb3B0aW9ucy5zdGF0dXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTdGF0dXNDbGFzczogb3B0aW9ucy5zZXRTdGF0dXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBkcm9wOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkcm9wVGFyZ2V0ID0gJChvcHRpb25zLmRyb3BUYXJnZXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmF2aWdhdGlvblRhcmdldCA9IGRyb3BUYXJnZXQuY2xvc2VzdChcImFcIik7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYobmF2aWdhdGlvblRhcmdldCAmJiBuYXZpZ2F0aW9uVGFyZ2V0LmF0dHIoXCJocmVmXCIpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQuX3RlbXBQcmV2ZW50TmF2aWdhdGlvbihuYXZpZ2F0aW9uVGFyZ2V0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aWRnZXQudHJpZ2dlcihEUk9QLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBvcHRpb25zLm9yaWdpbmFsRXZlbnQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VOb2RlOiBvcHRpb25zLnNvdXJjZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uTm9kZTogb3B0aW9ucy5kZXN0aW5hdGlvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkOiBvcHRpb25zLnZhbGlkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsaWQ6IGZ1bmN0aW9uKHN0YXRlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWxpZCA9IHN0YXRlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2V0VmFsaWQoc3RhdGUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BUYXJnZXQ6IG9wdGlvbnMuZHJvcFRhcmdldCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BQb3NpdGlvbjogb3B0aW9ucy5wb3NpdGlvblxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGRyYWdlbmQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IG9wdGlvbnMuc291cmNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVzdGluYXRpb24gPSBvcHRpb25zLmRlc3RpbmF0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRyaWdnZXJEcmFnRW5kKHNvdXJjZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpZGdldC5vcHRpb25zLmNoZWNrYm94ZXMgJiYgd2lkZ2V0Lm9wdGlvbnMuY2hlY2tib3hlcy5jaGVja0NoaWxkcmVuKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LnVwZGF0ZUluZGV0ZXJtaW5hdGUoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkZ2V0LnRyaWdnZXIoRFJBR0VORCwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IG9wdGlvbnMub3JpZ2luYWxFdmVudCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VOb2RlOiBzb3VyY2UgJiYgc291cmNlWzBdLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uTm9kZTogZGVzdGluYXRpb25bMF0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcFBvc2l0aW9uOiBwb3NpdGlvblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBwZXJmb3JtIHJlb3JkZXIgLyBtb3ZlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVudCBoYW5kbGluZyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBhcHBlbmQgbWlnaHQgYmUgYXN5bmMgaW4gcmVtb3RlIGJvdW5kIHRyZWVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IFwib3ZlclwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQuYXBwZW5kKHNvdXJjZSwgZGVzdGluYXRpb24sIHRyaWdnZXJEcmFnRW5kKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBcImJlZm9yZVwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gd2lkZ2V0Lmluc2VydEJlZm9yZShzb3VyY2UsIGRlc3RpbmF0aW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT0gXCJhZnRlclwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlID0gd2lkZ2V0Lmluc2VydEFmdGVyKHNvdXJjZSwgZGVzdGluYXRpb24pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyRHJhZ0VuZChzb3VyY2UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoIWVuYWJsZWQgJiYgZHJhZ2dpbmcpIHtcblx0ICAgICAgICAgICAgICAgIGRyYWdnaW5nLmRlc3Ryb3koKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF90ZW1wUHJldmVudE5hdmlnYXRpb246IGZ1bmN0aW9uKG5vZGUpIHtcblx0ICAgICAgICAgICAgbm9kZS5vbihDTElDSyArIE5TICsgVEVNUF9OUywgZnVuY3Rpb24gKGV2KSB7XG5cdCAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgICAgICAgICAgICAgbm9kZS5vZmYoQ0xJQ0sgKyBOUyArIFRFTVBfTlMpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2hpbnRUZXh0OiBmdW5jdGlvbihub2RlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlcy5kcmFnQ2x1ZSh7XG5cdCAgICAgICAgICAgICAgICBpdGVtOiB0aGlzLmRhdGFJdGVtKG5vZGUpLFxuXHQgICAgICAgICAgICAgICAgdHJlZXZpZXc6IHRoaXMub3B0aW9uc1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3RlbXBsYXRlczogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB0aGF0Lm9wdGlvbnMsXG5cdCAgICAgICAgICAgICAgICBmaWVsZEFjY2Vzc29yID0gcHJveHkodGhhdC5fZmllbGRBY2Nlc3NvciwgdGhhdCk7XG5cblx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMudGVtcGxhdGUgJiYgdHlwZW9mIG9wdGlvbnMudGVtcGxhdGUgPT0gU1RSSU5HKSB7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLnRlbXBsYXRlID0gdGVtcGxhdGUob3B0aW9ucy50ZW1wbGF0ZSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMudGVtcGxhdGUpIHtcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMudGVtcGxhdGUgPSB0ZW1wbGF0ZU5vV2l0aChcblx0ICAgICAgICAgICAgICAgICAgICBcIiMgdmFyIHRleHQgPSBcIiArIGZpZWxkQWNjZXNzb3IoXCJ0ZXh0XCIpICsgXCIoZGF0YS5pdGVtKTsgI1wiICtcblx0ICAgICAgICAgICAgICAgICAgICBcIiMgaWYgKHR5cGVvZiBkYXRhLml0ZW0uZW5jb2RlZCAhPSAndW5kZWZpbmVkJyAmJiBkYXRhLml0ZW0uZW5jb2RlZCA9PT0gZmFsc2UpIHsjXCIgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBcIiM9IHRleHQgI1wiICtcblx0ICAgICAgICAgICAgICAgICAgICBcIiMgfSBlbHNlIHsgI1wiICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCIjOiB0ZXh0ICNcIiArXG5cdCAgICAgICAgICAgICAgICAgICAgXCIjIH0gI1wiXG5cdCAgICAgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdGhhdC5fY2hlY2tib3hlcygpO1xuXG5cdCAgICAgICAgICAgIHRoYXQudGVtcGxhdGVzID0ge1xuXHQgICAgICAgICAgICAgICAgd3JhcHBlckNzc0NsYXNzOiBmdW5jdGlvbiAoZ3JvdXAsIGl0ZW0pIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJrLWl0ZW1cIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpdGVtLmluZGV4O1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwLmZpcnN0TGV2ZWwgJiYgaW5kZXggPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIGstZmlyc3RcIjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gZ3JvdXAubGVuZ3RoLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIGstbGFzdFwiO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgY3NzQ2xhc3M6IGZ1bmN0aW9uKGdyb3VwLCBpdGVtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaXRlbS5pbmRleCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGggLSAxO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwLmZpcnN0TGV2ZWwgJiYgaW5kZXggPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiay10b3AgXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwICYmIGluZGV4ICE9IGdyb3VwTGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcImstdG9wXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PSBncm91cExlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJrLWJvdFwiO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcImstbWlkXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICB0ZXh0Q2xhc3M6IGZ1bmN0aW9uKGl0ZW0sIGlzTGluaykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBcImstaW5cIjtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc0xpbmspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIGstbGlua1wiO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmVuYWJsZWQgPT09IGZhbHNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBrLXN0YXRlLWRpc2FibGVkXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0ZWQgPT09IHRydWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIGstc3RhdGUtc2VsZWN0ZWRcIjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIHRvZ2dsZUJ1dHRvbkNsYXNzOiBmdW5jdGlvbihpdGVtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwiay1pY29uXCI7XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5leHBhbmRlZCAhPT0gdHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgay1pLWV4cGFuZFwiO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiBrLWktY29sbGFwc2VcIjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIGdyb3VwQXR0cmlidXRlczogZnVuY3Rpb24oZ3JvdXApIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IFwiXCI7XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWdyb3VwLmZpcnN0TGV2ZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IFwicm9sZT0nZ3JvdXAnXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMgKyAoZ3JvdXAuZXhwYW5kZWQgIT09IHRydWUgPyBcIiBzdHlsZT0nZGlzcGxheTpub25lJ1wiIDogXCJcIik7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgZ3JvdXBDc3NDbGFzczogZnVuY3Rpb24oZ3JvdXApIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY3NzQ2xhc3MgPSBcImstZ3JvdXBcIjtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChncm91cC5maXJzdExldmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNzc0NsYXNzICs9IFwiIGstdHJlZXZpZXctbGluZXNcIjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3NzQ2xhc3M7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgZHJhZ0NsdWU6IHRlbXBsYXRlTm9XaXRoKFxuXHQgICAgICAgICAgICAgICAgICAgIFwiIz0gZGF0YS50cmVldmlldy50ZW1wbGF0ZShkYXRhKSAjXCJcblx0ICAgICAgICAgICAgICAgICksXG5cdCAgICAgICAgICAgICAgICBncm91cDogdGVtcGxhdGVOb1dpdGgoXG5cdCAgICAgICAgICAgICAgICAgICAgXCI8dWwgcm9sZT0nZ3JvdXAnIGNsYXNzPScjPSBkYXRhLnIuZ3JvdXBDc3NDbGFzcyhkYXRhLmdyb3VwKSAjJyM9IGRhdGEuci5ncm91cEF0dHJpYnV0ZXMoZGF0YS5ncm91cCkgIz5cIiArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiIz0gZGF0YS5yZW5kZXJJdGVtcyhkYXRhKSAjXCIgK1xuXHQgICAgICAgICAgICAgICAgICAgIFwiPC91bD5cIlxuXHQgICAgICAgICAgICAgICAgKSxcblx0ICAgICAgICAgICAgICAgIGl0ZW1Db250ZW50OiB0ZW1wbGF0ZU5vV2l0aChcblx0ICAgICAgICAgICAgICAgICAgICBcIiMgdmFyIGltYWdlVXJsID0gXCIgKyBmaWVsZEFjY2Vzc29yKFwiaW1hZ2VVcmxcIikgKyBcIihkYXRhLml0ZW0pOyAjXCIgK1xuXHQgICAgICAgICAgICAgICAgICAgIFwiIyB2YXIgc3ByaXRlQ3NzQ2xhc3MgPSBcIiArIGZpZWxkQWNjZXNzb3IoXCJzcHJpdGVDc3NDbGFzc1wiKSArIFwiKGRhdGEuaXRlbSk7ICNcIiArXG5cdCAgICAgICAgICAgICAgICAgICAgXCIjIGlmIChpbWFnZVVybCkgeyAjXCIgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBcIjxpbWcgY2xhc3M9J2staW1hZ2UnIGFsdD0nJyBzcmM9JyM9IGltYWdlVXJsICMnPlwiICtcblx0ICAgICAgICAgICAgICAgICAgICBcIiMgfSAjXCIgK1xuXG5cdCAgICAgICAgICAgICAgICAgICAgXCIjIGlmIChzcHJpdGVDc3NDbGFzcykgeyAjXCIgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBcIjxzcGFuIGNsYXNzPSdrLXNwcml0ZSAjPSBzcHJpdGVDc3NDbGFzcyAjJyAvPlwiICtcblx0ICAgICAgICAgICAgICAgICAgICBcIiMgfSAjXCIgK1xuXG5cdCAgICAgICAgICAgICAgICAgICAgXCIjPSBkYXRhLnRyZWV2aWV3LnRlbXBsYXRlKGRhdGEpICNcIlxuXHQgICAgICAgICAgICAgICAgKSxcblx0ICAgICAgICAgICAgICAgIGl0ZW1FbGVtZW50OiB0ZW1wbGF0ZU5vV2l0aChcblx0ICAgICAgICAgICAgICAgICAgICBcIiMgdmFyIGl0ZW0gPSBkYXRhLml0ZW0sIHIgPSBkYXRhLnI7ICNcIiArXG5cdCAgICAgICAgICAgICAgICAgICAgXCIjIHZhciB1cmwgPSBcIiArIGZpZWxkQWNjZXNzb3IoXCJ1cmxcIikgKyBcIihpdGVtKTsgI1wiICtcblx0ICAgICAgICAgICAgICAgICAgICBcIjxkaXYgY2xhc3M9JyM9IHIuY3NzQ2xhc3MoZGF0YS5ncm91cCwgaXRlbSkgIyc+XCIgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBcIiMgaWYgKGl0ZW0uaGFzQ2hpbGRyZW4pIHsgI1wiICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPHNwYW4gY2xhc3M9JyM9IHIudG9nZ2xlQnV0dG9uQ2xhc3MoaXRlbSkgIycvPlwiICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCIjIH0gI1wiICtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcIiMgaWYgKGRhdGEudHJlZXZpZXcuY2hlY2tib3hlcykgeyAjXCIgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8c3BhbiBjbGFzcz0nay1jaGVja2JveC13cmFwcGVyJyByb2xlPSdwcmVzZW50YXRpb24nPlwiICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiM9IGRhdGEudHJlZXZpZXcuY2hlY2tib3hlcy50ZW1wbGF0ZShkYXRhKSAjXCIgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8L3NwYW4+XCIgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBcIiMgfSAjXCIgK1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiIyB2YXIgdGFnID0gdXJsID8gJ2EnIDogJ3NwYW4nOyAjXCIgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBcIiMgdmFyIHRleHRBdHRyID0gdXJsID8gJyBocmVmPVxcXFwnJyArIHVybCArICdcXFxcJycgOiAnJzsgI1wiICtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcIjwjPXRhZyMgY2xhc3M9JyM9IHIudGV4dENsYXNzKGl0ZW0sICEhdXJsKSAjJyM9IHRleHRBdHRyICM+XCIgK1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIjPSByLml0ZW1Db250ZW50KGRhdGEpICNcIiArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiPC8jPXRhZyM+XCIgK1xuXHQgICAgICAgICAgICAgICAgICAgIFwiPC9kaXY+XCJcblx0ICAgICAgICAgICAgICAgICksXG5cdCAgICAgICAgICAgICAgICBpdGVtOiB0ZW1wbGF0ZU5vV2l0aChcblx0ICAgICAgICAgICAgICAgICAgICBcIiMgdmFyIGl0ZW0gPSBkYXRhLml0ZW0sIHIgPSBkYXRhLnI7ICNcIiArXG5cdCAgICAgICAgICAgICAgICAgICAgXCI8bGkgcm9sZT0ndHJlZWl0ZW0nIGNsYXNzPScjPSByLndyYXBwZXJDc3NDbGFzcyhkYXRhLmdyb3VwLCBpdGVtKSAjJ1wiICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAga2VuZG8uYXR0cihcInVpZFwiKSArIFwiPScjPSBpdGVtLnVpZCAjJyBcIiArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiYXJpYS1jaGVja2VkPScjPSBpdGVtLmNoZWNrZWQgPyBcXFwidHJ1ZVxcXCIgOiBcXFwiZmFsc2VcXFwiICMnIFwiICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJhcmlhLXNlbGVjdGVkPScjPSBpdGVtLnNlbGVjdGVkID8gXFxcInRydWVcXFwiIDogXFxcImZhbHNlXFxcIiAjJyBcIiArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiIz1pdGVtLmVuYWJsZWQgPT09IGZhbHNlID8gXFxcImFyaWEtZGlzYWJsZWQ9J3RydWUnXFxcIiA6ICcnI1wiICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJhcmlhLWV4cGFuZGVkPScjPSBpdGVtLmV4cGFuZGVkID8gXFxcInRydWVcXFwiIDogXFxcImZhbHNlXFxcIiAjJyBcIiArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiZGF0YS1leHBhbmRlZD0nIz0gaXRlbS5leHBhbmRlZCA/IFxcXCJ0cnVlXFxcIiA6IFxcXCJmYWxzZVxcXCIgIycgXCIgK1xuXHQgICAgICAgICAgICAgICAgICAgIFwiPlwiICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCIjPSByLml0ZW1FbGVtZW50KGRhdGEpICNcIiArXG5cdCAgICAgICAgICAgICAgICAgICAgXCI8L2xpPlwiXG5cdCAgICAgICAgICAgICAgICApLFxuXHQgICAgICAgICAgICAgICAgbG9hZGluZzogdGVtcGxhdGVOb1dpdGgoXG5cdCAgICAgICAgICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPSdrLWljb24gay1pLWxvYWRpbmcnIC8+ICM6IGRhdGEubWVzc2FnZXMubG9hZGluZyAjXCJcblx0ICAgICAgICAgICAgICAgICksXG5cdCAgICAgICAgICAgICAgICByZXRyeTogdGVtcGxhdGVOb1dpdGgoXG5cdCAgICAgICAgICAgICAgICAgICAgXCIjOiBkYXRhLm1lc3NhZ2VzLnJlcXVlc3RGYWlsZWQgIyBcIiArXG5cdCAgICAgICAgICAgICAgICAgICAgXCI8YnV0dG9uIGNsYXNzPSdrLWJ1dHRvbiBrLXJlcXVlc3QtcmV0cnknPiM6IGRhdGEubWVzc2FnZXMucmV0cnkgIzwvYnV0dG9uPlwiXG5cdCAgICAgICAgICAgICAgICApXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGl0ZW1zOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5maW5kKFwiLmstaXRlbSA+IGRpdjpmaXJzdC1jaGlsZFwiKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgc2V0RGF0YVNvdXJjZTogZnVuY3Rpb24oZGF0YVNvdXJjZSkge1xuXHQgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuXHQgICAgICAgICAgICBvcHRpb25zLmRhdGFTb3VyY2UgPSBkYXRhU291cmNlO1xuXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGFTb3VyY2VVaWRzID0ge307XG5cblx0ICAgICAgICAgICAgdGhpcy5fZGF0YVNvdXJjZSgpO1xuXG5cdCAgICAgICAgICAgIGlmIChvcHRpb25zLmNoZWNrYm94ZXMgJiYgb3B0aW9ucy5jaGVja2JveGVzLmNoZWNrQ2hpbGRyZW4pIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5vbmUoXCJjaGFuZ2VcIiwgJC5wcm94eSh0aGlzLnVwZGF0ZUluZGV0ZXJtaW5hdGUsIHRoaXMsIG51bGwpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0JpbmQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5mZXRjaCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9iaW5kRGF0YVNvdXJjZTogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hIYW5kbGVyID0gcHJveHkodGhpcy5yZWZyZXNoLCB0aGlzKTtcblx0ICAgICAgICAgICAgdGhpcy5fZXJyb3JIYW5kbGVyID0gcHJveHkodGhpcy5fZXJyb3IsIHRoaXMpO1xuXG5cdCAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5iaW5kKENIQU5HRSwgdGhpcy5fcmVmcmVzaEhhbmRsZXIpO1xuXHQgICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UuYmluZChFUlJPUiwgdGhpcy5fZXJyb3JIYW5kbGVyKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3VuYmluZERhdGFTb3VyY2U6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgZGF0YVNvdXJjZSA9IHRoaXMuZGF0YVNvdXJjZTtcblxuXHQgICAgICAgICAgICBpZiAoZGF0YVNvdXJjZSkge1xuXHQgICAgICAgICAgICAgICAgZGF0YVNvdXJjZS51bmJpbmQoQ0hBTkdFLCB0aGlzLl9yZWZyZXNoSGFuZGxlcik7XG5cdCAgICAgICAgICAgICAgICBkYXRhU291cmNlLnVuYmluZChFUlJPUiwgdGhpcy5fZXJyb3JIYW5kbGVyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZGF0YVNvdXJjZTogZnVuY3Rpb24oc2lsZW50UmVhZCkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zID0gdGhhdC5vcHRpb25zLFxuXHQgICAgICAgICAgICAgICAgZGF0YVNvdXJjZSA9IG9wdGlvbnMuZGF0YVNvdXJjZTtcblxuXHQgICAgICAgICAgICBmdW5jdGlvbiByZWN1cnNpdmVSZWFkKGRhdGEpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGRhdGFbaV0uX2luaXRDaGlsZHJlbigpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YVtpXS5jaGlsZHJlbi5mZXRjaCgpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlUmVhZChkYXRhW2ldLmNoaWxkcmVuLnZpZXcoKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBkYXRhU291cmNlID0gaXNBcnJheShkYXRhU291cmNlKSA/IHsgZGF0YTogZGF0YVNvdXJjZSB9IDogZGF0YVNvdXJjZTtcblxuXHQgICAgICAgICAgICB0aGF0Ll91bmJpbmREYXRhU291cmNlKCk7XG5cblx0ICAgICAgICAgICAgaWYgKCFkYXRhU291cmNlLmZpZWxkcykge1xuXHQgICAgICAgICAgICAgICAgZGF0YVNvdXJjZS5maWVsZHMgPSBbXG5cdCAgICAgICAgICAgICAgICAgICAgeyBmaWVsZDogXCJ0ZXh0XCIgfSxcblx0ICAgICAgICAgICAgICAgICAgICB7IGZpZWxkOiBcInVybFwiIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgeyBmaWVsZDogXCJzcHJpdGVDc3NDbGFzc1wiIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgeyBmaWVsZDogXCJpbWFnZVVybFwiIH1cblx0ICAgICAgICAgICAgICAgIF07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGF0LmRhdGFTb3VyY2UgPSBkYXRhU291cmNlID0gSGllcmFyY2hpY2FsRGF0YVNvdXJjZS5jcmVhdGUoZGF0YVNvdXJjZSk7XG5cblx0ICAgICAgICAgICAgaWYgKHNpbGVudFJlYWQpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UuZmV0Y2goKTtcblxuXHQgICAgICAgICAgICAgICAgcmVjdXJzaXZlUmVhZChkYXRhU291cmNlLnZpZXcoKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGF0Ll9iaW5kRGF0YVNvdXJjZSgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBldmVudHM6IFtcblx0ICAgICAgICAgICAgRFJBR1NUQVJULFxuXHQgICAgICAgICAgICBEUkFHLFxuXHQgICAgICAgICAgICBEUk9QLFxuXHQgICAgICAgICAgICBEUkFHRU5ELFxuXG5cdCAgICAgICAgICAgIERBVEFCT1VORCxcblxuXHQgICAgICAgICAgICBFWFBBTkQsXG5cdCAgICAgICAgICAgIENPTExBUFNFLFxuXHQgICAgICAgICAgICBTRUxFQ1QsXG5cdCAgICAgICAgICAgIENIQU5HRSxcblx0ICAgICAgICAgICAgTkFWSUdBVEUsXG5cdCAgICAgICAgICAgIENIRUNLXG5cdCAgICAgICAgXSxcblxuXHQgICAgICAgIG9wdGlvbnM6IHtcblx0ICAgICAgICAgICAgbmFtZTogXCJUcmVlVmlld1wiLFxuXHQgICAgICAgICAgICBkYXRhU291cmNlOiB7fSxcblx0ICAgICAgICAgICAgYW5pbWF0aW9uOiB7XG5cdCAgICAgICAgICAgICAgICBleHBhbmQ6IHtcblx0ICAgICAgICAgICAgICAgICAgICBlZmZlY3RzOiBcImV4cGFuZDp2ZXJ0aWNhbFwiLFxuXHQgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAyMDBcblx0ICAgICAgICAgICAgICAgIH0sIGNvbGxhcHNlOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IDEwMFxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBtZXNzYWdlczoge1xuXHQgICAgICAgICAgICAgICAgbG9hZGluZzogXCJMb2FkaW5nLi4uXCIsXG5cdCAgICAgICAgICAgICAgICByZXF1ZXN0RmFpbGVkOiBcIlJlcXVlc3QgZmFpbGVkLlwiLFxuXHQgICAgICAgICAgICAgICAgcmV0cnk6IFwiUmV0cnlcIlxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBkcmFnQW5kRHJvcDogZmFsc2UsXG5cdCAgICAgICAgICAgIGNoZWNrYm94ZXM6IGZhbHNlLFxuXHQgICAgICAgICAgICBhdXRvQmluZDogdHJ1ZSxcblx0ICAgICAgICAgICAgYXV0b1Njcm9sbDogZmFsc2UsXG5cdCAgICAgICAgICAgIGxvYWRPbkRlbWFuZDogdHJ1ZSxcblx0ICAgICAgICAgICAgdGVtcGxhdGU6IFwiXCIsXG5cdCAgICAgICAgICAgIGRhdGFUZXh0RmllbGQ6IG51bGxcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2FjY2Vzc29yczogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB0aGF0Lm9wdGlvbnMsXG5cdCAgICAgICAgICAgICAgICBpLCBmaWVsZCwgdGV4dEZpZWxkLFxuXHQgICAgICAgICAgICAgICAgZWxlbWVudCA9IHRoYXQuZWxlbWVudDtcblxuXHQgICAgICAgICAgICBmb3IgKGkgaW4gYmluZGluZ3MpIHtcblx0ICAgICAgICAgICAgICAgIGZpZWxkID0gb3B0aW9uc1tiaW5kaW5nc1tpXV07XG5cdCAgICAgICAgICAgICAgICB0ZXh0RmllbGQgPSBlbGVtZW50LmF0dHIoa2VuZG8uYXR0cihpICsgXCItZmllbGRcIikpO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoIWZpZWxkICYmIHRleHRGaWVsZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZpZWxkID0gdGV4dEZpZWxkO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAoIWZpZWxkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoZmllbGQpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBbZmllbGRdO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zW2JpbmRpbmdzW2ldXSA9IGZpZWxkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8vIGdlbmVyYXRlcyBhY2Nlc3NvciBmdW5jdGlvbiBmb3IgYSBnaXZlbiBmaWVsZCBuYW1lLCBob25vcmluZyB0aGUgZGF0YSpGaWVsZCBhcnJheXNcblx0ICAgICAgICBfZmllbGRBY2Nlc3NvcjogZnVuY3Rpb24oZmllbGROYW1lKSB7XG5cdCAgICAgICAgICAgIHZhciBmaWVsZEJpbmRpbmdzID0gdGhpcy5vcHRpb25zW2JpbmRpbmdzW2ZpZWxkTmFtZV1dLFxuXHQgICAgICAgICAgICAgICAgY291bnQgPSBmaWVsZEJpbmRpbmdzLmxlbmd0aCxcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IFwiKGZ1bmN0aW9uKGl0ZW0pIHtcIjtcblxuXHQgICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcInJldHVybiBpdGVtWydcIiArIGZpZWxkTmFtZSArIFwiJ107XCI7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJ2YXIgbGV2ZWxzID0gW1wiICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICQubWFwKGZpZWxkQmluZGluZ3MsIGZ1bmN0aW9uKHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvbihkKXsgcmV0dXJuIFwiICsga2VuZG8uZXhwcih4KSArIFwifVwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbihcIixcIikgKyBcIl07XCI7XG5cblx0ICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcInJldHVybiBsZXZlbHNbTWF0aC5taW4oaXRlbS5sZXZlbCgpLCBcIiArIGNvdW50ICsgXCItMSldKGl0ZW0pXCI7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXN1bHQgKz0gXCJ9KVwiO1xuXG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgV2lkZ2V0LmZuLnNldE9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuXHQgICAgICAgICAgICB0aGlzLl9hbmltYXRpb24oKTtcblxuXHQgICAgICAgICAgICB0aGlzLl9kcmFnZ2luZygpO1xuXG5cdCAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlcygpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfdHJpZ2dlcjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgbm9kZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKGV2ZW50TmFtZSwge1xuXHQgICAgICAgICAgICAgICAgbm9kZTogbm9kZS5jbG9zZXN0KE5PREUpWzBdXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfc2V0Q2hlY2tlZDogZnVuY3Rpb24oZGF0YXNvdXJjZSwgdmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKCFkYXRhc291cmNlIHx8ICEkLmlzRnVuY3Rpb24oZGF0YXNvdXJjZS52aWV3KSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG5vZGVzID0gZGF0YXNvdXJjZS52aWV3KCk7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYobm9kZXNbaV0uZW5hYmxlZCAhPT0gZmFsc2Upe1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldENoZWNrZWRWYWx1ZShub2Rlc1tpXSwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAobm9kZXNbaV0uY2hpbGRyZW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDaGVja2VkKG5vZGVzW2ldLmNoaWxkcmVuLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3NldENoZWNrZWRWYWx1ZTogZnVuY3Rpb24gKG5vZGUsIHZhbHVlKXtcblx0ICAgICAgICAgICAgbm9kZVtDSEVDS0VEXSA9IHZhbHVlO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfc2V0SW5kZXRlcm1pbmF0ZTogZnVuY3Rpb24obm9kZSkge1xuXHQgICAgICAgICAgICB2YXIgZ3JvdXAgPSBzdWJHcm91cChub2RlKSxcblx0ICAgICAgICAgICAgICAgIHNpYmxpbmdzLCBsZW5ndGgsXG5cdCAgICAgICAgICAgICAgICBhbGwgPSB0cnVlLFxuXHQgICAgICAgICAgICAgICAgaTtcblxuXHQgICAgICAgICAgICBpZiAoIWdyb3VwLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgc2libGluZ3MgPSBjaGVja2JveGVzKGdyb3VwLmNoaWxkcmVuKCkpO1xuXG5cdCAgICAgICAgICAgIGxlbmd0aCA9IHNpYmxpbmdzLmxlbmd0aDtcblxuXHQgICAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzaWJsaW5nc1tpXS5jaGVja2VkICE9IHNpYmxpbmdzW2ktMV0uY2hlY2tlZCB8fFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzaWJsaW5nc1tpXS5pbmRldGVybWluYXRlIHx8IHNpYmxpbmdzW2ktMV0uaW5kZXRlcm1pbmF0ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhbGwgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgYWxsID0gIXNpYmxpbmdzWzBdLmluZGV0ZXJtaW5hdGU7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBub2RlLmF0dHIoQVJJQUNIRUNLRUQsIGFsbCA/IHNpYmxpbmdzWzBdLmNoZWNrZWQgOiBcIm1peGVkXCIpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjaGVja2JveGVzKG5vZGUpXG5cdCAgICAgICAgICAgICAgICAuZGF0YShJTkRFVEVSTUlOQVRFLCAhYWxsKVxuXHQgICAgICAgICAgICAgICAgLnByb3AoSU5ERVRFUk1JTkFURSwgIWFsbClcblx0ICAgICAgICAgICAgICAgIC5wcm9wKENIRUNLRUQsIGFsbCAmJiBzaWJsaW5nc1swXS5jaGVja2VkKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgdXBkYXRlSW5kZXRlcm1pbmF0ZTogZnVuY3Rpb24obm9kZSkge1xuXHQgICAgICAgICAgICAvLyB0b3AtZG93biB1cGRhdGUgb2YgaW5pdGFsIGluZGV0ZXJtaW5hdGUgc3RhdGUgZm9yIGFsbCBub2Rlc1xuXHQgICAgICAgICAgICBub2RlID0gbm9kZSB8fCB0aGlzLndyYXBwZXI7XG5cblx0ICAgICAgICAgICAgdmFyIHN1Ym5vZGVzID0gc3ViR3JvdXAobm9kZSkuY2hpbGRyZW4oKTtcblx0ICAgICAgICAgICAgdmFyIGk7XG5cdCAgICAgICAgICAgIHZhciBjaGVja2JveDtcblx0ICAgICAgICAgICAgdmFyIGRhdGFJdGVtO1xuXG5cdCAgICAgICAgICAgIGlmIChzdWJub2Rlcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdWJub2Rlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSW5kZXRlcm1pbmF0ZShzdWJub2Rlcy5lcShpKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLmlzKFwiLmstdHJlZXZpZXdcIikpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGNoZWNrYm94ID0gdGhpcy5fc2V0SW5kZXRlcm1pbmF0ZShub2RlKTtcblxuXHQgICAgICAgICAgICAgICAgZGF0YUl0ZW0gPSB0aGlzLmRhdGFJdGVtKG5vZGUpO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoY2hlY2tib3ggJiYgY2hlY2tib3gucHJvcChDSEVDS0VEKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtLmNoZWNrZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUl0ZW0pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRhdGFJdGVtLmNoZWNrZWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9idWJibGVJbmRldGVybWluYXRlOiBmdW5jdGlvbihub2RlLCBza2lwRG93bndhcmQpIHtcblx0ICAgICAgICAgICAgLy8gYm90dG9tLXVwIHNldHRpbmcgb2YgaW5kZXRlcm1pbmF0ZSBzdGF0ZSBvZiBwYXJlbnQgbm9kZXNcblx0ICAgICAgICAgICAgaWYgKCFub2RlLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKCFza2lwRG93bndhcmQpIHtcblx0ICAgICAgICAgICAgICAgIC8vdXBkYXRlIHRoZSBpbmRldGVybWluYXRlIHN0YXRlIG9mIHRoZSBub2RlIGl0c2VsZlxuXHQgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbmRldGVybWluYXRlKG5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLnBhcmVudChub2RlKSxcblx0ICAgICAgICAgICAgICAgIGNoZWNrYm94O1xuXG5cdCAgICAgICAgICAgIGlmIChwYXJlbnROb2RlLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc2V0SW5kZXRlcm1pbmF0ZShwYXJlbnROb2RlKTtcblxuXHQgICAgICAgICAgICAgICAgY2hlY2tib3ggPSBwYXJlbnROb2RlLmNoaWxkcmVuKFwiZGl2XCIpLmZpbmQoXCIuay1jaGVja2JveC13cmFwcGVyIGlucHV0W3R5cGU9Y2hlY2tib3hdXCIpO1xuXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9za2lwID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIGlmIChjaGVja2JveC5wcm9wKElOREVURVJNSU5BVEUpID09PSBmYWxzZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YUl0ZW0ocGFyZW50Tm9kZSkuc2V0KENIRUNLRUQsIGNoZWNrYm94LnByb3AoQ0hFQ0tFRCkpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBkZWxldGUgdGhpcy5kYXRhSXRlbShwYXJlbnROb2RlKS5jaGVja2VkO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YUl0ZW0ocGFyZW50Tm9kZSkuc2V0KENIRUNLRUQsIGZhbHNlKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdGhpcy5fc2tpcCA9IGZhbHNlO1xuXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9idWJibGVJbmRldGVybWluYXRlKHBhcmVudE5vZGUsIHRydWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9jaGVja2JveENoYW5nZTogZnVuY3Rpb24oZSkge1xuXHQgICAgICAgICAgICB2YXIgY2hlY2tib3ggPSAkKGUudGFyZ2V0KTtcblx0ICAgICAgICAgICAgdmFyIGlzQ2hlY2tlZCA9IGNoZWNrYm94LnByb3AoQ0hFQ0tFRCk7XG5cdCAgICAgICAgICAgIHZhciBub2RlID0gY2hlY2tib3guY2xvc2VzdChOT0RFKTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFJdGVtID0gdGhpcy5kYXRhSXRlbShub2RlKTtcblxuXHQgICAgICAgICAgICBpZiAodGhpcy5fcHJldmVudENoYW5nZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGRhdGFJdGVtLmNoZWNrZWQgIT0gaXNDaGVja2VkKSB7XG5cdCAgICAgICAgICAgICAgICBkYXRhSXRlbS5zZXQoQ0hFQ0tFRCwgaXNDaGVja2VkKTtcblx0ICAgICAgICAgICAgICAgIG5vZGUuYXR0cihBUklBQ0hFQ0tFRCwgaXNDaGVja2VkKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoQ0hFQ0ssIG5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF90b2dnbGVCdXR0b25DbGljazogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgICAgdmFyIG5vZGUgPSAkKGUuY3VycmVudFRhcmdldCkuY2xvc2VzdChOT0RFKTtcblxuXHQgICAgICAgICAgICBpZiAobm9kZS5pcyhcIlthcmlhLWRpc2FibGVkPSd0cnVlJ11cIikpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoaXMudG9nZ2xlKG5vZGUpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblx0ICAgICAgICAgICAgdmFyIGN1cnJlbnRUYXJnZXQgPSAkKGUuY3VycmVudFRhcmdldCk7XG5cdCAgICAgICAgICAgIHZhciBub2RlID0gJChlLmN1cnJlbnRUYXJnZXQpLmNsb3Nlc3QoTk9ERSk7XG5cdCAgICAgICAgICAgIHZhciBicm93c2VyID0ga2VuZG8uc3VwcG9ydC5icm93c2VyO1xuXG5cdCAgICAgICAgICAgIGlmIChub2RlLmlzKFwiW2FyaWEtZGlzYWJsZWQ9J3RydWUnXVwiKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy9JRSBkb2VzIG5vdCB0cmlnZ2VyIGNoYW5nZSBmb3IgaW5kZXRlcm1pbmF0ZSBjaGVja2JveGVzXG5cdCAgICAgICAgICAgIGlmICgoYnJvd3Nlci5tc2llIHx8IGJyb3dzZXIuZWRnZSkgJiYgY3VycmVudFRhcmdldC5pcyhcIjpjaGVja2JveFwiKSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQucHJvcChJTkRFVEVSTUlOQVRFKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuX3ByZXZlbnRDaGFuZ2UgPSBmYWxzZTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQucHJvcChDSEVDS0VELCAhY3VycmVudFRhcmdldC5wcm9wKENIRUNLRUQpKTtcblx0ICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0LnRyaWdnZXIoQ0hBTkdFKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQub24oQ0xJQ0sgKyBOUywgZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC5fcHJldmVudENoYW5nZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQub2ZmKENMSUNLICsgTlMpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuX3ByZXZlbnRDaGFuZ2UgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoYXQuX2NsaWNrVGFyZ2V0ID0gbm9kZTtcblx0ICAgICAgICAgICAgdGhhdC5jdXJyZW50KG5vZGUpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZm9jdXNhYmxlOiBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbm9kZSAmJiBub2RlLmxlbmd0aCAmJiBub2RlLmlzKFwiOnZpc2libGVcIikgJiYgIW5vZGUuZmluZChcIi5rLWluOmZpcnN0XCIpLmhhc0NsYXNzKERJU0FCTEVEKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2ZvY3VzOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLnNlbGVjdCgpLFxuXHQgICAgICAgICAgICAgICAgY2xpY2tUYXJnZXQgPSB0aGlzLl9jbGlja1RhcmdldDtcblxuXHQgICAgICAgICAgICAvLyBzdXBwcmVzcyBpbml0aWFsIGZvY3VzIHN0YXRlIG9uIHRvdWNoIGRldmljZXMgKHVudGlsIGtleWJvYXJkIGlzIHVzZWQpXG5cdCAgICAgICAgICAgIGlmIChrZW5kby5zdXBwb3J0LnRvdWNoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoY2xpY2tUYXJnZXQgJiYgY2xpY2tUYXJnZXQubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICBjdXJyZW50ID0gY2xpY2tUYXJnZXQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoIXRoaXMuX2ZvY3VzYWJsZShjdXJyZW50KSkge1xuXHQgICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuY3VycmVudCgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKCF0aGlzLl9mb2N1c2FibGUoY3VycmVudCkpIHtcblx0ICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLl9uZXh0VmlzaWJsZSgkKCkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdGhpcy5jdXJyZW50KGN1cnJlbnQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBmb2N1czogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciB3cmFwcGVyID0gdGhpcy53cmFwcGVyLFxuXHQgICAgICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVyID0gd3JhcHBlclswXSxcblx0ICAgICAgICAgICAgICAgIGNvbnRhaW5lcnMgPSBbXSxcblx0ICAgICAgICAgICAgICAgIG9mZnNldHMgPSBbXSxcblx0ICAgICAgICAgICAgICAgIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcblx0ICAgICAgICAgICAgICAgIGk7XG5cblx0ICAgICAgICAgICAgZG8ge1xuXHQgICAgICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVyID0gc2Nyb2xsQ29udGFpbmVyLnBhcmVudE5vZGU7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChzY3JvbGxDb250YWluZXIuc2Nyb2xsSGVpZ2h0ID4gc2Nyb2xsQ29udGFpbmVyLmNsaWVudEhlaWdodCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcnMucHVzaChzY3JvbGxDb250YWluZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIG9mZnNldHMucHVzaChzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSB3aGlsZSAoc2Nyb2xsQ29udGFpbmVyICE9IGRvY3VtZW50RWxlbWVudCk7XG5cblx0ICAgICAgICAgICAgd3JhcHBlci5mb2N1cygpO1xuXG5cdCAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb250YWluZXJzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBjb250YWluZXJzW2ldLnNjcm9sbFRvcCA9IG9mZnNldHNbaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2JsdXI6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB0aGlzLmN1cnJlbnQoKS5maW5kKFwiLmstaW46Zmlyc3RcIikucmVtb3ZlQ2xhc3MoXCJrLXN0YXRlLWZvY3VzZWRcIik7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9lbmFibGVkOiBmdW5jdGlvbihub2RlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAhbm9kZS5jaGlsZHJlbihcImRpdlwiKS5jaGlsZHJlbihcIi5rLWluXCIpLmhhc0NsYXNzKERJU0FCTEVEKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgcGFyZW50OiBmdW5jdGlvbihub2RlKSB7XG5cdCAgICAgICAgICAgIHZhciB3cmFwcGVyUmUgPSAvXFxiay10cmVldmlld1xcYi8sXG5cdCAgICAgICAgICAgICAgICBpdGVtUmUgPSAvXFxiay1pdGVtXFxiLyxcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCxcblx0ICAgICAgICAgICAgICAgIHNraXBTZWxmO1xuXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PSBTVFJJTkcpIHtcblx0ICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLmVsZW1lbnQuZmluZChub2RlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICghaXNEb21FbGVtZW50KG5vZGUpKSB7XG5cdCAgICAgICAgICAgICAgICBub2RlID0gbm9kZVswXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHNraXBTZWxmID0gaXRlbVJlLnRlc3Qobm9kZS5jbGFzc05hbWUpO1xuXG5cdCAgICAgICAgICAgIGRvIHtcblx0ICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpdGVtUmUudGVzdChub2RlLmNsYXNzTmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcFNlbGYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbm9kZTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBza2lwU2VsZiA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IHdoaWxlICghd3JhcHBlclJlLnRlc3Qobm9kZS5jbGFzc05hbWUpICYmICFyZXN1bHQpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiAkKHJlc3VsdCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9uZXh0VmlzaWJsZTogZnVuY3Rpb24obm9kZSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBleHBhbmRlZCA9IHRoYXQuX2V4cGFuZGVkKG5vZGUpLFxuXHQgICAgICAgICAgICAgICAgcmVzdWx0O1xuXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIG5leHRQYXJlbnQobm9kZSkge1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKG5vZGUubGVuZ3RoICYmICFub2RlLm5leHQoKS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlID0gdGhhdC5wYXJlbnQobm9kZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLm5leHQoKS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5uZXh0KCk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKCFub2RlLmxlbmd0aCB8fCAhbm9kZS5pcyhcIjp2aXNpYmxlXCIpKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGF0LnJvb3QuY2hpbGRyZW4oKS5lcSgwKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChleHBhbmRlZCkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gc3ViR3JvdXAobm9kZSkuY2hpbGRyZW4oKS5maXJzdCgpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBleHBhbmRlZCBub2RlIHdpdGggbm8gY2hpbGRyZW5cblx0ICAgICAgICAgICAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5leHRQYXJlbnQobm9kZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXh0UGFyZW50KG5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3ByZXZpb3VzVmlzaWJsZTogZnVuY3Rpb24obm9kZSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBsYXN0Q2hpbGQsXG5cdCAgICAgICAgICAgICAgICByZXN1bHQ7XG5cblx0ICAgICAgICAgICAgaWYgKCFub2RlLmxlbmd0aCB8fCBub2RlLnByZXYoKS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5vZGUucHJldigpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGF0LnJvb3QuY2hpbGRyZW4oKS5sYXN0KCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHdoaWxlICh0aGF0Ll9leHBhbmRlZChyZXN1bHQpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbGFzdENoaWxkID0gc3ViR3JvdXAocmVzdWx0KS5jaGlsZHJlbigpLmxhc3QoKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghbGFzdENoaWxkLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBsYXN0Q2hpbGQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGF0LnBhcmVudChub2RlKSB8fCBub2RlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2tleWRvd246IGZ1bmN0aW9uKGUpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAga2V5ID0gZS5rZXlDb2RlLFxuXHQgICAgICAgICAgICAgICAgdGFyZ2V0LFxuXHQgICAgICAgICAgICAgICAgZm9jdXNlZCA9IHRoYXQuY3VycmVudCgpLFxuXHQgICAgICAgICAgICAgICAgZXhwYW5kZWQgPSB0aGF0Ll9leHBhbmRlZChmb2N1c2VkKSxcblx0ICAgICAgICAgICAgICAgIGNoZWNrYm94ID0gZm9jdXNlZC5maW5kKFwiLmstY2hlY2tib3gtd3JhcHBlcjpmaXJzdCA6Y2hlY2tib3hcIiksXG5cdCAgICAgICAgICAgICAgICBydGwgPSBrZW5kby5zdXBwb3J0LmlzUnRsKHRoYXQuZWxlbWVudCk7XG5cblx0ICAgICAgICAgICAgaWYgKGUudGFyZ2V0ICE9IGUuY3VycmVudFRhcmdldCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKCghcnRsICYmIGtleSA9PSBrZXlzLlJJR0hUKSB8fCAocnRsICYmIGtleSA9PSBrZXlzLkxFRlQpKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXhwYW5kZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGF0Ll9uZXh0VmlzaWJsZShmb2N1c2VkKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWZvY3VzZWQuZmluZChcIi5rLWluOmZpcnN0XCIpLmhhc0NsYXNzKERJU0FCTEVEKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuZXhwYW5kKGZvY3VzZWQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKCghcnRsICYmIGtleSA9PSBrZXlzLkxFRlQpIHx8IChydGwgJiYga2V5ID09IGtleXMuUklHSFQpKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXhwYW5kZWQgJiYgIWZvY3VzZWQuZmluZChcIi5rLWluOmZpcnN0XCIpLmhhc0NsYXNzKERJU0FCTEVEKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuY29sbGFwc2UoZm9jdXNlZCk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoYXQucGFyZW50KGZvY3VzZWQpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGF0Ll9lbmFibGVkKHRhcmdldCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT0ga2V5cy5ET1dOKSB7XG5cdCAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGF0Ll9uZXh0VmlzaWJsZShmb2N1c2VkKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT0ga2V5cy5VUCkge1xuXHQgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhhdC5fcHJldmlvdXNWaXNpYmxlKGZvY3VzZWQpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PSBrZXlzLkhPTUUpIHtcblx0ICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoYXQuX25leHRWaXNpYmxlKCQoKSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5ID09IGtleXMuRU5EKSB7XG5cdCAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGF0Ll9wcmV2aW91c1Zpc2libGUoJCgpKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT0ga2V5cy5FTlRFUiAmJiAhZm9jdXNlZC5maW5kKFwiLmstaW46Zmlyc3RcIikuaGFzQ2xhc3MoRElTQUJMRUQpKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWZvY3VzZWQuZmluZChcIi5rLWluOmZpcnN0XCIpLmhhc0NsYXNzKFwiay1zdGF0ZS1zZWxlY3RlZFwiKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdGhhdC5fdHJpZ2dlcihTRUxFQ1QsIGZvY3VzZWQpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0KGZvY3VzZWQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT0ga2V5cy5TUEFDRUJBUiAmJiBjaGVja2JveC5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIGlmKCFmb2N1c2VkLmZpbmQoXCIuay1pbjpmaXJzdFwiKS5oYXNDbGFzcyhESVNBQkxFRCkpe1xuXHQgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94LnByb3AoQ0hFQ0tFRCwgIWNoZWNrYm94LnByb3AoQ0hFQ0tFRCkpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKElOREVURVJNSU5BVEUsIGZhbHNlKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAucHJvcChJTkRFVEVSTUlOQVRFLCBmYWxzZSk7XG5cblx0ICAgICAgICAgICAgICAgICAgICB0aGF0Ll9jaGVja2JveENoYW5nZSh7IHRhcmdldDogY2hlY2tib3ggfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0YXJnZXQgPSBmb2N1c2VkO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuXHQgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoZm9jdXNlZFswXSAhPSB0YXJnZXRbMF0pIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0Ll90cmlnZ2VyKE5BVklHQVRFLCB0YXJnZXQpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuY3VycmVudCh0YXJnZXQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9rZXlwcmVzczogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgZGVsYXkgPSAzMDA7XG5cdCAgICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGUgPSB0aGF0Ll9nZXRTZWxlY3RlZE5vZGUoKTtcblx0ICAgICAgICAgICAgdmFyIG1hdGNoVG9TZWxlY3Q7XG5cblx0ICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0ga2V5cy5FTlRFUiB8fCBlLmtleUNvZGUgPT09IGtleXMuU1BBQ0VCQVIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICghdGhhdC5fbWF0Y2gpIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX21hdGNoID0gXCJcIjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoYXQuX21hdGNoICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZS5rZXlDb2RlKTtcblx0ICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoYXQuX21hdGNoVGltZXIpO1xuXHQgICAgICAgICAgICB0aGF0Ll9tYXRjaFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX21hdGNoID0gXCJcIjtcblx0ICAgICAgICAgICAgfSwgZGVsYXkpO1xuXG5cdCAgICAgICAgICAgIG1hdGNoVG9TZWxlY3QgPSBzZWxlY3RlZE5vZGUgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX21hdGNoTmV4dEJ5VGV4dChcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMuZWxlbWVudC5maW5kKFwiLmstaXRlbVwiKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZE5vZGVbMF0pLCB0aGF0Ll9tYXRjaFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuXHQgICAgICAgICAgICBpZiAoIW1hdGNoVG9TZWxlY3QpIHtcblx0ICAgICAgICAgICAgICAgIG1hdGNoVG9TZWxlY3QgPSB0aGF0Ll9tYXRjaE5leHRCeVRleHQoLTEsIHRoYXQuX21hdGNoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGF0LnNlbGVjdChtYXRjaFRvU2VsZWN0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX21hdGNoTmV4dEJ5VGV4dDogZnVuY3Rpb24oc3RhcnRJbmRleCwgdGV4dCkge1xuXHQgICAgICAgICAgICByZXR1cm4gJCh0aGlzLmVsZW1lbnQpLmZpbmQoXCIuay1pblwiKS5maWx0ZXIoZnVuY3Rpb24oaSwgZWxlbWVudCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIChpID4gc3RhcnRJbmRleCAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAkKGVsZW1lbnQpLmlzKFwiOnZpc2libGVcIikgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgISQoZWxlbWVudCkuaGFzQ2xhc3MoRElTQUJMRUQpICYmXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICQoZWxlbWVudCkudGV4dCgpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0ZXh0KSA9PT0gMCk7XG5cdCAgICAgICAgICAgIH0pLmNsb3Nlc3QoTk9ERSlbMF07XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9jbGljazogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgbm9kZSA9ICQoZS5jdXJyZW50VGFyZ2V0KSxcblx0ICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gbm9kZUNvbnRlbnRzKG5vZGUuY2xvc2VzdChOT0RFKSksXG5cdCAgICAgICAgICAgICAgICBocmVmID0gbm9kZS5hdHRyKFwiaHJlZlwiKSxcblx0ICAgICAgICAgICAgICAgIHNob3VsZE5hdmlnYXRlO1xuXG5cdCAgICAgICAgICAgIGlmIChocmVmKSB7XG5cdCAgICAgICAgICAgICAgICBzaG91bGROYXZpZ2F0ZSA9IGhyZWYgPT0gXCIjXCIgfHwgaHJlZi5pbmRleE9mKFwiI1wiICsgdGhpcy5lbGVtZW50LmlkICsgXCItXCIpID49IDA7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBzaG91bGROYXZpZ2F0ZSA9IGNvbnRlbnRzLmxlbmd0aCAmJiAhY29udGVudHMuY2hpbGRyZW4oKS5sZW5ndGg7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoc2hvdWxkTmF2aWdhdGUpIHtcblx0ICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICghbm9kZS5oYXNDbGFzcyhcIi5rLXN0YXRlLXNlbGVjdGVkXCIpICYmICF0aGF0Ll90cmlnZ2VyKFNFTEVDVCwgbm9kZSkpIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQuc2VsZWN0KG5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF93cmFwcGVyOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgZWxlbWVudCA9IHRoYXQuZWxlbWVudCxcblx0ICAgICAgICAgICAgICAgIHdyYXBwZXIsIHJvb3QsXG5cdCAgICAgICAgICAgICAgICB3cmFwcGVyQ2xhc3NlcyA9IFwiay13aWRnZXQgay10cmVldmlld1wiO1xuXG5cdCAgICAgICAgICAgIGlmIChlbGVtZW50LmlzKFwidWxcIikpIHtcblx0ICAgICAgICAgICAgICAgIHdyYXBwZXIgPSBlbGVtZW50LndyYXAoJzxkaXYgLz4nKS5wYXJlbnQoKTtcblx0ICAgICAgICAgICAgICAgIHJvb3QgPSBlbGVtZW50O1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgd3JhcHBlciA9IGVsZW1lbnQ7XG5cdCAgICAgICAgICAgICAgICByb290ID0gd3JhcHBlci5jaGlsZHJlbihcInVsXCIpLmVxKDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdGhhdC53cmFwcGVyID0gd3JhcHBlci5hZGRDbGFzcyh3cmFwcGVyQ2xhc3Nlcyk7XG5cdCAgICAgICAgICAgIHRoYXQucm9vdCA9IHJvb3Q7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9nZXRTZWxlY3RlZE5vZGU6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmZpbmQoXCIuay1zdGF0ZS1zZWxlY3RlZFwiKS5jbG9zZXN0KE5PREUpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZ3JvdXA6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgZmlyc3RMZXZlbCA9IGl0ZW0uaGFzQ2xhc3MoS1RSRUVWSUVXKSxcblx0ICAgICAgICAgICAgICAgIGdyb3VwID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIGZpcnN0TGV2ZWw6IGZpcnN0TGV2ZWwsXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQ6IGZpcnN0TGV2ZWwgfHwgdGhhdC5fZXhwYW5kZWQoaXRlbSlcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBncm91cEVsZW1lbnQgPSBpdGVtLmNoaWxkcmVuKFwidWxcIik7XG5cblx0ICAgICAgICAgICAgZ3JvdXBFbGVtZW50XG5cdCAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhhdC50ZW1wbGF0ZXMuZ3JvdXBDc3NDbGFzcyhncm91cCkpXG5cdCAgICAgICAgICAgICAgICAuY3NzKFwiZGlzcGxheVwiLCBncm91cC5leHBhbmRlZCA/IFwiXCIgOiBcIm5vbmVcIik7XG5cblx0ICAgICAgICAgICAgdGhhdC5fbm9kZXMoZ3JvdXBFbGVtZW50LCBncm91cCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9ub2RlczogZnVuY3Rpb24oZ3JvdXBFbGVtZW50LCBncm91cERhdGEpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgbm9kZXMgPSBncm91cEVsZW1lbnQuY2hpbGRyZW4oXCJsaVwiKSxcblx0ICAgICAgICAgICAgICAgIG5vZGVEYXRhO1xuXG5cdCAgICAgICAgICAgIGdyb3VwRGF0YSA9IGV4dGVuZCh7IGxlbmd0aDogbm9kZXMubGVuZ3RoIH0sIGdyb3VwRGF0YSk7XG5cblx0ICAgICAgICAgICAgbm9kZXMuZWFjaChmdW5jdGlvbihpLCBub2RlKSB7XG5cdCAgICAgICAgICAgICAgICBub2RlID0gJChub2RlKTtcblxuXHQgICAgICAgICAgICAgICAgbm9kZURhdGEgPSB7IGluZGV4OiBpLCBleHBhbmRlZDogdGhhdC5fZXhwYW5kZWQobm9kZSkgfTtcblxuXHQgICAgICAgICAgICAgICAgdXBkYXRlTm9kZUh0bWwobm9kZSk7XG5cblx0ICAgICAgICAgICAgICAgIHRoYXQuX3VwZGF0ZU5vZGVDbGFzc2VzKG5vZGUsIGdyb3VwRGF0YSwgbm9kZURhdGEpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBpdGVyYXRlIG92ZXIgY2hpbGQgbm9kZXNcblx0ICAgICAgICAgICAgICAgIHRoYXQuX2dyb3VwKG5vZGUpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2NoZWNrYm94ZXM6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0ICAgICAgICAgICAgdmFyIGNoZWNrYm94ZXMgPSBvcHRpb25zLmNoZWNrYm94ZXM7XG5cdCAgICAgICAgICAgIHZhciBkZWZhdWx0VGVtcGxhdGU7XG5cblx0ICAgICAgICAgICAgaWYgKGNoZWNrYm94ZXMpIHtcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHRUZW1wbGF0ZSA9IFwiPGlucHV0IHR5cGU9J2NoZWNrYm94JyB0YWJpbmRleD0nLTEnICM9IChpdGVtLmVuYWJsZWQgPT09IGZhbHNlKSA/ICdkaXNhYmxlZCcgOiAnJyAjICM9IGl0ZW0uY2hlY2tlZCA/ICdjaGVja2VkJyA6ICcnICNcIjtcblxuXG5cdCAgICAgICAgICAgICAgICBpZiAoY2hlY2tib3hlcy5uYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFRlbXBsYXRlICs9IFwiIG5hbWU9J1wiICsgY2hlY2tib3hlcy5uYW1lICsgXCInXCI7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGRlZmF1bHRUZW1wbGF0ZSArPSBcIiBpZD0nXyM9IGl0ZW0udWlkICMnIGNsYXNzPSdrLWNoZWNrYm94JyAvPjxzcGFuIGNsYXNzPSdrLWNoZWNrYm94LWxhYmVsIGNoZWNrYm94LXNwYW4nPjwvc3Bhbj5cIjtcblxuXHQgICAgICAgICAgICAgICAgY2hlY2tib3hlcyA9IGV4dGVuZCh7XG5cdCAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGRlZmF1bHRUZW1wbGF0ZVxuXHQgICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5jaGVja2JveGVzKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGVja2JveGVzLnRlbXBsYXRlID09IFNUUklORykge1xuXHQgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94ZXMudGVtcGxhdGUgPSB0ZW1wbGF0ZShjaGVja2JveGVzLnRlbXBsYXRlKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5jaGVja2JveGVzID0gY2hlY2tib3hlcztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfdXBkYXRlTm9kZUNsYXNzZXM6IGZ1bmN0aW9uIChub2RlLCBncm91cERhdGEsIG5vZGVEYXRhKSB7XG5cdCAgICAgICAgICAgIHZhciB3cmFwcGVyID0gbm9kZS5jaGlsZHJlbihcImRpdlwiKSxcblx0ICAgICAgICAgICAgICAgIGdyb3VwID0gbm9kZS5jaGlsZHJlbihcInVsXCIpLFxuXHQgICAgICAgICAgICAgICAgdGVtcGxhdGVzID0gdGhpcy50ZW1wbGF0ZXM7XG5cblx0ICAgICAgICAgICAgaWYgKG5vZGUuaGFzQ2xhc3MoXCJrLXRyZWV2aWV3XCIpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBub2RlRGF0YSA9IG5vZGVEYXRhIHx8IHt9O1xuXHQgICAgICAgICAgICBub2RlRGF0YS5leHBhbmRlZCA9IHR5cGVvZiBub2RlRGF0YS5leHBhbmRlZCAhPSBVTkRFRklORUQgPyBub2RlRGF0YS5leHBhbmRlZCA6IHRoaXMuX2V4cGFuZGVkKG5vZGUpO1xuXHQgICAgICAgICAgICBub2RlRGF0YS5pbmRleCA9IHR5cGVvZiBub2RlRGF0YS5pbmRleCAhPSBVTkRFRklORUQgPyBub2RlRGF0YS5pbmRleCA6IG5vZGUuaW5kZXgoKTtcblx0ICAgICAgICAgICAgbm9kZURhdGEuZW5hYmxlZCA9IHR5cGVvZiBub2RlRGF0YS5lbmFibGVkICE9IFVOREVGSU5FRCA/IG5vZGVEYXRhLmVuYWJsZWQgOiAhd3JhcHBlci5jaGlsZHJlbihcIi5rLWluXCIpLmhhc0NsYXNzKFwiay1zdGF0ZS1kaXNhYmxlZFwiKTtcblxuXHQgICAgICAgICAgICBncm91cERhdGEgPSBncm91cERhdGEgfHwge307XG5cdCAgICAgICAgICAgIGdyb3VwRGF0YS5maXJzdExldmVsID0gdHlwZW9mIGdyb3VwRGF0YS5maXJzdExldmVsICE9IFVOREVGSU5FRCA/IGdyb3VwRGF0YS5maXJzdExldmVsIDogbm9kZS5wYXJlbnQoKS5wYXJlbnQoKS5oYXNDbGFzcyhLVFJFRVZJRVcpO1xuXHQgICAgICAgICAgICBncm91cERhdGEubGVuZ3RoID0gdHlwZW9mIGdyb3VwRGF0YS5sZW5ndGggIT0gVU5ERUZJTkVEID8gZ3JvdXBEYXRhLmxlbmd0aCA6IG5vZGUucGFyZW50KCkuY2hpbGRyZW4oKS5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gbGlcblx0ICAgICAgICAgICAgbm9kZS5yZW1vdmVDbGFzcyhcImstZmlyc3Qgay1sYXN0XCIpXG5cdCAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGVtcGxhdGVzLndyYXBwZXJDc3NDbGFzcyhncm91cERhdGEsIG5vZGVEYXRhKSk7XG5cblx0ICAgICAgICAgICAgLy8gZGl2XG5cdCAgICAgICAgICAgIHdyYXBwZXIucmVtb3ZlQ2xhc3MoXCJrLXRvcCBrLW1pZCBrLWJvdFwiKVxuXHQgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRlbXBsYXRlcy5jc3NDbGFzcyhncm91cERhdGEsIG5vZGVEYXRhKSk7XG5cblx0ICAgICAgICAgICAgLy8gc3BhbiAvIGFcblx0ICAgICAgICAgICAgdmFyIHRleHRXcmFwID0gd3JhcHBlci5jaGlsZHJlbihcIi5rLWluXCIpO1xuXHQgICAgICAgICAgICB2YXIgaXNMaW5rID0gdGV4dFdyYXBbMF0gJiYgdGV4dFdyYXBbMF0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PSBcImFcIjtcblx0ICAgICAgICAgICAgdGV4dFdyYXAucmVtb3ZlQ2xhc3MoXCJrLWluIGstbGluayBrLXN0YXRlLWRlZmF1bHQgay1zdGF0ZS1kaXNhYmxlZFwiKVxuXHQgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRlbXBsYXRlcy50ZXh0Q2xhc3Mobm9kZURhdGEsIGlzTGluaykpO1xuXG5cdCAgICAgICAgICAgIC8vIHRvZ2dsZSBidXR0b25cblx0ICAgICAgICAgICAgaWYgKGdyb3VwLmxlbmd0aCB8fCBub2RlLmF0dHIoXCJkYXRhLWhhc0NoaWxkcmVuXCIpID09IFwidHJ1ZVwiKSB7XG5cdCAgICAgICAgICAgICAgICB3cmFwcGVyLmNoaWxkcmVuKFwiLmstaWNvblwiKS5yZW1vdmVDbGFzcyhcImstaS1leHBhbmQgay1pLWNvbGxhcHNlXCIpXG5cdCAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRlbXBsYXRlcy50b2dnbGVCdXR0b25DbGFzcyhub2RlRGF0YSkpO1xuXG5cdCAgICAgICAgICAgICAgICBncm91cC5hZGRDbGFzcyhcImstZ3JvdXBcIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cblx0ICAgICAgICBfcHJvY2Vzc05vZGVzOiBmdW5jdGlvbihub2RlcywgY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgaXRlbXMgPSB0aGF0LmVsZW1lbnQuZmluZChub2Rlcyk7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhhdCwgaSwgJChpdGVtc1tpXSkuY2xvc2VzdChOT0RFKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZGF0YUl0ZW06IGZ1bmN0aW9uKG5vZGUpIHtcblx0ICAgICAgICAgICAgdmFyIHVpZCA9ICQobm9kZSkuY2xvc2VzdChOT0RFKS5hdHRyKGtlbmRvLmF0dHIoXCJ1aWRcIikpLFxuXHQgICAgICAgICAgICAgICAgZGF0YVNvdXJjZSA9IHRoaXMuZGF0YVNvdXJjZTtcblxuXHQgICAgICAgICAgICByZXR1cm4gZGF0YVNvdXJjZSAmJiBkYXRhU291cmNlLmdldEJ5VWlkKHVpZCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kYXRhSXRlbTogZnVuY3Rpb24obm9kZSkge1xuXHQgICAgICAgICAgICB2YXIgdWlkID0gJChub2RlKS5jbG9zZXN0KE5PREUpLmF0dHIoa2VuZG8uYXR0cihcInVpZFwiKSksXG5cdCAgICAgICAgICAgICAgICBkYXRhU291cmNlID0gdGhpcy5kYXRhU291cmNlO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBkYXRhU291cmNlICYmIHRoaXMuX2RhdGFTb3VyY2VVaWRzW3VpZF07XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9pbnNlcnROb2RlOiBmdW5jdGlvbihub2RlRGF0YSwgaW5kZXgsIHBhcmVudE5vZGUsIGluc2VydENhbGxiYWNrLCBjb2xsYXBzZWQpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgZ3JvdXAgPSBzdWJHcm91cChwYXJlbnROb2RlKSxcblx0ICAgICAgICAgICAgICAgIHVwZGF0ZWRHcm91cExlbmd0aCA9IGdyb3VwLmNoaWxkcmVuKCkubGVuZ3RoICsgMSxcblx0ICAgICAgICAgICAgICAgIGNoaWxkcmVuRGF0YSxcblx0ICAgICAgICAgICAgICAgIGdyb3VwRGF0YSA9IHtcblx0ICAgICAgICAgICAgICAgICAgICBmaXJzdExldmVsOiBwYXJlbnROb2RlLmhhc0NsYXNzKEtUUkVFVklFVyksXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQ6ICFjb2xsYXBzZWQsXG5cdCAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiB1cGRhdGVkR3JvdXBMZW5ndGhcblx0ICAgICAgICAgICAgICAgIH0sIG5vZGUsIGksIGl0ZW0sIG5vZGVIdG1sID0gXCJcIiwgZmlyc3RDaGlsZCwgbGFzdENoaWxkLFxuXHQgICAgICAgICAgICAgICAgYXBwZW5kID0gZnVuY3Rpb24oaXRlbSwgZ3JvdXApIHtcblx0ICAgICAgICAgICAgICAgICAgICBpdGVtLmFwcGVuZFRvKGdyb3VwKTtcblx0ICAgICAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGVEYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBpdGVtID0gbm9kZURhdGFbaV07XG5cblx0ICAgICAgICAgICAgICAgIGl0ZW0uaW5kZXggPSBpbmRleCArIGk7XG5cblx0ICAgICAgICAgICAgICAgIG5vZGVIdG1sICs9IHRoYXQuX3JlbmRlckl0ZW0oe1xuXHQgICAgICAgICAgICAgICAgICAgIGdyb3VwOiBncm91cERhdGEsXG5cdCAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBub2RlID0gJChub2RlSHRtbCk7XG5cblx0ICAgICAgICAgICAgaWYgKCFub2RlLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdGhhdC5hbmd1bGFyKFwiY29tcGlsZVwiLCBmdW5jdGlvbigpe1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogbm9kZS5nZXQoKSxcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhOiBub2RlRGF0YS5tYXAoZnVuY3Rpb24oaXRlbSl7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGFJdGVtOiBpdGVtIH07XG5cdCAgICAgICAgICAgICAgICAgICAgfSlcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIGlmICghZ3JvdXAubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICBncm91cCA9ICQodGhhdC5fcmVuZGVyR3JvdXAoe1xuXHQgICAgICAgICAgICAgICAgICAgIGdyb3VwOiBncm91cERhdGFcblx0ICAgICAgICAgICAgICAgIH0pKS5hcHBlbmRUbyhwYXJlbnROb2RlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGluc2VydENhbGxiYWNrKG5vZGUsIGdyb3VwKTtcblxuXHQgICAgICAgICAgICBpZiAocGFyZW50Tm9kZS5oYXNDbGFzcyhcImstaXRlbVwiKSkge1xuXHQgICAgICAgICAgICAgICAgdXBkYXRlTm9kZUh0bWwocGFyZW50Tm9kZSk7XG5cdCAgICAgICAgICAgICAgICB0aGF0Ll91cGRhdGVOb2RlQ2xhc3NlcyhwYXJlbnROb2RlLCBncm91cERhdGEsIHtleHBhbmRlZDogIWNvbGxhcHNlZH0pO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZmlyc3RDaGlsZCA9IG5vZGUucHJldigpLmZpcnN0KCk7XG5cdCAgICAgICAgICAgIGxhc3RDaGlsZCA9IG5vZGUubmV4dCgpLmxhc3QoKTtcblxuXHQgICAgICAgICAgICB0aGF0Ll91cGRhdGVOb2RlQ2xhc3NlcyhmaXJzdENoaWxkLCB7fSwge2V4cGFuZGVkOiBmaXJzdENoaWxkLmF0dHIoXCJkYXRhLWV4cGFuZGVkXCIpfSk7XG5cdCAgICAgICAgICAgIHRoYXQuX3VwZGF0ZU5vZGVDbGFzc2VzKGxhc3RDaGlsZCwge30sIHtleHBhbmRlZDogbGFzdENoaWxkLmF0dHIoXCJkYXRhLWV4cGFuZGVkXCIpfSk7XG5cblx0ICAgICAgICAgICAgLy8gcmVuZGVyIHN1Yi1ub2Rlc1xuXHQgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZURhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGl0ZW0gPSBub2RlRGF0YVtpXTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKGl0ZW0uaGFzQ2hpbGRyZW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbkRhdGEgPSBpdGVtLmNoaWxkcmVuLmRhdGEoKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbkRhdGEubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX2luc2VydE5vZGUoY2hpbGRyZW5EYXRhLCBpdGVtLmluZGV4LCBub2RlLmVxKGkpLCBhcHBlbmQsICFpdGVtLmV4cGFuZGVkKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbm9kZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3VwZGF0ZU5vZGVzOiBmdW5jdGlvbihpdGVtcywgZmllbGQpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgaSwgbm9kZSwgbm9kZVdyYXBwZXIsIGl0ZW0sIGlzQ2hlY2tlZCwgaXNDb2xsYXBzZWQ7XG5cdCAgICAgICAgICAgIHZhciBjb250ZXh0ID0geyB0cmVldmlldzogdGhhdC5vcHRpb25zLCBpdGVtOiBpdGVtIH07XG5cdCAgICAgICAgICAgIHZhciByZW5kZXIgPSBmaWVsZCAhPSBcImV4cGFuZGVkXCIgJiYgZmllbGQgIT0gXCJjaGVja2VkXCI7XG5cblx0ICAgICAgICAgICAgZnVuY3Rpb24gc2V0Q2hlY2tlZFN0YXRlKHJvb3QsIHN0YXRlKSB7XG5cdCAgICAgICAgICAgICAgICByb290LmZpbmQoXCIuay1jaGVja2JveC13cmFwcGVyIGlucHV0W3R5cGU9Y2hlY2tib3hdOm5vdChbZGlzYWJsZWRdKVwiKVxuXHQgICAgICAgICAgICAgICAgICAgIC5wcm9wKENIRUNLRUQsIHN0YXRlKVxuXHQgICAgICAgICAgICAgICAgICAgIC5kYXRhKElOREVURVJNSU5BVEUsIGZhbHNlKVxuXHQgICAgICAgICAgICAgICAgICAgIC5wcm9wKElOREVURVJNSU5BVEUsIGZhbHNlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmIChmaWVsZCA9PSBcInNlbGVjdGVkXCIpIHtcblx0ICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtc1swXTtcblxuXHQgICAgICAgICAgICAgICAgbm9kZSA9IHRoYXQuZmluZEJ5VWlkKGl0ZW0udWlkKS5maW5kKFwiLmstaW46Zmlyc3RcIilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKFwiay1zdGF0ZS1ob3ZlclwiKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAudG9nZ2xlQ2xhc3MoXCJrLXN0YXRlLXNlbGVjdGVkXCIsIGl0ZW1bZmllbGRdKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAuZW5kKCk7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpdGVtW2ZpZWxkXSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuY3VycmVudChub2RlKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgbm9kZS5hdHRyKEFSSUFTRUxFQ1RFRCwgISFpdGVtW2ZpZWxkXSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSAkLm1hcChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0LmZpbmRCeVVpZChpdGVtLnVpZCkuY2hpbGRyZW4oXCJkaXZcIik7XG5cdCAgICAgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHJlbmRlcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuYW5ndWxhcihcImNsZWFudXBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB7IGVsZW1lbnRzOiBlbGVtZW50cyB9OyB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29udGV4dC5pdGVtID0gaXRlbSA9IGl0ZW1zW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGVXcmFwcGVyID0gZWxlbWVudHNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVXcmFwcGVyLnBhcmVudCgpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJlbmRlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBub2RlV3JhcHBlci5jaGlsZHJlbihcIi5rLWluXCIpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaHRtbCh0aGF0LnRlbXBsYXRlcy5pdGVtQ29udGVudChjb250ZXh0KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkID09IENIRUNLRUQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaXNDaGVja2VkID0gaXRlbVtmaWVsZF07XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q2hlY2tlZFN0YXRlKG5vZGVXcmFwcGVyLCBpc0NoZWNrZWQpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXR0cihBUklBQ0hFQ0tFRCwgaXNDaGVja2VkKTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLmNoZWNrYm94ZXMuY2hlY2tDaGlsZHJlbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q2hlY2tlZFN0YXRlKG5vZGUuY2hpbGRyZW4oXCIuay1ncm91cFwiKSwgaXNDaGVja2VkKTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fc2V0Q2hlY2tlZChpdGVtLmNoaWxkcmVuLCBpc0NoZWNrZWQpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5wYXJlbnQobm9kZSkubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fYnViYmxlSW5kZXRlcm1pbmF0ZShub2RlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQgPT0gXCJleHBhbmRlZFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3RvZ2dsZShub2RlLCBpdGVtLCBpdGVtW2ZpZWxkXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZCA9PSBcImVuYWJsZWRcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmZpbmQoXCIuay1jaGVja2JveC13cmFwcGVyIGlucHV0W3R5cGU9Y2hlY2tib3hdXCIpLnByb3AoXCJkaXNhYmxlZFwiLCAhaXRlbVtmaWVsZF0pO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29sbGFwc2VkID0gIW5vZGVDb250ZW50cyhub2RlKS5pcyhWSVNJQkxFKTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHIoQVJJQURJU0FCTEVEKTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW1bZmllbGRdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3RlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0KFwic2VsZWN0ZWRcIiwgZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5leHBhbmRlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0KFwiZXhwYW5kZWRcIiwgZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0NvbGxhcHNlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmF0dHIoQVJJQVNFTEVDVEVELCBmYWxzZSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihBUklBRElTQUJMRUQsIHRydWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fdXBkYXRlTm9kZUNsYXNzZXMobm9kZSwge30sIHsgZW5hYmxlZDogaXRlbVtmaWVsZF0sIGV4cGFuZGVkOiAhaXNDb2xsYXBzZWQgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVXcmFwcGVyLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJpdGVtQ2hhbmdlXCIsIHsgaXRlbTogbm9kZVdyYXBwZXIsIGRhdGE6IGl0ZW0sIG5zOiB1aSB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChyZW5kZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LmFuZ3VsYXIoXCJjb21waWxlXCIsIGZ1bmN0aW9uKCl7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAkLm1hcChpdGVtcywgZnVuY3Rpb24oaXRlbSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbeyBkYXRhSXRlbTogaXRlbSB9XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2FwcGVuZEl0ZW1zOiBmdW5jdGlvbihpbmRleCwgaXRlbXMsIHBhcmVudE5vZGUpIHtcblx0ICAgICAgICAgICAgdmFyIGdyb3VwID0gc3ViR3JvdXAocGFyZW50Tm9kZSk7XG5cdCAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGdyb3VwLmNoaWxkcmVuKCk7XG5cdCAgICAgICAgICAgIHZhciBjb2xsYXBzZWQgPSAhdGhpcy5fZXhwYW5kZWQocGFyZW50Tm9kZSk7XG5cblx0ICAgICAgICAgICAgaWYodGhpcy5lbGVtZW50ID09PSBwYXJlbnROb2RlKXtcblx0ICAgICAgICAgICAgICAgIHZhciBkYXRhSXRlbXMgPSB0aGlzLmRhdGFTb3VyY2UuZGF0YSgpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHZpZXdJdGVtcyA9IHRoaXMuZGF0YVNvdXJjZS52aWV3KCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgcm9vdEl0ZW1zID0gdmlld0l0ZW1zLmxlbmd0aCA8IGRhdGFJdGVtcy5sZW5ndGggPyB2aWV3SXRlbXMgOiBkYXRhSXRlbXM7XG5cdCAgICAgICAgICAgICAgICBpbmRleCA9IHJvb3RJdGVtcy5pbmRleE9mKGl0ZW1zWzBdKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtcy5sZW5ndGgpe1xuXHQgICAgICAgICAgICAgICAgaW5kZXggPSBpdGVtc1swXS5wYXJlbnQoKS5pbmRleE9mKGl0ZW1zWzBdKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gVU5ERUZJTkVEKSB7XG5cdCAgICAgICAgICAgICAgICBpbmRleCA9IGNoaWxkcmVuLmxlbmd0aDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoaXMuX2luc2VydE5vZGUoaXRlbXMsIGluZGV4LCBwYXJlbnROb2RlLCBmdW5jdGlvbihpdGVtLCBncm91cCkge1xuXHQgICAgICAgICAgICAgICAgLy8gaW5zZXJ0IG5vZGUgaW50byBET01cblx0ICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBjaGlsZHJlbi5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpdGVtLmFwcGVuZFRvKGdyb3VwKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaXRlbS5pbnNlcnRCZWZvcmUoY2hpbGRyZW4uZXEoaW5kZXgpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSwgY29sbGFwc2VkKTtcblxuXHQgICAgICAgICAgICBpZiAoIWNvbGxhcHNlZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTm9kZUNsYXNzZXMocGFyZW50Tm9kZSwge30sIHtleHBhbmRlZDogIWNvbGxhcHNlZH0pO1xuXHQgICAgICAgICAgICAgICAgc3ViR3JvdXAocGFyZW50Tm9kZSkuY3NzKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9yZWZyZXNoQ2hpbGRyZW46IGZ1bmN0aW9uKHBhcmVudE5vZGUsIGl0ZW1zLCBpbmRleCkge1xuXHQgICAgICAgICAgICB2YXIgaSwgY2hpbGRyZW4sIGNoaWxkO1xuXHQgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0ICAgICAgICAgICAgdmFyIGxvYWRPbkRlbWFuZCA9IG9wdGlvbnMubG9hZE9uRGVtYW5kO1xuXHQgICAgICAgICAgICB2YXIgY2hlY2tDaGlsZHJlbiA9IG9wdGlvbnMuY2hlY2tib3hlcyAmJiBvcHRpb25zLmNoZWNrYm94ZXMuY2hlY2tDaGlsZHJlbjtcblxuXHQgICAgICAgICAgICBzdWJHcm91cChwYXJlbnROb2RlKS5lbXB0eSgpO1xuXG5cdCAgICAgICAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICB1cGRhdGVOb2RlSHRtbChwYXJlbnROb2RlKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZEl0ZW1zKGluZGV4LCBpdGVtcywgcGFyZW50Tm9kZSk7XG5cblx0ICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gc3ViR3JvdXAocGFyZW50Tm9kZSkuY2hpbGRyZW4oKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKGxvYWRPbkRlbWFuZCAmJiBjaGVja0NoaWxkcmVuKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnViYmxlSW5kZXRlcm1pbmF0ZShjaGlsZHJlbi5sYXN0KCkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuLmVxKGkpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcIml0ZW1DaGFuZ2VcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBjaGlsZC5jaGlsZHJlbihcImRpdlwiKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaXRlbXNbaV0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5zOiB1aVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9yZWZyZXNoUm9vdDogZnVuY3Rpb24oaXRlbXMpIHtcblx0ICAgICAgICAgICAgdmFyIGdyb3VwSHRtbCA9IHRoaXMuX3JlbmRlckdyb3VwKHtcblx0ICAgICAgICAgICAgICAgICAgICBpdGVtczogaXRlbXMsXG5cdCAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RMZXZlbDogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQ6IHRydWVcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICBpZiAodGhpcy5yb290Lmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYW5ndWxhckl0ZW1zKFwiY2xlYW51cFwiKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIGdyb3VwID0gJChncm91cEh0bWwpO1xuXG5cdCAgICAgICAgICAgICAgICB0aGlzLnJvb3Rcblx0ICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGdyb3VwLmF0dHIoXCJjbGFzc1wiKSlcblx0ICAgICAgICAgICAgICAgICAgICAuaHRtbChncm91cC5odG1sKCkpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gdGhpcy53cmFwcGVyLmh0bWwoZ3JvdXBIdG1sKS5jaGlsZHJlbihcInVsXCIpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5yb290LmNoaWxkcmVuKFwiLmstaXRlbVwiKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwiaXRlbUNoYW5nZVwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgaXRlbTogZWxlbWVudHMuZXEoaSksXG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YTogaXRlbXNbaV0sXG5cdCAgICAgICAgICAgICAgICAgICAgbnM6IHVpXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9hbmd1bGFySXRlbXMoXCJjb21waWxlXCIpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICByZWZyZXNoOiBmdW5jdGlvbihlKSB7XG5cdCAgICAgICAgICAgIHZhciBub2RlID0gZS5ub2RlO1xuXHQgICAgICAgICAgICB2YXIgYWN0aW9uID0gZS5hY3Rpb247XG5cdCAgICAgICAgICAgIHZhciBpdGVtcyA9IGUuaXRlbXM7XG5cdCAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gdGhpcy53cmFwcGVyO1xuXHQgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0ICAgICAgICAgICAgdmFyIGxvYWRPbkRlbWFuZCA9IG9wdGlvbnMubG9hZE9uRGVtYW5kO1xuXHQgICAgICAgICAgICB2YXIgY2hlY2tDaGlsZHJlbiA9IG9wdGlvbnMuY2hlY2tib3hlcyAmJiBvcHRpb25zLmNoZWNrYm94ZXMuY2hlY2tDaGlsZHJlbjtcblx0ICAgICAgICAgICAgdmFyIGk7XG5cblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3NraXApIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZGF0YVNvdXJjZVVpZHNbaXRlbXNbaV0udWlkXSA9IGl0ZW1zW2ldO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGUuZmllbGQpIHtcblx0ICAgICAgICAgICAgICAgIGlmICghaXRlbXNbMF0gfHwgIWl0ZW1zWzBdLmxldmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlTm9kZXMoaXRlbXMsIGUuZmllbGQpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKG5vZGUpIHtcblx0ICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSB0aGlzLmZpbmRCeVVpZChub2RlLnVpZCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzcyhwYXJlbnROb2RlLCBmYWxzZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoY2hlY2tDaGlsZHJlbiAmJiBhY3Rpb24gIT0gXCJyZW1vdmVcIikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ1YmJsZSA9IGZhbHNlO1xuXG5cdCAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoXCJjaGVja2VkXCIgaW4gaXRlbXNbaV0pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnViYmxlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAoIWJ1YmJsZSAmJiBub2RlICYmIG5vZGUuY2hlY2tlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpXS5jaGVja2VkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoYWN0aW9uID09IFwiYWRkXCIpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZEl0ZW1zKGUuaW5kZXgsIGl0ZW1zLCBwYXJlbnROb2RlKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT0gXCJyZW1vdmVcIikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKHRoaXMuZmluZEJ5VWlkKGl0ZW1zWzBdLnVpZCksIGZhbHNlKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT0gXCJpdGVtY2hhbmdlXCIpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU5vZGVzKGl0ZW1zKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24gPT0gXCJpdGVtbG9hZGVkXCIpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JlZnJlc2hDaGlsZHJlbihwYXJlbnROb2RlLCBpdGVtcywgZS5pbmRleCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yZWZyZXNoUm9vdChpdGVtcyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoYWN0aW9uICE9IFwicmVtb3ZlXCIpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghbG9hZE9uRGVtYW5kIHx8IGl0ZW1zW2ldLmV4cGFuZGVkIHx8IGl0ZW1zW2ldLl9sb2FkZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0ubG9hZCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoaXMudHJpZ2dlcihEQVRBQk9VTkQsIHsgbm9kZTogbm9kZSA/IHBhcmVudE5vZGUgOiB1bmRlZmluZWQgfSk7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2UuZmlsdGVyKCkgJiYgdGhpcy5vcHRpb25zLmNoZWNrYm94ZXMuY2hlY2tDaGlsZHJlbikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbmRldGVybWluYXRlKHBhcmVudE5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9lcnJvcjogZnVuY3Rpb24oZSkge1xuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IGUubm9kZSAmJiB0aGlzLmZpbmRCeVVpZChlLm5vZGUudWlkKTtcblx0ICAgICAgICAgICAgdmFyIHJldHJ5SHRtbCA9IHRoaXMudGVtcGxhdGVzLnJldHJ5KHsgbWVzc2FnZXM6IHRoaXMub3B0aW9ucy5tZXNzYWdlcyB9KTtcblxuXHQgICAgICAgICAgICBpZiAobm9kZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcHJvZ3Jlc3Mobm9kZSwgZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZXhwYW5kZWQobm9kZSwgZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgbm9kZUljb24obm9kZSkuYWRkQ2xhc3MoXCJrLWktcmVsb2FkXCIpO1xuXHQgICAgICAgICAgICAgICAgZS5ub2RlLmxvYWRlZChmYWxzZSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzcyhmYWxzZSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuaHRtbChyZXRyeUh0bWwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9yZXRyeVJlcXVlc3Q6IGZ1bmN0aW9uKGUpIHtcblx0ICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdCAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5mZXRjaCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBleHBhbmQ6IGZ1bmN0aW9uIChub2Rlcykge1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzTm9kZXMobm9kZXMsIGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy50b2dnbGUoaXRlbSwgdHJ1ZSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjb2xsYXBzZTogZnVuY3Rpb24gKG5vZGVzKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NOb2Rlcyhub2RlcywgZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZShpdGVtLCBmYWxzZSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBlbmFibGU6IGZ1bmN0aW9uIChub2RlcywgZW5hYmxlKSB7XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZXMgPT09IFwiYm9vbGVhblwiKSB7XG5cdCAgICAgICAgICAgICAgICBlbmFibGUgPSBub2Rlcztcblx0ICAgICAgICAgICAgICAgIG5vZGVzID0gdGhpcy5pdGVtcygpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCA9PSAyID8gISFlbmFibGUgOiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc05vZGVzKG5vZGVzLCBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGF0YUl0ZW0oaXRlbSkuc2V0KFwiZW5hYmxlZFwiLCBlbmFibGUpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY3VycmVudDogZnVuY3Rpb24obm9kZSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhhdC5fY3VycmVudCxcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnQgPSB0aGF0LmVsZW1lbnQsXG5cdCAgICAgICAgICAgICAgICBpZCA9IHRoYXQuX2FyaWFJZDtcblxuXHQgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgbm9kZSAmJiBub2RlLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFswXS5pZCA9PT0gaWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudC5yZW1vdmVBdHRyKFwiaWRcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgY3VycmVudC5maW5kKFwiLmstaW46Zmlyc3RcIikucmVtb3ZlQ2xhc3MoXCJrLXN0YXRlLWZvY3VzZWRcIik7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGF0Ll9jdXJyZW50ID0gJChub2RlLCBlbGVtZW50KS5jbG9zZXN0KE5PREUpO1xuXG5cdCAgICAgICAgICAgICAgICBjdXJyZW50LmZpbmQoXCIuay1pbjpmaXJzdFwiKS5hZGRDbGFzcyhcImstc3RhdGUtZm9jdXNlZFwiKTtcblxuXHQgICAgICAgICAgICAgICAgaWQgPSBjdXJyZW50WzBdLmlkIHx8IGlkO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoaWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LndyYXBwZXIucmVtb3ZlQXR0cihcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICBjdXJyZW50LmF0dHIoXCJpZFwiLCBpZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC53cmFwcGVyLmF0dHIoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIiwgaWQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoIWN1cnJlbnQpIHtcblx0ICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGF0Ll9uZXh0VmlzaWJsZSgkKCkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHNlbGVjdDogZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgZWxlbWVudCA9IHRoYXQuZWxlbWVudDtcblxuXHQgICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmZpbmQoXCIuay1zdGF0ZS1zZWxlY3RlZFwiKS5jbG9zZXN0KE5PREUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgbm9kZSA9ICQobm9kZSwgZWxlbWVudCkuY2xvc2VzdChOT0RFKTtcblxuXHQgICAgICAgICAgICBlbGVtZW50LmZpbmQoXCIuay1zdGF0ZS1zZWxlY3RlZFwiKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGRhdGFJdGVtID0gdGhhdC5kYXRhSXRlbSh0aGlzKTtcblx0ICAgICAgICAgICAgICAgIGlmIChkYXRhSXRlbSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRhdGFJdGVtLnNldChcInNlbGVjdGVkXCIsIGZhbHNlKTtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGF0YUl0ZW0uc2VsZWN0ZWQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoXCJrLXN0YXRlLXNlbGVjdGVkXCIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICBpZiAobm9kZS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQuZGF0YUl0ZW0obm9kZSkuc2V0KFwic2VsZWN0ZWRcIiwgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9jbGlja1RhcmdldCA9IG5vZGU7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGF0LnRyaWdnZXIoQ0hBTkdFKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3RvZ2dsZTogZnVuY3Rpb24obm9kZSwgZGF0YUl0ZW0sIGV4cGFuZCkge1xuXHQgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblx0ICAgICAgICAgICAgdmFyIGNvbnRlbnRzID0gbm9kZUNvbnRlbnRzKG5vZGUpO1xuXHQgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gZXhwYW5kID8gXCJleHBhbmRcIiA6IFwiY29sbGFwc2VcIjtcblx0ICAgICAgICAgICAgdmFyIGxvYWRlZDtcblxuXHQgICAgICAgICAgICBpZiAoY29udGVudHMuZGF0YShcImFuaW1hdGluZ1wiKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgbG9hZGVkID0gZGF0YUl0ZW0gJiYgZGF0YUl0ZW0ubG9hZGVkKCk7XG5cblx0ICAgICAgICAgICAgaWYgKGV4cGFuZCAmJiAhbG9hZGVkKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2FkT25EZW1hbmQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9ncmVzcyhub2RlLCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgY29udGVudHMucmVtb3ZlKCk7XG5cdCAgICAgICAgICAgICAgICBkYXRhSXRlbS5sb2FkKCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVOb2RlQ2xhc3Nlcyhub2RlLCB7fSwgeyBleHBhbmRlZDogZXhwYW5kIH0pO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoIWV4cGFuZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzLmNzcyhcImhlaWdodFwiLCBjb250ZW50cy5oZWlnaHQoKSkuY3NzKFwiaGVpZ2h0XCIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBjb250ZW50c1xuXHQgICAgICAgICAgICAgICAgICAgIC5rZW5kb1N0b3AodHJ1ZSwgdHJ1ZSlcblx0ICAgICAgICAgICAgICAgICAgICAua2VuZG9BbmltYXRlKGV4dGVuZChcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeyByZXNldDogdHJ1ZSB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmFuaW1hdGlvbltkaXJlY3Rpb25dLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB7IGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBhbmQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50cy5jc3MoXCJoZWlnaHRcIiwgXCJcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gfVxuXHQgICAgICAgICAgICAgICAgICAgICkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbiAobm9kZSwgZXhwYW5kKSB7XG5cdCAgICAgICAgICAgIG5vZGUgPSAkKG5vZGUpO1xuXG5cdCAgICAgICAgICAgIGlmICghbm9kZUljb24obm9kZSkuaXMoXCIuay1pLWV4cGFuZCwgLmstaS1jb2xsYXBzZVwiKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuXHQgICAgICAgICAgICAgICAgZXhwYW5kID0gIXRoaXMuX2V4cGFuZGVkKG5vZGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdGhpcy5fZXhwYW5kZWQobm9kZSwgZXhwYW5kKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuXHQgICAgICAgICAgICBXaWRnZXQuZm4uZGVzdHJveS5jYWxsKHRoYXQpO1xuXG5cdCAgICAgICAgICAgIHRoYXQud3JhcHBlci5vZmYoTlMpO1xuXHQgICAgICAgICAgICB0aGF0LndyYXBwZXIuZmluZChcIi5rLWNoZWNrYm94LXdyYXBwZXIgOmNoZWNrYm94XCIpLm9mZihOUyk7XG5cblx0ICAgICAgICAgICAgdGhhdC5fdW5iaW5kRGF0YVNvdXJjZSgpO1xuXG5cdCAgICAgICAgICAgIGlmICh0aGF0LmRyYWdnaW5nKSB7XG5cdCAgICAgICAgICAgICAgICB0aGF0LmRyYWdnaW5nLmRlc3Ryb3koKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoYXQuX2RhdGFTb3VyY2VVaWRzID0ge307XG5cblx0ICAgICAgICAgICAga2VuZG8uZGVzdHJveSh0aGF0LmVsZW1lbnQpO1xuXG5cdCAgICAgICAgICAgIHRoYXQucm9vdCA9IHRoYXQud3JhcHBlciA9IHRoYXQuZWxlbWVudCA9IG51bGw7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9leHBhbmRlZDogZnVuY3Rpb24obm9kZSwgdmFsdWUsIGZvcmNlKSB7XG5cdCAgICAgICAgICAgIHZhciBleHBhbmRlZEF0dHIgPSBrZW5kby5hdHRyKFwiZXhwYW5kZWRcIik7XG5cdCAgICAgICAgICAgIHZhciBkYXRhSXRlbTtcblx0ICAgICAgICAgICAgdmFyIGV4cGFuZGVkID0gdmFsdWU7XG5cdCAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBleHBhbmRlZCA/IFwiZXhwYW5kXCIgOiBcImNvbGxhcHNlXCI7XG5cblx0ICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuXHQgICAgICAgICAgICAgICAgZGF0YUl0ZW0gPSB0aGlzLl9kYXRhSXRlbShub2RlKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmF0dHIoZXhwYW5kZWRBdHRyKSA9PT0gXCJ0cnVlXCIgfHwgKGRhdGFJdGVtICYmIGRhdGFJdGVtLmV4cGFuZGVkKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGRhdGFJdGVtID0gdGhpcy5kYXRhSXRlbShub2RlKTtcblxuXHQgICAgICAgICAgICBpZiAobm9kZUNvbnRlbnRzKG5vZGUpLmRhdGEoXCJhbmltYXRpbmdcIikpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmIChmb3JjZSB8fCAhdGhpcy5fdHJpZ2dlcihkaXJlY3Rpb24sIG5vZGUpKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXhwYW5kZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLmF0dHIoZXhwYW5kZWRBdHRyLCBcInRydWVcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgbm9kZS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIik7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cihleHBhbmRlZEF0dHIpO1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwgXCJmYWxzZVwiKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKGRhdGFJdGVtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YUl0ZW0uc2V0KFwiZXhwYW5kZWRcIiwgZXhwYW5kZWQpO1xuXHQgICAgICAgICAgICAgICAgICAgIC8vIG5lY2Vzc2FyeSB3aGVuIGV4cGFuZGluZyBhbiBpdGVtIHlpZWxkcyBhbiBlcnJvciBhbmQgdGhlIGl0ZW0gaXMgbm90IGV4cGFuZGVkIGFzIGEgcmVzdWx0XG5cdCAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQgPSBkYXRhSXRlbS5leHBhbmRlZDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfcHJvZ3Jlc3M6IGZ1bmN0aW9uKG5vZGUsIHNob3dQcm9ncmVzcykge1xuXHQgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblx0ICAgICAgICAgICAgdmFyIGxvYWRpbmdUZXh0ID0gdGhpcy50ZW1wbGF0ZXMubG9hZGluZyh7IG1lc3NhZ2VzOiB0aGlzLm9wdGlvbnMubWVzc2FnZXMgfSk7XG5cblx0ICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuXHQgICAgICAgICAgICAgICAgc2hvd1Byb2dyZXNzID0gbm9kZTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHNob3dQcm9ncmVzcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuaHRtbChsb2FkaW5nVGV4dCk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZW1wdHkoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIG5vZGVJY29uKG5vZGUpLnRvZ2dsZUNsYXNzKFwiay1pLWxvYWRpbmdcIiwgc2hvd1Byb2dyZXNzKS5yZW1vdmVDbGFzcyhcImstaS1yZWxvYWRcIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgdGV4dDogZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcblx0ICAgICAgICAgICAgdmFyIGRhdGFJdGVtID0gdGhpcy5kYXRhSXRlbShub2RlKSxcblx0ICAgICAgICAgICAgICAgIGZpZWxkQmluZGluZ3MgPSB0aGlzLm9wdGlvbnNbYmluZGluZ3MudGV4dF0sXG5cdCAgICAgICAgICAgICAgICBsZXZlbCA9IGRhdGFJdGVtLmxldmVsKCksXG5cdCAgICAgICAgICAgICAgICBsZW5ndGggPSBmaWVsZEJpbmRpbmdzLmxlbmd0aCxcblx0ICAgICAgICAgICAgICAgIGZpZWxkID0gZmllbGRCaW5kaW5nc1tNYXRoLm1pbihsZXZlbCwgbGVuZ3RoLTEpXTtcblxuXHQgICAgICAgICAgICBpZiAodGV4dCkge1xuXHQgICAgICAgICAgICAgICAgZGF0YUl0ZW0uc2V0KGZpZWxkLCB0ZXh0KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBkYXRhSXRlbVtmaWVsZF07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX29iamVjdE9yU2VsZjogZnVuY3Rpb24gKG5vZGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICQobm9kZSkuY2xvc2VzdChcIltkYXRhLXJvbGU9dHJlZXZpZXddXCIpLmRhdGEoXCJrZW5kb1RyZWVWaWV3XCIpIHx8IHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kYXRhU291cmNlTW92ZTogZnVuY3Rpb24obm9kZURhdGEsIGdyb3VwLCBwYXJlbnROb2RlLCBjYWxsYmFjaykge1xuXHQgICAgICAgICAgICB2YXIgcmVmZXJlbmNlRGF0YUl0ZW0sXG5cdCAgICAgICAgICAgICAgICBkZXN0VHJlZXZpZXcgPSB0aGlzLl9vYmplY3RPclNlbGYocGFyZW50Tm9kZSB8fCBncm91cCksXG5cdCAgICAgICAgICAgICAgICBkZXN0RGF0YVNvdXJjZSA9IGRlc3RUcmVldmlldy5kYXRhU291cmNlO1xuXHQgICAgICAgICAgICB2YXIgbG9hZFByb21pc2UgPSAkLkRlZmVycmVkKCkucmVzb2x2ZSgpLnByb21pc2UoKTtcblxuXHQgICAgICAgICAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlWzBdICE9IGRlc3RUcmVldmlldy5lbGVtZW50WzBdKSB7XG5cdCAgICAgICAgICAgICAgICByZWZlcmVuY2VEYXRhSXRlbSA9IGRlc3RUcmVldmlldy5kYXRhSXRlbShwYXJlbnROb2RlKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKCFyZWZlcmVuY2VEYXRhSXRlbS5sb2FkZWQoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlc3RUcmVldmlldy5fcHJvZ3Jlc3MocGFyZW50Tm9kZSwgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgbG9hZFByb21pc2UgPSByZWZlcmVuY2VEYXRhSXRlbS5sb2FkKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICE9IHRoaXMucm9vdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlc3REYXRhU291cmNlID0gcmVmZXJlbmNlRGF0YUl0ZW0uY2hpbGRyZW47XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWRlc3REYXRhU291cmNlIHx8ICEoZGVzdERhdGFTb3VyY2UgaW5zdGFuY2VvZiBIaWVyYXJjaGljYWxEYXRhU291cmNlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VEYXRhSXRlbS5faW5pdENoaWxkcmVuKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZURhdGFJdGVtLmxvYWRlZCh0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVzdERhdGFTb3VyY2UgPSByZWZlcmVuY2VEYXRhSXRlbS5jaGlsZHJlbjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBub2RlRGF0YSA9IHRoaXMuX3RvT2JzZXJ2YWJsZURhdGEobm9kZURhdGEpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKGRlc3RUcmVldmlldywgZGVzdERhdGFTb3VyY2UsIG5vZGVEYXRhLCBsb2FkUHJvbWlzZSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF90b09ic2VydmFibGVEYXRhOiBmdW5jdGlvbihub2RlKSB7XG5cdCAgICAgICAgICAgIHZhciBkYXRhSXRlbSA9IG5vZGUsIGRhdGFTb3VyY2UsIHVpZDtcblxuXHQgICAgICAgICAgICBpZiAoaXNKUXVlcnlJbnN0YW5jZShub2RlKSB8fCBpc0RvbUVsZW1lbnQobm9kZSkpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UgPSB0aGlzLl9vYmplY3RPclNlbGYobm9kZSkuZGF0YVNvdXJjZTtcblx0ICAgICAgICAgICAgICAgIHVpZCA9ICQobm9kZSkuYXR0cihrZW5kby5hdHRyKFwidWlkXCIpKTtcblx0ICAgICAgICAgICAgICAgIGRhdGFJdGVtID0gZGF0YVNvdXJjZS5nZXRCeVVpZCh1aWQpO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoZGF0YUl0ZW0pIHtcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhSXRlbSA9IGRhdGFTb3VyY2UucmVtb3ZlKGRhdGFJdGVtKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBkYXRhSXRlbTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2luc2VydDogZnVuY3Rpb24oZGF0YSwgbW9kZWwsIGluZGV4KSB7XG5cdCAgICAgICAgICAgIGlmICghKG1vZGVsIGluc3RhbmNlb2Yga2VuZG8uZGF0YS5PYnNlcnZhYmxlQXJyYXkpKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkobW9kZWwpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbW9kZWwgPSBbbW9kZWxdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gaXRlbXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gbmV3IE5vZGUgaW5zdGFuY2VzXG5cdCAgICAgICAgICAgICAgICBtb2RlbCA9IG1vZGVsLnRvSlNPTigpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBkYXRhLnBhcmVudCgpO1xuXG5cdCAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuX2luaXRDaGlsZHJlbikge1xuXHQgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5oYXNDaGlsZHJlbiA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBwYXJlbnROb2RlLl9pbml0Q2hpbGRyZW4oKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGRhdGEuc3BsaWNlLmFwcGx5KGRhdGEsIFsgaW5kZXgsIDAgXS5jb25jYXQobW9kZWwpKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5maW5kQnlVaWQoZGF0YVtpbmRleF0udWlkKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgaW5zZXJ0QWZ0ZXI6IGluc2VydEFjdGlvbigxKSxcblxuXHQgICAgICAgIGluc2VydEJlZm9yZTogaW5zZXJ0QWN0aW9uKDApLFxuXG5cdCAgICAgICAgYXBwZW5kOiBmdW5jdGlvbiAobm9kZURhdGEsIHBhcmVudE5vZGUsIHN1Y2Nlc3MpIHtcblx0ICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhpcy5yb290O1xuXG5cdCAgICAgICAgICAgIGlmKHBhcmVudE5vZGUgJiYgbm9kZURhdGEgaW5zdGFuY2VvZiBqUXVlcnkgJiYgcGFyZW50Tm9kZVswXSA9PT0gbm9kZURhdGFbMF0pe1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5sZW5ndGggPyBwYXJlbnROb2RlIDogbnVsbDtcblxuXHQgICAgICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuXHQgICAgICAgICAgICAgICAgZ3JvdXAgPSBzdWJHcm91cChwYXJlbnROb2RlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhU291cmNlTW92ZShub2RlRGF0YSwgZ3JvdXAsIHBhcmVudE5vZGUsIGZ1bmN0aW9uIChkYXRhU291cmNlLCBtb2RlbCwgbG9hZE1vZGVsKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5zZXJ0ZWQ7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGFkZCgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9leHBhbmRlZChwYXJlbnROb2RlLCB0cnVlLCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGRhdGFTb3VyY2UuZGF0YSgpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IE1hdGgubWF4KGRhdGEubGVuZ3RoLCAwKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0Ll9pbnNlcnQoZGF0YSwgbW9kZWwsIGluZGV4KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgbG9hZE1vZGVsLmRvbmUoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSBhZGQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gc3VjY2VzcyB8fCAkLm5vb3A7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VjY2VzcyhpbnNlcnRlZCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGluc2VydGVkIHx8IG51bGw7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfcmVtb3ZlOiBmdW5jdGlvbiAobm9kZSwga2VlcERhdGEpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgcGFyZW50Tm9kZSxcblx0ICAgICAgICAgICAgICAgIHByZXZTaWJsaW5nLCBuZXh0U2libGluZztcblxuXHQgICAgICAgICAgICBub2RlID0gJChub2RlLCB0aGF0LmVsZW1lbnQpO1xuXG5cdCAgICAgICAgICAgIHRoaXMuYW5ndWxhcihcImNsZWFudXBcIiwgZnVuY3Rpb24oKXtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7IGVsZW1lbnRzOiBub2RlLmdldCgpIH07XG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudCgpLnBhcmVudCgpO1xuXHQgICAgICAgICAgICBwcmV2U2libGluZyA9IG5vZGUucHJldigpO1xuXHQgICAgICAgICAgICBuZXh0U2libGluZyA9IG5vZGUubmV4dCgpO1xuXG5cdCAgICAgICAgICAgIG5vZGVba2VlcERhdGEgPyBcImRldGFjaFwiIDogXCJyZW1vdmVcIl0oKTtcblxuXHQgICAgICAgICAgICBpZiAocGFyZW50Tm9kZS5oYXNDbGFzcyhcImstaXRlbVwiKSkge1xuXHQgICAgICAgICAgICAgICAgdXBkYXRlTm9kZUh0bWwocGFyZW50Tm9kZSk7XG5cdCAgICAgICAgICAgICAgICB0aGF0Ll91cGRhdGVOb2RlQ2xhc3NlcyhwYXJlbnROb2RlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoYXQuX3VwZGF0ZU5vZGVDbGFzc2VzKHByZXZTaWJsaW5nKTtcblx0ICAgICAgICAgICAgdGhhdC5fdXBkYXRlTm9kZUNsYXNzZXMobmV4dFNpYmxpbmcpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBub2RlO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIChub2RlKSB7XG5cdCAgICAgICAgICAgIHZhciBkYXRhSXRlbSA9IHRoaXMuZGF0YUl0ZW0obm9kZSk7XG5cdCAgICAgICAgICAgIGlmIChkYXRhSXRlbSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnJlbW92ZShkYXRhSXRlbSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZGV0YWNoOiBmdW5jdGlvbiAobm9kZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlKG5vZGUsIHRydWUpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBmaW5kQnlUZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiAkKHRoaXMuZWxlbWVudCkuZmluZChcIi5rLWluXCIpLmZpbHRlcihmdW5jdGlvbihpLCBlbGVtZW50KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJChlbGVtZW50KS50ZXh0KCkgPT0gdGV4dDtcblx0ICAgICAgICAgICAgfSkuY2xvc2VzdChOT0RFKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZmluZEJ5VWlkOiBmdW5jdGlvbih1aWQpIHtcblx0ICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5lbGVtZW50LmZpbmQoXCIuay1pdGVtXCIpO1xuXHQgICAgICAgICAgICB2YXIgdWlkQXR0ciA9IGtlbmRvLmF0dHIoXCJ1aWRcIik7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQ7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGl0ZW1zW2ldLmdldEF0dHJpYnV0ZSh1aWRBdHRyKSA9PSB1aWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBpdGVtc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiAkKHJlc3VsdCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGV4cGFuZFBhdGg6IGZ1bmN0aW9uKHBhdGgsIGNvbXBsZXRlKSB7XG5cdCAgICAgICAgICAgIHZhciB0cmVldmlldyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciBub2RlSWRzID0gcGF0aC5zbGljZSgwKTtcblx0ICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gY29tcGxldGUgfHwgJC5ub29wO1xuXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHByb2NlZWQoKSB7XG5cdCAgICAgICAgICAgICAgICBub2RlSWRzLnNoaWZ0KCk7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChub2RlSWRzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGV4cGFuZChub2RlSWRzWzBdKS50aGVuKHByb2NlZWQpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRyZWV2aWV3KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIGV4cGFuZChpZCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICQuRGVmZXJyZWQoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBub2RlID0gdHJlZXZpZXcuZGF0YVNvdXJjZS5nZXQoaWQpO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxvYWRlZCgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0KFwiZXhwYW5kZWRcIiwgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFudWFsbHkgc2hvdyBwcm9ncmVzcyBvZiB0aGUgbm9kZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgbW92ZWQgdG8gYHJlZnJlc2hgXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBkYXRhc291cmNlIHN0YXJ0cyB0cmlnZ2VyaW5nIGEgYHJlcXVlc3RTdGFydGAgZXZlbnQgZm9yIG5vZGVzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyZWV2aWV3Ll9wcm9ncmVzcyh0cmVldmlldy5maW5kQnlVaWQobm9kZS51aWQpLCB0cnVlKTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmxvYWQoKS50aGVuKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXQoXCJleHBhbmRlZFwiLCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZXNvbHZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJlc29sdmUoKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5wcm9taXNlKCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBleHBhbmQgYXN5bmMgbm9kZXNcblx0ICAgICAgICAgICAgZXhwYW5kKG5vZGVJZHNbMF0pLnRoZW4ocHJvY2VlZCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9wYXJlbnRJZHM6IGZ1bmN0aW9uKG5vZGUpIHtcblx0ICAgICAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlKCk7XG5cdCAgICAgICAgICAgIHZhciBwYXJlbnRzID0gW107XG5cdCAgICAgICAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUpIHtcblx0ICAgICAgICAgICAgICAgIHBhcmVudHMudW5zaGlmdChwYXJlbnQuaWQpO1xuXHQgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGUoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBwYXJlbnRzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBleHBhbmRUbzogZnVuY3Rpb24obm9kZSkge1xuXHQgICAgICAgICAgICBpZiAoIShub2RlIGluc3RhbmNlb2Yga2VuZG8uZGF0YS5Ob2RlKSkge1xuXHQgICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuZGF0YVNvdXJjZS5nZXQobm9kZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB2YXIgcGFyZW50cyA9IHRoaXMuX3BhcmVudElkcyhub2RlKTtcblxuXHQgICAgICAgICAgICB0aGlzLmV4cGFuZFBhdGgocGFyZW50cyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9yZW5kZXJJdGVtOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHQgICAgICAgICAgICBpZiAoIW9wdGlvbnMuZ3JvdXApIHtcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuZ3JvdXAgPSB7fTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIG9wdGlvbnMudHJlZXZpZXcgPSB0aGlzLm9wdGlvbnM7XG5cblx0ICAgICAgICAgICAgb3B0aW9ucy5yID0gdGhpcy50ZW1wbGF0ZXM7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGVzLml0ZW0ob3B0aW9ucyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9yZW5kZXJHcm91cDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG5cdCAgICAgICAgICAgIG9wdGlvbnMucmVuZGVySXRlbXMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGh0bWwgPSBcIlwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpID0gMCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSBvcHRpb25zLml0ZW1zLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBpdGVtcyA/IGl0ZW1zLmxlbmd0aCA6IDAsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwID0gb3B0aW9ucy5ncm91cDtcblxuXHQgICAgICAgICAgICAgICAgICAgIGdyb3VwLmxlbmd0aCA9IGxlbjtcblxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5ncm91cCA9IGdyb3VwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLml0ZW0gPSBpdGVtc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5pdGVtLmluZGV4ID0gaTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaHRtbCArPSB0aGF0Ll9yZW5kZXJJdGVtKG9wdGlvbnMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBodG1sO1xuXHQgICAgICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICBvcHRpb25zLnIgPSB0aGF0LnRlbXBsYXRlcztcblxuXHQgICAgICAgICAgICByZXR1cm4gdGhhdC50ZW1wbGF0ZXMuZ3JvdXAob3B0aW9ucyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIHVpLnBsdWdpbihUcmVlVmlldyk7XG5cdH0pKHdpbmRvdy5rZW5kby5qUXVlcnkpO1xuXG5cdHJldHVybiB3aW5kb3cua2VuZG87XG5cblx0fSwgX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG5cblx0LyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18oMTAwMykpKVxuXG4vKioqLyB9KVxuXG4vKioqKioqLyB9KTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///04065e00ab361f322eef\n");

/***/ }),

/***/ "0aac488a388d7f2d0eea":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMGFhYzQ4OGEzODhkN2YyZDBlZWEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzP2Y2ZDMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0aac488a388d7f2d0eea\n");

/***/ }),

/***/ "127c8cf59f228bb01a21":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = jQuery;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI3YzhjZjU5ZjIyOGJiMDFhMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJqUXVlcnlcIj9jZDBjIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0galF1ZXJ5OyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///127c8cf59f228bb01a21\n");

/***/ }),

/***/ "1e4534d1d62a11482e97":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"0aac488a388d7f2d0eea\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMWU0NTM0ZDFkNjJhMTE0ODJlOTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQpe1xuICAgIHJldHVybiBwYXJlbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXNzaW5nIGZ1bmN0aW9uIGluIG9wdGlvbnMsIHRoZW4gdXNlIGl0IGZvciByZXNvbHZlIFwiaGVhZFwiIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gVXNlZnVsIGZvciBTaGFkb3cgUm9vdCBzdHlsZSBpLmVcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICBpbnNlcnRJbnRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvb1wiKS5zaGFkb3dSb290IH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGdldFRhcmdldC5jYWxsKHRoaXMsIHRhcmdldCwgcGFyZW50KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUsIHRhcmdldCk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0aWYob3B0aW9ucy5hdHRycy5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcblx0XHRpZiAobm9uY2UpIHtcblx0XHRcdG9wdGlvbnMuYXR0cnMubm9uY2UgPSBub25jZTtcblx0XHR9XG5cdH1cblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBnZXROb25jZSgpIHtcblx0aWYgKHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiBfX3dlYnBhY2tfbm9uY2VfXztcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSB0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbidcblx0XHQgPyBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKSBcblx0XHQgOiBvcHRpb25zLnRyYW5zZm9ybS5kZWZhdWx0KG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1e4534d1d62a11482e97\n");

/***/ }),

/***/ 3:
/*!**********************************************************************************!*\
  !*** multi ./src/vendor/Anakeen/SmartStructures/Iuser/Render/changeGroupView.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /home/charles/git/user-interfaces/src/vendor/Anakeen/SmartStructures/Iuser/Render/changeGroupView.js */"ed7ea6f7dc20380e2940");


/***/ }),

/***/ "46d3985e259824d97676":
/*!**********************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.core.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1045);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 1003:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! jquery */ \"127c8cf59f228bb01a21\");\n\n/***/ }),\n\n/***/ 1045:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(jQuery) {(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1003)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: \"core\",\n\t    name: \"Core\",\n\t    category: \"framework\",\n\t    description: \"The core of the Kendo framework.\"\n\t};\n\n\t/*jshint eqnull: true, loopfunc: true, evil: true, boss: true, freeze: false*/\n\t(function($, window, undefined) {\n\t    var kendo = window.kendo = window.kendo || { cultures: {} },\n\t        extend = $.extend,\n\t        each = $.each,\n\t        isArray = $.isArray,\n\t        proxy = $.proxy,\n\t        noop = $.noop,\n\t        math = Math,\n\t        Template,\n\t        JSON = window.JSON || {},\n\t        support = {},\n\t        percentRegExp = /%/,\n\t        formatRegExp = /\\{(\\d+)(:[^\\}]+)?\\}/g,\n\t        boxShadowRegExp = /(\\d+(?:\\.?)\\d*)px\\s*(\\d+(?:\\.?)\\d*)px\\s*(\\d+(?:\\.?)\\d*)px\\s*(\\d+)?/i,\n\t        numberRegExp = /^(\\+|-?)\\d+(\\.?)\\d*$/,\n\t        FUNCTION = \"function\",\n\t        STRING = \"string\",\n\t        NUMBER = \"number\",\n\t        OBJECT = \"object\",\n\t        NULL = \"null\",\n\t        BOOLEAN = \"boolean\",\n\t        UNDEFINED = \"undefined\",\n\t        getterCache = {},\n\t        setterCache = {},\n\t        slice = [].slice;\n\n\t    kendo.version = \"2018.3.1212\".replace(/^\\s+|\\s+$/g, '');\n\n\t    function Class() {}\n\n\t    Class.extend = function(proto) {\n\t        var base = function() {},\n\t            member,\n\t            that = this,\n\t            subclass = proto && proto.init ? proto.init : function () {\n\t                that.apply(this, arguments);\n\t            },\n\t            fn;\n\n\t        base.prototype = that.prototype;\n\t        fn = subclass.fn = subclass.prototype = new base();\n\n\t        for (member in proto) {\n\t            if (proto[member] != null && proto[member].constructor === Object) {\n\t                // Merge object members\n\t                fn[member] = extend(true, {}, base.prototype[member], proto[member]);\n\t            } else {\n\t                fn[member] = proto[member];\n\t            }\n\t        }\n\n\t        fn.constructor = subclass;\n\t        subclass.extend = that.extend;\n\n\t        return subclass;\n\t    };\n\n\t    Class.prototype._initOptions = function(options) {\n\t        this.options = deepExtend({}, this.options, options);\n\t    };\n\n\t    var isFunction = kendo.isFunction = function(fn) {\n\t        return typeof fn === \"function\";\n\t    };\n\n\t    var preventDefault = function() {\n\t        this._defaultPrevented = true;\n\t    };\n\n\t    var isDefaultPrevented = function() {\n\t        return this._defaultPrevented === true;\n\t    };\n\n\t    var Observable = Class.extend({\n\t        init: function() {\n\t            this._events = {};\n\t        },\n\n\t        bind: function(eventName, handlers, one) {\n\t            var that = this,\n\t                idx,\n\t                eventNames = typeof eventName === STRING ? [eventName] : eventName,\n\t                length,\n\t                original,\n\t                handler,\n\t                handlersIsFunction = typeof handlers === FUNCTION,\n\t                events;\n\n\t            if (handlers === undefined) {\n\t                for (idx in eventName) {\n\t                    that.bind(idx, eventName[idx]);\n\t                }\n\t                return that;\n\t            }\n\n\t            for (idx = 0, length = eventNames.length; idx < length; idx++) {\n\t                eventName = eventNames[idx];\n\n\t                handler = handlersIsFunction ? handlers : handlers[eventName];\n\n\t                if (handler) {\n\t                    if (one) {\n\t                        original = handler;\n\t                        handler = function() {\n\t                            that.unbind(eventName, handler);\n\t                            original.apply(that, arguments);\n\t                        };\n\t                        handler.original = original;\n\t                    }\n\t                    events = that._events[eventName] = that._events[eventName] || [];\n\t                    events.push(handler);\n\t                }\n\t            }\n\n\t            return that;\n\t        },\n\n\t        one: function(eventNames, handlers) {\n\t            return this.bind(eventNames, handlers, true);\n\t        },\n\n\t        first: function(eventName, handlers) {\n\t            var that = this,\n\t                idx,\n\t                eventNames = typeof eventName === STRING ? [eventName] : eventName,\n\t                length,\n\t                handler,\n\t                handlersIsFunction = typeof handlers === FUNCTION,\n\t                events;\n\n\t            for (idx = 0, length = eventNames.length; idx < length; idx++) {\n\t                eventName = eventNames[idx];\n\n\t                handler = handlersIsFunction ? handlers : handlers[eventName];\n\n\t                if (handler) {\n\t                    events = that._events[eventName] = that._events[eventName] || [];\n\t                    events.unshift(handler);\n\t                }\n\t            }\n\n\t            return that;\n\t        },\n\n\t        trigger: function(eventName, e) {\n\t            var that = this,\n\t                events = that._events[eventName],\n\t                idx,\n\t                length;\n\n\t            if (events) {\n\t                e = e || {};\n\n\t                e.sender = that;\n\n\t                e._defaultPrevented = false;\n\n\t                e.preventDefault = preventDefault;\n\n\t                e.isDefaultPrevented = isDefaultPrevented;\n\n\t                events = events.slice();\n\n\t                for (idx = 0, length = events.length; idx < length; idx++) {\n\t                    events[idx].call(that, e);\n\t                }\n\n\t                return e._defaultPrevented === true;\n\t            }\n\n\t            return false;\n\t        },\n\n\t        unbind: function(eventName, handler) {\n\t            var that = this,\n\t                events = that._events[eventName],\n\t                idx;\n\n\t            if (eventName === undefined) {\n\t                that._events = {};\n\t            } else if (events) {\n\t                if (handler) {\n\t                    for (idx = events.length - 1; idx >= 0; idx--) {\n\t                        if (events[idx] === handler || events[idx].original === handler) {\n\t                            events.splice(idx, 1);\n\t                        }\n\t                    }\n\t                } else {\n\t                    that._events[eventName] = [];\n\t                }\n\t            }\n\n\t            return that;\n\t        }\n\t    });\n\n\n\t     function compilePart(part, stringPart) {\n\t         if (stringPart) {\n\t             return \"'\" +\n\t                 part.split(\"'\").join(\"\\\\'\")\n\t                     .split('\\\\\"').join('\\\\\\\\\\\\\"')\n\t                     .replace(/\\n/g, \"\\\\n\")\n\t                     .replace(/\\r/g, \"\\\\r\")\n\t                     .replace(/\\t/g, \"\\\\t\") + \"'\";\n\t         } else {\n\t             var first = part.charAt(0),\n\t                 rest = part.substring(1);\n\n\t             if (first === \"=\") {\n\t                 return \"+(\" + rest + \")+\";\n\t             } else if (first === \":\") {\n\t                 return \"+$kendoHtmlEncode(\" + rest + \")+\";\n\t             } else {\n\t                 return \";\" + part + \";$kendoOutput+=\";\n\t             }\n\t         }\n\t     }\n\n\t    var argumentNameRegExp = /^\\w+/,\n\t        encodeRegExp = /\\$\\{([^}]*)\\}/g,\n\t        escapedCurlyRegExp = /\\\\\\}/g,\n\t        curlyRegExp = /__CURLY__/g,\n\t        escapedSharpRegExp = /\\\\#/g,\n\t        sharpRegExp = /__SHARP__/g,\n\t        zeros = [\"\", \"0\", \"00\", \"000\", \"0000\"];\n\n\t    Template = {\n\t        paramName: \"data\", // name of the parameter of the generated template\n\t        useWithBlock: true, // whether to wrap the template in a with() block\n\t        render: function(template, data) {\n\t            var idx,\n\t                length,\n\t                html = \"\";\n\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                html += template(data[idx]);\n\t            }\n\n\t            return html;\n\t        },\n\t        compile: function(template, options) {\n\t            var settings = extend({}, this, options),\n\t                paramName = settings.paramName,\n\t                argumentName = paramName.match(argumentNameRegExp)[0],\n\t                useWithBlock = settings.useWithBlock,\n\t                functionBody = \"var $kendoOutput, $kendoHtmlEncode = kendo.htmlEncode;\",\n\t                fn,\n\t                parts,\n\t                idx;\n\n\t            if (isFunction(template)) {\n\t                return template;\n\t            }\n\n\t            functionBody += useWithBlock ? \"with(\" + paramName + \"){\" : \"\";\n\n\t            functionBody += \"$kendoOutput=\";\n\n\t            parts = template\n\t                .replace(escapedCurlyRegExp, \"__CURLY__\")\n\t                .replace(encodeRegExp, \"#=$kendoHtmlEncode($1)#\")\n\t                .replace(curlyRegExp, \"}\")\n\t                .replace(escapedSharpRegExp, \"__SHARP__\")\n\t                .split(\"#\");\n\n\t            for (idx = 0; idx < parts.length; idx ++) {\n\t                functionBody += compilePart(parts[idx], idx % 2 === 0);\n\t            }\n\n\t            functionBody += useWithBlock ? \";}\" : \";\";\n\n\t            functionBody += \"return $kendoOutput;\";\n\n\t            functionBody = functionBody.replace(sharpRegExp, \"#\");\n\n\t            try {\n\t                fn = new Function(argumentName, functionBody);\n\t                fn._slotCount = Math.floor(parts.length / 2);\n\t                return fn;\n\t            } catch(e) {\n\t                throw new Error(kendo.format(\"Invalid template:'{0}' Generated code:'{1}'\", template, functionBody));\n\t            }\n\t        }\n\t    };\n\n\tfunction pad(number, digits, end) {\n\t    number = number + \"\";\n\t    digits = digits || 2;\n\t    end = digits - number.length;\n\n\t    if (end) {\n\t        return zeros[digits].substring(0, end) + number;\n\t    }\n\n\t    return number;\n\t}\n\n\t    //JSON stringify\n\t(function() {\n\t    var escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n\t        gap,\n\t        indent,\n\t        meta = {\n\t            \"\\b\": \"\\\\b\",\n\t            \"\\t\": \"\\\\t\",\n\t            \"\\n\": \"\\\\n\",\n\t            \"\\f\": \"\\\\f\",\n\t            \"\\r\": \"\\\\r\",\n\t            \"\\\"\" : '\\\\\"',\n\t            \"\\\\\": \"\\\\\\\\\"\n\t        },\n\t        rep,\n\t        toString = {}.toString;\n\n\n\t    if (typeof Date.prototype.toJSON !== FUNCTION) {\n\n\t        Date.prototype.toJSON = function () {\n\t            var that = this;\n\n\t            return isFinite(that.valueOf()) ?\n\t                pad(that.getUTCFullYear(), 4) + \"-\" +\n\t                pad(that.getUTCMonth() + 1)   + \"-\" +\n\t                pad(that.getUTCDate())        + \"T\" +\n\t                pad(that.getUTCHours())       + \":\" +\n\t                pad(that.getUTCMinutes())     + \":\" +\n\t                pad(that.getUTCSeconds())     + \"Z\" : null;\n\t        };\n\n\t        String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function () {\n\t            return this.valueOf();\n\t        };\n\t    }\n\n\t    function quote(string) {\n\t        escapable.lastIndex = 0;\n\t        return escapable.test(string) ? \"\\\"\" + string.replace(escapable, function (a) {\n\t            var c = meta[a];\n\t            return typeof c === STRING ? c :\n\t                \"\\\\u\" + (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\n\t        }) + \"\\\"\" : \"\\\"\" + string + \"\\\"\";\n\t    }\n\n\t    function str(key, holder) {\n\t        var i,\n\t            k,\n\t            v,\n\t            length,\n\t            mind = gap,\n\t            partial,\n\t            value = holder[key],\n\t            type;\n\n\t        if (value && typeof value === OBJECT && typeof value.toJSON === FUNCTION) {\n\t            value = value.toJSON(key);\n\t        }\n\n\t        if (typeof rep === FUNCTION) {\n\t            value = rep.call(holder, key, value);\n\t        }\n\n\t        type = typeof value;\n\t        if (type === STRING) {\n\t            return quote(value);\n\t        } else if (type === NUMBER) {\n\t            return isFinite(value) ? String(value) : NULL;\n\t        } else if (type === BOOLEAN || type === NULL) {\n\t            return String(value);\n\t        } else if (type === OBJECT) {\n\t            if (!value) {\n\t                return NULL;\n\t            }\n\t            gap += indent;\n\t            partial = [];\n\t            if (toString.apply(value) === \"[object Array]\") {\n\t                length = value.length;\n\t                for (i = 0; i < length; i++) {\n\t                    partial[i] = str(i, value) || NULL;\n\t                }\n\t                v = partial.length === 0 ? \"[]\" : gap ?\n\t                    \"[\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"]\" :\n\t                    \"[\" + partial.join(\",\") + \"]\";\n\t                gap = mind;\n\t                return v;\n\t            }\n\t            if (rep && typeof rep === OBJECT) {\n\t                length = rep.length;\n\t                for (i = 0; i < length; i++) {\n\t                    if (typeof rep[i] === STRING) {\n\t                        k = rep[i];\n\t                        v = str(k, value);\n\t                        if (v) {\n\t                            partial.push(quote(k) + (gap ? \": \" : \":\") + v);\n\t                        }\n\t                    }\n\t                }\n\t            } else {\n\t                for (k in value) {\n\t                    if (Object.hasOwnProperty.call(value, k)) {\n\t                        v = str(k, value);\n\t                        if (v) {\n\t                            partial.push(quote(k) + (gap ? \": \" : \":\") + v);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\n\t            v = partial.length === 0 ? \"{}\" : gap ?\n\t                \"{\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"}\" :\n\t                \"{\" + partial.join(\",\") + \"}\";\n\t            gap = mind;\n\t            return v;\n\t        }\n\t    }\n\n\t    if (typeof JSON.stringify !== FUNCTION) {\n\t        JSON.stringify = function (value, replacer, space) {\n\t            var i;\n\t            gap = \"\";\n\t            indent = \"\";\n\n\t            if (typeof space === NUMBER) {\n\t                for (i = 0; i < space; i += 1) {\n\t                    indent += \" \";\n\t                }\n\n\t            } else if (typeof space === STRING) {\n\t                indent = space;\n\t            }\n\n\t            rep = replacer;\n\t            if (replacer && typeof replacer !== FUNCTION && (typeof replacer !== OBJECT || typeof replacer.length !== NUMBER)) {\n\t                throw new Error(\"JSON.stringify\");\n\t            }\n\n\t            return str(\"\", {\"\": value});\n\t        };\n\t    }\n\t})();\n\n\t// Date and Number formatting\n\t(function() {\n\t    var dateFormatRegExp = /dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|HH|H|hh|h|mm|m|fff|ff|f|tt|ss|s|zzz|zz|z|\"[^\"]*\"|'[^']*'/g,\n\t        standardFormatRegExp =  /^(n|c|p|e)(\\d*)$/i,\n\t        literalRegExp = /(\\\\.)|(['][^']*[']?)|([\"][^\"]*[\"]?)/g,\n\t        commaRegExp = /\\,/g,\n\t        EMPTY = \"\",\n\t        POINT = \".\",\n\t        COMMA = \",\",\n\t        SHARP = \"#\",\n\t        ZERO = \"0\",\n\t        PLACEHOLDER = \"??\",\n\t        EN = \"en-US\",\n\t        objectToString = {}.toString;\n\n\t    //cultures\n\t    kendo.cultures[\"en-US\"] = {\n\t        name: EN,\n\t        numberFormat: {\n\t            pattern: [\"-n\"],\n\t            decimals: 2,\n\t            \",\": \",\",\n\t            \".\": \".\",\n\t            groupSize: [3],\n\t            percent: {\n\t                pattern: [\"-n %\", \"n %\"],\n\t                decimals: 2,\n\t                \",\": \",\",\n\t                \".\": \".\",\n\t                groupSize: [3],\n\t                symbol: \"%\"\n\t            },\n\t            currency: {\n\t                name: \"US Dollar\",\n\t                abbr: \"USD\",\n\t                pattern: [\"($n)\", \"$n\"],\n\t                decimals: 2,\n\t                \",\": \",\",\n\t                \".\": \".\",\n\t                groupSize: [3],\n\t                symbol: \"$\"\n\t            }\n\t        },\n\t        calendars: {\n\t            standard: {\n\t                days: {\n\t                    names: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n\t                    namesAbbr: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n\t                    namesShort: [ \"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\" ]\n\t                },\n\t                months: {\n\t                    names: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n\t                    namesAbbr: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n\t                },\n\t                AM: [ \"AM\", \"am\", \"AM\" ],\n\t                PM: [ \"PM\", \"pm\", \"PM\" ],\n\t                patterns: {\n\t                    d: \"M/d/yyyy\",\n\t                    D: \"dddd, MMMM dd, yyyy\",\n\t                    F: \"dddd, MMMM dd, yyyy h:mm:ss tt\",\n\t                    g: \"M/d/yyyy h:mm tt\",\n\t                    G: \"M/d/yyyy h:mm:ss tt\",\n\t                    m: \"MMMM dd\",\n\t                    M: \"MMMM dd\",\n\t                    s: \"yyyy'-'MM'-'ddTHH':'mm':'ss\",\n\t                    t: \"h:mm tt\",\n\t                    T: \"h:mm:ss tt\",\n\t                    u: \"yyyy'-'MM'-'dd HH':'mm':'ss'Z'\",\n\t                    y: \"MMMM, yyyy\",\n\t                    Y: \"MMMM, yyyy\"\n\t                },\n\t                \"/\": \"/\",\n\t                \":\": \":\",\n\t                firstDay: 0,\n\t                twoDigitYearMax: 2029\n\t            }\n\t        }\n\t    };\n\n\n\t     function findCulture(culture) {\n\t        if (culture) {\n\t            if (culture.numberFormat) {\n\t                return culture;\n\t            }\n\n\t            if (typeof culture === STRING) {\n\t                var cultures = kendo.cultures;\n\t                return cultures[culture] || cultures[culture.split(\"-\")[0]] || null;\n\t            }\n\n\t            return null;\n\t        }\n\n\t        return null;\n\t    }\n\n\t    function getCulture(culture) {\n\t        if (culture) {\n\t            culture = findCulture(culture);\n\t        }\n\n\t        return culture || kendo.cultures.current;\n\t    }\n\n\t    kendo.culture = function(cultureName) {\n\t        var cultures = kendo.cultures, culture;\n\n\t        if (cultureName !== undefined) {\n\t            culture = findCulture(cultureName) || cultures[EN];\n\t            culture.calendar = culture.calendars.standard;\n\t            cultures.current = culture;\n\t        } else {\n\t            return cultures.current;\n\t        }\n\t    };\n\n\t    kendo.findCulture = findCulture;\n\t    kendo.getCulture = getCulture;\n\n\t    //set current culture to en-US.\n\t    kendo.culture(EN);\n\n\t    function formatDate(date, format, culture) {\n\t        culture = getCulture(culture);\n\n\t        var calendar = culture.calendars.standard,\n\t            days = calendar.days,\n\t            months = calendar.months;\n\n\t        format = calendar.patterns[format] || format;\n\n\t        return format.replace(dateFormatRegExp, function (match) {\n\t            var minutes;\n\t            var result;\n\t            var sign;\n\n\t            if (match === \"d\") {\n\t                result = date.getDate();\n\t            } else if (match === \"dd\") {\n\t                result = pad(date.getDate());\n\t            } else if (match === \"ddd\") {\n\t                result = days.namesAbbr[date.getDay()];\n\t            } else if (match === \"dddd\") {\n\t                result = days.names[date.getDay()];\n\t            } else if (match === \"M\") {\n\t                result = date.getMonth() + 1;\n\t            } else if (match === \"MM\") {\n\t                result = pad(date.getMonth() + 1);\n\t            } else if (match === \"MMM\") {\n\t                result = months.namesAbbr[date.getMonth()];\n\t            } else if (match === \"MMMM\") {\n\t                result = months.names[date.getMonth()];\n\t            } else if (match === \"yy\") {\n\t                result = pad(date.getFullYear() % 100);\n\t            } else if (match === \"yyyy\") {\n\t                result = pad(date.getFullYear(), 4);\n\t            } else if (match === \"h\" ) {\n\t                result = date.getHours() % 12 || 12;\n\t            } else if (match === \"hh\") {\n\t                result = pad(date.getHours() % 12 || 12);\n\t            } else if (match === \"H\") {\n\t                result = date.getHours();\n\t            } else if (match === \"HH\") {\n\t                result = pad(date.getHours());\n\t            } else if (match === \"m\") {\n\t                result = date.getMinutes();\n\t            } else if (match === \"mm\") {\n\t                result = pad(date.getMinutes());\n\t            } else if (match === \"s\") {\n\t                result = date.getSeconds();\n\t            } else if (match === \"ss\") {\n\t                result = pad(date.getSeconds());\n\t            } else if (match === \"f\") {\n\t                result = math.floor(date.getMilliseconds() / 100);\n\t            } else if (match === \"ff\") {\n\t                result = date.getMilliseconds();\n\t                if (result > 99) {\n\t                    result = math.floor(result / 10);\n\t                }\n\t                result = pad(result);\n\t            } else if (match === \"fff\") {\n\t                result = pad(date.getMilliseconds(), 3);\n\t            } else if (match === \"tt\") {\n\t                result = date.getHours() < 12 ? calendar.AM[0] : calendar.PM[0];\n\t            } else if (match === \"zzz\") {\n\t                minutes = date.getTimezoneOffset();\n\t                sign = minutes < 0;\n\n\t                result = math.abs(minutes / 60).toString().split(\".\")[0];\n\t                minutes = math.abs(minutes) - (result * 60);\n\n\t                result = (sign ? \"+\" : \"-\") + pad(result);\n\t                result += \":\" + pad(minutes);\n\t            } else if (match === \"zz\" || match === \"z\") {\n\t                result = date.getTimezoneOffset() / 60;\n\t                sign = result < 0;\n\n\t                result = math.abs(result).toString().split(\".\")[0];\n\t                result = (sign ? \"+\" : \"-\") + (match === \"zz\" ? pad(result) : result);\n\t            }\n\n\t            return result !== undefined ? result : match.slice(1, match.length - 1);\n\t        });\n\t    }\n\n\t    //number formatting\n\t    function formatNumber(number, format, culture) {\n\t        culture = getCulture(culture);\n\n\t        var numberFormat = culture.numberFormat,\n\t            decimal = numberFormat[POINT],\n\t            precision = numberFormat.decimals,\n\t            pattern = numberFormat.pattern[0],\n\t            literals = [],\n\t            symbol,\n\t            isCurrency, isPercent,\n\t            customPrecision,\n\t            formatAndPrecision,\n\t            negative = number < 0,\n\t            integer,\n\t            fraction,\n\t            integerLength,\n\t            fractionLength,\n\t            replacement = EMPTY,\n\t            value = EMPTY,\n\t            idx,\n\t            length,\n\t            ch,\n\t            hasGroup,\n\t            hasNegativeFormat,\n\t            decimalIndex,\n\t            sharpIndex,\n\t            zeroIndex,\n\t            hasZero, hasSharp,\n\t            percentIndex,\n\t            currencyIndex,\n\t            startZeroIndex,\n\t            start = -1,\n\t            end;\n\n\t        //return empty string if no number\n\t        if (number === undefined) {\n\t            return EMPTY;\n\t        }\n\n\t        if (!isFinite(number)) {\n\t            return number;\n\t        }\n\n\t        //if no format then return number.toString() or number.toLocaleString() if culture.name is not defined\n\t        if (!format) {\n\t            return culture.name.length ? number.toLocaleString() : number.toString();\n\t        }\n\n\t        formatAndPrecision = standardFormatRegExp.exec(format);\n\n\t        // standard formatting\n\t        if (formatAndPrecision) {\n\t            format = formatAndPrecision[1].toLowerCase();\n\n\t            isCurrency = format === \"c\";\n\t            isPercent = format === \"p\";\n\n\t            if (isCurrency || isPercent) {\n\t                //get specific number format information if format is currency or percent\n\t                numberFormat = isCurrency ? numberFormat.currency : numberFormat.percent;\n\t                decimal = numberFormat[POINT];\n\t                precision = numberFormat.decimals;\n\t                symbol = numberFormat.symbol;\n\t                pattern = numberFormat.pattern[negative ? 0 : 1];\n\t            }\n\n\t            customPrecision = formatAndPrecision[2];\n\n\t            if (customPrecision) {\n\t                precision = +customPrecision;\n\t            }\n\n\t            //return number in exponential format\n\t            if (format === \"e\") {\n\t                var exp = customPrecision ? number.toExponential(precision) : number.toExponential(); // toExponential() and toExponential(undefined) differ in FF #653438.\n\n\t                return exp.replace(POINT, numberFormat[POINT]);\n\t            }\n\n\t            // multiply if format is percent\n\t            if (isPercent) {\n\t                number *= 100;\n\t            }\n\n\t            number = round(number, precision);\n\t            negative = number < 0;\n\t            number = number.split(POINT);\n\n\t            integer = number[0];\n\t            fraction = number[1];\n\n\t            //exclude \"-\" if number is negative.\n\t            if (negative) {\n\t                integer = integer.substring(1);\n\t            }\n\n\t            value = groupInteger(integer, 0, integer.length, numberFormat);\n\n\t            if (fraction) {\n\t                value += decimal + fraction;\n\t            }\n\n\t            if (format === \"n\" && !negative) {\n\t                return value;\n\t            }\n\n\t            number = EMPTY;\n\n\t            for (idx = 0, length = pattern.length; idx < length; idx++) {\n\t                ch = pattern.charAt(idx);\n\n\t                if (ch === \"n\") {\n\t                    number += value;\n\t                } else if (ch === \"$\" || ch === \"%\") {\n\t                    number += symbol;\n\t                } else {\n\t                    number += ch;\n\t                }\n\t            }\n\n\t            return number;\n\t        }\n\n\t        //custom formatting\n\t        //\n\t        //separate format by sections.\n\n\t        if (format.indexOf(\"'\") > -1 || format.indexOf(\"\\\"\") > -1 || format.indexOf(\"\\\\\") > -1) {\n\t            format = format.replace(literalRegExp, function (match) {\n\t                var quoteChar = match.charAt(0).replace(\"\\\\\", \"\"),\n\t                    literal = match.slice(1).replace(quoteChar, \"\");\n\n\t                literals.push(literal);\n\n\t                return PLACEHOLDER;\n\t            });\n\t        }\n\n\t        format = format.split(\";\");\n\t        if (negative && format[1]) {\n\t            //get negative format\n\t            format = format[1];\n\t            hasNegativeFormat = true;\n\t        } else if (number === 0 && format[2]) {\n\t            //format for zeros\n\t            format = format[2];\n\t            if (format.indexOf(SHARP) == -1 && format.indexOf(ZERO) == -1) {\n\t                //return format if it is string constant.\n\t                return format;\n\t            }\n\t        } else {\n\t            format = format[0];\n\t        }\n\n\t        percentIndex = format.indexOf(\"%\");\n\t        currencyIndex = format.indexOf(\"$\");\n\n\t        isPercent = percentIndex != -1;\n\t        isCurrency = currencyIndex != -1;\n\n\t        //multiply number if the format has percent\n\t        if (isPercent) {\n\t            number *= 100;\n\t        }\n\n\t        if (isCurrency && format[currencyIndex - 1] === \"\\\\\") {\n\t            format = format.split(\"\\\\\").join(\"\");\n\t            isCurrency = false;\n\t        }\n\n\t        if (isCurrency || isPercent) {\n\t            //get specific number format information if format is currency or percent\n\t            numberFormat = isCurrency ? numberFormat.currency : numberFormat.percent;\n\t            decimal = numberFormat[POINT];\n\t            precision = numberFormat.decimals;\n\t            symbol = numberFormat.symbol;\n\t        }\n\n\t        hasGroup = format.indexOf(COMMA) > -1;\n\t        if (hasGroup) {\n\t            format = format.replace(commaRegExp, EMPTY);\n\t        }\n\n\t        decimalIndex = format.indexOf(POINT);\n\t        length = format.length;\n\n\t        if (decimalIndex != -1) {\n\t            fraction = number.toString().split(\"e\");\n\t            if (fraction[1]) {\n\t                fraction = round(number, Math.abs(fraction[1]));\n\t            } else {\n\t                fraction = fraction[0];\n\t            }\n\t            fraction = fraction.split(POINT)[1] || EMPTY;\n\t            zeroIndex = format.lastIndexOf(ZERO) - decimalIndex;\n\t            sharpIndex = format.lastIndexOf(SHARP) - decimalIndex;\n\t            hasZero = zeroIndex > -1;\n\t            hasSharp = sharpIndex > -1;\n\t            idx = fraction.length;\n\n\t            if (!hasZero && !hasSharp) {\n\t                format = format.substring(0, decimalIndex) + format.substring(decimalIndex + 1);\n\t                length = format.length;\n\t                decimalIndex = -1;\n\t                idx = 0;\n\t            }\n\n\t            if (hasZero && zeroIndex > sharpIndex) {\n\t                idx = zeroIndex;\n\t            } else if (sharpIndex > zeroIndex) {\n\t                if (hasSharp && idx > sharpIndex) {\n\t                    var rounded = round(number, sharpIndex, negative);\n\n\t                    while (rounded.charAt(rounded.length - 1) === ZERO && sharpIndex > 0 && sharpIndex > zeroIndex) {\n\t                        sharpIndex--;\n\n\t                        rounded = round(number, sharpIndex, negative);\n\t                    }\n\n\t                    idx = sharpIndex;\n\t                } else if (hasZero && idx < zeroIndex) {\n\t                    idx = zeroIndex;\n\t                }\n\t            }\n\t        }\n\n\t        number = round(number, idx, negative);\n\n\t        sharpIndex = format.indexOf(SHARP);\n\t        startZeroIndex = zeroIndex = format.indexOf(ZERO);\n\n\t        //define the index of the first digit placeholder\n\t        if (sharpIndex == -1 && zeroIndex != -1) {\n\t            start = zeroIndex;\n\t        } else if (sharpIndex != -1 && zeroIndex == -1) {\n\t            start = sharpIndex;\n\t        } else {\n\t            start = sharpIndex > zeroIndex ? zeroIndex : sharpIndex;\n\t        }\n\n\t        sharpIndex = format.lastIndexOf(SHARP);\n\t        zeroIndex = format.lastIndexOf(ZERO);\n\n\t        //define the index of the last digit placeholder\n\t        if (sharpIndex == -1 && zeroIndex != -1) {\n\t            end = zeroIndex;\n\t        } else if (sharpIndex != -1 && zeroIndex == -1) {\n\t            end = sharpIndex;\n\t        } else {\n\t            end = sharpIndex > zeroIndex ? sharpIndex : zeroIndex;\n\t        }\n\n\t        if (start == length) {\n\t            end = start;\n\t        }\n\n\t        if (start != -1) {\n\t            value = number.toString().split(POINT);\n\t            integer = value[0];\n\t            fraction = value[1] || EMPTY;\n\n\t            integerLength = integer.length;\n\t            fractionLength = fraction.length;\n\n\t            if (negative && (number * -1) >= 0) {\n\t                negative = false;\n\t            }\n\n\t            number = format.substring(0, start);\n\n\t            if (negative && !hasNegativeFormat) {\n\t                number += \"-\";\n\t            }\n\n\t            for (idx = start; idx < length; idx++) {\n\t                ch = format.charAt(idx);\n\n\t                if (decimalIndex == -1) {\n\t                    if (end - idx < integerLength) {\n\t                        number += integer;\n\t                        break;\n\t                    }\n\t                } else {\n\t                    if (zeroIndex != -1 && zeroIndex < idx) {\n\t                        replacement = EMPTY;\n\t                    }\n\n\t                    if ((decimalIndex - idx) <= integerLength && decimalIndex - idx > -1) {\n\t                        number += integer;\n\t                        idx = decimalIndex;\n\t                    }\n\n\t                    if (decimalIndex === idx) {\n\t                        number += (fraction ? decimal : EMPTY) + fraction;\n\t                        idx += end - decimalIndex + 1;\n\t                        continue;\n\t                    }\n\t                }\n\n\t                if (ch === ZERO) {\n\t                    number += ch;\n\t                    replacement = ch;\n\t                } else if (ch === SHARP) {\n\t                    number += replacement;\n\t                }\n\t            }\n\n\t            if (hasGroup) {\n\t                number = groupInteger(number, start + (negative && !hasNegativeFormat ? 1 : 0), Math.max(end, (integerLength + start)), numberFormat);\n\t            }\n\n\t            if (end >= start) {\n\t                number += format.substring(end + 1);\n\t            }\n\n\t            //replace symbol placeholders\n\t            if (isCurrency || isPercent) {\n\t                value = EMPTY;\n\t                for (idx = 0, length = number.length; idx < length; idx++) {\n\t                    ch = number.charAt(idx);\n\t                    value += (ch === \"$\" || ch === \"%\") ? symbol : ch;\n\t                }\n\t                number = value;\n\t            }\n\n\t            length = literals.length;\n\n\t            if (length) {\n\t                for (idx = 0; idx < length; idx++) {\n\t                    number = number.replace(PLACEHOLDER, literals[idx]);\n\t                }\n\t            }\n\t        }\n\n\t        return number;\n\t    }\n\n\t    var groupInteger = function(number, start, end, numberFormat) {\n\t        var decimalIndex = number.indexOf(numberFormat[POINT]);\n\t        var groupSizes = numberFormat.groupSize.slice();\n\t        var groupSize = groupSizes.shift();\n\t        var integer, integerLength;\n\t        var idx, parts, value;\n\t        var newGroupSize;\n\n\t        end = decimalIndex !== -1 ? decimalIndex : end + 1;\n\n\t        integer = number.substring(start, end);\n\t        integerLength = integer.length;\n\n\t        if (integerLength >= groupSize) {\n\t            idx = integerLength;\n\t            parts = [];\n\n\t            while (idx > -1) {\n\t                value = integer.substring(idx - groupSize, idx);\n\t                if (value) {\n\t                    parts.push(value);\n\t                }\n\t                idx -= groupSize;\n\t                newGroupSize = groupSizes.shift();\n\t                groupSize = newGroupSize !== undefined ? newGroupSize : groupSize;\n\n\t                if (groupSize === 0) {\n\t                    if (idx > 0) {\n\t                        parts.push(integer.substring(0, idx));\n\t                    }\n\t                    break;\n\t                }\n\t            }\n\n\t            integer = parts.reverse().join(numberFormat[COMMA]);\n\t            number = number.substring(0, start) + integer + number.substring(end);\n\t        }\n\n\t        return number;\n\t    };\n\n\t    var round = function(value, precision, negative) {\n\t        precision = precision || 0;\n\n\t        value = value.toString().split('e');\n\t        value = Math.round(+(value[0] + 'e' + (value[1] ? (+value[1] + precision) : precision)));\n\n\t        if (negative) {\n\t            value = -value;\n\t        }\n\n\t        value = value.toString().split('e');\n\t        value = +(value[0] + 'e' + (value[1] ? (+value[1] - precision) : -precision));\n\n\t        return value.toFixed(Math.min(precision, 20));\n\t    };\n\n\t    var toString = function(value, fmt, culture) {\n\t        if (fmt) {\n\t            if (objectToString.call(value) === \"[object Date]\") {\n\t                return formatDate(value, fmt, culture);\n\t            } else if (typeof value === NUMBER) {\n\t                return formatNumber(value, fmt, culture);\n\t            }\n\t        }\n\n\t        return value !== undefined ? value : \"\";\n\t    };\n\n\t    kendo.format = function(fmt) {\n\t        var values = arguments;\n\n\t        return fmt.replace(formatRegExp, function(match, index, placeholderFormat) {\n\t            var value = values[parseInt(index, 10) + 1];\n\n\t            return toString(value, placeholderFormat ? placeholderFormat.substring(1) : \"\");\n\t        });\n\t    };\n\n\t    kendo._extractFormat = function (format) {\n\t        if (format.slice(0,3) === \"{0:\") {\n\t            format = format.slice(3, format.length - 1);\n\t        }\n\n\t        return format;\n\t    };\n\n\t    kendo._activeElement = function() {\n\t        try {\n\t            return document.activeElement;\n\t        } catch(e) {\n\t            return document.documentElement.activeElement;\n\t        }\n\t    };\n\n\t    kendo._round = round;\n\t    kendo._outerWidth = function (element, includeMargin) { return $(element).outerWidth(includeMargin || false) || 0; };\n\t    kendo._outerHeight = function (element, includeMargin) { return $(element).outerHeight(includeMargin || false) || 0; };\n\t    kendo.toString = toString;\n\t})();\n\n\n\t(function() {\n\t    var nonBreakingSpaceRegExp = /\\u00A0/g,\n\t        exponentRegExp = /[eE][\\-+]?[0-9]+/,\n\t        shortTimeZoneRegExp = /[+|\\-]\\d{1,2}/,\n\t        longTimeZoneRegExp = /[+|\\-]\\d{1,2}:?\\d{2}/,\n\t        dateRegExp = /^\\/Date\\((.*?)\\)\\/$/,\n\t        offsetRegExp = /[+-]\\d*/,\n\t        FORMATS_SEQUENCE = [ [], [ \"G\", \"g\", \"F\" ], [ \"D\", \"d\", \"y\", \"m\", \"T\", \"t\" ] ],\n\t        STANDARD_FORMATS = [\n\t            [\n\t            \"yyyy-MM-ddTHH:mm:ss.fffffffzzz\",\n\t            \"yyyy-MM-ddTHH:mm:ss.fffffff\",\n\t            \"yyyy-MM-ddTHH:mm:ss.fffzzz\",\n\t            \"yyyy-MM-ddTHH:mm:ss.fff\",\n\t            \"ddd MMM dd yyyy HH:mm:ss\",\n\t            \"yyyy-MM-ddTHH:mm:sszzz\",\n\t            \"yyyy-MM-ddTHH:mmzzz\",\n\t            \"yyyy-MM-ddTHH:mmzz\",\n\t            \"yyyy-MM-ddTHH:mm:ss\",\n\t            \"yyyy-MM-dd HH:mm:ss\",\n\t            \"yyyy/MM/dd HH:mm:ss\"\n\t            ], [\n\t            \"yyyy-MM-ddTHH:mm\",\n\t            \"yyyy-MM-dd HH:mm\",\n\t            \"yyyy/MM/dd HH:mm\"\n\t            ], [\n\t            \"yyyy/MM/dd\",\n\t            \"yyyy-MM-dd\",\n\t            \"HH:mm:ss\",\n\t            \"HH:mm\"\n\t            ]\n\t        ],\n\t        numberRegExp = {\n\t            2: /^\\d{1,2}/,\n\t            3: /^\\d{1,3}/,\n\t            4: /^\\d{4}/\n\t        },\n\t        objectToString = {}.toString;\n\n\t    function outOfRange(value, start, end) {\n\t        return !(value >= start && value <= end);\n\t    }\n\n\t    function designatorPredicate(designator) {\n\t        return designator.charAt(0);\n\t    }\n\n\t    function mapDesignators(designators) {\n\t        return $.map(designators, designatorPredicate);\n\t    }\n\n\t    //if date's day is different than the typed one - adjust\n\t    function adjustDST(date, hours) {\n\t        if (!hours && date.getHours() === 23) {\n\t            date.setHours(date.getHours() + 2);\n\t        }\n\t    }\n\n\t    function lowerArray(data) {\n\t        var idx = 0,\n\t            length = data.length,\n\t            array = [];\n\n\t        for (; idx < length; idx++) {\n\t            array[idx] = (data[idx] + \"\").toLowerCase();\n\t        }\n\n\t        return array;\n\t    }\n\n\t    function lowerLocalInfo(localInfo) {\n\t        var newLocalInfo = {}, property;\n\n\t        for (property in localInfo) {\n\t            newLocalInfo[property] = lowerArray(localInfo[property]);\n\t        }\n\n\t        return newLocalInfo;\n\t    }\n\n\t    function parseExact(value, format, culture, strict) {\n\t        if (!value) {\n\t            return null;\n\t        }\n\n\t        var lookAhead = function (match) {\n\t                var i = 0;\n\t                while (format[idx] === match) {\n\t                    i++;\n\t                    idx++;\n\t                }\n\t                if (i > 0) {\n\t                    idx -= 1;\n\t                }\n\t                return i;\n\t            },\n\t            getNumber = function(size) {\n\t                var rg = numberRegExp[size] || new RegExp('^\\\\d{1,' + size + '}'),\n\t                    match = value.substr(valueIdx, size).match(rg);\n\n\t                if (match) {\n\t                    match = match[0];\n\t                    valueIdx += match.length;\n\t                    return parseInt(match, 10);\n\t                }\n\t                return null;\n\t            },\n\t            getIndexByName = function (names, lower) {\n\t                var i = 0,\n\t                    length = names.length,\n\t                    name, nameLength,\n\t                    matchLength = 0,\n\t                    matchIdx = 0,\n\t                    subValue;\n\n\t                for (; i < length; i++) {\n\t                    name = names[i];\n\t                    nameLength = name.length;\n\t                    subValue = value.substr(valueIdx, nameLength);\n\n\t                    if (lower) {\n\t                        subValue = subValue.toLowerCase();\n\t                    }\n\n\t                    if (subValue == name && nameLength > matchLength) {\n\t                        matchLength = nameLength;\n\t                        matchIdx = i;\n\t                    }\n\t                }\n\n\t                if (matchLength) {\n\t                    valueIdx += matchLength;\n\t                    return matchIdx + 1;\n\t                }\n\n\t                return null;\n\t            },\n\t            checkLiteral = function() {\n\t                var result = false;\n\t                if (value.charAt(valueIdx) === format[idx]) {\n\t                    valueIdx++;\n\t                    result = true;\n\t                }\n\t                return result;\n\t            },\n\t            calendar = culture.calendars.standard,\n\t            year = null,\n\t            month = null,\n\t            day = null,\n\t            hours = null,\n\t            minutes = null,\n\t            seconds = null,\n\t            milliseconds = null,\n\t            idx = 0,\n\t            valueIdx = 0,\n\t            literal = false,\n\t            date = new Date(),\n\t            twoDigitYearMax = calendar.twoDigitYearMax || 2029,\n\t            defaultYear = date.getFullYear(),\n\t            ch, count, length, pattern,\n\t            pmHour, UTC, matches,\n\t            amDesignators, pmDesignators,\n\t            hoursOffset, minutesOffset,\n\t            hasTime, match;\n\n\t        if (!format) {\n\t            format = \"d\"; //shord date format\n\t        }\n\n\t        //if format is part of the patterns get real format\n\t        pattern = calendar.patterns[format];\n\t        if (pattern) {\n\t            format = pattern;\n\t        }\n\n\t        format = format.split(\"\");\n\t        length = format.length;\n\n\t        for (; idx < length; idx++) {\n\t            ch = format[idx];\n\n\t            if (literal) {\n\t                if (ch === \"'\") {\n\t                    literal = false;\n\t                } else {\n\t                    checkLiteral();\n\t                }\n\t            } else {\n\t                if (ch === \"d\") {\n\t                    count = lookAhead(\"d\");\n\t                    if (!calendar._lowerDays) {\n\t                        calendar._lowerDays = lowerLocalInfo(calendar.days);\n\t                    }\n\n\t                    if (day !== null && count > 2) {\n\t                        continue;\n\t                    }\n\n\t                    day = count < 3 ? getNumber(2) : getIndexByName(calendar._lowerDays[count == 3 ? \"namesAbbr\" : \"names\"], true);\n\n\t                    if (day === null || outOfRange(day, 1, 31)) {\n\t                        return null;\n\t                    }\n\t                } else if (ch === \"M\") {\n\t                    count = lookAhead(\"M\");\n\t                    if (!calendar._lowerMonths) {\n\t                        calendar._lowerMonths = lowerLocalInfo(calendar.months);\n\t                    }\n\t                    month = count < 3 ? getNumber(2) : getIndexByName(calendar._lowerMonths[count == 3 ? 'namesAbbr' : 'names'], true);\n\n\t                    if (month === null || outOfRange(month, 1, 12)) {\n\t                        return null;\n\t                    }\n\t                    month -= 1; //because month is zero based\n\t                } else if (ch === \"y\") {\n\t                    count = lookAhead(\"y\");\n\t                    year = getNumber(count);\n\n\t                    if (year === null) {\n\t                        return null;\n\t                    }\n\n\t                    if (count == 2) {\n\t                        if (typeof twoDigitYearMax === \"string\") {\n\t                            twoDigitYearMax = defaultYear + parseInt(twoDigitYearMax, 10);\n\t                        }\n\n\t                        year = (defaultYear - defaultYear % 100) + year;\n\t                        if (year > twoDigitYearMax) {\n\t                            year -= 100;\n\t                        }\n\t                    }\n\t                } else if (ch === \"h\" ) {\n\t                    lookAhead(\"h\");\n\t                    hours = getNumber(2);\n\t                    if (hours == 12) {\n\t                        hours = 0;\n\t                    }\n\t                    if (hours === null || outOfRange(hours, 0, 11)) {\n\t                        return null;\n\t                    }\n\t                } else if (ch === \"H\") {\n\t                    lookAhead(\"H\");\n\t                    hours = getNumber(2);\n\t                    if (hours === null || outOfRange(hours, 0, 23)) {\n\t                        return null;\n\t                    }\n\t                } else if (ch === \"m\") {\n\t                    lookAhead(\"m\");\n\t                    minutes = getNumber(2);\n\t                    if (minutes === null || outOfRange(minutes, 0, 59)) {\n\t                        return null;\n\t                    }\n\t                } else if (ch === \"s\") {\n\t                    lookAhead(\"s\");\n\t                    seconds = getNumber(2);\n\t                    if (seconds === null || outOfRange(seconds, 0, 59)) {\n\t                        return null;\n\t                    }\n\t                } else if (ch === \"f\") {\n\t                    count = lookAhead(\"f\");\n\n\t                    match = value.substr(valueIdx, count).match(numberRegExp[3]);\n\t                    milliseconds = getNumber(count); //move value index position\n\n\t                    if (milliseconds !== null) {\n\t                        milliseconds = parseFloat(\"0.\" + match[0], 10);\n\t                        milliseconds = kendo._round(milliseconds, 3);\n\t                        milliseconds *= 1000;\n\t                    }\n\n\t                    if (milliseconds === null || outOfRange(milliseconds, 0, 999)) {\n\t                        return null;\n\t                    }\n\n\t                } else if (ch === \"t\") {\n\t                    count = lookAhead(\"t\");\n\t                    amDesignators = calendar.AM;\n\t                    pmDesignators = calendar.PM;\n\n\t                    if (count === 1) {\n\t                        amDesignators = mapDesignators(amDesignators);\n\t                        pmDesignators = mapDesignators(pmDesignators);\n\t                    }\n\n\t                    pmHour = getIndexByName(pmDesignators);\n\t                    if (!pmHour && !getIndexByName(amDesignators)) {\n\t                        return null;\n\t                    }\n\t                }\n\t                else if (ch === \"z\") {\n\t                    UTC = true;\n\t                    count = lookAhead(\"z\");\n\n\t                    if (value.substr(valueIdx, 1) === \"Z\") {\n\t                        checkLiteral();\n\t                        continue;\n\t                    }\n\n\t                    matches = value.substr(valueIdx, 6)\n\t                                   .match(count > 2 ? longTimeZoneRegExp : shortTimeZoneRegExp);\n\n\t                    if (!matches) {\n\t                        return null;\n\t                    }\n\n\t                    matches = matches[0].split(\":\");\n\n\t                    hoursOffset = matches[0];\n\t                    minutesOffset = matches[1];\n\n\t                    if (!minutesOffset && hoursOffset.length > 3) { //(+|-)[hh][mm] format is used\n\t                        valueIdx = hoursOffset.length - 2;\n\t                        minutesOffset = hoursOffset.substring(valueIdx);\n\t                        hoursOffset = hoursOffset.substring(0, valueIdx);\n\t                    }\n\n\t                    hoursOffset = parseInt(hoursOffset, 10);\n\t                    if (outOfRange(hoursOffset, -12, 13)) {\n\t                        return null;\n\t                    }\n\n\t                    if (count > 2) {\n\t                        minutesOffset = matches[0][0] + minutesOffset;\n\t                        minutesOffset = parseInt(minutesOffset, 10);\n\t                        if (isNaN(minutesOffset) || outOfRange(minutesOffset, -59, 59)) {\n\t                            return null;\n\t                        }\n\t                    }\n\t                } else if (ch === \"'\") {\n\t                    literal = true;\n\t                    checkLiteral();\n\t                } else if (!checkLiteral()) {\n\t                    return null;\n\t                }\n\t            }\n\t        }\n\n\t        // if more characters follow, assume wrong format\n\t        // https://github.com/telerik/kendo-ui-core/issues/3476\n\t        if (strict && !/^\\s*$/.test(value.substr(valueIdx))) {\n\t            return null;\n\t        }\n\n\t        hasTime = hours !== null || minutes !== null || seconds || null;\n\n\t        if (year === null && month === null && day === null && hasTime) {\n\t            year = defaultYear;\n\t            month = date.getMonth();\n\t            day = date.getDate();\n\t        } else {\n\t            if (year === null) {\n\t                year = defaultYear;\n\t            }\n\n\t            if (day === null) {\n\t                day = 1;\n\t            }\n\t        }\n\n\t        if (pmHour && hours < 12) {\n\t            hours += 12;\n\t        }\n\n\t        if (UTC) {\n\t            if (hoursOffset) {\n\t                hours += -hoursOffset;\n\t            }\n\n\t            if (minutesOffset) {\n\t                minutes += -minutesOffset;\n\t            }\n\n\t            value = new Date(Date.UTC(year, month, day, hours, minutes, seconds, milliseconds));\n\t        } else {\n\t            value = new Date(year, month, day, hours, minutes, seconds, milliseconds);\n\t            adjustDST(value, hours);\n\t        }\n\n\t        if (year < 100) {\n\t            value.setFullYear(year);\n\t        }\n\n\t        if (value.getDate() !== day && UTC === undefined) {\n\t            return null;\n\t        }\n\n\t        return value;\n\t    }\n\n\t    function parseMicrosoftFormatOffset(offset) {\n\t        var sign = offset.substr(0, 1) === \"-\" ? -1 : 1;\n\n\t        offset = offset.substring(1);\n\t        offset = (parseInt(offset.substr(0, 2), 10) * 60) + parseInt(offset.substring(2), 10);\n\n\t        return sign * offset;\n\t    }\n\n\t    function getDefaultFormats(culture) {\n\t        var length = math.max(FORMATS_SEQUENCE.length, STANDARD_FORMATS.length);\n\t        var calendar = culture.calendar || culture.calendars.standard;\n\t        var patterns = calendar.patterns;\n\t        var cultureFormats, formatIdx, idx;\n\t        var formats = [];\n\n\t        for (idx = 0; idx < length; idx++) {\n\t            cultureFormats = FORMATS_SEQUENCE[idx];\n\t            for (formatIdx = 0; formatIdx < cultureFormats.length; formatIdx++) {\n\t                formats.push(patterns[cultureFormats[formatIdx]]);\n\t            }\n\t            formats = formats.concat(STANDARD_FORMATS[idx]);\n\t        }\n\n\t        return formats;\n\t    }\n\n\t    function internalParseDate(value, formats, culture, strict) {\n\t        if (objectToString.call(value) === \"[object Date]\") {\n\t            return value;\n\t        }\n\n\t        var idx = 0;\n\t        var date = null;\n\t        var length;\n\t        var tzoffset;\n\n\t        if (value && value.indexOf(\"/D\") === 0) {\n\t            date = dateRegExp.exec(value);\n\t            if (date) {\n\t                date = date[1];\n\t                tzoffset = offsetRegExp.exec(date.substring(1));\n\n\t                date = new Date(parseInt(date, 10));\n\n\t                if (tzoffset) {\n\t                    tzoffset = parseMicrosoftFormatOffset(tzoffset[0]);\n\t                    date = kendo.timezone.apply(date, 0);\n\t                    date = kendo.timezone.convert(date, 0, -1 * tzoffset);\n\t                }\n\n\t                return date;\n\t            }\n\t        }\n\n\t        culture = kendo.getCulture(culture);\n\n\t        if (!formats) {\n\t            formats = getDefaultFormats(culture);\n\t        }\n\n\t        formats = isArray(formats) ? formats: [formats];\n\t        length = formats.length;\n\n\t        for (; idx < length; idx++) {\n\t            date = parseExact(value, formats[idx], culture, strict);\n\t            if (date) {\n\t                return date;\n\t            }\n\t        }\n\n\t        return date;\n\t    }\n\n\t    kendo.parseDate = function(value, formats, culture) {\n\t        return internalParseDate(value, formats, culture, false);\n\t    };\n\n\t    kendo.parseExactDate = function(value, formats, culture) {\n\t        return internalParseDate(value, formats, culture, true);\n\t    };\n\n\t    kendo.parseInt = function(value, culture) {\n\t        var result = kendo.parseFloat(value, culture);\n\t        if (result) {\n\t            result = result | 0;\n\t        }\n\t        return result;\n\t    };\n\n\t    kendo.parseFloat = function(value, culture, format) {\n\t        if (!value && value !== 0) {\n\t           return null;\n\t        }\n\n\t        if (typeof value === NUMBER) {\n\t           return value;\n\t        }\n\n\t        value = value.toString();\n\t        culture = kendo.getCulture(culture);\n\n\t        var number = culture.numberFormat,\n\t            percent = number.percent,\n\t            currency = number.currency,\n\t            symbol = currency.symbol,\n\t            percentSymbol = percent.symbol,\n\t            negative = value.indexOf(\"-\"),\n\t            parts, isPercent;\n\n\t        //handle exponential number\n\t        if (exponentRegExp.test(value)) {\n\t            value = parseFloat(value.replace(number[\".\"], \".\"));\n\t            if (isNaN(value)) {\n\t                value = null;\n\t            }\n\t            return value;\n\t        }\n\n\t        if (negative > 0) {\n\t            return null;\n\t        } else {\n\t            negative = negative > -1;\n\t        }\n\n\t        if (value.indexOf(symbol) > -1 || (format && format.toLowerCase().indexOf(\"c\") > -1)) {\n\t            number = currency;\n\t            parts = number.pattern[0].replace(\"$\", symbol).split(\"n\");\n\t            if (value.indexOf(parts[0]) > -1 && value.indexOf(parts[1]) > -1) {\n\t                value = value.replace(parts[0], \"\").replace(parts[1], \"\");\n\t                negative = true;\n\t            }\n\t        } else if (value.indexOf(percentSymbol) > -1) {\n\t            isPercent = true;\n\t            number = percent;\n\t            symbol = percentSymbol;\n\t        }\n\n\t        value = value.replace(\"-\", \"\")\n\t                     .replace(symbol, \"\")\n\t                     .replace(nonBreakingSpaceRegExp, \" \")\n\t                     .split(number[\",\"].replace(nonBreakingSpaceRegExp, \" \")).join(\"\")\n\t                     .replace(number[\".\"], \".\");\n\n\t        value = parseFloat(value);\n\n\t        if (isNaN(value)) {\n\t            value = null;\n\t        } else if (negative) {\n\t            value *= -1;\n\t        }\n\n\t        if (value && isPercent) {\n\t            value /= 100;\n\t        }\n\n\t        return value;\n\t    };\n\t})();\n\n\t    function getShadows(element) {\n\t        var shadow = element.css(kendo.support.transitions.css + \"box-shadow\") || element.css(\"box-shadow\"),\n\t            radius = shadow ? shadow.match(boxShadowRegExp) || [ 0, 0, 0, 0, 0 ] : [ 0, 0, 0, 0, 0 ],\n\t            blur = math.max((+radius[3]), +(radius[4] || 0));\n\n\t        return {\n\t            left: (-radius[1]) + blur,\n\t            right: (+radius[1]) + blur,\n\t            bottom: (+radius[2]) + blur\n\t        };\n\t    }\n\n\t    function wrap(element, autosize) {\n\t        var browser = support.browser,\n\t            percentage,\n\t            outerWidth = kendo._outerWidth,\n\t            outerHeight = kendo._outerHeight;\n\n\t        if (!element.parent().hasClass(\"k-animation-container\")) {\n\t            var width = element[0].style.width,\n\t                height = element[0].style.height,\n\t                percentWidth = percentRegExp.test(width),\n\t                percentHeight = percentRegExp.test(height);\n\n\t            percentage = percentWidth || percentHeight;\n\n\t            if (!percentWidth && (!autosize || (autosize && width) || element.hasClass(\"k-tooltip\"))) { width = autosize ? outerWidth(element) + 1 : outerWidth(element); }\n\t            if (!percentHeight && (!autosize || (autosize && height))) { height = outerHeight(element); }\n\n\t            element.wrap(\n\t                         $(\"<div/>\")\n\t                         .addClass(\"k-animation-container\")\n\t                         .css({\n\t                             width: width,\n\t                             height: height\n\t                         }));\n\n\t            if (percentage) {\n\t                element.css({\n\t                    width: \"100%\",\n\t                    height: \"100%\",\n\t                    boxSizing: \"border-box\",\n\t                    mozBoxSizing: \"border-box\",\n\t                    webkitBoxSizing: \"border-box\"\n\t                });\n\t            }\n\t        } else {\n\t            var wrapper = element.parent(\".k-animation-container\"),\n\t                wrapperStyle = wrapper[0].style;\n\n\t            if (wrapper.is(\":hidden\")) {\n\t                wrapper.css({\n\t                    display: \"\",\n\t                    position: \"\"\n\t                });\n\t            }\n\n\t            percentage = percentRegExp.test(wrapperStyle.width) || percentRegExp.test(wrapperStyle.height);\n\n\t            if (!percentage) {\n\t                wrapper.css({\n\t                    width: autosize ? outerWidth(element) + 1 : outerWidth(element),\n\t                    height: outerHeight(element),\n\t                    boxSizing: \"content-box\",\n\t                    mozBoxSizing: \"content-box\",\n\t                    webkitBoxSizing: \"content-box\"\n\t                });\n\t            }\n\t        }\n\n\t        if (browser.msie && math.floor(browser.version) <= 7) {\n\t            element.css({ zoom: 1 });\n\t            element.children(\".k-menu\").width(element.width());\n\t        }\n\n\t        return element.parent();\n\t    }\n\n\t    function deepExtend(destination) {\n\t        var i = 1,\n\t            length = arguments.length;\n\n\t        for (i = 1; i < length; i++) {\n\t            deepExtendOne(destination, arguments[i]);\n\t        }\n\n\t        return destination;\n\t    }\n\n\t    function deepExtendOne(destination, source) {\n\t        var ObservableArray = kendo.data.ObservableArray,\n\t            LazyObservableArray = kendo.data.LazyObservableArray,\n\t            DataSource = kendo.data.DataSource,\n\t            HierarchicalDataSource = kendo.data.HierarchicalDataSource,\n\t            property,\n\t            propValue,\n\t            propType,\n\t            propInit,\n\t            destProp;\n\n\t        for (property in source) {\n\t            propValue = source[property];\n\t            propType = typeof propValue;\n\n\t            if (propType === OBJECT && propValue !== null) {\n\t                propInit = propValue.constructor;\n\t            } else {\n\t                propInit = null;\n\t            }\n\n\t            if (propInit &&\n\t                propInit !== Array && propInit !== ObservableArray && propInit !== LazyObservableArray &&\n\t                propInit !== DataSource && propInit !== HierarchicalDataSource && propInit !== RegExp) {\n\n\t                if (propValue instanceof Date) {\n\t                    destination[property] = new Date(propValue.getTime());\n\t                } else if (isFunction(propValue.clone)) {\n\t                    destination[property] = propValue.clone();\n\t                } else {\n\t                    destProp = destination[property];\n\t                    if (typeof (destProp) === OBJECT) {\n\t                        destination[property] = destProp || {};\n\t                    } else {\n\t                        destination[property] = {};\n\t                    }\n\t                    deepExtendOne(destination[property], propValue);\n\t                }\n\t            } else if (propType !== UNDEFINED) {\n\t                destination[property] = propValue;\n\t            }\n\t        }\n\n\t        return destination;\n\t    }\n\n\t    function testRx(agent, rxs, dflt) {\n\t        for (var rx in rxs) {\n\t            if (rxs.hasOwnProperty(rx) && rxs[rx].test(agent)) {\n\t                return rx;\n\t            }\n\t        }\n\t        return dflt !== undefined ? dflt : agent;\n\t    }\n\n\t    function toHyphens(str) {\n\t        return str.replace(/([a-z][A-Z])/g, function (g) {\n\t            return g.charAt(0) + '-' + g.charAt(1).toLowerCase();\n\t        });\n\t    }\n\n\t    function toCamelCase(str) {\n\t        return str.replace(/\\-(\\w)/g, function (strMatch, g1) {\n\t            return g1.toUpperCase();\n\t        });\n\t    }\n\n\t    function getComputedStyles(element, properties) {\n\t        var styles = {}, computedStyle;\n\n\t        if (document.defaultView && document.defaultView.getComputedStyle) {\n\t            computedStyle = document.defaultView.getComputedStyle(element, \"\");\n\n\t            if (properties) {\n\t                $.each(properties, function(idx, value) {\n\t                    styles[value] = computedStyle.getPropertyValue(value);\n\t                });\n\t            }\n\t        } else {\n\t            computedStyle = element.currentStyle;\n\n\t            if (properties) {\n\t                $.each(properties, function(idx, value) {\n\t                    styles[value] = computedStyle[toCamelCase(value)];\n\t                });\n\t            }\n\t        }\n\n\t        if (!kendo.size(styles)) {\n\t            styles = computedStyle;\n\t        }\n\n\t        return styles;\n\t    }\n\n\t    function isScrollable(element) {\n\t        if (element && element.className && typeof(element.className) === \"string\" && element.className.indexOf(\"k-auto-scrollable\") > -1) {\n\t            return true;\n\t        }\n\n\t        var overflow = getComputedStyles(element, [\"overflow\"]).overflow;\n\t        return overflow == \"auto\" || overflow == \"scroll\";\n\t    }\n\n\t    function scrollLeft(element, value) {\n\t        var webkit = support.browser.webkit;\n\t        var mozila = support.browser.mozilla;\n\t        var el = element instanceof $ ? element[0] : element;\n\t        var isRtl;\n\n\t        if (!element) {\n\t            return;\n\t        }\n\n\t        isRtl = support.isRtl(element);\n\n\t        if (value !== undefined) {\n\t            if (isRtl && webkit) {\n\t                el.scrollLeft = el.scrollWidth - el.clientWidth - value;\n\t            } else if (isRtl && mozila) {\n\t                el.scrollLeft = -value;\n\t            } else {\n\t                el.scrollLeft = value;\n\t            }\n\t        } else {\n\t            if (isRtl && webkit) {\n\t                return el.scrollWidth - el.clientWidth - el.scrollLeft;\n\t            } else {\n\t                return Math.abs(el.scrollLeft);\n\t            }\n\t        }\n\t    }\n\n\t    (function () {\n\t        support._scrollbar = undefined;\n\n\t        support.scrollbar = function (refresh) {\n\t            if (!isNaN(support._scrollbar) && !refresh) {\n\t                return support._scrollbar;\n\t            } else {\n\t                var div = document.createElement(\"div\"),\n\t                    result;\n\n\t                div.style.cssText = \"overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block\";\n\t                div.innerHTML = \"&nbsp;\";\n\t                document.body.appendChild(div);\n\n\t                support._scrollbar = result = div.offsetWidth - div.scrollWidth;\n\n\t                document.body.removeChild(div);\n\n\t                return result;\n\t            }\n\t        };\n\n\t        support.isRtl = function(element) {\n\t            return $(element).closest(\".k-rtl\").length > 0;\n\t        };\n\n\t        var table = document.createElement(\"table\");\n\n\t        // Internet Explorer does not support setting the innerHTML of TBODY and TABLE elements\n\t        try {\n\t            table.innerHTML = \"<tr><td></td></tr>\";\n\n\t            support.tbodyInnerHtml = true;\n\t        } catch (e) {\n\t            support.tbodyInnerHtml = false;\n\t        }\n\n\t        support.touch = \"ontouchstart\" in window;\n\n\t        var docStyle = document.documentElement.style;\n\t        var transitions = support.transitions = false,\n\t            transforms = support.transforms = false,\n\t            elementProto = \"HTMLElement\" in window ? HTMLElement.prototype : [];\n\n\t        support.hasHW3D = (\"WebKitCSSMatrix\" in window && \"m11\" in new window.WebKitCSSMatrix()) || \"MozPerspective\" in docStyle || \"msPerspective\" in docStyle;\n\t        support.cssFlexbox = (\"flexWrap\" in docStyle) || (\"WebkitFlexWrap\" in docStyle) || (\"msFlexWrap\" in docStyle);\n\n\t        each([ \"Moz\", \"webkit\", \"O\", \"ms\" ], function () {\n\t            var prefix = this.toString(),\n\t                hasTransitions = typeof table.style[prefix + \"Transition\"] === STRING;\n\n\t            if (hasTransitions || typeof table.style[prefix + \"Transform\"] === STRING) {\n\t                var lowPrefix = prefix.toLowerCase();\n\n\t                transforms = {\n\t                    css: (lowPrefix != \"ms\") ? \"-\" + lowPrefix + \"-\" : \"\",\n\t                    prefix: prefix,\n\t                    event: (lowPrefix === \"o\" || lowPrefix === \"webkit\") ? lowPrefix : \"\"\n\t                };\n\n\t                if (hasTransitions) {\n\t                    transitions = transforms;\n\t                    transitions.event = transitions.event ? transitions.event + \"TransitionEnd\" : \"transitionend\";\n\t                }\n\n\t                return false;\n\t            }\n\t        });\n\n\t        table = null;\n\n\t        support.transforms = transforms;\n\t        support.transitions = transitions;\n\n\t        support.devicePixelRatio = window.devicePixelRatio === undefined ? 1 : window.devicePixelRatio;\n\n\t        try {\n\t            support.screenWidth = window.outerWidth || window.screen ? window.screen.availWidth : window.innerWidth;\n\t            support.screenHeight = window.outerHeight || window.screen ? window.screen.availHeight : window.innerHeight;\n\t        } catch(e) {\n\t            //window.outerWidth throws error when in IE showModalDialog.\n\t            support.screenWidth = window.screen.availWidth;\n\t            support.screenHeight = window.screen.availHeight;\n\t        }\n\n\t        support.detectOS = function (ua) {\n\t            var os = false, minorVersion, match = [],\n\t                notAndroidPhone = !/mobile safari/i.test(ua),\n\t                agentRxs = {\n\t                    wp: /(Windows Phone(?: OS)?)\\s(\\d+)\\.(\\d+(\\.\\d+)?)/,\n\t                    fire: /(Silk)\\/(\\d+)\\.(\\d+(\\.\\d+)?)/,\n\t                    android: /(Android|Android.*(?:Opera|Firefox).*?\\/)\\s*(\\d+)\\.?(\\d+(\\.\\d+)?)?/,\n\t                    iphone: /(iPhone|iPod).*OS\\s+(\\d+)[\\._]([\\d\\._]+)/,\n\t                    ipad: /(iPad).*OS\\s+(\\d+)[\\._]([\\d_]+)/,\n\t                    meego: /(MeeGo).+NokiaBrowser\\/(\\d+)\\.([\\d\\._]+)/,\n\t                    webos: /(webOS)\\/(\\d+)\\.(\\d+(\\.\\d+)?)/,\n\t                    blackberry: /(BlackBerry|BB10).*?Version\\/(\\d+)\\.(\\d+(\\.\\d+)?)/,\n\t                    playbook: /(PlayBook).*?Tablet\\s*OS\\s*(\\d+)\\.(\\d+(\\.\\d+)?)/,\n\t                    windows: /(MSIE)\\s+(\\d+)\\.(\\d+(\\.\\d+)?)/,\n\t                    tizen: /(tizen).*?Version\\/(\\d+)\\.(\\d+(\\.\\d+)?)/i,\n\t                    sailfish: /(sailfish).*rv:(\\d+)\\.(\\d+(\\.\\d+)?).*firefox/i,\n\t                    ffos: /(Mobile).*rv:(\\d+)\\.(\\d+(\\.\\d+)?).*Firefox/\n\t                },\n\t                osRxs = {\n\t                    ios: /^i(phone|pad|pod)$/i,\n\t                    android: /^android|fire$/i,\n\t                    blackberry: /^blackberry|playbook/i,\n\t                    windows: /windows/,\n\t                    wp: /wp/,\n\t                    flat: /sailfish|ffos|tizen/i,\n\t                    meego: /meego/\n\t                },\n\t                formFactorRxs = {\n\t                    tablet: /playbook|ipad|fire/i\n\t                },\n\t                browserRxs = {\n\t                    omini: /Opera\\sMini/i,\n\t                    omobile: /Opera\\sMobi/i,\n\t                    firefox: /Firefox|Fennec/i,\n\t                    mobilesafari: /version\\/.*safari/i,\n\t                    ie: /MSIE|Windows\\sPhone/i,\n\t                    chrome: /chrome|crios/i,\n\t                    webkit: /webkit/i\n\t                };\n\n\t            for (var agent in agentRxs) {\n\t                if (agentRxs.hasOwnProperty(agent)) {\n\t                    match = ua.match(agentRxs[agent]);\n\t                    if (match) {\n\t                        if (agent == \"windows\" && \"plugins\" in navigator) { return false; } // Break if not Metro/Mobile Windows\n\n\t                        os = {};\n\t                        os.device = agent;\n\t                        os.tablet = testRx(agent, formFactorRxs, false);\n\t                        os.browser = testRx(ua, browserRxs, \"default\");\n\t                        os.name = testRx(agent, osRxs);\n\t                        os[os.name] = true;\n\t                        os.majorVersion = match[2];\n\t                        os.minorVersion = (match[3] || \"0\").replace(\"_\", \".\");\n\t                        minorVersion = os.minorVersion.replace(\".\", \"\").substr(0, 2);\n\t                        os.flatVersion = os.majorVersion + minorVersion + (new Array(3 - (minorVersion.length < 3 ? minorVersion.length : 2)).join(\"0\"));\n\t                        os.cordova = typeof window.PhoneGap !== UNDEFINED || typeof window.cordova !== UNDEFINED; // Use file protocol to detect appModes.\n\t                        os.appMode = window.navigator.standalone || (/file|local|wmapp/).test(window.location.protocol) || os.cordova; // Use file protocol to detect appModes.\n\n\t                        if (os.android && (support.devicePixelRatio < 1.5 && os.flatVersion < 400 || notAndroidPhone) && (support.screenWidth > 800 || support.screenHeight > 800)) {\n\t                            os.tablet = agent;\n\t                        }\n\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t            return os;\n\t        };\n\n\t        var mobileOS = support.mobileOS = support.detectOS(navigator.userAgent);\n\n\t        support.wpDevicePixelRatio = mobileOS.wp ? screen.width / 320 : 0;\n\n\t        support.hasNativeScrolling = false;\n\n\t        if (mobileOS.ios || (mobileOS.android && mobileOS.majorVersion > 2) || mobileOS.wp) {\n\t            support.hasNativeScrolling = mobileOS;\n\t        }\n\n\t        support.delayedClick = function() {\n\n\t            // only the mobile devices with touch events do this.\n\t            if (support.touch) {\n\t                // All iOS devices so far (by the time I am writing this, iOS 9.0.2 is the latest),\n\t                // delay their click events.\n\t                if (mobileOS.ios) {\n\t                    return true;\n\t                }\n\n\t                if (mobileOS.android) {\n\n\t                    if (!support.browser.chrome) { // older webkits and webviews delay the click\n\t                        return true;\n\t                    }\n\n\t                    // from here on, we deal with Chrome on Android.\n\t                    if (support.browser.version < 32) {\n\t                        return false;\n\t                    }\n\n\t                    // Chrome 32+ does conditional fast clicks if the view port is not user scalable.\n\t                    return !($(\"meta[name=viewport]\").attr(\"content\") || \"\").match(/user-scalable=no/i);\n\t                }\n\t            }\n\n\t            return false;\n\t        };\n\n\t        support.mouseAndTouchPresent = support.touch && !(support.mobileOS.ios || support.mobileOS.android);\n\n\t        support.detectBrowser = function(ua) {\n\t            var browser = false, match = [],\n\t                browserRxs = {\n\t                    edge: /(edge)[ \\/]([\\w.]+)/i,\n\t                    webkit: /(chrome|crios)[ \\/]([\\w.]+)/i,\n\t                    safari: /(webkit)[ \\/]([\\w.]+)/i,\n\t                    opera: /(opera)(?:.*version|)[ \\/]([\\w.]+)/i,\n\t                    msie: /(msie\\s|trident.*? rv:)([\\w.]+)/i,\n\t                    mozilla: /(mozilla)(?:.*? rv:([\\w.]+)|)/i\n\t                };\n\n\t            for (var agent in browserRxs) {\n\t                if (browserRxs.hasOwnProperty(agent)) {\n\t                    match = ua.match(browserRxs[agent]);\n\t                    if (match) {\n\t                        browser = {};\n\t                        browser[agent] = true;\n\t                        browser[match[1].toLowerCase().split(\" \")[0].split(\"/\")[0]] = true;\n\t                        browser.version = parseInt(document.documentMode || match[2], 10);\n\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\n\t            return browser;\n\t        };\n\n\t        support.browser = support.detectBrowser(navigator.userAgent);\n\n\t        support.detectClipboardAccess = function() {\n\t            var commands = {\n\t                copy: document.queryCommandSupported ? document.queryCommandSupported(\"copy\") : false,\n\t                cut: document.queryCommandSupported ? document.queryCommandSupported(\"cut\") : false,\n\t                paste : document.queryCommandSupported ? document.queryCommandSupported(\"paste\") : false\n\t            };\n\n\t            if (support.browser.chrome) {\n\t                //not using queryCommandSupported due to chromium issues 476508 and 542948\n\t                commands.paste = false;\n\t                if(support.browser.version >= 43) {\n\t                    commands.copy = true;\n\t                    commands.cut = true;\n\t                }\n\t            }\n\n\t            return commands;\n\t        };\n\n\t        support.clipboard = support.detectClipboardAccess();\n\n\t        support.zoomLevel = function() {\n\t            try {\n\t                var browser = support.browser;\n\t                var ie11WidthCorrection = 0;\n\t                var docEl = document.documentElement;\n\n\t                if (browser.msie && browser.version == 11 && docEl.scrollHeight > docEl.clientHeight && !support.touch) {\n\t                    ie11WidthCorrection = support.scrollbar();\n\t                }\n\n\t                return support.touch ? (docEl.clientWidth / window.innerWidth) :\n\t                       browser.msie && browser.version >= 10 ? (((top || window).document.documentElement.offsetWidth + ie11WidthCorrection) / (top || window).innerWidth) : 1;\n\t            } catch(e) {\n\t                return 1;\n\t            }\n\t        };\n\n\t        support.cssBorderSpacing = typeof docStyle.borderSpacing != \"undefined\" && !(support.browser.msie && support.browser.version < 8);\n\n\t        (function(browser) {\n\t            // add browser-specific CSS class\n\t            var cssClass = \"\",\n\t                docElement = $(document.documentElement),\n\t                majorVersion = parseInt(browser.version, 10);\n\n\t            if (browser.msie) {\n\t                cssClass = \"ie\";\n\t            } else if (browser.mozilla) {\n\t                cssClass = \"ff\";\n\t            } else if (browser.safari) {\n\t                cssClass = \"safari\";\n\t            } else if (browser.webkit) {\n\t                cssClass = \"webkit\";\n\t            } else if (browser.opera) {\n\t                cssClass = \"opera\";\n\t            } else if (browser.edge) {\n\t                cssClass = \"edge\";\n\t            }\n\n\t            if (cssClass) {\n\t                cssClass = \"k-\" + cssClass + \" k-\" + cssClass + majorVersion;\n\t            }\n\t            if (support.mobileOS) {\n\t                cssClass += \" k-mobile\";\n\t            }\n\n\t            if (!support.cssFlexbox) {\n\t                cssClass += \" k-no-flexbox\";\n\t            }\n\n\t            docElement.addClass(cssClass);\n\t        })(support.browser);\n\n\t        support.eventCapture = document.documentElement.addEventListener;\n\n\t        var input = document.createElement(\"input\");\n\n\t        support.placeholder = \"placeholder\" in input;\n\t        support.propertyChangeEvent = \"onpropertychange\" in input;\n\n\t        support.input = (function() {\n\t            var types = [\"number\", \"date\", \"time\", \"month\", \"week\", \"datetime\", \"datetime-local\"];\n\t            var length = types.length;\n\t            var value = \"test\";\n\t            var result = {};\n\t            var idx = 0;\n\t            var type;\n\n\t            for (;idx < length; idx++) {\n\t                type = types[idx];\n\t                input.setAttribute(\"type\", type);\n\t                input.value = value;\n\n\t                result[type.replace(\"-\", \"\")] = input.type !== \"text\" && input.value !== value;\n\t            }\n\n\t            return result;\n\t        })();\n\n\t        input.style.cssText = \"float:left;\";\n\n\t        support.cssFloat = !!input.style.cssFloat;\n\n\t        input = null;\n\n\t        support.stableSort = (function() {\n\t            // Chrome sort is not stable for more than *10* items\n\t            // IE9+ sort is not stable for than *512* items\n\t            var threshold = 513;\n\n\t            var sorted = [{\n\t                index: 0,\n\t                field: \"b\"\n\t            }];\n\n\t            for (var i = 1; i < threshold; i++) {\n\t                sorted.push({\n\t                    index: i,\n\t                    field: \"a\"\n\t                });\n\t            }\n\n\t            sorted.sort(function(a, b) {\n\t                return a.field > b.field ? 1 : (a.field < b.field ? -1 : 0);\n\t            });\n\n\t            return sorted[0].index === 1;\n\t        })();\n\n\t        support.matchesSelector = elementProto.webkitMatchesSelector || elementProto.mozMatchesSelector ||\n\t                                  elementProto.msMatchesSelector || elementProto.oMatchesSelector ||\n\t                                  elementProto.matchesSelector || elementProto.matches ||\n\t          function( selector ) {\n\t              var nodeList = document.querySelectorAll ? ( this.parentNode || document ).querySelectorAll( selector ) || [] : $(selector),\n\t                  i = nodeList.length;\n\n\t              while (i--) {\n\t                  if (nodeList[i] == this) {\n\t                      return true;\n\t                  }\n\t              }\n\n\t              return false;\n\t          };\n\n\t        support.matchMedia = \"matchMedia\" in window;\n\n\t        support.pushState = window.history && window.history.pushState;\n\n\t        var documentMode = document.documentMode;\n\n\t        support.hashChange = (\"onhashchange\" in window) && !(support.browser.msie && (!documentMode || documentMode <= 8)); // old IE detection\n\n\t        support.customElements = (\"registerElement\" in window.document);\n\n\t        var chrome = support.browser.chrome,\n\t            mozilla = support.browser.mozilla;\n\t        support.msPointers = !chrome && window.MSPointerEvent;\n\t        support.pointers = !chrome && !mozilla && window.PointerEvent;\n\t        support.kineticScrollNeeded = mobileOS && (support.touch || support.msPointers || support.pointers);\n\t    })();\n\n\n\t    function size(obj) {\n\t        var result = 0, key;\n\t        for (key in obj) {\n\t            if (obj.hasOwnProperty(key) && key != \"toJSON\") { // Ignore fake IE7 toJSON.\n\t                result++;\n\t            }\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function getOffset(element, type, positioned) {\n\t        if (!type) {\n\t            type = \"offset\";\n\t        }\n\n\t        var offset = element[type]();\n\t        // clone ClientRect object to JS object (jQuery3)\n\t        var result = {\n\t            top: offset.top,\n\t            right: offset.right,\n\t            bottom: offset.bottom,\n\t            left: offset.left\n\t        };\n\n\t        // IE10 touch zoom is living in a separate viewport\n\t        if (support.browser.msie && (support.pointers || support.msPointers) && !positioned) {\n\t            var sign = support.isRtl(element) ? 1 : -1;\n\n\t            result.top -= (window.pageYOffset - (document.documentElement.scrollTop));\n\t            result.left -= (window.pageXOffset + (sign * document.documentElement.scrollLeft));\n\t        }\n\n\t        return result;\n\t    }\n\n\t    var directions = {\n\t        left: { reverse: \"right\" },\n\t        right: { reverse: \"left\" },\n\t        down: { reverse: \"up\" },\n\t        up: { reverse: \"down\" },\n\t        top: { reverse: \"bottom\" },\n\t        bottom: { reverse: \"top\" },\n\t        \"in\": { reverse: \"out\" },\n\t        out: { reverse: \"in\" }\n\t    };\n\n\t    function parseEffects(input) {\n\t        var effects = {};\n\n\t        each((typeof input === \"string\" ? input.split(\" \") : input), function(idx) {\n\t            effects[idx] = this;\n\t        });\n\n\t        return effects;\n\t    }\n\n\t    function fx(element) {\n\t        return new kendo.effects.Element(element);\n\t    }\n\n\t    var effects = {};\n\n\t    $.extend(effects, {\n\t        enabled: true,\n\t        Element: function(element) {\n\t            this.element = $(element);\n\t        },\n\n\t        promise: function(element, options) {\n\t            if (!element.is(\":visible\")) {\n\t                element.css({ display: element.data(\"olddisplay\") || \"block\" }).css(\"display\");\n\t            }\n\n\t            if (options.hide) {\n\t                element.data(\"olddisplay\", element.css(\"display\")).hide();\n\t            }\n\n\t            if (options.init) {\n\t                options.init();\n\t            }\n\n\t            if (options.completeCallback) {\n\t                options.completeCallback(element); // call the external complete callback with the element\n\t            }\n\n\t            element.dequeue();\n\t        },\n\n\t        disable: function() {\n\t            this.enabled = false;\n\t            this.promise = this.promiseShim;\n\t        },\n\n\t        enable: function() {\n\t            this.enabled = true;\n\t            this.promise = this.animatedPromise;\n\t        }\n\t    });\n\n\t    effects.promiseShim = effects.promise;\n\n\t    function prepareAnimationOptions(options, duration, reverse, complete) {\n\t        if (typeof options === STRING) {\n\t            // options is the list of effect names separated by space e.g. animate(element, \"fadeIn slideDown\")\n\n\t            // only callback is provided e.g. animate(element, options, function() {});\n\t            if (isFunction(duration)) {\n\t                complete = duration;\n\t                duration = 400;\n\t                reverse = false;\n\t            }\n\n\t            if (isFunction(reverse)) {\n\t                complete = reverse;\n\t                reverse = false;\n\t            }\n\n\t            if (typeof duration === BOOLEAN){\n\t                reverse = duration;\n\t                duration = 400;\n\t            }\n\n\t            options = {\n\t                effects: options,\n\t                duration: duration,\n\t                reverse: reverse,\n\t                complete: complete\n\t            };\n\t        }\n\n\t        return extend({\n\t            //default options\n\t            effects: {},\n\t            duration: 400, //jQuery default duration\n\t            reverse: false,\n\t            init: noop,\n\t            teardown: noop,\n\t            hide: false\n\t        }, options, { completeCallback: options.complete, complete: noop }); // Move external complete callback, so deferred.resolve can be always executed.\n\n\t    }\n\n\t    function animate(element, options, duration, reverse, complete) {\n\t        var idx = 0,\n\t            length = element.length,\n\t            instance;\n\n\t        for (; idx < length; idx ++) {\n\t            instance = $(element[idx]);\n\t            instance.queue(function() {\n\t                effects.promise(instance, prepareAnimationOptions(options, duration, reverse, complete));\n\t            });\n\t        }\n\n\t        return element;\n\t    }\n\n\t    function toggleClass(element, classes, options, add) {\n\t        if (classes) {\n\t            classes = classes.split(\" \");\n\n\t            each(classes, function(idx, value) {\n\t                element.toggleClass(value, add);\n\t            });\n\t        }\n\n\t        return element;\n\t    }\n\n\t    if (!(\"kendoAnimate\" in $.fn)) {\n\t        extend($.fn, {\n\t            kendoStop: function(clearQueue, gotoEnd) {\n\t                return this.stop(clearQueue, gotoEnd);\n\t            },\n\n\t            kendoAnimate: function(options, duration, reverse, complete) {\n\t                return animate(this, options, duration, reverse, complete);\n\t            },\n\n\t            kendoAddClass: function(classes, options){\n\t                return kendo.toggleClass(this, classes, options, true);\n\t            },\n\n\t            kendoRemoveClass: function(classes, options){\n\t                return kendo.toggleClass(this, classes, options, false);\n\t            },\n\t            kendoToggleClass: function(classes, options, toggle){\n\t                return kendo.toggleClass(this, classes, options, toggle);\n\t            }\n\t        });\n\t    }\n\n\t    var ampRegExp = /&/g,\n\t        ltRegExp = /</g,\n\t        quoteRegExp = /\"/g,\n\t        aposRegExp = /'/g,\n\t        gtRegExp = />/g;\n\t    function htmlEncode(value) {\n\t        return (\"\" + value).replace(ampRegExp, \"&amp;\").replace(ltRegExp, \"&lt;\").replace(gtRegExp, \"&gt;\").replace(quoteRegExp, \"&quot;\").replace(aposRegExp, \"&#39;\");\n\t    }\n\n\t    var eventTarget = function (e) {\n\t        return e.target;\n\t    };\n\n\t    if (support.touch) {\n\n\t        eventTarget = function(e) {\n\t            var touches = \"originalEvent\" in e ? e.originalEvent.changedTouches : \"changedTouches\" in e ? e.changedTouches : null;\n\n\t            return touches ? document.elementFromPoint(touches[0].clientX, touches[0].clientY) : e.target;\n\t        };\n\n\t        each([\"swipe\", \"swipeLeft\", \"swipeRight\", \"swipeUp\", \"swipeDown\", \"doubleTap\", \"tap\"], function(m, value) {\n\t            $.fn[value] = function(callback) {\n\t                return this.bind(value, callback);\n\t            };\n\t        });\n\t    }\n\n\t    if (support.touch) {\n\t        if (!support.mobileOS) {\n\t            support.mousedown = \"mousedown touchstart\";\n\t            support.mouseup = \"mouseup touchend\";\n\t            support.mousemove = \"mousemove touchmove\";\n\t            support.mousecancel = \"mouseleave touchcancel\";\n\t            support.click = \"click\";\n\t            support.resize = \"resize\";\n\t        } else {\n\t            support.mousedown = \"touchstart\";\n\t            support.mouseup = \"touchend\";\n\t            support.mousemove = \"touchmove\";\n\t            support.mousecancel = \"touchcancel\";\n\t            support.click = \"touchend\";\n\t            support.resize = \"orientationchange\";\n\t        }\n\t    } else if (support.pointers) {\n\t        support.mousemove = \"pointermove\";\n\t        support.mousedown = \"pointerdown\";\n\t        support.mouseup = \"pointerup\";\n\t        support.mousecancel = \"pointercancel\";\n\t        support.click = \"pointerup\";\n\t        support.resize = \"orientationchange resize\";\n\t    } else if (support.msPointers) {\n\t        support.mousemove = \"MSPointerMove\";\n\t        support.mousedown = \"MSPointerDown\";\n\t        support.mouseup = \"MSPointerUp\";\n\t        support.mousecancel = \"MSPointerCancel\";\n\t        support.click = \"MSPointerUp\";\n\t        support.resize = \"orientationchange resize\";\n\t    } else {\n\t        support.mousemove = \"mousemove\";\n\t        support.mousedown = \"mousedown\";\n\t        support.mouseup = \"mouseup\";\n\t        support.mousecancel = \"mouseleave\";\n\t        support.click = \"click\";\n\t        support.resize = \"resize\";\n\t    }\n\n\t    var wrapExpression = function(members, paramName) {\n\t        var result = paramName || \"d\",\n\t            index,\n\t            idx,\n\t            length,\n\t            member,\n\t            count = 1;\n\n\t        for (idx = 0, length = members.length; idx < length; idx++) {\n\t            member = members[idx];\n\t            if (member !== \"\") {\n\t                index = member.indexOf(\"[\");\n\n\t                if (index !== 0) {\n\t                    if (index == -1) {\n\t                        member = \".\" + member;\n\t                    } else {\n\t                        count++;\n\t                        member = \".\" + member.substring(0, index) + \" || {})\" + member.substring(index);\n\t                    }\n\t                }\n\n\t                count++;\n\t                result += member + ((idx < length - 1) ? \" || {})\" : \")\");\n\t            }\n\t        }\n\t        return new Array(count).join(\"(\") + result;\n\t    },\n\t    localUrlRe = /^([a-z]+:)?\\/\\//i;\n\n\t    extend(kendo, {\n\t        widgets: [],\n\t        _widgetRegisteredCallbacks: [],\n\t        ui: kendo.ui || {},\n\t        fx: kendo.fx || fx,\n\t        effects: kendo.effects || effects,\n\t        mobile: kendo.mobile || { },\n\t        data: kendo.data || {},\n\t        dataviz: kendo.dataviz || {},\n\t        drawing: kendo.drawing || {},\n\t        spreadsheet: { messages: {} },\n\t        keys: {\n\t            INSERT: 45,\n\t            DELETE: 46,\n\t            BACKSPACE: 8,\n\t            TAB: 9,\n\t            ENTER: 13,\n\t            ESC: 27,\n\t            LEFT: 37,\n\t            UP: 38,\n\t            RIGHT: 39,\n\t            DOWN: 40,\n\t            END: 35,\n\t            HOME: 36,\n\t            SPACEBAR: 32,\n\t            PAGEUP: 33,\n\t            PAGEDOWN: 34,\n\t            F2: 113,\n\t            F10: 121,\n\t            F12: 123,\n\t            NUMPAD_PLUS: 107,\n\t            NUMPAD_MINUS: 109,\n\t            NUMPAD_DOT: 110\n\t        },\n\t        support: kendo.support || support,\n\t        animate: kendo.animate || animate,\n\t        ns: \"\",\n\t        attr: function(value) {\n\t            return \"data-\" + kendo.ns + value;\n\t        },\n\t        getShadows: getShadows,\n\t        wrap: wrap,\n\t        deepExtend: deepExtend,\n\t        getComputedStyles: getComputedStyles,\n\t        webComponents: kendo.webComponents || [],\n\t        isScrollable: isScrollable,\n\t        scrollLeft: scrollLeft,\n\t        size: size,\n\t        toCamelCase: toCamelCase,\n\t        toHyphens: toHyphens,\n\t        getOffset: kendo.getOffset || getOffset,\n\t        parseEffects: kendo.parseEffects || parseEffects,\n\t        toggleClass: kendo.toggleClass || toggleClass,\n\t        directions: kendo.directions || directions,\n\t        Observable: Observable,\n\t        Class: Class,\n\t        Template: Template,\n\t        template: proxy(Template.compile, Template),\n\t        render: proxy(Template.render, Template),\n\t        stringify: proxy(JSON.stringify, JSON),\n\t        eventTarget: eventTarget,\n\t        htmlEncode: htmlEncode,\n\t        isLocalUrl: function(url) {\n\t            return url && !localUrlRe.test(url);\n\t        },\n\n\t        expr: function(expression, safe, paramName) {\n\t            expression = expression || \"\";\n\n\t            if (typeof safe == STRING) {\n\t                paramName = safe;\n\t                safe = false;\n\t            }\n\n\t            paramName = paramName || \"d\";\n\n\t            if (expression && expression.charAt(0) !== \"[\") {\n\t                expression = \".\" + expression;\n\t            }\n\n\t            if (safe) {\n\t                expression = expression.replace(/\"([^.]*)\\.([^\"]*)\"/g,'\"$1_$DOT$_$2\"');\n\t                expression = expression.replace(/'([^.]*)\\.([^']*)'/g,\"'$1_$DOT$_$2'\");\n\t                expression = wrapExpression(expression.split(\".\"), paramName);\n\t                expression = expression.replace(/_\\$DOT\\$_/g, \".\");\n\t            } else {\n\t                expression = paramName + expression;\n\t            }\n\n\t            return expression;\n\t        },\n\n\t        getter: function(expression, safe) {\n\t            var key = expression + safe;\n\t            return getterCache[key] = getterCache[key] || new Function(\"d\", \"return \" + kendo.expr(expression, safe));\n\t        },\n\n\t        setter: function(expression) {\n\t            return setterCache[expression] = setterCache[expression] || new Function(\"d,value\", kendo.expr(expression) + \"=value\");\n\t        },\n\n\t        accessor: function(expression) {\n\t            return {\n\t                get: kendo.getter(expression),\n\t                set: kendo.setter(expression)\n\t            };\n\t        },\n\n\t        guid: function() {\n\t            var id = \"\", i, random;\n\n\t            for (i = 0; i < 32; i++) {\n\t                random = math.random() * 16 | 0;\n\n\t                if (i == 8 || i == 12 || i == 16 || i == 20) {\n\t                    id += \"-\";\n\t                }\n\t                id += (i == 12 ? 4 : (i == 16 ? (random & 3 | 8) : random)).toString(16);\n\t            }\n\n\t            return id;\n\t        },\n\n\t        roleSelector: function(role) {\n\t            return role.replace(/(\\S+)/g, \"[\" + kendo.attr(\"role\") + \"=$1],\").slice(0, -1);\n\t        },\n\n\t        directiveSelector: function(directives) {\n\t            var selectors = directives.split(\" \");\n\n\t            if (selectors) {\n\t                for (var i = 0; i < selectors.length; i++) {\n\t                    if (selectors[i] != \"view\") {\n\t                        selectors[i] = selectors[i].replace(/(\\w*)(view|bar|strip|over)$/, \"$1-$2\");\n\t                    }\n\t                }\n\t            }\n\n\t            return selectors.join(\" \").replace(/(\\S+)/g, \"kendo-mobile-$1,\").slice(0, -1);\n\t        },\n\n\t        triggeredByInput: function(e) {\n\t            return (/^(label|input|textarea|select)$/i).test(e.target.tagName);\n\t        },\n\n\t        onWidgetRegistered: function(callback) {\n\t            for (var i = 0, len = kendo.widgets.length; i < len; i++) {\n\t                callback(kendo.widgets[i]);\n\t            }\n\n\t            kendo._widgetRegisteredCallbacks.push(callback);\n\t        },\n\n\t        logToConsole: function(message, type) {\n\t            var console = window.console;\n\n\t            if (!kendo.suppressLog && typeof(console) != \"undefined\" && console.log) {\n\t                console[type || \"log\"](message);\n\t            }\n\t        }\n\t    });\n\n\t    var Widget = Observable.extend( {\n\t        init: function(element, options) {\n\t            var that = this;\n\n\t            that.element = kendo.jQuery(element).handler(that);\n\n\t            that.angular(\"init\", options);\n\n\t            Observable.fn.init.call(that);\n\n\t            var dataSource = options ? options.dataSource : null;\n\n\t            if (dataSource) {\n\t                // avoid deep cloning the data source\n\t                options = extend({}, options, { dataSource: {} });\n\t            }\n\n\t            options = that.options = extend(true, {}, that.options, options);\n\n\t            if (dataSource) {\n\t                options.dataSource = dataSource;\n\t            }\n\n\t            if (!that.element.attr(kendo.attr(\"role\"))) {\n\t                that.element.attr(kendo.attr(\"role\"), (options.name || \"\").toLowerCase());\n\t            }\n\n\t            that.element.data(\"kendo\" + options.prefix + options.name, that);\n\n\t            that.bind(that.events, options);\n\t        },\n\n\t        events: [],\n\n\t        options: {\n\t            prefix: \"\"\n\t        },\n\n\t        _hasBindingTarget: function() {\n\t            return !!this.element[0].kendoBindingTarget;\n\t        },\n\n\t        _tabindex: function(target) {\n\t            target = target || this.wrapper;\n\n\t            var element = this.element,\n\t                TABINDEX = \"tabindex\",\n\t                tabindex = target.attr(TABINDEX) || element.attr(TABINDEX);\n\n\t            element.removeAttr(TABINDEX);\n\n\t            target.attr(TABINDEX, !isNaN(tabindex) ? tabindex : 0);\n\t        },\n\n\t        setOptions: function(options) {\n\t            this._setEvents(options);\n\t            $.extend(this.options, options);\n\t        },\n\n\t        _setEvents: function(options) {\n\t            var that = this,\n\t                idx = 0,\n\t                length = that.events.length,\n\t                e;\n\n\t            for (; idx < length; idx ++) {\n\t                e = that.events[idx];\n\t                if (that.options[e] && options[e]) {\n\t                    that.unbind(e, that.options[e]);\n\t                }\n\t            }\n\n\t            that.bind(that.events, options);\n\t        },\n\n\t        resize: function(force) {\n\t            var size = this.getSize(),\n\t                currentSize = this._size;\n\n\t            if (force || (size.width > 0 || size.height > 0) && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {\n\t                this._size = size;\n\t                this._resize(size, force);\n\t                this.trigger(\"resize\", size);\n\t            }\n\t        },\n\n\t        getSize: function() {\n\t            return kendo.dimensions(this.element);\n\t        },\n\n\t        size: function(size) {\n\t            if (!size) {\n\t                return this.getSize();\n\t            } else {\n\t                this.setSize(size);\n\t            }\n\t        },\n\n\t        setSize: $.noop,\n\t        _resize: $.noop,\n\n\t        destroy: function() {\n\t            var that = this;\n\n\t            that.element.removeData(\"kendo\" + that.options.prefix + that.options.name);\n\t            that.element.removeData(\"handler\");\n\t            that.unbind();\n\t        },\n\t        _destroy: function() {\n\t            this.destroy();\n\t        },\n\t        angular: function(){},\n\n\t        _muteAngularRebind: function(callback) {\n\t            this._muteRebind = true;\n\n\t            callback.call(this);\n\n\t            this._muteRebind = false;\n\t        }\n\t    });\n\n\t    var DataBoundWidget = Widget.extend({\n\t        // Angular consumes these.\n\t        dataItems: function() {\n\t            return this.dataSource.flatView();\n\t        },\n\n\t        _angularItems: function(cmd) {\n\t            var that = this;\n\t            that.angular(cmd, function(){\n\t                return {\n\t                    elements: that.items(),\n\t                    data: $.map(that.dataItems(), function(dataItem){\n\t                        return { dataItem: dataItem };\n\t                    })\n\t                };\n\t            });\n\t        }\n\t    });\n\n\t    kendo.dimensions = function(element, dimensions) {\n\t        var domElement = element[0];\n\n\t        if (dimensions) {\n\t            element.css(dimensions);\n\t        }\n\n\t        return { width: domElement.offsetWidth, height: domElement.offsetHeight };\n\t    };\n\n\t    kendo.notify = noop;\n\n\t    var templateRegExp = /template$/i,\n\t        jsonRegExp = /^\\s*(?:\\{(?:.|\\r\\n|\\n)*\\}|\\[(?:.|\\r\\n|\\n)*\\])\\s*$/,\n\t        jsonFormatRegExp = /^\\{(\\d+)(:[^\\}]+)?\\}|^\\[[A-Za-z_]+\\]$/,\n\t        dashRegExp = /([A-Z])/g;\n\n\t    function parseOption(element, option) {\n\t        var value;\n\n\t        if (option.indexOf(\"data\") === 0) {\n\t            option = option.substring(4);\n\t            option = option.charAt(0).toLowerCase() + option.substring(1);\n\t        }\n\n\t        option = option.replace(dashRegExp, \"-$1\");\n\t        value = element.getAttribute(\"data-\" + kendo.ns + option);\n\n\t        if (value === null) {\n\t            value = undefined;\n\t        } else if (value === \"null\") {\n\t            value = null;\n\t        } else if (value === \"true\") {\n\t            value = true;\n\t        } else if (value === \"false\") {\n\t            value = false;\n\t        } else if (numberRegExp.test(value) && option != \"mask\") {\n\t            value = parseFloat(value);\n\t        } else if (jsonRegExp.test(value) && !jsonFormatRegExp.test(value)) {\n\t            value = new Function(\"return (\" + value + \")\")();\n\t        }\n\n\t        return value;\n\t    }\n\n\t    function parseOptions(element, options, source) {\n\t        var result = {},\n\t            option,\n\t            value;\n\n\t        for (option in options) {\n\t            value = parseOption(element, option);\n\n\t            if (value !== undefined) {\n\n\t                if (templateRegExp.test(option)) {\n\t                    if(typeof value === \"string\") {\n\t                        if($(\"#\" + value).length){\n\t                            value = kendo.template($(\"#\" + value).html());\n\t                        }else if (source){\n\t                            value = kendo.template(source[value]);\n\t                        }\n\t                    } else {\n\t                        value = element.getAttribute(option);\n\t                    }\n\t                }\n\n\t                result[option] = value;\n\t            }\n\t        }\n\n\t        return result;\n\t    }\n\n\t    kendo.initWidget = function(element, options, roles) {\n\t        var result,\n\t            option,\n\t            widget,\n\t            idx,\n\t            length,\n\t            role,\n\t            value,\n\t            dataSource,\n\t            fullPath,\n\t            widgetKeyRegExp;\n\n\t        // Preserve backwards compatibility with (element, options, namespace) signature, where namespace was kendo.ui\n\t        if (!roles) {\n\t            roles = kendo.ui.roles;\n\t        } else if (roles.roles) {\n\t            roles = roles.roles;\n\t        }\n\n\t        element = element.nodeType ? element : element[0];\n\n\t        role = element.getAttribute(\"data-\" + kendo.ns + \"role\");\n\n\t        if (!role) {\n\t            return;\n\t        }\n\n\t        fullPath = role.indexOf(\".\") === -1;\n\n\t        // look for any widget that may be already instantiated based on this role.\n\t        // The prefix used is unknown, hence the regexp\n\t        //\n\n\t        if (fullPath) {\n\t            widget = roles[role];\n\t        } else { // full namespace path - like kendo.ui.Widget\n\t            widget = kendo.getter(role)(window);\n\t        }\n\n\t        var data = $(element).data(),\n\t            widgetKey = widget ? \"kendo\" + widget.fn.options.prefix + widget.fn.options.name : \"\";\n\n\t        if (fullPath) {\n\t            widgetKeyRegExp = new RegExp(\"^kendo.*\" + role + \"$\", \"i\");\n\t        } else { // full namespace path - like kendo.ui.Widget\n\t            widgetKeyRegExp = new RegExp(\"^\" + widgetKey + \"$\", \"i\");\n\t        }\n\n\t        for(var key in data) {\n\t            if (key.match(widgetKeyRegExp)) {\n\t                // we have detected a widget of the same kind - save its reference, we will set its options\n\t                if (key === widgetKey) {\n\t                    result = data[key];\n\t                } else {\n\t                    return data[key];\n\t                }\n\t            }\n\t        }\n\n\t        if (!widget) {\n\t            return;\n\t        }\n\n\t        dataSource = parseOption(element, \"dataSource\");\n\n\t        options = $.extend({}, parseOptions(element, widget.fn.options), options);\n\n\t        if (dataSource) {\n\t            if (typeof dataSource === STRING) {\n\t                options.dataSource = kendo.getter(dataSource)(window);\n\t            } else {\n\t                options.dataSource = dataSource;\n\t            }\n\t        }\n\n\t        for (idx = 0, length = widget.fn.events.length; idx < length; idx++) {\n\t            option = widget.fn.events[idx];\n\n\t            value = parseOption(element, option);\n\n\t            if (value !== undefined) {\n\t                options[option] = kendo.getter(value)(window);\n\t            }\n\t        }\n\n\t        if (!result) {\n\t            result = new widget(element, options);\n\t        } else if (!$.isEmptyObject(options)) {\n\t            result.setOptions(options);\n\t        }\n\n\t        return result;\n\t    };\n\n\t    kendo.rolesFromNamespaces = function(namespaces) {\n\t        var roles = [],\n\t            idx,\n\t            length;\n\n\t        if (!namespaces[0]) {\n\t            namespaces = [kendo.ui, kendo.dataviz.ui];\n\t        }\n\n\t        for (idx = 0, length = namespaces.length; idx < length; idx ++) {\n\t            roles[idx] = namespaces[idx].roles;\n\t        }\n\n\t        return extend.apply(null, [{}].concat(roles.reverse()));\n\t    };\n\n\t    kendo.init = function(element) {\n\t        var roles = kendo.rolesFromNamespaces(slice.call(arguments, 1));\n\n\t        $(element).find(\"[data-\" + kendo.ns + \"role]\").addBack().each(function(){\n\t            kendo.initWidget(this, {}, roles);\n\t        });\n\t    };\n\n\t    kendo.destroy = function(element) {\n\t        $(element).find(\"[data-\" + kendo.ns + \"role]\").addBack().each(function(){\n\t            var data = $(this).data();\n\n\t            for (var key in data) {\n\t                if (key.indexOf(\"kendo\") === 0 && typeof data[key].destroy === FUNCTION) {\n\t                    data[key].destroy();\n\t                }\n\t            }\n\t        });\n\t    };\n\n\t    function containmentComparer(a, b) {\n\t        return $.contains(a, b) ? -1 : 1;\n\t    }\n\n\t    function resizableWidget() {\n\t        var widget = $(this);\n\t        return ($.inArray(widget.attr(\"data-\" + kendo.ns + \"role\"), [\"slider\", \"rangeslider\"]) > -1) || widget.is(\":visible\");\n\t    }\n\n\t    kendo.resize = function(element, force) {\n\t        var widgets = $(element).find(\"[data-\" + kendo.ns + \"role]\").addBack().filter(resizableWidget);\n\n\t        if (!widgets.length) {\n\t            return;\n\t        }\n\n\t        // sort widgets based on their parent-child relation\n\t        var widgetsArray = $.makeArray(widgets);\n\t        widgetsArray.sort(containmentComparer);\n\n\t        // resize widgets\n\t        $.each(widgetsArray, function () {\n\t            var widget = kendo.widgetInstance($(this));\n\t            if (widget) {\n\t                widget.resize(force);\n\t            }\n\t        });\n\t    };\n\n\t    kendo.parseOptions = parseOptions;\n\n\t    extend(kendo.ui, {\n\t        Widget: Widget,\n\t        DataBoundWidget: DataBoundWidget,\n\t        roles: {},\n\t        progress: function(container, toggle, options) {\n\t            var mask = container.find(\".k-loading-mask\"),\n\t                support = kendo.support,\n\t                browser = support.browser,\n\t                isRtl, leftRight, webkitCorrection, containerScrollLeft, cssClass;\n\n\t                options = $.extend({}, {\n\t                    width: \"100%\",\n\t                    height: \"100%\",\n\t                    top: container.scrollTop(),\n\t                    opacity: false\n\t                }, options);\n\n\t                cssClass = options.opacity ? 'k-loading-mask k-opaque' : 'k-loading-mask';\n\n\t            if (toggle) {\n\t                if (!mask.length) {\n\t                    isRtl = support.isRtl(container);\n\t                    leftRight = isRtl ? \"right\" : \"left\";\n\t                    containerScrollLeft = container.scrollLeft();\n\t                    webkitCorrection = browser.webkit ? (!isRtl ? 0 : container[0].scrollWidth - container.width() - 2 * containerScrollLeft) : 0;\n\n\t                    mask = $(kendo.format(\"<div class='{0}'><span class='k-loading-text'>{1}</span><div class='k-loading-image'/><div class='k-loading-color'/></div>\", cssClass, kendo.ui.progress.messages.loading))\n\t                        .width(options.width).height(options.height)\n\t                        .css(\"top\", options.top)\n\t                        .css(leftRight, Math.abs(containerScrollLeft) + webkitCorrection)\n\t                        .prependTo(container);\n\t                }\n\t            } else if (mask) {\n\t                mask.remove();\n\t            }\n\t        },\n\t        plugin: function(widget, register, prefix) {\n\t            var name = widget.fn.options.name,\n\t                getter;\n\n\t            register = register || kendo.ui;\n\t            prefix = prefix || \"\";\n\n\t            register[name] = widget;\n\n\t            register.roles[name.toLowerCase()] = widget;\n\n\t            getter = \"getKendo\" + prefix + name;\n\t            name = \"kendo\" + prefix + name;\n\n\t            var widgetEntry = { name: name, widget: widget, prefix: prefix || \"\" };\n\t            kendo.widgets.push(widgetEntry);\n\n\t            for (var i = 0, len = kendo._widgetRegisteredCallbacks.length; i < len; i++) {\n\t                kendo._widgetRegisteredCallbacks[i](widgetEntry);\n\t            }\n\n\t            $.fn[name] = function(options) {\n\t                var value = this,\n\t                    args;\n\n\t                if (typeof options === STRING) {\n\t                    args = slice.call(arguments, 1);\n\n\t                    this.each(function(){\n\t                        var widget = $.data(this, name),\n\t                            method,\n\t                            result;\n\n\t                        if (!widget) {\n\t                            throw new Error(kendo.format(\"Cannot call method '{0}' of {1} before it is initialized\", options, name));\n\t                        }\n\n\t                        method = widget[options];\n\n\t                        if (typeof method !== FUNCTION) {\n\t                            throw new Error(kendo.format(\"Cannot find method '{0}' of {1}\", options, name));\n\t                        }\n\n\t                        result = method.apply(widget, args);\n\n\t                        if (result !== undefined) {\n\t                            value = result;\n\t                            return false;\n\t                        }\n\t                    });\n\t                } else {\n\t                    this.each(function() {\n\t                        return new widget(this, options);\n\t                    });\n\t                }\n\n\t                return value;\n\t            };\n\n\t            $.fn[name].widget = widget;\n\n\t            $.fn[getter] = function() {\n\t                return this.data(name);\n\t            };\n\t        }\n\t    });\n\n\t    kendo.ui.progress.messages = {\n\t        loading: \"Loading...\"\n\t    };\n\n\t    var ContainerNullObject = { bind: function () { return this; }, nullObject: true, options: {} };\n\n\t    var MobileWidget = Widget.extend({\n\t        init: function(element, options) {\n\t            Widget.fn.init.call(this, element, options);\n\t            this.element.autoApplyNS();\n\t            this.wrapper = this.element;\n\t            this.element.addClass(\"km-widget\");\n\t        },\n\n\t        destroy: function() {\n\t            Widget.fn.destroy.call(this);\n\t            this.element.kendoDestroy();\n\t        },\n\n\t        options: {\n\t            prefix: \"Mobile\"\n\t        },\n\n\t        events: [],\n\n\t        view: function() {\n\t            var viewElement = this.element.closest(kendo.roleSelector(\"view splitview modalview drawer\"));\n\t            return kendo.widgetInstance(viewElement, kendo.mobile.ui) || ContainerNullObject;\n\t        },\n\n\t        viewHasNativeScrolling: function() {\n\t            var view = this.view();\n\t            return view && view.options.useNativeScrolling;\n\t        },\n\n\t        container: function() {\n\t            var element = this.element.closest(kendo.roleSelector(\"view layout modalview drawer splitview\"));\n\t            return kendo.widgetInstance(element.eq(0), kendo.mobile.ui) || ContainerNullObject;\n\t        }\n\t    });\n\n\t    extend(kendo.mobile, {\n\t        init: function(element) {\n\t            kendo.init(element, kendo.mobile.ui, kendo.ui, kendo.dataviz.ui);\n\t        },\n\n\t        appLevelNativeScrolling: function() {\n\t            return kendo.mobile.application && kendo.mobile.application.options && kendo.mobile.application.options.useNativeScrolling;\n\t        },\n\n\t        roles: {},\n\n\t        ui: {\n\t            Widget: MobileWidget,\n\t            DataBoundWidget: DataBoundWidget.extend(MobileWidget.prototype),\n\t            roles: {},\n\t            plugin: function(widget) {\n\t                kendo.ui.plugin(widget, kendo.mobile.ui, \"Mobile\");\n\t            }\n\t        }\n\t    });\n\n\t    deepExtend(kendo.dataviz, {\n\t        init: function(element) {\n\t            kendo.init(element, kendo.dataviz.ui);\n\t        },\n\t        ui: {\n\t            roles: {},\n\t            themes: {},\n\t            views: [],\n\t            plugin: function(widget) {\n\t                kendo.ui.plugin(widget, kendo.dataviz.ui);\n\t            }\n\t        },\n\t        roles: {}\n\t    });\n\n\t    kendo.touchScroller = function(elements, options) {\n\t        // return the first touch scroller\n\t        if (!options){ options = {}; }\n\n\t        options.useNative = true;\n\n\t        return $(elements).map(function(idx, element) {\n\t            element = $(element);\n\t            if (support.kineticScrollNeeded && kendo.mobile.ui.Scroller && !element.data(\"kendoMobileScroller\")) {\n\t                element.kendoMobileScroller(options);\n\t                return element.data(\"kendoMobileScroller\");\n\t            } else {\n\t                return false;\n\t            }\n\t        })[0];\n\t    };\n\n\t    kendo.preventDefault = function(e) {\n\t        e.preventDefault();\n\t    };\n\n\t    kendo.widgetInstance = function(element, suites) {\n\t        var role = element.data(kendo.ns + \"role\"),\n\t            widgets = [], i, length;\n\n\t        if (role) {\n\t            // HACK!!! mobile view scroller widgets are instantiated on data-role=\"content\" elements. We need to discover them when resizing.\n\t            if (role === \"content\") {\n\t                role = \"scroller\";\n\t            }\n\n\t            // kendoEditorToolbar is not a public plugin, thus it does not exist in kendo.ui.roles.\n\t            // Therefore, this is needed in order to be resized when placed in Kendo Window.\n\t            if (role === \"editortoolbar\") {\n\t                var editorToolbar = element.data(\"kendoEditorToolbar\");\n\t                if (editorToolbar) {\n\t                    return editorToolbar;\n\t                }\n\t            }\n\n\t            if (suites) {\n\t                if (suites[0]) {\n\t                    for (i = 0, length = suites.length; i < length; i ++) {\n\t                        widgets.push(suites[i].roles[role]);\n\t                    }\n\t                } else {\n\t                    widgets.push(suites.roles[role]);\n\t                }\n\t            }\n\t            else {\n\t                widgets = [ kendo.ui.roles[role], kendo.dataviz.ui.roles[role],  kendo.mobile.ui.roles[role] ];\n\t            }\n\n\t            if (role.indexOf(\".\") >= 0) {\n\t                widgets = [ kendo.getter(role)(window) ];\n\t            }\n\n\t            for (i = 0, length = widgets.length; i < length; i ++) {\n\t                var widget = widgets[i];\n\t                if (widget) {\n\t                    var instance = element.data(\"kendo\" + widget.fn.options.prefix + widget.fn.options.name);\n\t                    if (instance) {\n\t                        return instance;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    };\n\n\t    kendo.onResize = function(callback) {\n\t        var handler = callback;\n\t        if (support.mobileOS.android) {\n\t            handler = function() { setTimeout(callback, 600); };\n\t        }\n\n\t        $(window).on(support.resize, handler);\n\t        return handler;\n\t    };\n\n\t    kendo.unbindResize = function(callback) {\n\t        $(window).off(support.resize, callback);\n\t    };\n\n\t    kendo.attrValue = function(element, key) {\n\t        return element.data(kendo.ns + key);\n\t    };\n\n\t    kendo.days = {\n\t        Sunday: 0,\n\t        Monday: 1,\n\t        Tuesday: 2,\n\t        Wednesday: 3,\n\t        Thursday: 4,\n\t        Friday: 5,\n\t        Saturday: 6\n\t    };\n\n\t    function focusable(element, isTabIndexNotNaN) {\n\t        var nodeName = element.nodeName.toLowerCase();\n\n\t        return (/input|select|textarea|button|object/.test(nodeName) ?\n\t                !element.disabled :\n\t                \"a\" === nodeName ?\n\t                element.href || isTabIndexNotNaN :\n\t                isTabIndexNotNaN\n\t               ) &&\n\t            visible(element);\n\t    }\n\n\t    function visible(element) {\n\t        return $.expr.filters.visible(element) &&\n\t            !$(element).parents().addBack().filter(function() {\n\t                return $.css(this,\"visibility\") === \"hidden\";\n\t            }).length;\n\t    }\n\n\t    $.extend($.expr[ \":\" ], {\n\t        kendoFocusable: function(element) {\n\t            var idx = $.attr(element, \"tabindex\");\n\t            return focusable(element, !isNaN(idx) && idx > -1);\n\t        }\n\t    });\n\n\t    var MOUSE_EVENTS = [\"mousedown\", \"mousemove\", \"mouseenter\", \"mouseleave\", \"mouseover\", \"mouseout\", \"mouseup\", \"click\"];\n\t    var EXCLUDE_BUST_CLICK_SELECTOR = \"label, input, [data-rel=external]\";\n\n\t    var MouseEventNormalizer = {\n\t        setupMouseMute: function() {\n\t            var idx = 0,\n\t                length = MOUSE_EVENTS.length,\n\t                element = document.documentElement;\n\n\t            if (MouseEventNormalizer.mouseTrap || !support.eventCapture) {\n\t                return;\n\t            }\n\n\t            MouseEventNormalizer.mouseTrap = true;\n\n\t            MouseEventNormalizer.bustClick = false;\n\t            MouseEventNormalizer.captureMouse = false;\n\n\t            var handler = function(e) {\n\t                if (MouseEventNormalizer.captureMouse) {\n\t                    if (e.type === \"click\") {\n\t                        if (MouseEventNormalizer.bustClick && !$(e.target).is(EXCLUDE_BUST_CLICK_SELECTOR)) {\n\t                            e.preventDefault();\n\t                            e.stopPropagation();\n\t                        }\n\t                    } else {\n\t                        e.stopPropagation();\n\t                    }\n\t                }\n\t            };\n\n\t            for (; idx < length; idx++) {\n\t                element.addEventListener(MOUSE_EVENTS[idx], handler, true);\n\t            }\n\t        },\n\n\t        muteMouse: function(e) {\n\t            MouseEventNormalizer.captureMouse = true;\n\t            if (e.data.bustClick) {\n\t                MouseEventNormalizer.bustClick = true;\n\t            }\n\t            clearTimeout(MouseEventNormalizer.mouseTrapTimeoutID);\n\t        },\n\n\t        unMuteMouse: function() {\n\t            clearTimeout(MouseEventNormalizer.mouseTrapTimeoutID);\n\t            MouseEventNormalizer.mouseTrapTimeoutID = setTimeout(function() {\n\t                MouseEventNormalizer.captureMouse = false;\n\t                MouseEventNormalizer.bustClick = false;\n\t            }, 400);\n\t        }\n\t    };\n\n\t    var eventMap = {\n\t        down: \"touchstart mousedown\",\n\t        move: \"mousemove touchmove\",\n\t        up: \"mouseup touchend touchcancel\",\n\t        cancel: \"mouseleave touchcancel\"\n\t    };\n\n\t    if (support.touch && (support.mobileOS.ios || support.mobileOS.android)) {\n\t        eventMap = {\n\t            down: \"touchstart\",\n\t            move: \"touchmove\",\n\t            up: \"touchend touchcancel\",\n\t            cancel: \"touchcancel\"\n\t        };\n\t    } else if (support.pointers) {\n\t        eventMap = {\n\t            down: \"pointerdown\",\n\t            move: \"pointermove\",\n\t            up: \"pointerup\",\n\t            cancel: \"pointercancel pointerleave\"\n\t        };\n\t    } else if (support.msPointers) {\n\t        eventMap = {\n\t            down: \"MSPointerDown\",\n\t            move: \"MSPointerMove\",\n\t            up: \"MSPointerUp\",\n\t            cancel: \"MSPointerCancel MSPointerLeave\"\n\t        };\n\t    }\n\n\t    if (support.msPointers && !(\"onmspointerenter\" in window)) { // IE10\n\t        // Create MSPointerEnter/MSPointerLeave events using mouseover/out and event-time checks\n\t        $.each({\n\t            MSPointerEnter: \"MSPointerOver\",\n\t            MSPointerLeave: \"MSPointerOut\"\n\t        }, function( orig, fix ) {\n\t            $.event.special[ orig ] = {\n\t                delegateType: fix,\n\t                bindType: fix,\n\n\t                handle: function( event ) {\n\t                    var ret,\n\t                        target = this,\n\t                        related = event.relatedTarget,\n\t                        handleObj = event.handleObj;\n\n\t                    // For mousenter/leave call the handler if related is outside the target.\n\t                    // NB: No relatedTarget if the mouse left/entered the browser window\n\t                    if ( !related || (related !== target && !$.contains( target, related )) ) {\n\t                        event.type = handleObj.origType;\n\t                        ret = handleObj.handler.apply( this, arguments );\n\t                        event.type = fix;\n\t                    }\n\t                    return ret;\n\t                }\n\t            };\n\t        });\n\t    }\n\n\n\t    var getEventMap = function(e) { return (eventMap[e] || e); },\n\t        eventRegEx = /([^ ]+)/g;\n\n\t    kendo.applyEventMap = function(events, ns) {\n\t        events = events.replace(eventRegEx, getEventMap);\n\n\t        if (ns) {\n\t            events = events.replace(eventRegEx, \"$1.\" + ns);\n\t        }\n\n\t        return events;\n\t    };\n\n\t    var on = $.fn.on;\n\n\t    function kendoJQuery(selector, context) {\n\t        return new kendoJQuery.fn.init(selector, context);\n\t    }\n\n\t    extend(true, kendoJQuery, $);\n\n\t    kendoJQuery.fn = kendoJQuery.prototype = new $();\n\n\t    kendoJQuery.fn.constructor = kendoJQuery;\n\n\t    kendoJQuery.fn.init = function(selector, context) {\n\t        if (context && context instanceof $ && !(context instanceof kendoJQuery)) {\n\t            context = kendoJQuery(context);\n\t        }\n\n\t        return $.fn.init.call(this, selector, context, rootjQuery);\n\t    };\n\n\t    kendoJQuery.fn.init.prototype = kendoJQuery.fn;\n\n\t    var rootjQuery = kendoJQuery(document);\n\n\t    extend(kendoJQuery.fn, {\n\t        handler: function(handler) {\n\t            this.data(\"handler\", handler);\n\t            return this;\n\t        },\n\n\t        autoApplyNS: function(ns) {\n\t            this.data(\"kendoNS\", ns || kendo.guid());\n\t            return this;\n\t        },\n\n\t        on: function() {\n\t            var that = this,\n\t                ns = that.data(\"kendoNS\");\n\n\t            // support for event map signature\n\t            if (arguments.length === 1) {\n\t                return on.call(that, arguments[0]);\n\t            }\n\n\t            var context = that,\n\t                args = slice.call(arguments);\n\n\t            if (typeof args[args.length -1] === UNDEFINED) {\n\t                args.pop();\n\t            }\n\n\t            var callback =  args[args.length - 1],\n\t                events = kendo.applyEventMap(args[0], ns);\n\n\t            // setup mouse trap\n\t            if (support.mouseAndTouchPresent && events.search(/mouse|click/) > -1 && this[0] !== document.documentElement) {\n\t                MouseEventNormalizer.setupMouseMute();\n\n\t                var selector = args.length === 2 ? null : args[1],\n\t                    bustClick = events.indexOf(\"click\") > -1 && events.indexOf(\"touchend\") > -1;\n\n\t                on.call(this,\n\t                    {\n\t                        touchstart: MouseEventNormalizer.muteMouse,\n\t                        touchend: MouseEventNormalizer.unMuteMouse\n\t                    },\n\t                    selector,\n\t                    {\n\t                        bustClick: bustClick\n\t                    });\n\t            }\n\n\t            if (typeof callback === STRING) {\n\t                context = that.data(\"handler\");\n\t                callback = context[callback];\n\n\t                args[args.length - 1] = function(e) {\n\t                    callback.call(context, e);\n\t                };\n\t            }\n\n\t            args[0] = events;\n\n\t            on.apply(that, args);\n\n\t            return that;\n\t        },\n\n\t        kendoDestroy: function(ns) {\n\t            ns = ns || this.data(\"kendoNS\");\n\n\t            if (ns) {\n\t                this.off(\".\" + ns);\n\t            }\n\n\t            return this;\n\t        }\n\t    });\n\n\t    kendo.jQuery = kendoJQuery;\n\t    kendo.eventMap = eventMap;\n\n\t    kendo.timezone = (function(){\n\t        var months =  { Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5, Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11 };\n\t        var days = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 };\n\n\t        function ruleToDate(year, rule) {\n\t            var date;\n\t            var targetDay;\n\t            var ourDay;\n\t            var month = rule[3];\n\t            var on = rule[4];\n\t            var time = rule[5];\n\t            var cache = rule[8];\n\n\t            if (!cache) {\n\t                rule[8] = cache = {};\n\t            }\n\n\t            if (cache[year]) {\n\t                return cache[year];\n\t            }\n\n\t            if (!isNaN(on)) {\n\t                date = new Date(Date.UTC(year, months[month], on, time[0], time[1], time[2], 0));\n\t            } else if (on.indexOf(\"last\") === 0) {\n\t                date = new Date(Date.UTC(year, months[month] + 1, 1, time[0] - 24, time[1], time[2], 0));\n\n\t                targetDay = days[on.substr(4, 3)];\n\t                ourDay = date.getUTCDay();\n\n\t                date.setUTCDate(date.getUTCDate() + targetDay - ourDay - (targetDay > ourDay ? 7 : 0));\n\t            } else if (on.indexOf(\">=\") >= 0) {\n\t                date = new Date(Date.UTC(year, months[month], on.substr(5), time[0], time[1], time[2], 0));\n\n\t                targetDay = days[on.substr(0, 3)];\n\t                ourDay = date.getUTCDay();\n\n\t                date.setUTCDate(date.getUTCDate() + targetDay - ourDay + (targetDay < ourDay ? 7 : 0));\n\t            }\n\n\t            return cache[year] = date;\n\t        }\n\n\t        function findRule(utcTime, rules, zone) {\n\t            rules = rules[zone];\n\n\t            if (!rules) {\n\t                var time = zone.split(\":\");\n\t                var offset = 0;\n\n\t                if (time.length > 1) {\n\t                    offset = time[0] * 60 + Number(time[1]);\n\t                }\n\n\t                return [-1000000, 'max', '-', 'Jan', 1, [0, 0, 0], offset, '-'];\n\t            }\n\n\t            var year = new Date(utcTime).getUTCFullYear();\n\n\t            rules = jQuery.grep(rules, function(rule) {\n\t                var from = rule[0];\n\t                var to = rule[1];\n\n\t                return from <= year && (to >= year || (from == year && to == \"only\") || to == \"max\");\n\t            });\n\n\t            rules.push(utcTime);\n\n\t            rules.sort(function(a, b) {\n\t                if (typeof a != \"number\") {\n\t                    a = Number(ruleToDate(year, a));\n\t                }\n\n\t                if (typeof b != \"number\") {\n\t                    b = Number(ruleToDate(year, b));\n\t                }\n\n\t                return a - b;\n\t            });\n\n\t            var rule = rules[jQuery.inArray(utcTime, rules) - 1] || rules[rules.length - 1];\n\n\t            return isNaN(rule) ? rule : null;\n\t        }\n\n\t        function findZone(utcTime, zones, timezone) {\n\t            var zoneRules = zones[timezone];\n\n\t            if (typeof zoneRules === \"string\") {\n\t                zoneRules = zones[zoneRules];\n\t            }\n\n\t            if (!zoneRules) {\n\t                throw new Error('Timezone \"' + timezone + '\" is either incorrect, or kendo.timezones.min.js is not included.');\n\t            }\n\n\t            for (var idx = zoneRules.length - 1; idx >= 0; idx--) {\n\t                var until = zoneRules[idx][3];\n\n\t                if (until && utcTime > until) {\n\t                    break;\n\t                }\n\t            }\n\n\t            var zone = zoneRules[idx + 1];\n\n\t            if (!zone) {\n\t                throw new Error('Timezone \"' + timezone + '\" not found on ' + utcTime + \".\");\n\t            }\n\n\t            return zone;\n\t        }\n\n\t        function zoneAndRule(utcTime, zones, rules, timezone) {\n\t            if (typeof utcTime != NUMBER) {\n\t                utcTime = Date.UTC(utcTime.getFullYear(), utcTime.getMonth(),\n\t                    utcTime.getDate(), utcTime.getHours(), utcTime.getMinutes(),\n\t                    utcTime.getSeconds(), utcTime.getMilliseconds());\n\t            }\n\n\t            var zone = findZone(utcTime, zones, timezone);\n\n\t            return {\n\t                zone: zone,\n\t                rule: findRule(utcTime, rules, zone[1])\n\t            };\n\t        }\n\n\t        function offset(utcTime, timezone) {\n\t            if (timezone == \"Etc/UTC\" || timezone == \"Etc/GMT\") {\n\t                return 0;\n\t            }\n\n\t            var info = zoneAndRule(utcTime, this.zones, this.rules, timezone);\n\t            var zone = info.zone;\n\t            var rule = info.rule;\n\n\t            return kendo.parseFloat(rule? zone[0] - rule[6] : zone[0]);\n\t        }\n\n\t        function abbr(utcTime, timezone) {\n\t            var info = zoneAndRule(utcTime, this.zones, this.rules, timezone);\n\t            var zone = info.zone;\n\t            var rule = info.rule;\n\n\t            var base = zone[2];\n\n\t            if (base.indexOf(\"/\") >= 0) {\n\t                return base.split(\"/\")[rule && +rule[6] ? 1 : 0];\n\t            } else if (base.indexOf(\"%s\") >= 0) {\n\t                return base.replace(\"%s\", (!rule || rule[7] == \"-\") ? '' : rule[7]);\n\t            }\n\n\t            return base;\n\t        }\n\n\t        function convert(date, fromOffset, toOffset) {\n\t            var tempToOffset = toOffset;\n\t            var diff;\n\n\t            if (typeof fromOffset == STRING) {\n\t                fromOffset = this.offset(date, fromOffset);\n\t            }\n\n\t            if (typeof toOffset == STRING) {\n\t                toOffset = this.offset(date, toOffset);\n\t            }\n\n\t            var fromLocalOffset = date.getTimezoneOffset();\n\n\t            date = new Date(date.getTime() + (fromOffset - toOffset) * 60000);\n\n\t            var toLocalOffset = date.getTimezoneOffset();\n\n\t            if (typeof tempToOffset == STRING) {\n\t                tempToOffset = this.offset(date, tempToOffset);\n\t            }\n\n\t            diff = (toLocalOffset - fromLocalOffset) + (toOffset - tempToOffset);\n\n\t            return new Date(date.getTime() + diff * 60000);\n\t        }\n\n\t        function apply(date, timezone) {\n\t           return this.convert(date, date.getTimezoneOffset(), timezone);\n\t        }\n\n\t        function remove(date, timezone) {\n\t           return this.convert(date, timezone, date.getTimezoneOffset());\n\t        }\n\n\t        function toLocalDate(time) {\n\t            return this.apply(new Date(time), \"Etc/UTC\");\n\t        }\n\n\t        return {\n\t           zones: {},\n\t           rules: {},\n\t           offset: offset,\n\t           convert: convert,\n\t           apply: apply,\n\t           remove: remove,\n\t           abbr: abbr,\n\t           toLocalDate: toLocalDate\n\t        };\n\t    })();\n\n\t    kendo.date = (function(){\n\t        var MS_PER_MINUTE = 60000,\n\t            MS_PER_DAY = 86400000;\n\n\t        function adjustDST(date, hours) {\n\t            if (hours === 0 && date.getHours() === 23) {\n\t                date.setHours(date.getHours() + 2);\n\t                return true;\n\t            }\n\n\t            return false;\n\t        }\n\n\t        function setDayOfWeek(date, day, dir) {\n\t            var hours = date.getHours();\n\n\t            dir = dir || 1;\n\t            day = ((day - date.getDay()) + (7 * dir)) % 7;\n\n\t            date.setDate(date.getDate() + day);\n\t            adjustDST(date, hours);\n\t        }\n\n\t        function dayOfWeek(date, day, dir) {\n\t            date = new Date(date);\n\t            setDayOfWeek(date, day, dir);\n\t            return date;\n\t        }\n\n\t        function firstDayOfMonth(date) {\n\t            return new Date(\n\t                date.getFullYear(),\n\t                date.getMonth(),\n\t                1\n\t            );\n\t        }\n\n\t        function lastDayOfMonth(date) {\n\t            var last = new Date(date.getFullYear(), date.getMonth() + 1, 0),\n\t                first = firstDayOfMonth(date),\n\t                timeOffset = Math.abs(last.getTimezoneOffset() - first.getTimezoneOffset());\n\n\t            if (timeOffset) {\n\t                last.setHours(first.getHours() + (timeOffset / 60));\n\t            }\n\n\t            return last;\n\t        }\n\n\t        function moveDateToWeekStart(date, weekStartDay) {\n\t            if (weekStartDay !== 1) {\n\t                return addDays(dayOfWeek(date, weekStartDay, -1), 4);\n\t            }\n\n\t            return addDays(date, (4 - (date.getDay() || 7)));\n\t        }\n\n\t        function calcWeekInYear(date, weekStartDay) {\n\t            var firstWeekInYear = new Date(date.getFullYear(), 0, 1, -6);\n\n\t            var newDate = moveDateToWeekStart(date, weekStartDay);\n\n\t            var diffInMS = newDate.getTime() - firstWeekInYear.getTime();\n\n\t            var days = Math.floor(diffInMS / MS_PER_DAY);\n\n\t            return 1 + Math.floor(days / 7);\n\t        }\n\n\t        function weekInYear(date, weekStartDay) {\n\t            if(weekStartDay === undefined) {\n\t                weekStartDay = kendo.culture().calendar.firstDay;\n\t            }\n\n\t            var prevWeekDate = addDays(date, -7);\n\t            var nextWeekDate = addDays(date, 7);\n\n\t            var weekNumber = calcWeekInYear(date, weekStartDay);\n\n\t            if (weekNumber === 0) {\n\t                return calcWeekInYear(prevWeekDate, weekStartDay) + 1;\n\t            }\n\n\t            if (weekNumber === 53 && calcWeekInYear(nextWeekDate, weekStartDay) > 1) {\n\t                return 1;\n\t            }\n\n\t            return weekNumber;\n\t        }\n\n\t        function getDate(date) {\n\t            date = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);\n\t            adjustDST(date, 0);\n\t            return date;\n\t        }\n\n\t        function toUtcTime(date) {\n\t            return Date.UTC(date.getFullYear(), date.getMonth(),\n\t                        date.getDate(), date.getHours(), date.getMinutes(),\n\t                        date.getSeconds(), date.getMilliseconds());\n\t        }\n\n\t        function getMilliseconds(date) {\n\t            return toInvariantTime(date).getTime() - getDate(toInvariantTime(date));\n\t        }\n\n\t        function isInTimeRange(value, min, max) {\n\t            var msMin = getMilliseconds(min),\n\t                msMax = getMilliseconds(max),\n\t                msValue;\n\n\t            if (!value || msMin == msMax) {\n\t                return true;\n\t            }\n\n\t            if (min >= max) {\n\t                max += MS_PER_DAY;\n\t            }\n\n\t            msValue = getMilliseconds(value);\n\n\t            if (msMin > msValue) {\n\t                msValue += MS_PER_DAY;\n\t            }\n\n\t            if (msMax < msMin) {\n\t                msMax += MS_PER_DAY;\n\t            }\n\n\t            return msValue >= msMin && msValue <= msMax;\n\t        }\n\n\t        function isInDateRange(value, min, max) {\n\t            var msMin = min.getTime(),\n\t                msMax = max.getTime(),\n\t                msValue;\n\n\t            if (msMin >= msMax) {\n\t                msMax += MS_PER_DAY;\n\t            }\n\n\t            msValue = value.getTime();\n\n\t            return msValue >= msMin && msValue <= msMax;\n\t        }\n\n\t        function addDays(date, offset) {\n\t            var hours = date.getHours();\n\t                date = new Date(date);\n\n\t            setTime(date, offset * MS_PER_DAY);\n\t            adjustDST(date, hours);\n\t            return date;\n\t        }\n\n\t        function setTime(date, milliseconds, ignoreDST) {\n\t            var offset = date.getTimezoneOffset();\n\t            var difference;\n\n\t            date.setTime(date.getTime() + milliseconds);\n\n\t            if (!ignoreDST) {\n\t                difference = date.getTimezoneOffset() - offset;\n\t                date.setTime(date.getTime() + difference * MS_PER_MINUTE);\n\t            }\n\t        }\n\n\t        function setHours(date, time) {\n\t            date = new Date(kendo.date.getDate(date).getTime() + kendo.date.getMilliseconds(time));\n\t            adjustDST(date, time.getHours());\n\t            return date;\n\t        }\n\n\t        function today() {\n\t            return getDate(new Date());\n\t        }\n\n\t        function isToday(date) {\n\t           return getDate(date).getTime() == today().getTime();\n\t        }\n\n\t        function toInvariantTime(date) {\n\t            var staticDate = new Date(1980, 1, 1, 0, 0, 0);\n\n\t            if (date) {\n\t                staticDate.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n\t            }\n\n\t            return staticDate;\n\t        }\n\n\t        return {\n\t            adjustDST: adjustDST,\n\t            dayOfWeek: dayOfWeek,\n\t            setDayOfWeek: setDayOfWeek,\n\t            getDate: getDate,\n\t            isInDateRange: isInDateRange,\n\t            isInTimeRange: isInTimeRange,\n\t            isToday: isToday,\n\t            nextDay: function(date) {\n\t                return addDays(date, 1);\n\t            },\n\t            previousDay: function(date) {\n\t                return addDays(date, -1);\n\t            },\n\t            toUtcTime: toUtcTime,\n\t            MS_PER_DAY: MS_PER_DAY,\n\t            MS_PER_HOUR: 60 * MS_PER_MINUTE,\n\t            MS_PER_MINUTE: MS_PER_MINUTE,\n\t            setTime: setTime,\n\t            setHours: setHours,\n\t            addDays: addDays,\n\t            today: today,\n\t            toInvariantTime: toInvariantTime,\n\t            firstDayOfMonth: firstDayOfMonth,\n\t            lastDayOfMonth: lastDayOfMonth,\n\t            weekInYear: weekInYear,\n\t            getMilliseconds: getMilliseconds\n\t        };\n\t    })();\n\n\n\t    kendo.stripWhitespace = function(element) {\n\t        if (document.createNodeIterator) {\n\t            var iterator = document.createNodeIterator(element, NodeFilter.SHOW_TEXT, function(node) {\n\t                    return node.parentNode == element ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;\n\t                }, false);\n\n\t            while (iterator.nextNode()) {\n\t                if (iterator.referenceNode && !iterator.referenceNode.textContent.trim()) {\n\t                    iterator.referenceNode.parentNode.removeChild(iterator.referenceNode);\n\t                }\n\t            }\n\t        } else { // IE7/8 support\n\t            for (var i = 0; i < element.childNodes.length; i++) {\n\t                var child = element.childNodes[i];\n\n\t                if (child.nodeType == 3 && !/\\S/.test(child.nodeValue)) {\n\t                    element.removeChild(child);\n\t                    i--;\n\t                }\n\n\t                if (child.nodeType == 1) {\n\t                    kendo.stripWhitespace(child);\n\t                }\n\t            }\n\t        }\n\t    };\n\n\t    var animationFrame  = window.requestAnimationFrame       ||\n\t                          window.webkitRequestAnimationFrame ||\n\t                          window.mozRequestAnimationFrame    ||\n\t                          window.oRequestAnimationFrame      ||\n\t                          window.msRequestAnimationFrame     ||\n\t                          function(callback){ setTimeout(callback, 1000 / 60); };\n\n\t    kendo.animationFrame = function(callback) {\n\t        animationFrame.call(window, callback);\n\t    };\n\n\t    var animationQueue = [];\n\n\t    kendo.queueAnimation = function(callback) {\n\t        animationQueue[animationQueue.length] = callback;\n\t        if (animationQueue.length === 1) {\n\t            kendo.runNextAnimation();\n\t        }\n\t    };\n\n\t    kendo.runNextAnimation = function() {\n\t        kendo.animationFrame(function() {\n\t            if (animationQueue[0]) {\n\t                animationQueue.shift()();\n\t                if (animationQueue[0]) {\n\t                    kendo.runNextAnimation();\n\t                }\n\t            }\n\t        });\n\t    };\n\n\t    kendo.parseQueryStringParams = function(url) {\n\t        var queryString = url.split('?')[1] || \"\",\n\t            params = {},\n\t            paramParts = queryString.split(/&|=/),\n\t            length = paramParts.length,\n\t            idx = 0;\n\n\t        for (; idx < length; idx += 2) {\n\t            if(paramParts[idx] !== \"\") {\n\t                params[decodeURIComponent(paramParts[idx])] = decodeURIComponent(paramParts[idx + 1]);\n\t            }\n\t        }\n\n\t        return params;\n\t    };\n\n\t    kendo.elementUnderCursor = function(e) {\n\t        if (typeof e.x.client != \"undefined\") {\n\t            return document.elementFromPoint(e.x.client, e.y.client);\n\t        }\n\t    };\n\n\t    kendo.wheelDeltaY = function(jQueryEvent) {\n\t        var e = jQueryEvent.originalEvent,\n\t            deltaY = e.wheelDeltaY,\n\t            delta;\n\n\t            if (e.wheelDelta) { // Webkit and IE\n\t                if (deltaY === undefined || deltaY) { // IE does not have deltaY, thus always scroll (horizontal scrolling is treated as vertical)\n\t                    delta = e.wheelDelta;\n\t                }\n\t            } else if (e.detail && e.axis === e.VERTICAL_AXIS) { // Firefox and Opera\n\t                delta = (-e.detail) * 10;\n\t            }\n\n\t        return delta;\n\t    };\n\n\t    kendo.throttle = function(fn, delay) {\n\t        var timeout;\n\t        var lastExecTime = 0;\n\n\t        if (!delay || delay <= 0) {\n\t            return fn;\n\t        }\n\n\t        var throttled = function() {\n\t            var that = this;\n\t            var elapsed = +new Date() - lastExecTime;\n\t            var args = arguments;\n\n\t            function exec() {\n\t                fn.apply(that, args);\n\t                lastExecTime = +new Date();\n\t            }\n\n\t            // first execution\n\t            if (!lastExecTime) {\n\t                return exec();\n\t            }\n\n\t            if (timeout) {\n\t                clearTimeout(timeout);\n\t            }\n\n\t            if (elapsed > delay) {\n\t                exec();\n\t            } else {\n\t                timeout = setTimeout(exec, delay - elapsed);\n\t            }\n\t        };\n\n\t        throttled.cancel = function() {\n\t            clearTimeout(timeout);\n\t        };\n\n\t        return throttled;\n\t    };\n\n\n\t    kendo.caret = function (element, start, end) {\n\t        var rangeElement;\n\t        var isPosition = start !== undefined;\n\n\t        if (end === undefined) {\n\t            end = start;\n\t        }\n\n\t        if (element[0]) {\n\t            element = element[0];\n\t        }\n\n\t        if (isPosition && element.disabled) {\n\t            return;\n\t        }\n\n\t        try {\n\t            if (element.selectionStart !== undefined) {\n\t                if (isPosition) {\n\t                    element.focus();\n\t                    var mobile = support.mobileOS;\n\t                    if(mobile.wp || mobile.android) {// without the timeout the caret is at the end of the input\n\t                        setTimeout(function() { element.setSelectionRange(start, end); }, 0);\n\t                    }\n\t                    else {\n\t                        element.setSelectionRange(start, end);\n\t                    }\n\t                } else {\n\t                    start = [element.selectionStart, element.selectionEnd];\n\t                }\n\t            } else if (document.selection) {\n\t                if ($(element).is(\":visible\")) {\n\t                    element.focus();\n\t                }\n\n\t                rangeElement = element.createTextRange();\n\n\t                if (isPosition) {\n\t                    rangeElement.collapse(true);\n\t                    rangeElement.moveStart(\"character\", start);\n\t                    rangeElement.moveEnd(\"character\", end - start);\n\t                    rangeElement.select();\n\t                } else {\n\t                    var rangeDuplicated = rangeElement.duplicate(),\n\t                        selectionStart, selectionEnd;\n\n\t                        rangeElement.moveToBookmark(document.selection.createRange().getBookmark());\n\t                        rangeDuplicated.setEndPoint('EndToStart', rangeElement);\n\t                        selectionStart = rangeDuplicated.text.length;\n\t                        selectionEnd = selectionStart + rangeElement.text.length;\n\n\t                    start = [selectionStart, selectionEnd];\n\t                }\n\t            }\n\t        } catch(e) {\n\t            /* element is not focused or it is not in the DOM */\n\t            start = [];\n\t        }\n\n\t        return start;\n\t    };\n\n\t    kendo.compileMobileDirective = function(element, scope) {\n\t        var angular = window.angular;\n\n\t        element.attr(\"data-\" + kendo.ns + \"role\", element[0].tagName.toLowerCase().replace('kendo-mobile-', '').replace('-', ''));\n\n\t        angular.element(element).injector().invoke([\"$compile\", function($compile) {\n\t            $compile(element)(scope);\n\n\t            if (!/^\\$(digest|apply)$/.test(scope.$$phase)) {\n\t                scope.$digest();\n\t            }\n\t        }]);\n\n\t        return kendo.widgetInstance(element, kendo.mobile.ui);\n\t    };\n\n\t    kendo.antiForgeryTokens = function() {\n\t        var tokens = { },\n\t            csrf_token = $(\"meta[name=csrf-token],meta[name=_csrf]\").attr(\"content\"),\n\t            csrf_param = $(\"meta[name=csrf-param],meta[name=_csrf_header]\").attr(\"content\");\n\n\t        $(\"input[name^='__RequestVerificationToken']\").each(function() {\n\t            tokens[this.name] = this.value;\n\t        });\n\n\t        if (csrf_param !== undefined && csrf_token !== undefined) {\n\t          tokens[csrf_param] = csrf_token;\n\t        }\n\n\t        return tokens;\n\t    };\n\n\t    kendo.cycleForm = function(form) {\n\t        var firstElement = form.find(\"input, .k-widget\").first();\n\t        var lastElement = form.find(\"button, .k-button\").last();\n\n\t        function focus(el) {\n\t            var widget = kendo.widgetInstance(el);\n\n\t            if (widget && widget.focus) {\n\t              widget.focus();\n\t            } else {\n\t              el.focus();\n\t            }\n\t        }\n\n\t        lastElement.on(\"keydown\", function(e) {\n\t          if (e.keyCode == kendo.keys.TAB && !e.shiftKey) {\n\t            e.preventDefault();\n\t            focus(firstElement);\n\t          }\n\t        });\n\n\t        firstElement.on(\"keydown\", function(e) {\n\t          if (e.keyCode == kendo.keys.TAB && e.shiftKey) {\n\t            e.preventDefault();\n\t            focus(lastElement);\n\t          }\n\t        });\n\t    };\n\n\t    kendo.focusElement = function(element) {\n\t        var scrollTopPositions = [];\n\t        var scrollableParents = element.parentsUntil(\"body\")\n\t                .filter(function(index, element) {\n\t                    var computedStyle = kendo.getComputedStyles(element, [\"overflow\"]);\n\t                    return computedStyle.overflow !== \"visible\";\n\t                })\n\t                .add(window);\n\n\t        scrollableParents.each(function(index, parent) {\n\t            scrollTopPositions[index] = $(parent).scrollTop();\n\t        });\n\n\t        try {\n\t            //The setActive method does not cause the document to scroll to the active object in the current page\n\t            element[0].setActive();\n\t        } catch (e) {\n\t            element[0].focus();\n\t        }\n\n\t        scrollableParents.each(function(index, parent) {\n\t            $(parent).scrollTop(scrollTopPositions[index]);\n\t        });\n\t    };\n\n\t    kendo.matchesMedia = function(mediaQuery) {\n\t        var media = kendo._bootstrapToMedia(mediaQuery) || mediaQuery;\n\t        return support.matchMedia && window.matchMedia(media).matches;\n\t    };\n\n\t    kendo._bootstrapToMedia = function(bootstrapMedia) {\n\t        return {\n\t            \"xs\": \"(max-width: 576px)\",\n\t            \"sm\": \"(min-width: 576px)\",\n\t            \"md\": \"(min-width: 768px)\",\n\t            \"lg\": \"(min-width: 992px)\",\n\t            \"xl\": \"(min-width: 1200px)\"\n\t        }[bootstrapMedia];\n\t    };\n\n\t    // kendo.saveAs -----------------------------------------------\n\t    (function() {\n\t        function postToProxy(dataURI, fileName, proxyURL, proxyTarget) {\n\t            var form = $(\"<form>\").attr({\n\t                action: proxyURL,\n\t                method: \"POST\",\n\t                target: proxyTarget\n\t            });\n\n\t            var data = kendo.antiForgeryTokens();\n\t            data.fileName = fileName;\n\n\t            var parts = dataURI.split(\";base64,\");\n\t            data.contentType = parts[0].replace(\"data:\", \"\");\n\t            data.base64 = parts[1];\n\n\t            for (var name in data) {\n\t                if (data.hasOwnProperty(name)) {\n\t                    $('<input>').attr({\n\t                        value: data[name],\n\t                        name: name,\n\t                        type: \"hidden\"\n\t                    }).appendTo(form);\n\t                }\n\t            }\n\n\t            form.appendTo(\"body\").submit().remove();\n\t        }\n\n\t        var fileSaver = document.createElement(\"a\");\n\t        var downloadAttribute = \"download\" in fileSaver && !kendo.support.browser.edge;\n\n\t        function saveAsBlob(dataURI, fileName) {\n\t            var blob = dataURI; // could be a Blob object\n\n\t            if (typeof dataURI == \"string\") {\n\t                var parts = dataURI.split(\";base64,\");\n\t                var contentType = parts[0];\n\t                var base64 = atob(parts[1]);\n\t                var array = new Uint8Array(base64.length);\n\n\t                for (var idx = 0; idx < base64.length; idx++) {\n\t                    array[idx] = base64.charCodeAt(idx);\n\t                }\n\t                blob = new Blob([array.buffer], { type: contentType });\n\t            }\n\n\t            navigator.msSaveBlob(blob, fileName);\n\t        }\n\n\t        function saveAsDataURI(dataURI, fileName) {\n\t            if (window.Blob && dataURI instanceof Blob) {\n\t                dataURI = URL.createObjectURL(dataURI);\n\t            }\n\n\t            fileSaver.download = fileName;\n\t            fileSaver.href = dataURI;\n\n\t            var e = document.createEvent(\"MouseEvents\");\n\t            e.initMouseEvent(\"click\", true, false, window,\n\t                0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\n\t            fileSaver.dispatchEvent(e);\n\t            setTimeout(function(){\n\t                URL.revokeObjectURL(dataURI);\n\t            });\n\t        }\n\n\t        kendo.saveAs = function(options) {\n\t            var save = postToProxy;\n\n\t            if (!options.forceProxy) {\n\t                if (downloadAttribute) {\n\t                    save = saveAsDataURI;\n\t                } else if (navigator.msSaveBlob) {\n\t                    save = saveAsBlob;\n\t                }\n\t            }\n\n\t            save(options.dataURI, options.fileName, options.proxyURL, options.proxyTarget);\n\t        };\n\t    })();\n\n\t    // kendo proxySetters\n\t    kendo.proxyModelSetters = function proxyModelSetters(data) {\n\t        var observable = {};\n\n\t        Object.keys(data || {}).forEach(function(property) {\n\t          Object.defineProperty(observable, property, {\n\t            get: function() {\n\t              return data[property];\n\t            },\n\t            set: function(value) {\n\t              data[property] = value;\n\t              data.dirty = true;\n\t            }\n\t          });\n\t        });\n\n\t        return observable;\n\t    };\n\n\t})(jQuery, window);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1003)))\n\n/***/ })\n\n/******/ });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDZkMzk4NWUyNTk4MjRkOTc2NzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb2dyZXNzL2tlbmRvLXVpL2pzL2tlbmRvLmNvcmUuanM/MzhmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuXG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyAwOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDQ1KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJkZWZpbmUgY2Fubm90IGJlIHVzZWQgaW5kaXJlY3RcIik7IH07XHJcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTAwMzpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJqcXVlcnlcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMDQ1OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOy8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihqUXVlcnkpIHsoZnVuY3Rpb24oZiwgZGVmaW5lKXtcblx0ICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMDMpXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGYpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID8gKF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XG5cdH0pKGZ1bmN0aW9uKCl7XG5cblx0dmFyIF9fbWV0YV9fID0geyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblx0ICAgIGlkOiBcImNvcmVcIixcblx0ICAgIG5hbWU6IFwiQ29yZVwiLFxuXHQgICAgY2F0ZWdvcnk6IFwiZnJhbWV3b3JrXCIsXG5cdCAgICBkZXNjcmlwdGlvbjogXCJUaGUgY29yZSBvZiB0aGUgS2VuZG8gZnJhbWV3b3JrLlwiXG5cdH07XG5cblx0Lypqc2hpbnQgZXFudWxsOiB0cnVlLCBsb29wZnVuYzogdHJ1ZSwgZXZpbDogdHJ1ZSwgYm9zczogdHJ1ZSwgZnJlZXplOiBmYWxzZSovXG5cdChmdW5jdGlvbigkLCB3aW5kb3csIHVuZGVmaW5lZCkge1xuXHQgICAgdmFyIGtlbmRvID0gd2luZG93LmtlbmRvID0gd2luZG93LmtlbmRvIHx8IHsgY3VsdHVyZXM6IHt9IH0sXG5cdCAgICAgICAgZXh0ZW5kID0gJC5leHRlbmQsXG5cdCAgICAgICAgZWFjaCA9ICQuZWFjaCxcblx0ICAgICAgICBpc0FycmF5ID0gJC5pc0FycmF5LFxuXHQgICAgICAgIHByb3h5ID0gJC5wcm94eSxcblx0ICAgICAgICBub29wID0gJC5ub29wLFxuXHQgICAgICAgIG1hdGggPSBNYXRoLFxuXHQgICAgICAgIFRlbXBsYXRlLFxuXHQgICAgICAgIEpTT04gPSB3aW5kb3cuSlNPTiB8fCB7fSxcblx0ICAgICAgICBzdXBwb3J0ID0ge30sXG5cdCAgICAgICAgcGVyY2VudFJlZ0V4cCA9IC8lLyxcblx0ICAgICAgICBmb3JtYXRSZWdFeHAgPSAvXFx7KFxcZCspKDpbXlxcfV0rKT9cXH0vZyxcblx0ICAgICAgICBib3hTaGFkb3dSZWdFeHAgPSAvKFxcZCsoPzpcXC4/KVxcZCopcHhcXHMqKFxcZCsoPzpcXC4/KVxcZCopcHhcXHMqKFxcZCsoPzpcXC4/KVxcZCopcHhcXHMqKFxcZCspPy9pLFxuXHQgICAgICAgIG51bWJlclJlZ0V4cCA9IC9eKFxcK3wtPylcXGQrKFxcLj8pXFxkKiQvLFxuXHQgICAgICAgIEZVTkNUSU9OID0gXCJmdW5jdGlvblwiLFxuXHQgICAgICAgIFNUUklORyA9IFwic3RyaW5nXCIsXG5cdCAgICAgICAgTlVNQkVSID0gXCJudW1iZXJcIixcblx0ICAgICAgICBPQkpFQ1QgPSBcIm9iamVjdFwiLFxuXHQgICAgICAgIE5VTEwgPSBcIm51bGxcIixcblx0ICAgICAgICBCT09MRUFOID0gXCJib29sZWFuXCIsXG5cdCAgICAgICAgVU5ERUZJTkVEID0gXCJ1bmRlZmluZWRcIixcblx0ICAgICAgICBnZXR0ZXJDYWNoZSA9IHt9LFxuXHQgICAgICAgIHNldHRlckNhY2hlID0ge30sXG5cdCAgICAgICAgc2xpY2UgPSBbXS5zbGljZTtcblxuXHQgICAga2VuZG8udmVyc2lvbiA9IFwiMjAxOC4zLjEyMTJcIi5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG5cblx0ICAgIGZ1bmN0aW9uIENsYXNzKCkge31cblxuXHQgICAgQ2xhc3MuZXh0ZW5kID0gZnVuY3Rpb24ocHJvdG8pIHtcblx0ICAgICAgICB2YXIgYmFzZSA9IGZ1bmN0aW9uKCkge30sXG5cdCAgICAgICAgICAgIG1lbWJlcixcblx0ICAgICAgICAgICAgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgIHN1YmNsYXNzID0gcHJvdG8gJiYgcHJvdG8uaW5pdCA/IHByb3RvLmluaXQgOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICB0aGF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGZuO1xuXG5cdCAgICAgICAgYmFzZS5wcm90b3R5cGUgPSB0aGF0LnByb3RvdHlwZTtcblx0ICAgICAgICBmbiA9IHN1YmNsYXNzLmZuID0gc3ViY2xhc3MucHJvdG90eXBlID0gbmV3IGJhc2UoKTtcblxuXHQgICAgICAgIGZvciAobWVtYmVyIGluIHByb3RvKSB7XG5cdCAgICAgICAgICAgIGlmIChwcm90b1ttZW1iZXJdICE9IG51bGwgJiYgcHJvdG9bbWVtYmVyXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBNZXJnZSBvYmplY3QgbWVtYmVyc1xuXHQgICAgICAgICAgICAgICAgZm5bbWVtYmVyXSA9IGV4dGVuZCh0cnVlLCB7fSwgYmFzZS5wcm90b3R5cGVbbWVtYmVyXSwgcHJvdG9bbWVtYmVyXSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBmblttZW1iZXJdID0gcHJvdG9bbWVtYmVyXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZuLmNvbnN0cnVjdG9yID0gc3ViY2xhc3M7XG5cdCAgICAgICAgc3ViY2xhc3MuZXh0ZW5kID0gdGhhdC5leHRlbmQ7XG5cblx0ICAgICAgICByZXR1cm4gc3ViY2xhc3M7XG5cdCAgICB9O1xuXG5cdCAgICBDbGFzcy5wcm90b3R5cGUuX2luaXRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgICAgICAgIHRoaXMub3B0aW9ucyA9IGRlZXBFeHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cdCAgICB9O1xuXG5cdCAgICB2YXIgaXNGdW5jdGlvbiA9IGtlbmRvLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihmbikge1xuXHQgICAgICAgIHJldHVybiB0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIjtcblx0ICAgIH07XG5cblx0ICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHRoaXMuX2RlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuXHQgICAgfTtcblxuXHQgICAgdmFyIGlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0UHJldmVudGVkID09PSB0cnVlO1xuXHQgICAgfTtcblxuXHQgICAgdmFyIE9ic2VydmFibGUgPSBDbGFzcy5leHRlbmQoe1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9ldmVudHMgPSB7fTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmluZDogZnVuY3Rpb24oZXZlbnROYW1lLCBoYW5kbGVycywgb25lKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcblx0ICAgICAgICAgICAgICAgIGlkeCxcblx0ICAgICAgICAgICAgICAgIGV2ZW50TmFtZXMgPSB0eXBlb2YgZXZlbnROYW1lID09PSBTVFJJTkcgPyBbZXZlbnROYW1lXSA6IGV2ZW50TmFtZSxcblx0ICAgICAgICAgICAgICAgIGxlbmd0aCxcblx0ICAgICAgICAgICAgICAgIG9yaWdpbmFsLFxuXHQgICAgICAgICAgICAgICAgaGFuZGxlcixcblx0ICAgICAgICAgICAgICAgIGhhbmRsZXJzSXNGdW5jdGlvbiA9IHR5cGVvZiBoYW5kbGVycyA9PT0gRlVOQ1RJT04sXG5cdCAgICAgICAgICAgICAgICBldmVudHM7XG5cblx0ICAgICAgICAgICAgaWYgKGhhbmRsZXJzID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAoaWR4IGluIGV2ZW50TmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuYmluZChpZHgsIGV2ZW50TmFtZVtpZHhdKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGF0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSBldmVudE5hbWVzLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lc1tpZHhdO1xuXG5cdCAgICAgICAgICAgICAgICBoYW5kbGVyID0gaGFuZGxlcnNJc0Z1bmN0aW9uID8gaGFuZGxlcnMgOiBoYW5kbGVyc1tldmVudE5hbWVdO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvbmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWwgPSBoYW5kbGVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnVuYmluZChldmVudE5hbWUsIGhhbmRsZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWwuYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlci5vcmlnaW5hbCA9IG9yaWdpbmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBldmVudHMgPSB0aGF0Ll9ldmVudHNbZXZlbnROYW1lXSA9IHRoYXQuX2V2ZW50c1tldmVudE5hbWVdIHx8IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGV2ZW50cy5wdXNoKGhhbmRsZXIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHRoYXQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIG9uZTogZnVuY3Rpb24oZXZlbnROYW1lcywgaGFuZGxlcnMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluZChldmVudE5hbWVzLCBoYW5kbGVycywgdHJ1ZSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGZpcnN0OiBmdW5jdGlvbihldmVudE5hbWUsIGhhbmRsZXJzKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcblx0ICAgICAgICAgICAgICAgIGlkeCxcblx0ICAgICAgICAgICAgICAgIGV2ZW50TmFtZXMgPSB0eXBlb2YgZXZlbnROYW1lID09PSBTVFJJTkcgPyBbZXZlbnROYW1lXSA6IGV2ZW50TmFtZSxcblx0ICAgICAgICAgICAgICAgIGxlbmd0aCxcblx0ICAgICAgICAgICAgICAgIGhhbmRsZXIsXG5cdCAgICAgICAgICAgICAgICBoYW5kbGVyc0lzRnVuY3Rpb24gPSB0eXBlb2YgaGFuZGxlcnMgPT09IEZVTkNUSU9OLFxuXHQgICAgICAgICAgICAgICAgZXZlbnRzO1xuXG5cdCAgICAgICAgICAgIGZvciAoaWR4ID0gMCwgbGVuZ3RoID0gZXZlbnROYW1lcy5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZXNbaWR4XTtcblxuXHQgICAgICAgICAgICAgICAgaGFuZGxlciA9IGhhbmRsZXJzSXNGdW5jdGlvbiA/IGhhbmRsZXJzIDogaGFuZGxlcnNbZXZlbnROYW1lXTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBldmVudHMgPSB0aGF0Ll9ldmVudHNbZXZlbnROYW1lXSA9IHRoYXQuX2V2ZW50c1tldmVudE5hbWVdIHx8IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGV2ZW50cy51bnNoaWZ0KGhhbmRsZXIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHRoYXQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBldmVudHMgPSB0aGF0Ll9ldmVudHNbZXZlbnROYW1lXSxcblx0ICAgICAgICAgICAgICAgIGlkeCxcblx0ICAgICAgICAgICAgICAgIGxlbmd0aDtcblxuXHQgICAgICAgICAgICBpZiAoZXZlbnRzKSB7XG5cdCAgICAgICAgICAgICAgICBlID0gZSB8fCB7fTtcblxuXHQgICAgICAgICAgICAgICAgZS5zZW5kZXIgPSB0aGF0O1xuXG5cdCAgICAgICAgICAgICAgICBlLl9kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG5cblx0ICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQgPSBwcmV2ZW50RGVmYXVsdDtcblxuXHQgICAgICAgICAgICAgICAgZS5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBpc0RlZmF1bHRQcmV2ZW50ZWQ7XG5cblx0ICAgICAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5zbGljZSgpO1xuXG5cdCAgICAgICAgICAgICAgICBmb3IgKGlkeCA9IDAsIGxlbmd0aCA9IGV2ZW50cy5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBldmVudHNbaWR4XS5jYWxsKHRoYXQsIGUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZS5fZGVmYXVsdFByZXZlbnRlZCA9PT0gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgdW5iaW5kOiBmdW5jdGlvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgZXZlbnRzID0gdGhhdC5fZXZlbnRzW2V2ZW50TmFtZV0sXG5cdCAgICAgICAgICAgICAgICBpZHg7XG5cblx0ICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9ldmVudHMgPSB7fTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudHMpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpZHggPSBldmVudHMubGVuZ3RoIC0gMTsgaWR4ID49IDA7IGlkeC0tKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudHNbaWR4XSA9PT0gaGFuZGxlciB8fCBldmVudHNbaWR4XS5vcmlnaW5hbCA9PT0gaGFuZGxlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnNwbGljZShpZHgsIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0Ll9ldmVudHNbZXZlbnROYW1lXSA9IFtdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHRoYXQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblxuXHQgICAgIGZ1bmN0aW9uIGNvbXBpbGVQYXJ0KHBhcnQsIHN0cmluZ1BhcnQpIHtcblx0ICAgICAgICAgaWYgKHN0cmluZ1BhcnQpIHtcblx0ICAgICAgICAgICAgIHJldHVybiBcIidcIiArXG5cdCAgICAgICAgICAgICAgICAgcGFydC5zcGxpdChcIidcIikuam9pbihcIlxcXFwnXCIpXG5cdCAgICAgICAgICAgICAgICAgICAgIC5zcGxpdCgnXFxcXFwiJykuam9pbignXFxcXFxcXFxcXFxcXCInKVxuXHQgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIilcblx0ICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcci9nLCBcIlxcXFxyXCIpXG5cdCAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKSArIFwiJ1wiO1xuXHQgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgdmFyIGZpcnN0ID0gcGFydC5jaGFyQXQoMCksXG5cdCAgICAgICAgICAgICAgICAgcmVzdCA9IHBhcnQuc3Vic3RyaW5nKDEpO1xuXG5cdCAgICAgICAgICAgICBpZiAoZmlyc3QgPT09IFwiPVwiKSB7XG5cdCAgICAgICAgICAgICAgICAgcmV0dXJuIFwiKyhcIiArIHJlc3QgKyBcIikrXCI7XG5cdCAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpcnN0ID09PSBcIjpcIikge1xuXHQgICAgICAgICAgICAgICAgIHJldHVybiBcIiska2VuZG9IdG1sRW5jb2RlKFwiICsgcmVzdCArIFwiKStcIjtcblx0ICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgcmV0dXJuIFwiO1wiICsgcGFydCArIFwiOyRrZW5kb091dHB1dCs9XCI7XG5cdCAgICAgICAgICAgICB9XG5cdCAgICAgICAgIH1cblx0ICAgICB9XG5cblx0ICAgIHZhciBhcmd1bWVudE5hbWVSZWdFeHAgPSAvXlxcdysvLFxuXHQgICAgICAgIGVuY29kZVJlZ0V4cCA9IC9cXCRcXHsoW159XSopXFx9L2csXG5cdCAgICAgICAgZXNjYXBlZEN1cmx5UmVnRXhwID0gL1xcXFxcXH0vZyxcblx0ICAgICAgICBjdXJseVJlZ0V4cCA9IC9fX0NVUkxZX18vZyxcblx0ICAgICAgICBlc2NhcGVkU2hhcnBSZWdFeHAgPSAvXFxcXCMvZyxcblx0ICAgICAgICBzaGFycFJlZ0V4cCA9IC9fX1NIQVJQX18vZyxcblx0ICAgICAgICB6ZXJvcyA9IFtcIlwiLCBcIjBcIiwgXCIwMFwiLCBcIjAwMFwiLCBcIjAwMDBcIl07XG5cblx0ICAgIFRlbXBsYXRlID0ge1xuXHQgICAgICAgIHBhcmFtTmFtZTogXCJkYXRhXCIsIC8vIG5hbWUgb2YgdGhlIHBhcmFtZXRlciBvZiB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlXG5cdCAgICAgICAgdXNlV2l0aEJsb2NrOiB0cnVlLCAvLyB3aGV0aGVyIHRvIHdyYXAgdGhlIHRlbXBsYXRlIGluIGEgd2l0aCgpIGJsb2NrXG5cdCAgICAgICAgcmVuZGVyOiBmdW5jdGlvbih0ZW1wbGF0ZSwgZGF0YSkge1xuXHQgICAgICAgICAgICB2YXIgaWR4LFxuXHQgICAgICAgICAgICAgICAgbGVuZ3RoLFxuXHQgICAgICAgICAgICAgICAgaHRtbCA9IFwiXCI7XG5cblx0ICAgICAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgaHRtbCArPSB0ZW1wbGF0ZShkYXRhW2lkeF0pO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGh0bWw7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBjb21waWxlOiBmdW5jdGlvbih0ZW1wbGF0ZSwgb3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBleHRlbmQoe30sIHRoaXMsIG9wdGlvbnMpLFxuXHQgICAgICAgICAgICAgICAgcGFyYW1OYW1lID0gc2V0dGluZ3MucGFyYW1OYW1lLFxuXHQgICAgICAgICAgICAgICAgYXJndW1lbnROYW1lID0gcGFyYW1OYW1lLm1hdGNoKGFyZ3VtZW50TmFtZVJlZ0V4cClbMF0sXG5cdCAgICAgICAgICAgICAgICB1c2VXaXRoQmxvY2sgPSBzZXR0aW5ncy51c2VXaXRoQmxvY2ssXG5cdCAgICAgICAgICAgICAgICBmdW5jdGlvbkJvZHkgPSBcInZhciAka2VuZG9PdXRwdXQsICRrZW5kb0h0bWxFbmNvZGUgPSBrZW5kby5odG1sRW5jb2RlO1wiLFxuXHQgICAgICAgICAgICAgICAgZm4sXG5cdCAgICAgICAgICAgICAgICBwYXJ0cyxcblx0ICAgICAgICAgICAgICAgIGlkeDtcblxuXHQgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbih0ZW1wbGF0ZSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uQm9keSArPSB1c2VXaXRoQmxvY2sgPyBcIndpdGgoXCIgKyBwYXJhbU5hbWUgKyBcIil7XCIgOiBcIlwiO1xuXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uQm9keSArPSBcIiRrZW5kb091dHB1dD1cIjtcblxuXHQgICAgICAgICAgICBwYXJ0cyA9IHRlbXBsYXRlXG5cdCAgICAgICAgICAgICAgICAucmVwbGFjZShlc2NhcGVkQ3VybHlSZWdFeHAsIFwiX19DVVJMWV9fXCIpXG5cdCAgICAgICAgICAgICAgICAucmVwbGFjZShlbmNvZGVSZWdFeHAsIFwiIz0ka2VuZG9IdG1sRW5jb2RlKCQxKSNcIilcblx0ICAgICAgICAgICAgICAgIC5yZXBsYWNlKGN1cmx5UmVnRXhwLCBcIn1cIilcblx0ICAgICAgICAgICAgICAgIC5yZXBsYWNlKGVzY2FwZWRTaGFycFJlZ0V4cCwgXCJfX1NIQVJQX19cIilcblx0ICAgICAgICAgICAgICAgIC5zcGxpdChcIiNcIik7XG5cblx0ICAgICAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBwYXJ0cy5sZW5ndGg7IGlkeCArKykge1xuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb25Cb2R5ICs9IGNvbXBpbGVQYXJ0KHBhcnRzW2lkeF0sIGlkeCAlIDIgPT09IDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZnVuY3Rpb25Cb2R5ICs9IHVzZVdpdGhCbG9jayA/IFwiO31cIiA6IFwiO1wiO1xuXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uQm9keSArPSBcInJldHVybiAka2VuZG9PdXRwdXQ7XCI7XG5cblx0ICAgICAgICAgICAgZnVuY3Rpb25Cb2R5ID0gZnVuY3Rpb25Cb2R5LnJlcGxhY2Uoc2hhcnBSZWdFeHAsIFwiI1wiKTtcblxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgZm4gPSBuZXcgRnVuY3Rpb24oYXJndW1lbnROYW1lLCBmdW5jdGlvbkJvZHkpO1xuXHQgICAgICAgICAgICAgICAgZm4uX3Nsb3RDb3VudCA9IE1hdGguZmxvb3IocGFydHMubGVuZ3RoIC8gMik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZm47XG5cdCAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGtlbmRvLmZvcm1hdChcIkludmFsaWQgdGVtcGxhdGU6J3swfScgR2VuZXJhdGVkIGNvZGU6J3sxfSdcIiwgdGVtcGxhdGUsIGZ1bmN0aW9uQm9keSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHRmdW5jdGlvbiBwYWQobnVtYmVyLCBkaWdpdHMsIGVuZCkge1xuXHQgICAgbnVtYmVyID0gbnVtYmVyICsgXCJcIjtcblx0ICAgIGRpZ2l0cyA9IGRpZ2l0cyB8fCAyO1xuXHQgICAgZW5kID0gZGlnaXRzIC0gbnVtYmVyLmxlbmd0aDtcblxuXHQgICAgaWYgKGVuZCkge1xuXHQgICAgICAgIHJldHVybiB6ZXJvc1tkaWdpdHNdLnN1YnN0cmluZygwLCBlbmQpICsgbnVtYmVyO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbnVtYmVyO1xuXHR9XG5cblx0ICAgIC8vSlNPTiBzdHJpbmdpZnlcblx0KGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIGVzY2FwYWJsZSA9IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceDlmXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG5cdCAgICAgICAgZ2FwLFxuXHQgICAgICAgIGluZGVudCxcblx0ICAgICAgICBtZXRhID0ge1xuXHQgICAgICAgICAgICBcIlxcYlwiOiBcIlxcXFxiXCIsXG5cdCAgICAgICAgICAgIFwiXFx0XCI6IFwiXFxcXHRcIixcblx0ICAgICAgICAgICAgXCJcXG5cIjogXCJcXFxcblwiLFxuXHQgICAgICAgICAgICBcIlxcZlwiOiBcIlxcXFxmXCIsXG5cdCAgICAgICAgICAgIFwiXFxyXCI6IFwiXFxcXHJcIixcblx0ICAgICAgICAgICAgXCJcXFwiXCIgOiAnXFxcXFwiJyxcblx0ICAgICAgICAgICAgXCJcXFxcXCI6IFwiXFxcXFxcXFxcIlxuXHQgICAgICAgIH0sXG5cdCAgICAgICAgcmVwLFxuXHQgICAgICAgIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cblxuXHQgICAgaWYgKHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0pTT04gIT09IEZVTkNUSU9OKSB7XG5cblx0ICAgICAgICBEYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuXHQgICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodGhhdC52YWx1ZU9mKCkpID9cblx0ICAgICAgICAgICAgICAgIHBhZCh0aGF0LmdldFVUQ0Z1bGxZZWFyKCksIDQpICsgXCItXCIgK1xuXHQgICAgICAgICAgICAgICAgcGFkKHRoYXQuZ2V0VVRDTW9udGgoKSArIDEpICAgKyBcIi1cIiArXG5cdCAgICAgICAgICAgICAgICBwYWQodGhhdC5nZXRVVENEYXRlKCkpICAgICAgICArIFwiVFwiICtcblx0ICAgICAgICAgICAgICAgIHBhZCh0aGF0LmdldFVUQ0hvdXJzKCkpICAgICAgICsgXCI6XCIgK1xuXHQgICAgICAgICAgICAgICAgcGFkKHRoYXQuZ2V0VVRDTWludXRlcygpKSAgICAgKyBcIjpcIiArXG5cdCAgICAgICAgICAgICAgICBwYWQodGhhdC5nZXRVVENTZWNvbmRzKCkpICAgICArIFwiWlwiIDogbnVsbDtcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgU3RyaW5nLnByb3RvdHlwZS50b0pTT04gPSBOdW1iZXIucHJvdG90eXBlLnRvSlNPTiA9IEJvb2xlYW4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpO1xuXHQgICAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHF1b3RlKHN0cmluZykge1xuXHQgICAgICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuXHQgICAgICAgIHJldHVybiBlc2NhcGFibGUudGVzdChzdHJpbmcpID8gXCJcXFwiXCIgKyBzdHJpbmcucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChhKSB7XG5cdCAgICAgICAgICAgIHZhciBjID0gbWV0YVthXTtcblx0ICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSBTVFJJTkcgPyBjIDpcblx0ICAgICAgICAgICAgICAgIFwiXFxcXHVcIiArIChcIjAwMDBcIiArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcblx0ICAgICAgICB9KSArIFwiXFxcIlwiIDogXCJcXFwiXCIgKyBzdHJpbmcgKyBcIlxcXCJcIjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gc3RyKGtleSwgaG9sZGVyKSB7XG5cdCAgICAgICAgdmFyIGksXG5cdCAgICAgICAgICAgIGssXG5cdCAgICAgICAgICAgIHYsXG5cdCAgICAgICAgICAgIGxlbmd0aCxcblx0ICAgICAgICAgICAgbWluZCA9IGdhcCxcblx0ICAgICAgICAgICAgcGFydGlhbCxcblx0ICAgICAgICAgICAgdmFsdWUgPSBob2xkZXJba2V5XSxcblx0ICAgICAgICAgICAgdHlwZTtcblxuXHQgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IE9CSkVDVCAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSBGVU5DVElPTikge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh0eXBlb2YgcmVwID09PSBGVU5DVElPTikge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHJlcC5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0ICAgICAgICBpZiAodHlwZSA9PT0gU1RSSU5HKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG5cdCAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBOVU1CRVIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiBOVUxMO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gQk9PTEVBTiB8fCB0eXBlID09PSBOVUxMKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gT0JKRUNUKSB7XG5cdCAgICAgICAgICAgIGlmICghdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBOVUxMO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG5cdCAgICAgICAgICAgIHBhcnRpYWwgPSBbXTtcblx0ICAgICAgICAgICAgaWYgKHRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG5cdCAgICAgICAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsW2ldID0gc3RyKGksIHZhbHVlKSB8fCBOVUxMO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gXCJbXVwiIDogZ2FwID9cblx0ICAgICAgICAgICAgICAgICAgICBcIltcXG5cIiArIGdhcCArIHBhcnRpYWwuam9pbihcIixcXG5cIiArIGdhcCkgKyBcIlxcblwiICsgbWluZCArIFwiXVwiIDpcblx0ICAgICAgICAgICAgICAgICAgICBcIltcIiArIHBhcnRpYWwuam9pbihcIixcIikgKyBcIl1cIjtcblx0ICAgICAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAocmVwICYmIHR5cGVvZiByZXAgPT09IE9CSkVDVCkge1xuXHQgICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVwLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwW2ldID09PSBTVFJJTkcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgayA9IHJlcFtpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gXCI6IFwiIDogXCI6XCIpICsgdik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/IFwiOiBcIiA6IFwiOlwiKSArIHYpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gXCJ7fVwiIDogZ2FwID9cblx0ICAgICAgICAgICAgICAgIFwie1xcblwiICsgZ2FwICsgcGFydGlhbC5qb2luKFwiLFxcblwiICsgZ2FwKSArIFwiXFxuXCIgKyBtaW5kICsgXCJ9XCIgOlxuXHQgICAgICAgICAgICAgICAgXCJ7XCIgKyBwYXJ0aWFsLmpvaW4oXCIsXCIpICsgXCJ9XCI7XG5cdCAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG5cdCAgICAgICAgICAgIHJldHVybiB2O1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBKU09OLnN0cmluZ2lmeSAhPT0gRlVOQ1RJT04pIHtcblx0ICAgICAgICBKU09OLnN0cmluZ2lmeSA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG5cdCAgICAgICAgICAgIHZhciBpO1xuXHQgICAgICAgICAgICBnYXAgPSBcIlwiO1xuXHQgICAgICAgICAgICBpbmRlbnQgPSBcIlwiO1xuXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09IE5VTUJFUikge1xuXHQgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbmRlbnQgKz0gXCIgXCI7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3BhY2UgPT09IFNUUklORykge1xuXHQgICAgICAgICAgICAgICAgaW5kZW50ID0gc3BhY2U7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXAgPSByZXBsYWNlcjtcblx0ICAgICAgICAgICAgaWYgKHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciAhPT0gRlVOQ1RJT04gJiYgKHR5cGVvZiByZXBsYWNlciAhPT0gT0JKRUNUIHx8IHR5cGVvZiByZXBsYWNlci5sZW5ndGggIT09IE5VTUJFUikpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkpTT04uc3RyaW5naWZ5XCIpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHN0cihcIlwiLCB7XCJcIjogdmFsdWV9KTtcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXHR9KSgpO1xuXG5cdC8vIERhdGUgYW5kIE51bWJlciBmb3JtYXR0aW5nXG5cdChmdW5jdGlvbigpIHtcblx0ICAgIHZhciBkYXRlRm9ybWF0UmVnRXhwID0gL2RkZGR8ZGRkfGRkfGR8TU1NTXxNTU18TU18TXx5eXl5fHl5fEhIfEh8aGh8aHxtbXxtfGZmZnxmZnxmfHR0fHNzfHN8enp6fHp6fHp8XCJbXlwiXSpcInwnW14nXSonL2csXG5cdCAgICAgICAgc3RhbmRhcmRGb3JtYXRSZWdFeHAgPSAgL14obnxjfHB8ZSkoXFxkKikkL2ksXG5cdCAgICAgICAgbGl0ZXJhbFJlZ0V4cCA9IC8oXFxcXC4pfChbJ11bXiddKlsnXT8pfChbXCJdW15cIl0qW1wiXT8pL2csXG5cdCAgICAgICAgY29tbWFSZWdFeHAgPSAvXFwsL2csXG5cdCAgICAgICAgRU1QVFkgPSBcIlwiLFxuXHQgICAgICAgIFBPSU5UID0gXCIuXCIsXG5cdCAgICAgICAgQ09NTUEgPSBcIixcIixcblx0ICAgICAgICBTSEFSUCA9IFwiI1wiLFxuXHQgICAgICAgIFpFUk8gPSBcIjBcIixcblx0ICAgICAgICBQTEFDRUhPTERFUiA9IFwiPz9cIixcblx0ICAgICAgICBFTiA9IFwiZW4tVVNcIixcblx0ICAgICAgICBvYmplY3RUb1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5cdCAgICAvL2N1bHR1cmVzXG5cdCAgICBrZW5kby5jdWx0dXJlc1tcImVuLVVTXCJdID0ge1xuXHQgICAgICAgIG5hbWU6IEVOLFxuXHQgICAgICAgIG51bWJlckZvcm1hdDoge1xuXHQgICAgICAgICAgICBwYXR0ZXJuOiBbXCItblwiXSxcblx0ICAgICAgICAgICAgZGVjaW1hbHM6IDIsXG5cdCAgICAgICAgICAgIFwiLFwiOiBcIixcIixcblx0ICAgICAgICAgICAgXCIuXCI6IFwiLlwiLFxuXHQgICAgICAgICAgICBncm91cFNpemU6IFszXSxcblx0ICAgICAgICAgICAgcGVyY2VudDoge1xuXHQgICAgICAgICAgICAgICAgcGF0dGVybjogW1wiLW4gJVwiLCBcIm4gJVwiXSxcblx0ICAgICAgICAgICAgICAgIGRlY2ltYWxzOiAyLFxuXHQgICAgICAgICAgICAgICAgXCIsXCI6IFwiLFwiLFxuXHQgICAgICAgICAgICAgICAgXCIuXCI6IFwiLlwiLFxuXHQgICAgICAgICAgICAgICAgZ3JvdXBTaXplOiBbM10sXG5cdCAgICAgICAgICAgICAgICBzeW1ib2w6IFwiJVwiXG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGN1cnJlbmN5OiB7XG5cdCAgICAgICAgICAgICAgICBuYW1lOiBcIlVTIERvbGxhclwiLFxuXHQgICAgICAgICAgICAgICAgYWJicjogXCJVU0RcIixcblx0ICAgICAgICAgICAgICAgIHBhdHRlcm46IFtcIigkbilcIiwgXCIkblwiXSxcblx0ICAgICAgICAgICAgICAgIGRlY2ltYWxzOiAyLFxuXHQgICAgICAgICAgICAgICAgXCIsXCI6IFwiLFwiLFxuXHQgICAgICAgICAgICAgICAgXCIuXCI6IFwiLlwiLFxuXHQgICAgICAgICAgICAgICAgZ3JvdXBTaXplOiBbM10sXG5cdCAgICAgICAgICAgICAgICBzeW1ib2w6IFwiJFwiXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIGNhbGVuZGFyczoge1xuXHQgICAgICAgICAgICBzdGFuZGFyZDoge1xuXHQgICAgICAgICAgICAgICAgZGF5czoge1xuXHQgICAgICAgICAgICAgICAgICAgIG5hbWVzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcblx0ICAgICAgICAgICAgICAgICAgICBuYW1lc0FiYnI6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcblx0ICAgICAgICAgICAgICAgICAgICBuYW1lc1Nob3J0OiBbIFwiU3VcIiwgXCJNb1wiLCBcIlR1XCIsIFwiV2VcIiwgXCJUaFwiLCBcIkZyXCIsIFwiU2FcIiBdXG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgbW9udGhzOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgbmFtZXM6IFtcIkphbnVhcnlcIiwgXCJGZWJydWFyeVwiLCBcIk1hcmNoXCIsIFwiQXByaWxcIiwgXCJNYXlcIiwgXCJKdW5lXCIsIFwiSnVseVwiLCBcIkF1Z3VzdFwiLCBcIlNlcHRlbWJlclwiLCBcIk9jdG9iZXJcIiwgXCJOb3ZlbWJlclwiLCBcIkRlY2VtYmVyXCJdLFxuXHQgICAgICAgICAgICAgICAgICAgIG5hbWVzQWJicjogW1wiSmFuXCIsIFwiRmViXCIsIFwiTWFyXCIsIFwiQXByXCIsIFwiTWF5XCIsIFwiSnVuXCIsIFwiSnVsXCIsIFwiQXVnXCIsIFwiU2VwXCIsIFwiT2N0XCIsIFwiTm92XCIsIFwiRGVjXCJdXG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgQU06IFsgXCJBTVwiLCBcImFtXCIsIFwiQU1cIiBdLFxuXHQgICAgICAgICAgICAgICAgUE06IFsgXCJQTVwiLCBcInBtXCIsIFwiUE1cIiBdLFxuXHQgICAgICAgICAgICAgICAgcGF0dGVybnM6IHtcblx0ICAgICAgICAgICAgICAgICAgICBkOiBcIk0vZC95eXl5XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgRDogXCJkZGRkLCBNTU1NIGRkLCB5eXl5XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgRjogXCJkZGRkLCBNTU1NIGRkLCB5eXl5IGg6bW06c3MgdHRcIixcblx0ICAgICAgICAgICAgICAgICAgICBnOiBcIk0vZC95eXl5IGg6bW0gdHRcIixcblx0ICAgICAgICAgICAgICAgICAgICBHOiBcIk0vZC95eXl5IGg6bW06c3MgdHRcIixcblx0ICAgICAgICAgICAgICAgICAgICBtOiBcIk1NTU0gZGRcIixcblx0ICAgICAgICAgICAgICAgICAgICBNOiBcIk1NTU0gZGRcIixcblx0ICAgICAgICAgICAgICAgICAgICBzOiBcInl5eXknLSdNTSctJ2RkVEhIJzonbW0nOidzc1wiLFxuXHQgICAgICAgICAgICAgICAgICAgIHQ6IFwiaDptbSB0dFwiLFxuXHQgICAgICAgICAgICAgICAgICAgIFQ6IFwiaDptbTpzcyB0dFwiLFxuXHQgICAgICAgICAgICAgICAgICAgIHU6IFwieXl5eSctJ01NJy0nZGQgSEgnOidtbSc6J3NzJ1onXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgeTogXCJNTU1NLCB5eXl5XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgWTogXCJNTU1NLCB5eXl5XCJcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBcIi9cIjogXCIvXCIsXG5cdCAgICAgICAgICAgICAgICBcIjpcIjogXCI6XCIsXG5cdCAgICAgICAgICAgICAgICBmaXJzdERheTogMCxcblx0ICAgICAgICAgICAgICAgIHR3b0RpZ2l0WWVhck1heDogMjAyOVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXG5cdCAgICAgZnVuY3Rpb24gZmluZEN1bHR1cmUoY3VsdHVyZSkge1xuXHQgICAgICAgIGlmIChjdWx0dXJlKSB7XG5cdCAgICAgICAgICAgIGlmIChjdWx0dXJlLm51bWJlckZvcm1hdCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGN1bHR1cmU7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGN1bHR1cmUgPT09IFNUUklORykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGN1bHR1cmVzID0ga2VuZG8uY3VsdHVyZXM7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY3VsdHVyZXNbY3VsdHVyZV0gfHwgY3VsdHVyZXNbY3VsdHVyZS5zcGxpdChcIi1cIilbMF1dIHx8IG51bGw7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZ2V0Q3VsdHVyZShjdWx0dXJlKSB7XG5cdCAgICAgICAgaWYgKGN1bHR1cmUpIHtcblx0ICAgICAgICAgICAgY3VsdHVyZSA9IGZpbmRDdWx0dXJlKGN1bHR1cmUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBjdWx0dXJlIHx8IGtlbmRvLmN1bHR1cmVzLmN1cnJlbnQ7XG5cdCAgICB9XG5cblx0ICAgIGtlbmRvLmN1bHR1cmUgPSBmdW5jdGlvbihjdWx0dXJlTmFtZSkge1xuXHQgICAgICAgIHZhciBjdWx0dXJlcyA9IGtlbmRvLmN1bHR1cmVzLCBjdWx0dXJlO1xuXG5cdCAgICAgICAgaWYgKGN1bHR1cmVOYW1lICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgY3VsdHVyZSA9IGZpbmRDdWx0dXJlKGN1bHR1cmVOYW1lKSB8fCBjdWx0dXJlc1tFTl07XG5cdCAgICAgICAgICAgIGN1bHR1cmUuY2FsZW5kYXIgPSBjdWx0dXJlLmNhbGVuZGFycy5zdGFuZGFyZDtcblx0ICAgICAgICAgICAgY3VsdHVyZXMuY3VycmVudCA9IGN1bHR1cmU7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGN1bHR1cmVzLmN1cnJlbnQ7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAga2VuZG8uZmluZEN1bHR1cmUgPSBmaW5kQ3VsdHVyZTtcblx0ICAgIGtlbmRvLmdldEN1bHR1cmUgPSBnZXRDdWx0dXJlO1xuXG5cdCAgICAvL3NldCBjdXJyZW50IGN1bHR1cmUgdG8gZW4tVVMuXG5cdCAgICBrZW5kby5jdWx0dXJlKEVOKTtcblxuXHQgICAgZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXQsIGN1bHR1cmUpIHtcblx0ICAgICAgICBjdWx0dXJlID0gZ2V0Q3VsdHVyZShjdWx0dXJlKTtcblxuXHQgICAgICAgIHZhciBjYWxlbmRhciA9IGN1bHR1cmUuY2FsZW5kYXJzLnN0YW5kYXJkLFxuXHQgICAgICAgICAgICBkYXlzID0gY2FsZW5kYXIuZGF5cyxcblx0ICAgICAgICAgICAgbW9udGhzID0gY2FsZW5kYXIubW9udGhzO1xuXG5cdCAgICAgICAgZm9ybWF0ID0gY2FsZW5kYXIucGF0dGVybnNbZm9ybWF0XSB8fCBmb3JtYXQ7XG5cblx0ICAgICAgICByZXR1cm4gZm9ybWF0LnJlcGxhY2UoZGF0ZUZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24gKG1hdGNoKSB7XG5cdCAgICAgICAgICAgIHZhciBtaW51dGVzO1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0O1xuXHQgICAgICAgICAgICB2YXIgc2lnbjtcblxuXHQgICAgICAgICAgICBpZiAobWF0Y2ggPT09IFwiZFwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBkYXRlLmdldERhdGUoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCA9PT0gXCJkZFwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBwYWQoZGF0ZS5nZXREYXRlKCkpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID09PSBcImRkZFwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBkYXlzLm5hbWVzQWJicltkYXRlLmdldERheSgpXTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCA9PT0gXCJkZGRkXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRheXMubmFtZXNbZGF0ZS5nZXREYXkoKV07XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPT09IFwiTVwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID09PSBcIk1NXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhZChkYXRlLmdldE1vbnRoKCkgKyAxKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCA9PT0gXCJNTU1cIikge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gbW9udGhzLm5hbWVzQWJicltkYXRlLmdldE1vbnRoKCldO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID09PSBcIk1NTU1cIikge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gbW9udGhzLm5hbWVzW2RhdGUuZ2V0TW9udGgoKV07XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPT09IFwieXlcIikge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFkKGRhdGUuZ2V0RnVsbFllYXIoKSAlIDEwMCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPT09IFwieXl5eVwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBwYWQoZGF0ZS5nZXRGdWxsWWVhcigpLCA0KTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCA9PT0gXCJoXCIgKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBkYXRlLmdldEhvdXJzKCkgJSAxMiB8fCAxMjtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCA9PT0gXCJoaFwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBwYWQoZGF0ZS5nZXRIb3VycygpICUgMTIgfHwgMTIpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID09PSBcIkhcIikge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGF0ZS5nZXRIb3VycygpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID09PSBcIkhIXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhZChkYXRlLmdldEhvdXJzKCkpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID09PSBcIm1cIikge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGF0ZS5nZXRNaW51dGVzKCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPT09IFwibW1cIikge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gcGFkKGRhdGUuZ2V0TWludXRlcygpKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCA9PT0gXCJzXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRhdGUuZ2V0U2Vjb25kcygpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID09PSBcInNzXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhZChkYXRlLmdldFNlY29uZHMoKSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPT09IFwiZlwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLmZsb29yKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCkgLyAxMDApO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID09PSBcImZmXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCk7XG5cdCAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID4gOTkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLmZsb29yKHJlc3VsdCAvIDEwKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhZChyZXN1bHQpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID09PSBcImZmZlwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBwYWQoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSwgMyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPT09IFwidHRcIikge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGF0ZS5nZXRIb3VycygpIDwgMTIgPyBjYWxlbmRhci5BTVswXSA6IGNhbGVuZGFyLlBNWzBdO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID09PSBcInp6elwiKSB7XG5cdCAgICAgICAgICAgICAgICBtaW51dGVzID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuXHQgICAgICAgICAgICAgICAgc2lnbiA9IG1pbnV0ZXMgPCAwO1xuXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLmFicyhtaW51dGVzIC8gNjApLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzBdO1xuXHQgICAgICAgICAgICAgICAgbWludXRlcyA9IG1hdGguYWJzKG1pbnV0ZXMpIC0gKHJlc3VsdCAqIDYwKTtcblxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gKHNpZ24gPyBcIitcIiA6IFwiLVwiKSArIHBhZChyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiOlwiICsgcGFkKG1pbnV0ZXMpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID09PSBcInp6XCIgfHwgbWF0Y2ggPT09IFwielwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgLyA2MDtcblx0ICAgICAgICAgICAgICAgIHNpZ24gPSByZXN1bHQgPCAwO1xuXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLmFicyhyZXN1bHQpLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzBdO1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gKHNpZ24gPyBcIitcIiA6IFwiLVwiKSArIChtYXRjaCA9PT0gXCJ6elwiID8gcGFkKHJlc3VsdCkgOiByZXN1bHQpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCAhPT0gdW5kZWZpbmVkID8gcmVzdWx0IDogbWF0Y2guc2xpY2UoMSwgbWF0Y2gubGVuZ3RoIC0gMSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIC8vbnVtYmVyIGZvcm1hdHRpbmdcblx0ICAgIGZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW1iZXIsIGZvcm1hdCwgY3VsdHVyZSkge1xuXHQgICAgICAgIGN1bHR1cmUgPSBnZXRDdWx0dXJlKGN1bHR1cmUpO1xuXG5cdCAgICAgICAgdmFyIG51bWJlckZvcm1hdCA9IGN1bHR1cmUubnVtYmVyRm9ybWF0LFxuXHQgICAgICAgICAgICBkZWNpbWFsID0gbnVtYmVyRm9ybWF0W1BPSU5UXSxcblx0ICAgICAgICAgICAgcHJlY2lzaW9uID0gbnVtYmVyRm9ybWF0LmRlY2ltYWxzLFxuXHQgICAgICAgICAgICBwYXR0ZXJuID0gbnVtYmVyRm9ybWF0LnBhdHRlcm5bMF0sXG5cdCAgICAgICAgICAgIGxpdGVyYWxzID0gW10sXG5cdCAgICAgICAgICAgIHN5bWJvbCxcblx0ICAgICAgICAgICAgaXNDdXJyZW5jeSwgaXNQZXJjZW50LFxuXHQgICAgICAgICAgICBjdXN0b21QcmVjaXNpb24sXG5cdCAgICAgICAgICAgIGZvcm1hdEFuZFByZWNpc2lvbixcblx0ICAgICAgICAgICAgbmVnYXRpdmUgPSBudW1iZXIgPCAwLFxuXHQgICAgICAgICAgICBpbnRlZ2VyLFxuXHQgICAgICAgICAgICBmcmFjdGlvbixcblx0ICAgICAgICAgICAgaW50ZWdlckxlbmd0aCxcblx0ICAgICAgICAgICAgZnJhY3Rpb25MZW5ndGgsXG5cdCAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gRU1QVFksXG5cdCAgICAgICAgICAgIHZhbHVlID0gRU1QVFksXG5cdCAgICAgICAgICAgIGlkeCxcblx0ICAgICAgICAgICAgbGVuZ3RoLFxuXHQgICAgICAgICAgICBjaCxcblx0ICAgICAgICAgICAgaGFzR3JvdXAsXG5cdCAgICAgICAgICAgIGhhc05lZ2F0aXZlRm9ybWF0LFxuXHQgICAgICAgICAgICBkZWNpbWFsSW5kZXgsXG5cdCAgICAgICAgICAgIHNoYXJwSW5kZXgsXG5cdCAgICAgICAgICAgIHplcm9JbmRleCxcblx0ICAgICAgICAgICAgaGFzWmVybywgaGFzU2hhcnAsXG5cdCAgICAgICAgICAgIHBlcmNlbnRJbmRleCxcblx0ICAgICAgICAgICAgY3VycmVuY3lJbmRleCxcblx0ICAgICAgICAgICAgc3RhcnRaZXJvSW5kZXgsXG5cdCAgICAgICAgICAgIHN0YXJ0ID0gLTEsXG5cdCAgICAgICAgICAgIGVuZDtcblxuXHQgICAgICAgIC8vcmV0dXJuIGVtcHR5IHN0cmluZyBpZiBubyBudW1iZXJcblx0ICAgICAgICBpZiAobnVtYmVyID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEVNUFRZO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICghaXNGaW5pdGUobnVtYmVyKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vaWYgbm8gZm9ybWF0IHRoZW4gcmV0dXJuIG51bWJlci50b1N0cmluZygpIG9yIG51bWJlci50b0xvY2FsZVN0cmluZygpIGlmIGN1bHR1cmUubmFtZSBpcyBub3QgZGVmaW5lZFxuXHQgICAgICAgIGlmICghZm9ybWF0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjdWx0dXJlLm5hbWUubGVuZ3RoID8gbnVtYmVyLnRvTG9jYWxlU3RyaW5nKCkgOiBudW1iZXIudG9TdHJpbmcoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmb3JtYXRBbmRQcmVjaXNpb24gPSBzdGFuZGFyZEZvcm1hdFJlZ0V4cC5leGVjKGZvcm1hdCk7XG5cblx0ICAgICAgICAvLyBzdGFuZGFyZCBmb3JtYXR0aW5nXG5cdCAgICAgICAgaWYgKGZvcm1hdEFuZFByZWNpc2lvbikge1xuXHQgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXRBbmRQcmVjaXNpb25bMV0udG9Mb3dlckNhc2UoKTtcblxuXHQgICAgICAgICAgICBpc0N1cnJlbmN5ID0gZm9ybWF0ID09PSBcImNcIjtcblx0ICAgICAgICAgICAgaXNQZXJjZW50ID0gZm9ybWF0ID09PSBcInBcIjtcblxuXHQgICAgICAgICAgICBpZiAoaXNDdXJyZW5jeSB8fCBpc1BlcmNlbnQpIHtcblx0ICAgICAgICAgICAgICAgIC8vZ2V0IHNwZWNpZmljIG51bWJlciBmb3JtYXQgaW5mb3JtYXRpb24gaWYgZm9ybWF0IGlzIGN1cnJlbmN5IG9yIHBlcmNlbnRcblx0ICAgICAgICAgICAgICAgIG51bWJlckZvcm1hdCA9IGlzQ3VycmVuY3kgPyBudW1iZXJGb3JtYXQuY3VycmVuY3kgOiBudW1iZXJGb3JtYXQucGVyY2VudDtcblx0ICAgICAgICAgICAgICAgIGRlY2ltYWwgPSBudW1iZXJGb3JtYXRbUE9JTlRdO1xuXHQgICAgICAgICAgICAgICAgcHJlY2lzaW9uID0gbnVtYmVyRm9ybWF0LmRlY2ltYWxzO1xuXHQgICAgICAgICAgICAgICAgc3ltYm9sID0gbnVtYmVyRm9ybWF0LnN5bWJvbDtcblx0ICAgICAgICAgICAgICAgIHBhdHRlcm4gPSBudW1iZXJGb3JtYXQucGF0dGVybltuZWdhdGl2ZSA/IDAgOiAxXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGN1c3RvbVByZWNpc2lvbiA9IGZvcm1hdEFuZFByZWNpc2lvblsyXTtcblxuXHQgICAgICAgICAgICBpZiAoY3VzdG9tUHJlY2lzaW9uKSB7XG5cdCAgICAgICAgICAgICAgICBwcmVjaXNpb24gPSArY3VzdG9tUHJlY2lzaW9uO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy9yZXR1cm4gbnVtYmVyIGluIGV4cG9uZW50aWFsIGZvcm1hdFxuXHQgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBcImVcIikge1xuXHQgICAgICAgICAgICAgICAgdmFyIGV4cCA9IGN1c3RvbVByZWNpc2lvbiA/IG51bWJlci50b0V4cG9uZW50aWFsKHByZWNpc2lvbikgOiBudW1iZXIudG9FeHBvbmVudGlhbCgpOyAvLyB0b0V4cG9uZW50aWFsKCkgYW5kIHRvRXhwb25lbnRpYWwodW5kZWZpbmVkKSBkaWZmZXIgaW4gRkYgIzY1MzQzOC5cblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGV4cC5yZXBsYWNlKFBPSU5ULCBudW1iZXJGb3JtYXRbUE9JTlRdKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIG11bHRpcGx5IGlmIGZvcm1hdCBpcyBwZXJjZW50XG5cdCAgICAgICAgICAgIGlmIChpc1BlcmNlbnQpIHtcblx0ICAgICAgICAgICAgICAgIG51bWJlciAqPSAxMDA7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBudW1iZXIgPSByb3VuZChudW1iZXIsIHByZWNpc2lvbik7XG5cdCAgICAgICAgICAgIG5lZ2F0aXZlID0gbnVtYmVyIDwgMDtcblx0ICAgICAgICAgICAgbnVtYmVyID0gbnVtYmVyLnNwbGl0KFBPSU5UKTtcblxuXHQgICAgICAgICAgICBpbnRlZ2VyID0gbnVtYmVyWzBdO1xuXHQgICAgICAgICAgICBmcmFjdGlvbiA9IG51bWJlclsxXTtcblxuXHQgICAgICAgICAgICAvL2V4Y2x1ZGUgXCItXCIgaWYgbnVtYmVyIGlzIG5lZ2F0aXZlLlxuXHQgICAgICAgICAgICBpZiAobmVnYXRpdmUpIHtcblx0ICAgICAgICAgICAgICAgIGludGVnZXIgPSBpbnRlZ2VyLnN1YnN0cmluZygxKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHZhbHVlID0gZ3JvdXBJbnRlZ2VyKGludGVnZXIsIDAsIGludGVnZXIubGVuZ3RoLCBudW1iZXJGb3JtYXQpO1xuXG5cdCAgICAgICAgICAgIGlmIChmcmFjdGlvbikge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgKz0gZGVjaW1hbCArIGZyYWN0aW9uO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJuXCIgJiYgIW5lZ2F0aXZlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBudW1iZXIgPSBFTVBUWTtcblxuXHQgICAgICAgICAgICBmb3IgKGlkeCA9IDAsIGxlbmd0aCA9IHBhdHRlcm4ubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICBjaCA9IHBhdHRlcm4uY2hhckF0KGlkeCk7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gXCJuXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBudW1iZXIgKz0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIiRcIiB8fCBjaCA9PT0gXCIlXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBudW1iZXIgKz0gc3ltYm9sO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBudW1iZXIgKz0gY2g7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vY3VzdG9tIGZvcm1hdHRpbmdcblx0ICAgICAgICAvL1xuXHQgICAgICAgIC8vc2VwYXJhdGUgZm9ybWF0IGJ5IHNlY3Rpb25zLlxuXG5cdCAgICAgICAgaWYgKGZvcm1hdC5pbmRleE9mKFwiJ1wiKSA+IC0xIHx8IGZvcm1hdC5pbmRleE9mKFwiXFxcIlwiKSA+IC0xIHx8IGZvcm1hdC5pbmRleE9mKFwiXFxcXFwiKSA+IC0xKSB7XG5cdCAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxpdGVyYWxSZWdFeHAsIGZ1bmN0aW9uIChtYXRjaCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHF1b3RlQ2hhciA9IG1hdGNoLmNoYXJBdCgwKS5yZXBsYWNlKFwiXFxcXFwiLCBcIlwiKSxcblx0ICAgICAgICAgICAgICAgICAgICBsaXRlcmFsID0gbWF0Y2guc2xpY2UoMSkucmVwbGFjZShxdW90ZUNoYXIsIFwiXCIpO1xuXG5cdCAgICAgICAgICAgICAgICBsaXRlcmFscy5wdXNoKGxpdGVyYWwpO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gUExBQ0VIT0xERVI7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5zcGxpdChcIjtcIik7XG5cdCAgICAgICAgaWYgKG5lZ2F0aXZlICYmIGZvcm1hdFsxXSkge1xuXHQgICAgICAgICAgICAvL2dldCBuZWdhdGl2ZSBmb3JtYXRcblx0ICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0WzFdO1xuXHQgICAgICAgICAgICBoYXNOZWdhdGl2ZUZvcm1hdCA9IHRydWU7XG5cdCAgICAgICAgfSBlbHNlIGlmIChudW1iZXIgPT09IDAgJiYgZm9ybWF0WzJdKSB7XG5cdCAgICAgICAgICAgIC8vZm9ybWF0IGZvciB6ZXJvc1xuXHQgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXRbMl07XG5cdCAgICAgICAgICAgIGlmIChmb3JtYXQuaW5kZXhPZihTSEFSUCkgPT0gLTEgJiYgZm9ybWF0LmluZGV4T2YoWkVSTykgPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgIC8vcmV0dXJuIGZvcm1hdCBpZiBpdCBpcyBzdHJpbmcgY29uc3RhbnQuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0WzBdO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHBlcmNlbnRJbmRleCA9IGZvcm1hdC5pbmRleE9mKFwiJVwiKTtcblx0ICAgICAgICBjdXJyZW5jeUluZGV4ID0gZm9ybWF0LmluZGV4T2YoXCIkXCIpO1xuXG5cdCAgICAgICAgaXNQZXJjZW50ID0gcGVyY2VudEluZGV4ICE9IC0xO1xuXHQgICAgICAgIGlzQ3VycmVuY3kgPSBjdXJyZW5jeUluZGV4ICE9IC0xO1xuXG5cdCAgICAgICAgLy9tdWx0aXBseSBudW1iZXIgaWYgdGhlIGZvcm1hdCBoYXMgcGVyY2VudFxuXHQgICAgICAgIGlmIChpc1BlcmNlbnQpIHtcblx0ICAgICAgICAgICAgbnVtYmVyICo9IDEwMDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoaXNDdXJyZW5jeSAmJiBmb3JtYXRbY3VycmVuY3lJbmRleCAtIDFdID09PSBcIlxcXFxcIikge1xuXHQgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQuc3BsaXQoXCJcXFxcXCIpLmpvaW4oXCJcIik7XG5cdCAgICAgICAgICAgIGlzQ3VycmVuY3kgPSBmYWxzZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoaXNDdXJyZW5jeSB8fCBpc1BlcmNlbnQpIHtcblx0ICAgICAgICAgICAgLy9nZXQgc3BlY2lmaWMgbnVtYmVyIGZvcm1hdCBpbmZvcm1hdGlvbiBpZiBmb3JtYXQgaXMgY3VycmVuY3kgb3IgcGVyY2VudFxuXHQgICAgICAgICAgICBudW1iZXJGb3JtYXQgPSBpc0N1cnJlbmN5ID8gbnVtYmVyRm9ybWF0LmN1cnJlbmN5IDogbnVtYmVyRm9ybWF0LnBlcmNlbnQ7XG5cdCAgICAgICAgICAgIGRlY2ltYWwgPSBudW1iZXJGb3JtYXRbUE9JTlRdO1xuXHQgICAgICAgICAgICBwcmVjaXNpb24gPSBudW1iZXJGb3JtYXQuZGVjaW1hbHM7XG5cdCAgICAgICAgICAgIHN5bWJvbCA9IG51bWJlckZvcm1hdC5zeW1ib2w7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaGFzR3JvdXAgPSBmb3JtYXQuaW5kZXhPZihDT01NQSkgPiAtMTtcblx0ICAgICAgICBpZiAoaGFzR3JvdXApIHtcblx0ICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoY29tbWFSZWdFeHAsIEVNUFRZKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBkZWNpbWFsSW5kZXggPSBmb3JtYXQuaW5kZXhPZihQT0lOVCk7XG5cdCAgICAgICAgbGVuZ3RoID0gZm9ybWF0Lmxlbmd0aDtcblxuXHQgICAgICAgIGlmIChkZWNpbWFsSW5kZXggIT0gLTEpIHtcblx0ICAgICAgICAgICAgZnJhY3Rpb24gPSBudW1iZXIudG9TdHJpbmcoKS5zcGxpdChcImVcIik7XG5cdCAgICAgICAgICAgIGlmIChmcmFjdGlvblsxXSkge1xuXHQgICAgICAgICAgICAgICAgZnJhY3Rpb24gPSByb3VuZChudW1iZXIsIE1hdGguYWJzKGZyYWN0aW9uWzFdKSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBmcmFjdGlvbiA9IGZyYWN0aW9uWzBdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGZyYWN0aW9uID0gZnJhY3Rpb24uc3BsaXQoUE9JTlQpWzFdIHx8IEVNUFRZO1xuXHQgICAgICAgICAgICB6ZXJvSW5kZXggPSBmb3JtYXQubGFzdEluZGV4T2YoWkVSTykgLSBkZWNpbWFsSW5kZXg7XG5cdCAgICAgICAgICAgIHNoYXJwSW5kZXggPSBmb3JtYXQubGFzdEluZGV4T2YoU0hBUlApIC0gZGVjaW1hbEluZGV4O1xuXHQgICAgICAgICAgICBoYXNaZXJvID0gemVyb0luZGV4ID4gLTE7XG5cdCAgICAgICAgICAgIGhhc1NoYXJwID0gc2hhcnBJbmRleCA+IC0xO1xuXHQgICAgICAgICAgICBpZHggPSBmcmFjdGlvbi5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgaWYgKCFoYXNaZXJvICYmICFoYXNTaGFycCkge1xuXHQgICAgICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnN1YnN0cmluZygwLCBkZWNpbWFsSW5kZXgpICsgZm9ybWF0LnN1YnN0cmluZyhkZWNpbWFsSW5kZXggKyAxKTtcblx0ICAgICAgICAgICAgICAgIGxlbmd0aCA9IGZvcm1hdC5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICBkZWNpbWFsSW5kZXggPSAtMTtcblx0ICAgICAgICAgICAgICAgIGlkeCA9IDA7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoaGFzWmVybyAmJiB6ZXJvSW5kZXggPiBzaGFycEluZGV4KSB7XG5cdCAgICAgICAgICAgICAgICBpZHggPSB6ZXJvSW5kZXg7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcnBJbmRleCA+IHplcm9JbmRleCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGhhc1NoYXJwICYmIGlkeCA+IHNoYXJwSW5kZXgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcm91bmRlZCA9IHJvdW5kKG51bWJlciwgc2hhcnBJbmRleCwgbmVnYXRpdmUpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJvdW5kZWQuY2hhckF0KHJvdW5kZWQubGVuZ3RoIC0gMSkgPT09IFpFUk8gJiYgc2hhcnBJbmRleCA+IDAgJiYgc2hhcnBJbmRleCA+IHplcm9JbmRleCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzaGFycEluZGV4LS07XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcm91bmRlZCA9IHJvdW5kKG51bWJlciwgc2hhcnBJbmRleCwgbmVnYXRpdmUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGlkeCA9IHNoYXJwSW5kZXg7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhc1plcm8gJiYgaWR4IDwgemVyb0luZGV4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWR4ID0gemVyb0luZGV4O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgbnVtYmVyID0gcm91bmQobnVtYmVyLCBpZHgsIG5lZ2F0aXZlKTtcblxuXHQgICAgICAgIHNoYXJwSW5kZXggPSBmb3JtYXQuaW5kZXhPZihTSEFSUCk7XG5cdCAgICAgICAgc3RhcnRaZXJvSW5kZXggPSB6ZXJvSW5kZXggPSBmb3JtYXQuaW5kZXhPZihaRVJPKTtcblxuXHQgICAgICAgIC8vZGVmaW5lIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgZGlnaXQgcGxhY2Vob2xkZXJcblx0ICAgICAgICBpZiAoc2hhcnBJbmRleCA9PSAtMSAmJiB6ZXJvSW5kZXggIT0gLTEpIHtcblx0ICAgICAgICAgICAgc3RhcnQgPSB6ZXJvSW5kZXg7XG5cdCAgICAgICAgfSBlbHNlIGlmIChzaGFycEluZGV4ICE9IC0xICYmIHplcm9JbmRleCA9PSAtMSkge1xuXHQgICAgICAgICAgICBzdGFydCA9IHNoYXJwSW5kZXg7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgc3RhcnQgPSBzaGFycEluZGV4ID4gemVyb0luZGV4ID8gemVyb0luZGV4IDogc2hhcnBJbmRleDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBzaGFycEluZGV4ID0gZm9ybWF0Lmxhc3RJbmRleE9mKFNIQVJQKTtcblx0ICAgICAgICB6ZXJvSW5kZXggPSBmb3JtYXQubGFzdEluZGV4T2YoWkVSTyk7XG5cblx0ICAgICAgICAvL2RlZmluZSB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZGlnaXQgcGxhY2Vob2xkZXJcblx0ICAgICAgICBpZiAoc2hhcnBJbmRleCA9PSAtMSAmJiB6ZXJvSW5kZXggIT0gLTEpIHtcblx0ICAgICAgICAgICAgZW5kID0gemVyb0luZGV4O1xuXHQgICAgICAgIH0gZWxzZSBpZiAoc2hhcnBJbmRleCAhPSAtMSAmJiB6ZXJvSW5kZXggPT0gLTEpIHtcblx0ICAgICAgICAgICAgZW5kID0gc2hhcnBJbmRleDtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBlbmQgPSBzaGFycEluZGV4ID4gemVyb0luZGV4ID8gc2hhcnBJbmRleCA6IHplcm9JbmRleDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoc3RhcnQgPT0gbGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChzdGFydCAhPSAtMSkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IG51bWJlci50b1N0cmluZygpLnNwbGl0KFBPSU5UKTtcblx0ICAgICAgICAgICAgaW50ZWdlciA9IHZhbHVlWzBdO1xuXHQgICAgICAgICAgICBmcmFjdGlvbiA9IHZhbHVlWzFdIHx8IEVNUFRZO1xuXG5cdCAgICAgICAgICAgIGludGVnZXJMZW5ndGggPSBpbnRlZ2VyLmxlbmd0aDtcblx0ICAgICAgICAgICAgZnJhY3Rpb25MZW5ndGggPSBmcmFjdGlvbi5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgaWYgKG5lZ2F0aXZlICYmIChudW1iZXIgKiAtMSkgPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgbmVnYXRpdmUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIG51bWJlciA9IGZvcm1hdC5zdWJzdHJpbmcoMCwgc3RhcnQpO1xuXG5cdCAgICAgICAgICAgIGlmIChuZWdhdGl2ZSAmJiAhaGFzTmVnYXRpdmVGb3JtYXQpIHtcblx0ICAgICAgICAgICAgICAgIG51bWJlciArPSBcIi1cIjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGZvciAoaWR4ID0gc3RhcnQ7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgICAgIGNoID0gZm9ybWF0LmNoYXJBdChpZHgpO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoZGVjaW1hbEluZGV4ID09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCAtIGlkeCA8IGludGVnZXJMZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyICs9IGludGVnZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHplcm9JbmRleCAhPSAtMSAmJiB6ZXJvSW5kZXggPCBpZHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSBFTVBUWTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoKGRlY2ltYWxJbmRleCAtIGlkeCkgPD0gaW50ZWdlckxlbmd0aCAmJiBkZWNpbWFsSW5kZXggLSBpZHggPiAtMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgKz0gaW50ZWdlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWR4ID0gZGVjaW1hbEluZGV4O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkZWNpbWFsSW5kZXggPT09IGlkeCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIgKz0gKGZyYWN0aW9uID8gZGVjaW1hbCA6IEVNUFRZKSArIGZyYWN0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZHggKz0gZW5kIC0gZGVjaW1hbEluZGV4ICsgMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IFpFUk8pIHtcblx0ICAgICAgICAgICAgICAgICAgICBudW1iZXIgKz0gY2g7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSBjaDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFNIQVJQKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbnVtYmVyICs9IHJlcGxhY2VtZW50O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGhhc0dyb3VwKSB7XG5cdCAgICAgICAgICAgICAgICBudW1iZXIgPSBncm91cEludGVnZXIobnVtYmVyLCBzdGFydCArIChuZWdhdGl2ZSAmJiAhaGFzTmVnYXRpdmVGb3JtYXQgPyAxIDogMCksIE1hdGgubWF4KGVuZCwgKGludGVnZXJMZW5ndGggKyBzdGFydCkpLCBudW1iZXJGb3JtYXQpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGVuZCA+PSBzdGFydCkge1xuXHQgICAgICAgICAgICAgICAgbnVtYmVyICs9IGZvcm1hdC5zdWJzdHJpbmcoZW5kICsgMSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvL3JlcGxhY2Ugc3ltYm9sIHBsYWNlaG9sZGVyc1xuXHQgICAgICAgICAgICBpZiAoaXNDdXJyZW5jeSB8fCBpc1BlcmNlbnQpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gRU1QVFk7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGlkeCA9IDAsIGxlbmd0aCA9IG51bWJlci5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBjaCA9IG51bWJlci5jaGFyQXQoaWR4KTtcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSAoY2ggPT09IFwiJFwiIHx8IGNoID09PSBcIiVcIikgPyBzeW1ib2wgOiBjaDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG51bWJlciA9IHZhbHVlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgbGVuZ3RoID0gbGl0ZXJhbHMubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIGlmIChsZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIG51bWJlciA9IG51bWJlci5yZXBsYWNlKFBMQUNFSE9MREVSLCBsaXRlcmFsc1tpZHhdKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBudW1iZXI7XG5cdCAgICB9XG5cblx0ICAgIHZhciBncm91cEludGVnZXIgPSBmdW5jdGlvbihudW1iZXIsIHN0YXJ0LCBlbmQsIG51bWJlckZvcm1hdCkge1xuXHQgICAgICAgIHZhciBkZWNpbWFsSW5kZXggPSBudW1iZXIuaW5kZXhPZihudW1iZXJGb3JtYXRbUE9JTlRdKTtcblx0ICAgICAgICB2YXIgZ3JvdXBTaXplcyA9IG51bWJlckZvcm1hdC5ncm91cFNpemUuc2xpY2UoKTtcblx0ICAgICAgICB2YXIgZ3JvdXBTaXplID0gZ3JvdXBTaXplcy5zaGlmdCgpO1xuXHQgICAgICAgIHZhciBpbnRlZ2VyLCBpbnRlZ2VyTGVuZ3RoO1xuXHQgICAgICAgIHZhciBpZHgsIHBhcnRzLCB2YWx1ZTtcblx0ICAgICAgICB2YXIgbmV3R3JvdXBTaXplO1xuXG5cdCAgICAgICAgZW5kID0gZGVjaW1hbEluZGV4ICE9PSAtMSA/IGRlY2ltYWxJbmRleCA6IGVuZCArIDE7XG5cblx0ICAgICAgICBpbnRlZ2VyID0gbnVtYmVyLnN1YnN0cmluZyhzdGFydCwgZW5kKTtcblx0ICAgICAgICBpbnRlZ2VyTGVuZ3RoID0gaW50ZWdlci5sZW5ndGg7XG5cblx0ICAgICAgICBpZiAoaW50ZWdlckxlbmd0aCA+PSBncm91cFNpemUpIHtcblx0ICAgICAgICAgICAgaWR4ID0gaW50ZWdlckxlbmd0aDtcblx0ICAgICAgICAgICAgcGFydHMgPSBbXTtcblxuXHQgICAgICAgICAgICB3aGlsZSAoaWR4ID4gLTEpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gaW50ZWdlci5zdWJzdHJpbmcoaWR4IC0gZ3JvdXBTaXplLCBpZHgpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZHggLT0gZ3JvdXBTaXplO1xuXHQgICAgICAgICAgICAgICAgbmV3R3JvdXBTaXplID0gZ3JvdXBTaXplcy5zaGlmdCgpO1xuXHQgICAgICAgICAgICAgICAgZ3JvdXBTaXplID0gbmV3R3JvdXBTaXplICE9PSB1bmRlZmluZWQgPyBuZXdHcm91cFNpemUgOiBncm91cFNpemU7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChncm91cFNpemUgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaWR4ID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGludGVnZXIuc3Vic3RyaW5nKDAsIGlkeCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGludGVnZXIgPSBwYXJ0cy5yZXZlcnNlKCkuam9pbihudW1iZXJGb3JtYXRbQ09NTUFdKTtcblx0ICAgICAgICAgICAgbnVtYmVyID0gbnVtYmVyLnN1YnN0cmluZygwLCBzdGFydCkgKyBpbnRlZ2VyICsgbnVtYmVyLnN1YnN0cmluZyhlbmQpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBudW1iZXI7XG5cdCAgICB9O1xuXG5cdCAgICB2YXIgcm91bmQgPSBmdW5jdGlvbih2YWx1ZSwgcHJlY2lzaW9uLCBuZWdhdGl2ZSkge1xuXHQgICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCAwO1xuXG5cdCAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpLnNwbGl0KCdlJyk7XG5cdCAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKCsodmFsdWVbMF0gKyAnZScgKyAodmFsdWVbMV0gPyAoK3ZhbHVlWzFdICsgcHJlY2lzaW9uKSA6IHByZWNpc2lvbikpKTtcblxuXHQgICAgICAgIGlmIChuZWdhdGl2ZSkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoJ2UnKTtcblx0ICAgICAgICB2YWx1ZSA9ICsodmFsdWVbMF0gKyAnZScgKyAodmFsdWVbMV0gPyAoK3ZhbHVlWzFdIC0gcHJlY2lzaW9uKSA6IC1wcmVjaXNpb24pKTtcblxuXHQgICAgICAgIHJldHVybiB2YWx1ZS50b0ZpeGVkKE1hdGgubWluKHByZWNpc2lvbiwgMjApKTtcblx0ICAgIH07XG5cblx0ICAgIHZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKHZhbHVlLCBmbXQsIGN1bHR1cmUpIHtcblx0ICAgICAgICBpZiAoZm10KSB7XG5cdCAgICAgICAgICAgIGlmIChvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IERhdGVdXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXREYXRlKHZhbHVlLCBmbXQsIGN1bHR1cmUpO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gTlVNQkVSKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbHVlLCBmbXQsIGN1bHR1cmUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IFwiXCI7XG5cdCAgICB9O1xuXG5cdCAgICBrZW5kby5mb3JtYXQgPSBmdW5jdGlvbihmbXQpIHtcblx0ICAgICAgICB2YXIgdmFsdWVzID0gYXJndW1lbnRzO1xuXG5cdCAgICAgICAgcmV0dXJuIGZtdC5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24obWF0Y2gsIGluZGV4LCBwbGFjZWhvbGRlckZvcm1hdCkge1xuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbcGFyc2VJbnQoaW5kZXgsIDEwKSArIDFdO1xuXG5cdCAgICAgICAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSwgcGxhY2Vob2xkZXJGb3JtYXQgPyBwbGFjZWhvbGRlckZvcm1hdC5zdWJzdHJpbmcoMSkgOiBcIlwiKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cblx0ICAgIGtlbmRvLl9leHRyYWN0Rm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuXHQgICAgICAgIGlmIChmb3JtYXQuc2xpY2UoMCwzKSA9PT0gXCJ7MDpcIikge1xuXHQgICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQuc2xpY2UoMywgZm9ybWF0Lmxlbmd0aCAtIDEpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBmb3JtYXQ7XG5cdCAgICB9O1xuXG5cdCAgICBrZW5kby5fYWN0aXZlRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHQgICAgICAgIH0gY2F0Y2goZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAga2VuZG8uX3JvdW5kID0gcm91bmQ7XG5cdCAgICBrZW5kby5fb3V0ZXJXaWR0aCA9IGZ1bmN0aW9uIChlbGVtZW50LCBpbmNsdWRlTWFyZ2luKSB7IHJldHVybiAkKGVsZW1lbnQpLm91dGVyV2lkdGgoaW5jbHVkZU1hcmdpbiB8fCBmYWxzZSkgfHwgMDsgfTtcblx0ICAgIGtlbmRvLl9vdXRlckhlaWdodCA9IGZ1bmN0aW9uIChlbGVtZW50LCBpbmNsdWRlTWFyZ2luKSB7IHJldHVybiAkKGVsZW1lbnQpLm91dGVySGVpZ2h0KGluY2x1ZGVNYXJnaW4gfHwgZmFsc2UpIHx8IDA7IH07XG5cdCAgICBrZW5kby50b1N0cmluZyA9IHRvU3RyaW5nO1xuXHR9KSgpO1xuXG5cblx0KGZ1bmN0aW9uKCkge1xuXHQgICAgdmFyIG5vbkJyZWFraW5nU3BhY2VSZWdFeHAgPSAvXFx1MDBBMC9nLFxuXHQgICAgICAgIGV4cG9uZW50UmVnRXhwID0gL1tlRV1bXFwtK10/WzAtOV0rLyxcblx0ICAgICAgICBzaG9ydFRpbWVab25lUmVnRXhwID0gL1srfFxcLV1cXGR7MSwyfS8sXG5cdCAgICAgICAgbG9uZ1RpbWVab25lUmVnRXhwID0gL1srfFxcLV1cXGR7MSwyfTo/XFxkezJ9Lyxcblx0ICAgICAgICBkYXRlUmVnRXhwID0gL15cXC9EYXRlXFwoKC4qPylcXClcXC8kLyxcblx0ICAgICAgICBvZmZzZXRSZWdFeHAgPSAvWystXVxcZCovLFxuXHQgICAgICAgIEZPUk1BVFNfU0VRVUVOQ0UgPSBbIFtdLCBbIFwiR1wiLCBcImdcIiwgXCJGXCIgXSwgWyBcIkRcIiwgXCJkXCIsIFwieVwiLCBcIm1cIiwgXCJUXCIsIFwidFwiIF0gXSxcblx0ICAgICAgICBTVEFOREFSRF9GT1JNQVRTID0gW1xuXHQgICAgICAgICAgICBbXG5cdCAgICAgICAgICAgIFwieXl5eS1NTS1kZFRISDptbTpzcy5mZmZmZmZmenp6XCIsXG5cdCAgICAgICAgICAgIFwieXl5eS1NTS1kZFRISDptbTpzcy5mZmZmZmZmXCIsXG5cdCAgICAgICAgICAgIFwieXl5eS1NTS1kZFRISDptbTpzcy5mZmZ6enpcIixcblx0ICAgICAgICAgICAgXCJ5eXl5LU1NLWRkVEhIOm1tOnNzLmZmZlwiLFxuXHQgICAgICAgICAgICBcImRkZCBNTU0gZGQgeXl5eSBISDptbTpzc1wiLFxuXHQgICAgICAgICAgICBcInl5eXktTU0tZGRUSEg6bW06c3N6enpcIixcblx0ICAgICAgICAgICAgXCJ5eXl5LU1NLWRkVEhIOm1tenp6XCIsXG5cdCAgICAgICAgICAgIFwieXl5eS1NTS1kZFRISDptbXp6XCIsXG5cdCAgICAgICAgICAgIFwieXl5eS1NTS1kZFRISDptbTpzc1wiLFxuXHQgICAgICAgICAgICBcInl5eXktTU0tZGQgSEg6bW06c3NcIixcblx0ICAgICAgICAgICAgXCJ5eXl5L01NL2RkIEhIOm1tOnNzXCJcblx0ICAgICAgICAgICAgXSwgW1xuXHQgICAgICAgICAgICBcInl5eXktTU0tZGRUSEg6bW1cIixcblx0ICAgICAgICAgICAgXCJ5eXl5LU1NLWRkIEhIOm1tXCIsXG5cdCAgICAgICAgICAgIFwieXl5eS9NTS9kZCBISDptbVwiXG5cdCAgICAgICAgICAgIF0sIFtcblx0ICAgICAgICAgICAgXCJ5eXl5L01NL2RkXCIsXG5cdCAgICAgICAgICAgIFwieXl5eS1NTS1kZFwiLFxuXHQgICAgICAgICAgICBcIkhIOm1tOnNzXCIsXG5cdCAgICAgICAgICAgIFwiSEg6bW1cIlxuXHQgICAgICAgICAgICBdXG5cdCAgICAgICAgXSxcblx0ICAgICAgICBudW1iZXJSZWdFeHAgPSB7XG5cdCAgICAgICAgICAgIDI6IC9eXFxkezEsMn0vLFxuXHQgICAgICAgICAgICAzOiAvXlxcZHsxLDN9Lyxcblx0ICAgICAgICAgICAgNDogL15cXGR7NH0vXG5cdCAgICAgICAgfSxcblx0ICAgICAgICBvYmplY3RUb1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5cdCAgICBmdW5jdGlvbiBvdXRPZlJhbmdlKHZhbHVlLCBzdGFydCwgZW5kKSB7XG5cdCAgICAgICAgcmV0dXJuICEodmFsdWUgPj0gc3RhcnQgJiYgdmFsdWUgPD0gZW5kKTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZGVzaWduYXRvclByZWRpY2F0ZShkZXNpZ25hdG9yKSB7XG5cdCAgICAgICAgcmV0dXJuIGRlc2lnbmF0b3IuY2hhckF0KDApO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBtYXBEZXNpZ25hdG9ycyhkZXNpZ25hdG9ycykge1xuXHQgICAgICAgIHJldHVybiAkLm1hcChkZXNpZ25hdG9ycywgZGVzaWduYXRvclByZWRpY2F0ZSk7XG5cdCAgICB9XG5cblx0ICAgIC8vaWYgZGF0ZSdzIGRheSBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgdHlwZWQgb25lIC0gYWRqdXN0XG5cdCAgICBmdW5jdGlvbiBhZGp1c3REU1QoZGF0ZSwgaG91cnMpIHtcblx0ICAgICAgICBpZiAoIWhvdXJzICYmIGRhdGUuZ2V0SG91cnMoKSA9PT0gMjMpIHtcblx0ICAgICAgICAgICAgZGF0ZS5zZXRIb3VycyhkYXRlLmdldEhvdXJzKCkgKyAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGxvd2VyQXJyYXkoZGF0YSkge1xuXHQgICAgICAgIHZhciBpZHggPSAwLFxuXHQgICAgICAgICAgICBsZW5ndGggPSBkYXRhLmxlbmd0aCxcblx0ICAgICAgICAgICAgYXJyYXkgPSBbXTtcblxuXHQgICAgICAgIGZvciAoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgIGFycmF5W2lkeF0gPSAoZGF0YVtpZHhdICsgXCJcIikudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gYXJyYXk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGxvd2VyTG9jYWxJbmZvKGxvY2FsSW5mbykge1xuXHQgICAgICAgIHZhciBuZXdMb2NhbEluZm8gPSB7fSwgcHJvcGVydHk7XG5cblx0ICAgICAgICBmb3IgKHByb3BlcnR5IGluIGxvY2FsSW5mbykge1xuXHQgICAgICAgICAgICBuZXdMb2NhbEluZm9bcHJvcGVydHldID0gbG93ZXJBcnJheShsb2NhbEluZm9bcHJvcGVydHldKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gbmV3TG9jYWxJbmZvO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBwYXJzZUV4YWN0KHZhbHVlLCBmb3JtYXQsIGN1bHR1cmUsIHN0cmljdCkge1xuXHQgICAgICAgIGlmICghdmFsdWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGxvb2tBaGVhZCA9IGZ1bmN0aW9uIChtYXRjaCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKGZvcm1hdFtpZHhdID09PSBtYXRjaCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGkrKztcblx0ICAgICAgICAgICAgICAgICAgICBpZHgrKztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlkeCAtPSAxO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGdldE51bWJlciA9IGZ1bmN0aW9uKHNpemUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciByZyA9IG51bWJlclJlZ0V4cFtzaXplXSB8fCBuZXcgUmVnRXhwKCdeXFxcXGR7MSwnICsgc2l6ZSArICd9JyksXG5cdCAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB2YWx1ZS5zdWJzdHIodmFsdWVJZHgsIHNpemUpLm1hdGNoKHJnKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaFswXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZUlkeCArPSBtYXRjaC5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG1hdGNoLCAxMCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgZ2V0SW5kZXhCeU5hbWUgPSBmdW5jdGlvbiAobmFtZXMsIGxvd2VyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaSA9IDAsXG5cdCAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gbmFtZXMubGVuZ3RoLFxuXHQgICAgICAgICAgICAgICAgICAgIG5hbWUsIG5hbWVMZW5ndGgsXG5cdCAgICAgICAgICAgICAgICAgICAgbWF0Y2hMZW5ndGggPSAwLFxuXHQgICAgICAgICAgICAgICAgICAgIG1hdGNoSWR4ID0gMCxcblx0ICAgICAgICAgICAgICAgICAgICBzdWJWYWx1ZTtcblxuXHQgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICBuYW1lTGVuZ3RoID0gbmFtZS5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAgICAgc3ViVmFsdWUgPSB2YWx1ZS5zdWJzdHIodmFsdWVJZHgsIG5hbWVMZW5ndGgpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHN1YlZhbHVlID0gc3ViVmFsdWUudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3ViVmFsdWUgPT0gbmFtZSAmJiBuYW1lTGVuZ3RoID4gbWF0Y2hMZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hMZW5ndGggPSBuYW1lTGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaElkeCA9IGk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAobWF0Y2hMZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZUlkeCArPSBtYXRjaExlbmd0aDtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hJZHggKyAxO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgY2hlY2tMaXRlcmFsID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWUuY2hhckF0KHZhbHVlSWR4KSA9PT0gZm9ybWF0W2lkeF0pIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZUlkeCsrO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBjYWxlbmRhciA9IGN1bHR1cmUuY2FsZW5kYXJzLnN0YW5kYXJkLFxuXHQgICAgICAgICAgICB5ZWFyID0gbnVsbCxcblx0ICAgICAgICAgICAgbW9udGggPSBudWxsLFxuXHQgICAgICAgICAgICBkYXkgPSBudWxsLFxuXHQgICAgICAgICAgICBob3VycyA9IG51bGwsXG5cdCAgICAgICAgICAgIG1pbnV0ZXMgPSBudWxsLFxuXHQgICAgICAgICAgICBzZWNvbmRzID0gbnVsbCxcblx0ICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbnVsbCxcblx0ICAgICAgICAgICAgaWR4ID0gMCxcblx0ICAgICAgICAgICAgdmFsdWVJZHggPSAwLFxuXHQgICAgICAgICAgICBsaXRlcmFsID0gZmFsc2UsXG5cdCAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSgpLFxuXHQgICAgICAgICAgICB0d29EaWdpdFllYXJNYXggPSBjYWxlbmRhci50d29EaWdpdFllYXJNYXggfHwgMjAyOSxcblx0ICAgICAgICAgICAgZGVmYXVsdFllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCksXG5cdCAgICAgICAgICAgIGNoLCBjb3VudCwgbGVuZ3RoLCBwYXR0ZXJuLFxuXHQgICAgICAgICAgICBwbUhvdXIsIFVUQywgbWF0Y2hlcyxcblx0ICAgICAgICAgICAgYW1EZXNpZ25hdG9ycywgcG1EZXNpZ25hdG9ycyxcblx0ICAgICAgICAgICAgaG91cnNPZmZzZXQsIG1pbnV0ZXNPZmZzZXQsXG5cdCAgICAgICAgICAgIGhhc1RpbWUsIG1hdGNoO1xuXG5cdCAgICAgICAgaWYgKCFmb3JtYXQpIHtcblx0ICAgICAgICAgICAgZm9ybWF0ID0gXCJkXCI7IC8vc2hvcmQgZGF0ZSBmb3JtYXRcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvL2lmIGZvcm1hdCBpcyBwYXJ0IG9mIHRoZSBwYXR0ZXJucyBnZXQgcmVhbCBmb3JtYXRcblx0ICAgICAgICBwYXR0ZXJuID0gY2FsZW5kYXIucGF0dGVybnNbZm9ybWF0XTtcblx0ICAgICAgICBpZiAocGF0dGVybikge1xuXHQgICAgICAgICAgICBmb3JtYXQgPSBwYXR0ZXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5zcGxpdChcIlwiKTtcblx0ICAgICAgICBsZW5ndGggPSBmb3JtYXQubGVuZ3RoO1xuXG5cdCAgICAgICAgZm9yICg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgY2ggPSBmb3JtYXRbaWR4XTtcblxuXHQgICAgICAgICAgICBpZiAobGl0ZXJhbCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGNoID09PSBcIidcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGxpdGVyYWwgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hlY2tMaXRlcmFsKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoY2ggPT09IFwiZFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY291bnQgPSBsb29rQWhlYWQoXCJkXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghY2FsZW5kYXIuX2xvd2VyRGF5cykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYWxlbmRhci5fbG93ZXJEYXlzID0gbG93ZXJMb2NhbEluZm8oY2FsZW5kYXIuZGF5cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRheSAhPT0gbnVsbCAmJiBjb3VudCA+IDIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgZGF5ID0gY291bnQgPCAzID8gZ2V0TnVtYmVyKDIpIDogZ2V0SW5kZXhCeU5hbWUoY2FsZW5kYXIuX2xvd2VyRGF5c1tjb3VudCA9PSAzID8gXCJuYW1lc0FiYnJcIiA6IFwibmFtZXNcIl0sIHRydWUpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGRheSA9PT0gbnVsbCB8fCBvdXRPZlJhbmdlKGRheSwgMSwgMzEpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiTVwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY291bnQgPSBsb29rQWhlYWQoXCJNXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghY2FsZW5kYXIuX2xvd2VyTW9udGhzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyLl9sb3dlck1vbnRocyA9IGxvd2VyTG9jYWxJbmZvKGNhbGVuZGFyLm1vbnRocyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIG1vbnRoID0gY291bnQgPCAzID8gZ2V0TnVtYmVyKDIpIDogZ2V0SW5kZXhCeU5hbWUoY2FsZW5kYXIuX2xvd2VyTW9udGhzW2NvdW50ID09IDMgPyAnbmFtZXNBYmJyJyA6ICduYW1lcyddLCB0cnVlKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChtb250aCA9PT0gbnVsbCB8fCBvdXRPZlJhbmdlKG1vbnRoLCAxLCAxMikpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIG1vbnRoIC09IDE7IC8vYmVjYXVzZSBtb250aCBpcyB6ZXJvIGJhc2VkXG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcInlcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gbG9va0FoZWFkKFwieVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICB5ZWFyID0gZ2V0TnVtYmVyKGNvdW50KTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh5ZWFyID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PSAyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdHdvRGlnaXRZZWFyTWF4ID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0d29EaWdpdFllYXJNYXggPSBkZWZhdWx0WWVhciArIHBhcnNlSW50KHR3b0RpZ2l0WWVhck1heCwgMTApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgeWVhciA9IChkZWZhdWx0WWVhciAtIGRlZmF1bHRZZWFyICUgMTAwKSArIHllYXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5ZWFyID4gdHdvRGlnaXRZZWFyTWF4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ZWFyIC09IDEwMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiaFwiICkge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvb2tBaGVhZChcImhcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgaG91cnMgPSBnZXROdW1iZXIoMik7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGhvdXJzID09IDEyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhvdXJzID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBudWxsIHx8IG91dE9mUmFuZ2UoaG91cnMsIDAsIDExKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIkhcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvb2tBaGVhZChcIkhcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgaG91cnMgPSBnZXROdW1iZXIoMik7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGhvdXJzID09PSBudWxsIHx8IG91dE9mUmFuZ2UoaG91cnMsIDAsIDIzKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIm1cIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvb2tBaGVhZChcIm1cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGdldE51bWJlcigyKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobWludXRlcyA9PT0gbnVsbCB8fCBvdXRPZlJhbmdlKG1pbnV0ZXMsIDAsIDU5KSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcInNcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvb2tBaGVhZChcInNcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IGdldE51bWJlcigyKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2Vjb25kcyA9PT0gbnVsbCB8fCBvdXRPZlJhbmdlKHNlY29uZHMsIDAsIDU5KSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcImZcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gbG9va0FoZWFkKFwiZlwiKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gdmFsdWUuc3Vic3RyKHZhbHVlSWR4LCBjb3VudCkubWF0Y2gobnVtYmVyUmVnRXhwWzNdKTtcblx0ICAgICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBnZXROdW1iZXIoY291bnQpOyAvL21vdmUgdmFsdWUgaW5kZXggcG9zaXRpb25cblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChtaWxsaXNlY29uZHMgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gcGFyc2VGbG9hdChcIjAuXCIgKyBtYXRjaFswXSwgMTApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBrZW5kby5fcm91bmQobWlsbGlzZWNvbmRzLCAzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzICo9IDEwMDA7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG1pbGxpc2Vjb25kcyA9PT0gbnVsbCB8fCBvdXRPZlJhbmdlKG1pbGxpc2Vjb25kcywgMCwgOTk5KSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwidFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY291bnQgPSBsb29rQWhlYWQoXCJ0XCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGFtRGVzaWduYXRvcnMgPSBjYWxlbmRhci5BTTtcblx0ICAgICAgICAgICAgICAgICAgICBwbURlc2lnbmF0b3JzID0gY2FsZW5kYXIuUE07XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYW1EZXNpZ25hdG9ycyA9IG1hcERlc2lnbmF0b3JzKGFtRGVzaWduYXRvcnMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwbURlc2lnbmF0b3JzID0gbWFwRGVzaWduYXRvcnMocG1EZXNpZ25hdG9ycyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgcG1Ib3VyID0gZ2V0SW5kZXhCeU5hbWUocG1EZXNpZ25hdG9ycyk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFwbUhvdXIgJiYgIWdldEluZGV4QnlOYW1lKGFtRGVzaWduYXRvcnMpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09PSBcInpcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIFVUQyA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgY291bnQgPSBsb29rQWhlYWQoXCJ6XCIpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLnN1YnN0cih2YWx1ZUlkeCwgMSkgPT09IFwiWlwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrTGl0ZXJhbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gdmFsdWUuc3Vic3RyKHZhbHVlSWR4LCA2KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXRjaChjb3VudCA+IDIgPyBsb25nVGltZVpvbmVSZWdFeHAgOiBzaG9ydFRpbWVab25lUmVnRXhwKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlc1swXS5zcGxpdChcIjpcIik7XG5cblx0ICAgICAgICAgICAgICAgICAgICBob3Vyc09mZnNldCA9IG1hdGNoZXNbMF07XG5cdCAgICAgICAgICAgICAgICAgICAgbWludXRlc09mZnNldCA9IG1hdGNoZXNbMV07XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIW1pbnV0ZXNPZmZzZXQgJiYgaG91cnNPZmZzZXQubGVuZ3RoID4gMykgeyAvLygrfC0pW2hoXVttbV0gZm9ybWF0IGlzIHVzZWRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVJZHggPSBob3Vyc09mZnNldC5sZW5ndGggLSAyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtaW51dGVzT2Zmc2V0ID0gaG91cnNPZmZzZXQuc3Vic3RyaW5nKHZhbHVlSWR4KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaG91cnNPZmZzZXQgPSBob3Vyc09mZnNldC5zdWJzdHJpbmcoMCwgdmFsdWVJZHgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGhvdXJzT2Zmc2V0ID0gcGFyc2VJbnQoaG91cnNPZmZzZXQsIDEwKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3V0T2ZSYW5nZShob3Vyc09mZnNldCwgLTEyLCAxMykpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ID4gMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtaW51dGVzT2Zmc2V0ID0gbWF0Y2hlc1swXVswXSArIG1pbnV0ZXNPZmZzZXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZXNPZmZzZXQgPSBwYXJzZUludChtaW51dGVzT2Zmc2V0LCAxMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihtaW51dGVzT2Zmc2V0KSB8fCBvdXRPZlJhbmdlKG1pbnV0ZXNPZmZzZXQsIC01OSwgNTkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiJ1wiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbGl0ZXJhbCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hlY2tMaXRlcmFsKCk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFjaGVja0xpdGVyYWwoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gaWYgbW9yZSBjaGFyYWN0ZXJzIGZvbGxvdywgYXNzdW1lIHdyb25nIGZvcm1hdFxuXHQgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90ZWxlcmlrL2tlbmRvLXVpLWNvcmUvaXNzdWVzLzM0NzZcblx0ICAgICAgICBpZiAoc3RyaWN0ICYmICEvXlxccyokLy50ZXN0KHZhbHVlLnN1YnN0cih2YWx1ZUlkeCkpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGhhc1RpbWUgPSBob3VycyAhPT0gbnVsbCB8fCBtaW51dGVzICE9PSBudWxsIHx8IHNlY29uZHMgfHwgbnVsbDtcblxuXHQgICAgICAgIGlmICh5ZWFyID09PSBudWxsICYmIG1vbnRoID09PSBudWxsICYmIGRheSA9PT0gbnVsbCAmJiBoYXNUaW1lKSB7XG5cdCAgICAgICAgICAgIHllYXIgPSBkZWZhdWx0WWVhcjtcblx0ICAgICAgICAgICAgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG5cdCAgICAgICAgICAgIGRheSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIGlmICh5ZWFyID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB5ZWFyID0gZGVmYXVsdFllYXI7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoZGF5ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBkYXkgPSAxO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHBtSG91ciAmJiBob3VycyA8IDEyKSB7XG5cdCAgICAgICAgICAgIGhvdXJzICs9IDEyO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChVVEMpIHtcblx0ICAgICAgICAgICAgaWYgKGhvdXJzT2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICBob3VycyArPSAtaG91cnNPZmZzZXQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAobWludXRlc09mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgbWludXRlcyArPSAtbWludXRlc09mZnNldDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcykpO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRheSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcyk7XG5cdCAgICAgICAgICAgIGFkanVzdERTVCh2YWx1ZSwgaG91cnMpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh5ZWFyIDwgMTAwKSB7XG5cdCAgICAgICAgICAgIHZhbHVlLnNldEZ1bGxZZWFyKHllYXIpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh2YWx1ZS5nZXREYXRlKCkgIT09IGRheSAmJiBVVEMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHBhcnNlTWljcm9zb2Z0Rm9ybWF0T2Zmc2V0KG9mZnNldCkge1xuXHQgICAgICAgIHZhciBzaWduID0gb2Zmc2V0LnN1YnN0cigwLCAxKSA9PT0gXCItXCIgPyAtMSA6IDE7XG5cblx0ICAgICAgICBvZmZzZXQgPSBvZmZzZXQuc3Vic3RyaW5nKDEpO1xuXHQgICAgICAgIG9mZnNldCA9IChwYXJzZUludChvZmZzZXQuc3Vic3RyKDAsIDIpLCAxMCkgKiA2MCkgKyBwYXJzZUludChvZmZzZXQuc3Vic3RyaW5nKDIpLCAxMCk7XG5cblx0ICAgICAgICByZXR1cm4gc2lnbiAqIG9mZnNldDtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZ2V0RGVmYXVsdEZvcm1hdHMoY3VsdHVyZSkge1xuXHQgICAgICAgIHZhciBsZW5ndGggPSBtYXRoLm1heChGT1JNQVRTX1NFUVVFTkNFLmxlbmd0aCwgU1RBTkRBUkRfRk9STUFUUy5sZW5ndGgpO1xuXHQgICAgICAgIHZhciBjYWxlbmRhciA9IGN1bHR1cmUuY2FsZW5kYXIgfHwgY3VsdHVyZS5jYWxlbmRhcnMuc3RhbmRhcmQ7XG5cdCAgICAgICAgdmFyIHBhdHRlcm5zID0gY2FsZW5kYXIucGF0dGVybnM7XG5cdCAgICAgICAgdmFyIGN1bHR1cmVGb3JtYXRzLCBmb3JtYXRJZHgsIGlkeDtcblx0ICAgICAgICB2YXIgZm9ybWF0cyA9IFtdO1xuXG5cdCAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgIGN1bHR1cmVGb3JtYXRzID0gRk9STUFUU19TRVFVRU5DRVtpZHhdO1xuXHQgICAgICAgICAgICBmb3IgKGZvcm1hdElkeCA9IDA7IGZvcm1hdElkeCA8IGN1bHR1cmVGb3JtYXRzLmxlbmd0aDsgZm9ybWF0SWR4KyspIHtcblx0ICAgICAgICAgICAgICAgIGZvcm1hdHMucHVzaChwYXR0ZXJuc1tjdWx0dXJlRm9ybWF0c1tmb3JtYXRJZHhdXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZm9ybWF0cyA9IGZvcm1hdHMuY29uY2F0KFNUQU5EQVJEX0ZPUk1BVFNbaWR4XSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGZvcm1hdHM7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGludGVybmFsUGFyc2VEYXRlKHZhbHVlLCBmb3JtYXRzLCBjdWx0dXJlLCBzdHJpY3QpIHtcblx0ICAgICAgICBpZiAob2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBEYXRlXVwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgaWR4ID0gMDtcblx0ICAgICAgICB2YXIgZGF0ZSA9IG51bGw7XG5cdCAgICAgICAgdmFyIGxlbmd0aDtcblx0ICAgICAgICB2YXIgdHpvZmZzZXQ7XG5cblx0ICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUuaW5kZXhPZihcIi9EXCIpID09PSAwKSB7XG5cdCAgICAgICAgICAgIGRhdGUgPSBkYXRlUmVnRXhwLmV4ZWModmFsdWUpO1xuXHQgICAgICAgICAgICBpZiAoZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgZGF0ZSA9IGRhdGVbMV07XG5cdCAgICAgICAgICAgICAgICB0em9mZnNldCA9IG9mZnNldFJlZ0V4cC5leGVjKGRhdGUuc3Vic3RyaW5nKDEpKTtcblxuXHQgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHBhcnNlSW50KGRhdGUsIDEwKSk7XG5cblx0ICAgICAgICAgICAgICAgIGlmICh0em9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHR6b2Zmc2V0ID0gcGFyc2VNaWNyb3NvZnRGb3JtYXRPZmZzZXQodHpvZmZzZXRbMF0pO1xuXHQgICAgICAgICAgICAgICAgICAgIGRhdGUgPSBrZW5kby50aW1lem9uZS5hcHBseShkYXRlLCAwKTtcblx0ICAgICAgICAgICAgICAgICAgICBkYXRlID0ga2VuZG8udGltZXpvbmUuY29udmVydChkYXRlLCAwLCAtMSAqIHR6b2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBjdWx0dXJlID0ga2VuZG8uZ2V0Q3VsdHVyZShjdWx0dXJlKTtcblxuXHQgICAgICAgIGlmICghZm9ybWF0cykge1xuXHQgICAgICAgICAgICBmb3JtYXRzID0gZ2V0RGVmYXVsdEZvcm1hdHMoY3VsdHVyZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZm9ybWF0cyA9IGlzQXJyYXkoZm9ybWF0cykgPyBmb3JtYXRzOiBbZm9ybWF0c107XG5cdCAgICAgICAgbGVuZ3RoID0gZm9ybWF0cy5sZW5ndGg7XG5cblx0ICAgICAgICBmb3IgKDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICBkYXRlID0gcGFyc2VFeGFjdCh2YWx1ZSwgZm9ybWF0c1tpZHhdLCBjdWx0dXJlLCBzdHJpY3QpO1xuXHQgICAgICAgICAgICBpZiAoZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gZGF0ZTtcblx0ICAgIH1cblxuXHQgICAga2VuZG8ucGFyc2VEYXRlID0gZnVuY3Rpb24odmFsdWUsIGZvcm1hdHMsIGN1bHR1cmUpIHtcblx0ICAgICAgICByZXR1cm4gaW50ZXJuYWxQYXJzZURhdGUodmFsdWUsIGZvcm1hdHMsIGN1bHR1cmUsIGZhbHNlKTtcblx0ICAgIH07XG5cblx0ICAgIGtlbmRvLnBhcnNlRXhhY3REYXRlID0gZnVuY3Rpb24odmFsdWUsIGZvcm1hdHMsIGN1bHR1cmUpIHtcblx0ICAgICAgICByZXR1cm4gaW50ZXJuYWxQYXJzZURhdGUodmFsdWUsIGZvcm1hdHMsIGN1bHR1cmUsIHRydWUpO1xuXHQgICAgfTtcblxuXHQgICAga2VuZG8ucGFyc2VJbnQgPSBmdW5jdGlvbih2YWx1ZSwgY3VsdHVyZSkge1xuXHQgICAgICAgIHZhciByZXN1bHQgPSBrZW5kby5wYXJzZUZsb2F0KHZhbHVlLCBjdWx0dXJlKTtcblx0ICAgICAgICBpZiAocmVzdWx0KSB7XG5cdCAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8IDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXG5cdCAgICBrZW5kby5wYXJzZUZsb2F0ID0gZnVuY3Rpb24odmFsdWUsIGN1bHR1cmUsIGZvcm1hdCkge1xuXHQgICAgICAgIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHtcblx0ICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBOVU1CRVIpIHtcblx0ICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuXHQgICAgICAgIGN1bHR1cmUgPSBrZW5kby5nZXRDdWx0dXJlKGN1bHR1cmUpO1xuXG5cdCAgICAgICAgdmFyIG51bWJlciA9IGN1bHR1cmUubnVtYmVyRm9ybWF0LFxuXHQgICAgICAgICAgICBwZXJjZW50ID0gbnVtYmVyLnBlcmNlbnQsXG5cdCAgICAgICAgICAgIGN1cnJlbmN5ID0gbnVtYmVyLmN1cnJlbmN5LFxuXHQgICAgICAgICAgICBzeW1ib2wgPSBjdXJyZW5jeS5zeW1ib2wsXG5cdCAgICAgICAgICAgIHBlcmNlbnRTeW1ib2wgPSBwZXJjZW50LnN5bWJvbCxcblx0ICAgICAgICAgICAgbmVnYXRpdmUgPSB2YWx1ZS5pbmRleE9mKFwiLVwiKSxcblx0ICAgICAgICAgICAgcGFydHMsIGlzUGVyY2VudDtcblxuXHQgICAgICAgIC8vaGFuZGxlIGV4cG9uZW50aWFsIG51bWJlclxuXHQgICAgICAgIGlmIChleHBvbmVudFJlZ0V4cC50ZXN0KHZhbHVlKSkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUucmVwbGFjZShudW1iZXJbXCIuXCJdLCBcIi5cIikpO1xuXHQgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChuZWdhdGl2ZSA+IDApIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgbmVnYXRpdmUgPSBuZWdhdGl2ZSA+IC0xO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh2YWx1ZS5pbmRleE9mKHN5bWJvbCkgPiAtMSB8fCAoZm9ybWF0ICYmIGZvcm1hdC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJjXCIpID4gLTEpKSB7XG5cdCAgICAgICAgICAgIG51bWJlciA9IGN1cnJlbmN5O1xuXHQgICAgICAgICAgICBwYXJ0cyA9IG51bWJlci5wYXR0ZXJuWzBdLnJlcGxhY2UoXCIkXCIsIHN5bWJvbCkuc3BsaXQoXCJuXCIpO1xuXHQgICAgICAgICAgICBpZiAodmFsdWUuaW5kZXhPZihwYXJ0c1swXSkgPiAtMSAmJiB2YWx1ZS5pbmRleE9mKHBhcnRzWzFdKSA+IC0xKSB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocGFydHNbMF0sIFwiXCIpLnJlcGxhY2UocGFydHNbMV0sIFwiXCIpO1xuXHQgICAgICAgICAgICAgICAgbmVnYXRpdmUgPSB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5pbmRleE9mKHBlcmNlbnRTeW1ib2wpID4gLTEpIHtcblx0ICAgICAgICAgICAgaXNQZXJjZW50ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgbnVtYmVyID0gcGVyY2VudDtcblx0ICAgICAgICAgICAgc3ltYm9sID0gcGVyY2VudFN5bWJvbDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoXCItXCIsIFwiXCIpXG5cdCAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHN5bWJvbCwgXCJcIilcblx0ICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2Uobm9uQnJlYWtpbmdTcGFjZVJlZ0V4cCwgXCIgXCIpXG5cdCAgICAgICAgICAgICAgICAgICAgIC5zcGxpdChudW1iZXJbXCIsXCJdLnJlcGxhY2Uobm9uQnJlYWtpbmdTcGFjZVJlZ0V4cCwgXCIgXCIpKS5qb2luKFwiXCIpXG5cdCAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKG51bWJlcltcIi5cIl0sIFwiLlwiKTtcblxuXHQgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cblx0ICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcblx0ICAgICAgICB9IGVsc2UgaWYgKG5lZ2F0aXZlKSB7XG5cdCAgICAgICAgICAgIHZhbHVlICo9IC0xO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh2YWx1ZSAmJiBpc1BlcmNlbnQpIHtcblx0ICAgICAgICAgICAgdmFsdWUgLz0gMTAwO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH07XG5cdH0pKCk7XG5cblx0ICAgIGZ1bmN0aW9uIGdldFNoYWRvd3MoZWxlbWVudCkge1xuXHQgICAgICAgIHZhciBzaGFkb3cgPSBlbGVtZW50LmNzcyhrZW5kby5zdXBwb3J0LnRyYW5zaXRpb25zLmNzcyArIFwiYm94LXNoYWRvd1wiKSB8fCBlbGVtZW50LmNzcyhcImJveC1zaGFkb3dcIiksXG5cdCAgICAgICAgICAgIHJhZGl1cyA9IHNoYWRvdyA/IHNoYWRvdy5tYXRjaChib3hTaGFkb3dSZWdFeHApIHx8IFsgMCwgMCwgMCwgMCwgMCBdIDogWyAwLCAwLCAwLCAwLCAwIF0sXG5cdCAgICAgICAgICAgIGJsdXIgPSBtYXRoLm1heCgoK3JhZGl1c1szXSksICsocmFkaXVzWzRdIHx8IDApKTtcblxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIGxlZnQ6ICgtcmFkaXVzWzFdKSArIGJsdXIsXG5cdCAgICAgICAgICAgIHJpZ2h0OiAoK3JhZGl1c1sxXSkgKyBibHVyLFxuXHQgICAgICAgICAgICBib3R0b206ICgrcmFkaXVzWzJdKSArIGJsdXJcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiB3cmFwKGVsZW1lbnQsIGF1dG9zaXplKSB7XG5cdCAgICAgICAgdmFyIGJyb3dzZXIgPSBzdXBwb3J0LmJyb3dzZXIsXG5cdCAgICAgICAgICAgIHBlcmNlbnRhZ2UsXG5cdCAgICAgICAgICAgIG91dGVyV2lkdGggPSBrZW5kby5fb3V0ZXJXaWR0aCxcblx0ICAgICAgICAgICAgb3V0ZXJIZWlnaHQgPSBrZW5kby5fb3V0ZXJIZWlnaHQ7XG5cblx0ICAgICAgICBpZiAoIWVsZW1lbnQucGFyZW50KCkuaGFzQ2xhc3MoXCJrLWFuaW1hdGlvbi1jb250YWluZXJcIikpIHtcblx0ICAgICAgICAgICAgdmFyIHdpZHRoID0gZWxlbWVudFswXS5zdHlsZS53aWR0aCxcblx0ICAgICAgICAgICAgICAgIGhlaWdodCA9IGVsZW1lbnRbMF0uc3R5bGUuaGVpZ2h0LFxuXHQgICAgICAgICAgICAgICAgcGVyY2VudFdpZHRoID0gcGVyY2VudFJlZ0V4cC50ZXN0KHdpZHRoKSxcblx0ICAgICAgICAgICAgICAgIHBlcmNlbnRIZWlnaHQgPSBwZXJjZW50UmVnRXhwLnRlc3QoaGVpZ2h0KTtcblxuXHQgICAgICAgICAgICBwZXJjZW50YWdlID0gcGVyY2VudFdpZHRoIHx8IHBlcmNlbnRIZWlnaHQ7XG5cblx0ICAgICAgICAgICAgaWYgKCFwZXJjZW50V2lkdGggJiYgKCFhdXRvc2l6ZSB8fCAoYXV0b3NpemUgJiYgd2lkdGgpIHx8IGVsZW1lbnQuaGFzQ2xhc3MoXCJrLXRvb2x0aXBcIikpKSB7IHdpZHRoID0gYXV0b3NpemUgPyBvdXRlcldpZHRoKGVsZW1lbnQpICsgMSA6IG91dGVyV2lkdGgoZWxlbWVudCk7IH1cblx0ICAgICAgICAgICAgaWYgKCFwZXJjZW50SGVpZ2h0ICYmICghYXV0b3NpemUgfHwgKGF1dG9zaXplICYmIGhlaWdodCkpKSB7IGhlaWdodCA9IG91dGVySGVpZ2h0KGVsZW1lbnQpOyB9XG5cblx0ICAgICAgICAgICAgZWxlbWVudC53cmFwKFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgJChcIjxkaXYvPlwiKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKFwiay1hbmltYXRpb24tY29udGFpbmVyXCIpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuXHQgICAgICAgICAgICBpZiAocGVyY2VudGFnZSkge1xuXHQgICAgICAgICAgICAgICAgZWxlbWVudC5jc3Moe1xuXHQgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcblx0ICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuXHQgICAgICAgICAgICAgICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgbW96Qm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcblx0ICAgICAgICAgICAgICAgICAgICB3ZWJraXRCb3hTaXppbmc6IFwiYm9yZGVyLWJveFwiXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciB3cmFwcGVyID0gZWxlbWVudC5wYXJlbnQoXCIuay1hbmltYXRpb24tY29udGFpbmVyXCIpLFxuXHQgICAgICAgICAgICAgICAgd3JhcHBlclN0eWxlID0gd3JhcHBlclswXS5zdHlsZTtcblxuXHQgICAgICAgICAgICBpZiAod3JhcHBlci5pcyhcIjpoaWRkZW5cIikpIHtcblx0ICAgICAgICAgICAgICAgIHdyYXBwZXIuY3NzKHtcblx0ICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBcIlwiLFxuXHQgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBcIlwiXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHBlcmNlbnRhZ2UgPSBwZXJjZW50UmVnRXhwLnRlc3Qod3JhcHBlclN0eWxlLndpZHRoKSB8fCBwZXJjZW50UmVnRXhwLnRlc3Qod3JhcHBlclN0eWxlLmhlaWdodCk7XG5cblx0ICAgICAgICAgICAgaWYgKCFwZXJjZW50YWdlKSB7XG5cdCAgICAgICAgICAgICAgICB3cmFwcGVyLmNzcyh7XG5cdCAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGF1dG9zaXplID8gb3V0ZXJXaWR0aChlbGVtZW50KSArIDEgOiBvdXRlcldpZHRoKGVsZW1lbnQpLFxuXHQgICAgICAgICAgICAgICAgICAgIGhlaWdodDogb3V0ZXJIZWlnaHQoZWxlbWVudCksXG5cdCAgICAgICAgICAgICAgICAgICAgYm94U2l6aW5nOiBcImNvbnRlbnQtYm94XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgbW96Qm94U2l6aW5nOiBcImNvbnRlbnQtYm94XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgd2Via2l0Qm94U2l6aW5nOiBcImNvbnRlbnQtYm94XCJcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGJyb3dzZXIubXNpZSAmJiBtYXRoLmZsb29yKGJyb3dzZXIudmVyc2lvbikgPD0gNykge1xuXHQgICAgICAgICAgICBlbGVtZW50LmNzcyh7IHpvb206IDEgfSk7XG5cdCAgICAgICAgICAgIGVsZW1lbnQuY2hpbGRyZW4oXCIuay1tZW51XCIpLndpZHRoKGVsZW1lbnQud2lkdGgoKSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGVsZW1lbnQucGFyZW50KCk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGRlZXBFeHRlbmQoZGVzdGluYXRpb24pIHtcblx0ICAgICAgICB2YXIgaSA9IDEsXG5cdCAgICAgICAgICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cblx0ICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgZGVlcEV4dGVuZE9uZShkZXN0aW5hdGlvbiwgYXJndW1lbnRzW2ldKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gZGVzdGluYXRpb247XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGRlZXBFeHRlbmRPbmUoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuXHQgICAgICAgIHZhciBPYnNlcnZhYmxlQXJyYXkgPSBrZW5kby5kYXRhLk9ic2VydmFibGVBcnJheSxcblx0ICAgICAgICAgICAgTGF6eU9ic2VydmFibGVBcnJheSA9IGtlbmRvLmRhdGEuTGF6eU9ic2VydmFibGVBcnJheSxcblx0ICAgICAgICAgICAgRGF0YVNvdXJjZSA9IGtlbmRvLmRhdGEuRGF0YVNvdXJjZSxcblx0ICAgICAgICAgICAgSGllcmFyY2hpY2FsRGF0YVNvdXJjZSA9IGtlbmRvLmRhdGEuSGllcmFyY2hpY2FsRGF0YVNvdXJjZSxcblx0ICAgICAgICAgICAgcHJvcGVydHksXG5cdCAgICAgICAgICAgIHByb3BWYWx1ZSxcblx0ICAgICAgICAgICAgcHJvcFR5cGUsXG5cdCAgICAgICAgICAgIHByb3BJbml0LFxuXHQgICAgICAgICAgICBkZXN0UHJvcDtcblxuXHQgICAgICAgIGZvciAocHJvcGVydHkgaW4gc291cmNlKSB7XG5cdCAgICAgICAgICAgIHByb3BWYWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV07XG5cdCAgICAgICAgICAgIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcblxuXHQgICAgICAgICAgICBpZiAocHJvcFR5cGUgPT09IE9CSkVDVCAmJiBwcm9wVmFsdWUgIT09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHByb3BJbml0ID0gcHJvcFZhbHVlLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcHJvcEluaXQgPSBudWxsO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHByb3BJbml0ICYmXG5cdCAgICAgICAgICAgICAgICBwcm9wSW5pdCAhPT0gQXJyYXkgJiYgcHJvcEluaXQgIT09IE9ic2VydmFibGVBcnJheSAmJiBwcm9wSW5pdCAhPT0gTGF6eU9ic2VydmFibGVBcnJheSAmJlxuXHQgICAgICAgICAgICAgICAgcHJvcEluaXQgIT09IERhdGFTb3VyY2UgJiYgcHJvcEluaXQgIT09IEhpZXJhcmNoaWNhbERhdGFTb3VyY2UgJiYgcHJvcEluaXQgIT09IFJlZ0V4cCkge1xuXG5cdCAgICAgICAgICAgICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IG5ldyBEYXRlKHByb3BWYWx1ZS5nZXRUaW1lKCkpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHByb3BWYWx1ZS5jbG9uZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbltwcm9wZXJ0eV0gPSBwcm9wVmFsdWUuY2xvbmUoKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVzdFByb3AgPSBkZXN0aW5hdGlvbltwcm9wZXJ0eV07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoZGVzdFByb3ApID09PSBPQkpFQ1QpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gZGVzdFByb3AgfHwge307XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcGVydHldID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGRlZXBFeHRlbmRPbmUoZGVzdGluYXRpb25bcHJvcGVydHldLCBwcm9wVmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BUeXBlICE9PSBVTkRFRklORUQpIHtcblx0ICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BlcnR5XSA9IHByb3BWYWx1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gdGVzdFJ4KGFnZW50LCByeHMsIGRmbHQpIHtcblx0ICAgICAgICBmb3IgKHZhciByeCBpbiByeHMpIHtcblx0ICAgICAgICAgICAgaWYgKHJ4cy5oYXNPd25Qcm9wZXJ0eShyeCkgJiYgcnhzW3J4XS50ZXN0KGFnZW50KSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJ4O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBkZmx0ICE9PSB1bmRlZmluZWQgPyBkZmx0IDogYWdlbnQ7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHRvSHlwaGVucyhzdHIpIHtcblx0ICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XVtBLVpdKS9nLCBmdW5jdGlvbiAoZykge1xuXHQgICAgICAgICAgICByZXR1cm4gZy5jaGFyQXQoMCkgKyAnLScgKyBnLmNoYXJBdCgxKS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiB0b0NhbWVsQ2FzZShzdHIpIHtcblx0ICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xcLShcXHcpL2csIGZ1bmN0aW9uIChzdHJNYXRjaCwgZzEpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGcxLnRvVXBwZXJDYXNlKCk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGVzKGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcblx0ICAgICAgICB2YXIgc3R5bGVzID0ge30sIGNvbXB1dGVkU3R5bGU7XG5cblx0ICAgICAgICBpZiAoZG9jdW1lbnQuZGVmYXVsdFZpZXcgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuXHQgICAgICAgICAgICBjb21wdXRlZFN0eWxlID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBcIlwiKTtcblxuXHQgICAgICAgICAgICBpZiAocHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgJC5lYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKGlkeCwgdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdHlsZXNbdmFsdWVdID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgY29tcHV0ZWRTdHlsZSA9IGVsZW1lbnQuY3VycmVudFN0eWxlO1xuXG5cdCAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICAgICAgICAkLmVhY2gocHJvcGVydGllcywgZnVuY3Rpb24oaWR4LCB2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN0eWxlc1t2YWx1ZV0gPSBjb21wdXRlZFN0eWxlW3RvQ2FtZWxDYXNlKHZhbHVlKV07XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICgha2VuZG8uc2l6ZShzdHlsZXMpKSB7XG5cdCAgICAgICAgICAgIHN0eWxlcyA9IGNvbXB1dGVkU3R5bGU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHN0eWxlcztcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaXNTY3JvbGxhYmxlKGVsZW1lbnQpIHtcblx0ICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LmNsYXNzTmFtZSAmJiB0eXBlb2YoZWxlbWVudC5jbGFzc05hbWUpID09PSBcInN0cmluZ1wiICYmIGVsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YoXCJrLWF1dG8tc2Nyb2xsYWJsZVwiKSA+IC0xKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBvdmVyZmxvdyA9IGdldENvbXB1dGVkU3R5bGVzKGVsZW1lbnQsIFtcIm92ZXJmbG93XCJdKS5vdmVyZmxvdztcblx0ICAgICAgICByZXR1cm4gb3ZlcmZsb3cgPT0gXCJhdXRvXCIgfHwgb3ZlcmZsb3cgPT0gXCJzY3JvbGxcIjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gc2Nyb2xsTGVmdChlbGVtZW50LCB2YWx1ZSkge1xuXHQgICAgICAgIHZhciB3ZWJraXQgPSBzdXBwb3J0LmJyb3dzZXIud2Via2l0O1xuXHQgICAgICAgIHZhciBtb3ppbGEgPSBzdXBwb3J0LmJyb3dzZXIubW96aWxsYTtcblx0ICAgICAgICB2YXIgZWwgPSBlbGVtZW50IGluc3RhbmNlb2YgJCA/IGVsZW1lbnRbMF0gOiBlbGVtZW50O1xuXHQgICAgICAgIHZhciBpc1J0bDtcblxuXHQgICAgICAgIGlmICghZWxlbWVudCkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaXNSdGwgPSBzdXBwb3J0LmlzUnRsKGVsZW1lbnQpO1xuXG5cdCAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgaWYgKGlzUnRsICYmIHdlYmtpdCkge1xuXHQgICAgICAgICAgICAgICAgZWwuc2Nyb2xsTGVmdCA9IGVsLnNjcm9sbFdpZHRoIC0gZWwuY2xpZW50V2lkdGggLSB2YWx1ZTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChpc1J0bCAmJiBtb3ppbGEpIHtcblx0ICAgICAgICAgICAgICAgIGVsLnNjcm9sbExlZnQgPSAtdmFsdWU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBlbC5zY3JvbGxMZWZ0ID0gdmFsdWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBpZiAoaXNSdGwgJiYgd2Via2l0KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZWwuc2Nyb2xsV2lkdGggLSBlbC5jbGllbnRXaWR0aCAtIGVsLnNjcm9sbExlZnQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoZWwuc2Nyb2xsTGVmdCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgc3VwcG9ydC5fc2Nyb2xsYmFyID0gdW5kZWZpbmVkO1xuXG5cdCAgICAgICAgc3VwcG9ydC5zY3JvbGxiYXIgPSBmdW5jdGlvbiAocmVmcmVzaCkge1xuXHQgICAgICAgICAgICBpZiAoIWlzTmFOKHN1cHBvcnQuX3Njcm9sbGJhcikgJiYgIXJlZnJlc2gpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBzdXBwb3J0Ll9zY3JvbGxiYXI7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQ7XG5cblx0ICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5jc3NUZXh0ID0gXCJvdmVyZmxvdzpzY3JvbGw7b3ZlcmZsb3cteDpoaWRkZW47em9vbToxO2NsZWFyOmJvdGg7ZGlzcGxheTpibG9ja1wiO1xuXHQgICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IFwiJm5ic3A7XCI7XG5cdCAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG5cblx0ICAgICAgICAgICAgICAgIHN1cHBvcnQuX3Njcm9sbGJhciA9IHJlc3VsdCA9IGRpdi5vZmZzZXRXaWR0aCAtIGRpdi5zY3JvbGxXaWR0aDtcblxuXHQgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblxuXHQgICAgICAgIHN1cHBvcnQuaXNSdGwgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cdCAgICAgICAgICAgIHJldHVybiAkKGVsZW1lbnQpLmNsb3Nlc3QoXCIuay1ydGxcIikubGVuZ3RoID4gMDtcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgdmFyIHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRhYmxlXCIpO1xuXG5cdCAgICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgZG9lcyBub3Qgc3VwcG9ydCBzZXR0aW5nIHRoZSBpbm5lckhUTUwgb2YgVEJPRFkgYW5kIFRBQkxFIGVsZW1lbnRzXG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgdGFibGUuaW5uZXJIVE1MID0gXCI8dHI+PHRkPjwvdGQ+PC90cj5cIjtcblxuXHQgICAgICAgICAgICBzdXBwb3J0LnRib2R5SW5uZXJIdG1sID0gdHJ1ZTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgIHN1cHBvcnQudGJvZHlJbm5lckh0bWwgPSBmYWxzZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBzdXBwb3J0LnRvdWNoID0gXCJvbnRvdWNoc3RhcnRcIiBpbiB3aW5kb3c7XG5cblx0ICAgICAgICB2YXIgZG9jU3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG5cdCAgICAgICAgdmFyIHRyYW5zaXRpb25zID0gc3VwcG9ydC50cmFuc2l0aW9ucyA9IGZhbHNlLFxuXHQgICAgICAgICAgICB0cmFuc2Zvcm1zID0gc3VwcG9ydC50cmFuc2Zvcm1zID0gZmFsc2UsXG5cdCAgICAgICAgICAgIGVsZW1lbnRQcm90byA9IFwiSFRNTEVsZW1lbnRcIiBpbiB3aW5kb3cgPyBIVE1MRWxlbWVudC5wcm90b3R5cGUgOiBbXTtcblxuXHQgICAgICAgIHN1cHBvcnQuaGFzSFczRCA9IChcIldlYktpdENTU01hdHJpeFwiIGluIHdpbmRvdyAmJiBcIm0xMVwiIGluIG5ldyB3aW5kb3cuV2ViS2l0Q1NTTWF0cml4KCkpIHx8IFwiTW96UGVyc3BlY3RpdmVcIiBpbiBkb2NTdHlsZSB8fCBcIm1zUGVyc3BlY3RpdmVcIiBpbiBkb2NTdHlsZTtcblx0ICAgICAgICBzdXBwb3J0LmNzc0ZsZXhib3ggPSAoXCJmbGV4V3JhcFwiIGluIGRvY1N0eWxlKSB8fCAoXCJXZWJraXRGbGV4V3JhcFwiIGluIGRvY1N0eWxlKSB8fCAoXCJtc0ZsZXhXcmFwXCIgaW4gZG9jU3R5bGUpO1xuXG5cdCAgICAgICAgZWFjaChbIFwiTW96XCIsIFwid2Via2l0XCIsIFwiT1wiLCBcIm1zXCIgXSwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcHJlZml4ID0gdGhpcy50b1N0cmluZygpLFxuXHQgICAgICAgICAgICAgICAgaGFzVHJhbnNpdGlvbnMgPSB0eXBlb2YgdGFibGUuc3R5bGVbcHJlZml4ICsgXCJUcmFuc2l0aW9uXCJdID09PSBTVFJJTkc7XG5cblx0ICAgICAgICAgICAgaWYgKGhhc1RyYW5zaXRpb25zIHx8IHR5cGVvZiB0YWJsZS5zdHlsZVtwcmVmaXggKyBcIlRyYW5zZm9ybVwiXSA9PT0gU1RSSU5HKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbG93UHJlZml4ID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG5cblx0ICAgICAgICAgICAgICAgIHRyYW5zZm9ybXMgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY3NzOiAobG93UHJlZml4ICE9IFwibXNcIikgPyBcIi1cIiArIGxvd1ByZWZpeCArIFwiLVwiIDogXCJcIixcblx0ICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHByZWZpeCxcblx0ICAgICAgICAgICAgICAgICAgICBldmVudDogKGxvd1ByZWZpeCA9PT0gXCJvXCIgfHwgbG93UHJlZml4ID09PSBcIndlYmtpdFwiKSA/IGxvd1ByZWZpeCA6IFwiXCJcblx0ICAgICAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgICAgIGlmIChoYXNUcmFuc2l0aW9ucykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zID0gdHJhbnNmb3Jtcztcblx0ICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9ucy5ldmVudCA9IHRyYW5zaXRpb25zLmV2ZW50ID8gdHJhbnNpdGlvbnMuZXZlbnQgKyBcIlRyYW5zaXRpb25FbmRcIiA6IFwidHJhbnNpdGlvbmVuZFwiO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIHRhYmxlID0gbnVsbDtcblxuXHQgICAgICAgIHN1cHBvcnQudHJhbnNmb3JtcyA9IHRyYW5zZm9ybXM7XG5cdCAgICAgICAgc3VwcG9ydC50cmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zO1xuXG5cdCAgICAgICAgc3VwcG9ydC5kZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gPT09IHVuZGVmaW5lZCA/IDEgOiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcblxuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHN1cHBvcnQuc2NyZWVuV2lkdGggPSB3aW5kb3cub3V0ZXJXaWR0aCB8fCB3aW5kb3cuc2NyZWVuID8gd2luZG93LnNjcmVlbi5hdmFpbFdpZHRoIDogd2luZG93LmlubmVyV2lkdGg7XG5cdCAgICAgICAgICAgIHN1cHBvcnQuc2NyZWVuSGVpZ2h0ID0gd2luZG93Lm91dGVySGVpZ2h0IHx8IHdpbmRvdy5zY3JlZW4gPyB3aW5kb3cuc2NyZWVuLmF2YWlsSGVpZ2h0IDogd2luZG93LmlubmVySGVpZ2h0O1xuXHQgICAgICAgIH0gY2F0Y2goZSkge1xuXHQgICAgICAgICAgICAvL3dpbmRvdy5vdXRlcldpZHRoIHRocm93cyBlcnJvciB3aGVuIGluIElFIHNob3dNb2RhbERpYWxvZy5cblx0ICAgICAgICAgICAgc3VwcG9ydC5zY3JlZW5XaWR0aCA9IHdpbmRvdy5zY3JlZW4uYXZhaWxXaWR0aDtcblx0ICAgICAgICAgICAgc3VwcG9ydC5zY3JlZW5IZWlnaHQgPSB3aW5kb3cuc2NyZWVuLmF2YWlsSGVpZ2h0O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHN1cHBvcnQuZGV0ZWN0T1MgPSBmdW5jdGlvbiAodWEpIHtcblx0ICAgICAgICAgICAgdmFyIG9zID0gZmFsc2UsIG1pbm9yVmVyc2lvbiwgbWF0Y2ggPSBbXSxcblx0ICAgICAgICAgICAgICAgIG5vdEFuZHJvaWRQaG9uZSA9ICEvbW9iaWxlIHNhZmFyaS9pLnRlc3QodWEpLFxuXHQgICAgICAgICAgICAgICAgYWdlbnRSeHMgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgd3A6IC8oV2luZG93cyBQaG9uZSg/OiBPUyk/KVxccyhcXGQrKVxcLihcXGQrKFxcLlxcZCspPykvLFxuXHQgICAgICAgICAgICAgICAgICAgIGZpcmU6IC8oU2lsaylcXC8oXFxkKylcXC4oXFxkKyhcXC5cXGQrKT8pLyxcblx0ICAgICAgICAgICAgICAgICAgICBhbmRyb2lkOiAvKEFuZHJvaWR8QW5kcm9pZC4qKD86T3BlcmF8RmlyZWZveCkuKj9cXC8pXFxzKihcXGQrKVxcLj8oXFxkKyhcXC5cXGQrKT8pPy8sXG5cdCAgICAgICAgICAgICAgICAgICAgaXBob25lOiAvKGlQaG9uZXxpUG9kKS4qT1NcXHMrKFxcZCspW1xcLl9dKFtcXGRcXC5fXSspLyxcblx0ICAgICAgICAgICAgICAgICAgICBpcGFkOiAvKGlQYWQpLipPU1xccysoXFxkKylbXFwuX10oW1xcZF9dKykvLFxuXHQgICAgICAgICAgICAgICAgICAgIG1lZWdvOiAvKE1lZUdvKS4rTm9raWFCcm93c2VyXFwvKFxcZCspXFwuKFtcXGRcXC5fXSspLyxcblx0ICAgICAgICAgICAgICAgICAgICB3ZWJvczogLyh3ZWJPUylcXC8oXFxkKylcXC4oXFxkKyhcXC5cXGQrKT8pLyxcblx0ICAgICAgICAgICAgICAgICAgICBibGFja2JlcnJ5OiAvKEJsYWNrQmVycnl8QkIxMCkuKj9WZXJzaW9uXFwvKFxcZCspXFwuKFxcZCsoXFwuXFxkKyk/KS8sXG5cdCAgICAgICAgICAgICAgICAgICAgcGxheWJvb2s6IC8oUGxheUJvb2spLio/VGFibGV0XFxzKk9TXFxzKihcXGQrKVxcLihcXGQrKFxcLlxcZCspPykvLFxuXHQgICAgICAgICAgICAgICAgICAgIHdpbmRvd3M6IC8oTVNJRSlcXHMrKFxcZCspXFwuKFxcZCsoXFwuXFxkKyk/KS8sXG5cdCAgICAgICAgICAgICAgICAgICAgdGl6ZW46IC8odGl6ZW4pLio/VmVyc2lvblxcLyhcXGQrKVxcLihcXGQrKFxcLlxcZCspPykvaSxcblx0ICAgICAgICAgICAgICAgICAgICBzYWlsZmlzaDogLyhzYWlsZmlzaCkuKnJ2OihcXGQrKVxcLihcXGQrKFxcLlxcZCspPykuKmZpcmVmb3gvaSxcblx0ICAgICAgICAgICAgICAgICAgICBmZm9zOiAvKE1vYmlsZSkuKnJ2OihcXGQrKVxcLihcXGQrKFxcLlxcZCspPykuKkZpcmVmb3gvXG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgb3NSeHMgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW9zOiAvXmkocGhvbmV8cGFkfHBvZCkkL2ksXG5cdCAgICAgICAgICAgICAgICAgICAgYW5kcm9pZDogL15hbmRyb2lkfGZpcmUkL2ksXG5cdCAgICAgICAgICAgICAgICAgICAgYmxhY2tiZXJyeTogL15ibGFja2JlcnJ5fHBsYXlib29rL2ksXG5cdCAgICAgICAgICAgICAgICAgICAgd2luZG93czogL3dpbmRvd3MvLFxuXHQgICAgICAgICAgICAgICAgICAgIHdwOiAvd3AvLFxuXHQgICAgICAgICAgICAgICAgICAgIGZsYXQ6IC9zYWlsZmlzaHxmZm9zfHRpemVuL2ksXG5cdCAgICAgICAgICAgICAgICAgICAgbWVlZ286IC9tZWVnby9cblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBmb3JtRmFjdG9yUnhzID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIHRhYmxldDogL3BsYXlib29rfGlwYWR8ZmlyZS9pXG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgYnJvd3NlclJ4cyA9IHtcblx0ICAgICAgICAgICAgICAgICAgICBvbWluaTogL09wZXJhXFxzTWluaS9pLFxuXHQgICAgICAgICAgICAgICAgICAgIG9tb2JpbGU6IC9PcGVyYVxcc01vYmkvaSxcblx0ICAgICAgICAgICAgICAgICAgICBmaXJlZm94OiAvRmlyZWZveHxGZW5uZWMvaSxcblx0ICAgICAgICAgICAgICAgICAgICBtb2JpbGVzYWZhcmk6IC92ZXJzaW9uXFwvLipzYWZhcmkvaSxcblx0ICAgICAgICAgICAgICAgICAgICBpZTogL01TSUV8V2luZG93c1xcc1Bob25lL2ksXG5cdCAgICAgICAgICAgICAgICAgICAgY2hyb21lOiAvY2hyb21lfGNyaW9zL2ksXG5cdCAgICAgICAgICAgICAgICAgICAgd2Via2l0OiAvd2Via2l0L2lcblx0ICAgICAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgYWdlbnQgaW4gYWdlbnRSeHMpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChhZ2VudFJ4cy5oYXNPd25Qcm9wZXJ0eShhZ2VudCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IHVhLm1hdGNoKGFnZW50UnhzW2FnZW50XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZ2VudCA9PSBcIndpbmRvd3NcIiAmJiBcInBsdWdpbnNcIiBpbiBuYXZpZ2F0b3IpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIEJyZWFrIGlmIG5vdCBNZXRyby9Nb2JpbGUgV2luZG93c1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9zID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9zLmRldmljZSA9IGFnZW50O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcy50YWJsZXQgPSB0ZXN0UngoYWdlbnQsIGZvcm1GYWN0b3JSeHMsIGZhbHNlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3MuYnJvd3NlciA9IHRlc3RSeCh1YSwgYnJvd3NlclJ4cywgXCJkZWZhdWx0XCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcy5uYW1lID0gdGVzdFJ4KGFnZW50LCBvc1J4cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9zW29zLm5hbWVdID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3MubWFqb3JWZXJzaW9uID0gbWF0Y2hbMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9zLm1pbm9yVmVyc2lvbiA9IChtYXRjaFszXSB8fCBcIjBcIikucmVwbGFjZShcIl9cIiwgXCIuXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtaW5vclZlcnNpb24gPSBvcy5taW5vclZlcnNpb24ucmVwbGFjZShcIi5cIiwgXCJcIikuc3Vic3RyKDAsIDIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcy5mbGF0VmVyc2lvbiA9IG9zLm1ham9yVmVyc2lvbiArIG1pbm9yVmVyc2lvbiArIChuZXcgQXJyYXkoMyAtIChtaW5vclZlcnNpb24ubGVuZ3RoIDwgMyA/IG1pbm9yVmVyc2lvbi5sZW5ndGggOiAyKSkuam9pbihcIjBcIikpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcy5jb3Jkb3ZhID0gdHlwZW9mIHdpbmRvdy5QaG9uZUdhcCAhPT0gVU5ERUZJTkVEIHx8IHR5cGVvZiB3aW5kb3cuY29yZG92YSAhPT0gVU5ERUZJTkVEOyAvLyBVc2UgZmlsZSBwcm90b2NvbCB0byBkZXRlY3QgYXBwTW9kZXMuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9zLmFwcE1vZGUgPSB3aW5kb3cubmF2aWdhdG9yLnN0YW5kYWxvbmUgfHwgKC9maWxlfGxvY2FsfHdtYXBwLykudGVzdCh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wpIHx8IG9zLmNvcmRvdmE7IC8vIFVzZSBmaWxlIHByb3RvY29sIHRvIGRldGVjdCBhcHBNb2Rlcy5cblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3MuYW5kcm9pZCAmJiAoc3VwcG9ydC5kZXZpY2VQaXhlbFJhdGlvIDwgMS41ICYmIG9zLmZsYXRWZXJzaW9uIDwgNDAwIHx8IG5vdEFuZHJvaWRQaG9uZSkgJiYgKHN1cHBvcnQuc2NyZWVuV2lkdGggPiA4MDAgfHwgc3VwcG9ydC5zY3JlZW5IZWlnaHQgPiA4MDApKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcy50YWJsZXQgPSBhZ2VudDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gb3M7XG5cdCAgICAgICAgfTtcblxuXHQgICAgICAgIHZhciBtb2JpbGVPUyA9IHN1cHBvcnQubW9iaWxlT1MgPSBzdXBwb3J0LmRldGVjdE9TKG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cdCAgICAgICAgc3VwcG9ydC53cERldmljZVBpeGVsUmF0aW8gPSBtb2JpbGVPUy53cCA/IHNjcmVlbi53aWR0aCAvIDMyMCA6IDA7XG5cblx0ICAgICAgICBzdXBwb3J0Lmhhc05hdGl2ZVNjcm9sbGluZyA9IGZhbHNlO1xuXG5cdCAgICAgICAgaWYgKG1vYmlsZU9TLmlvcyB8fCAobW9iaWxlT1MuYW5kcm9pZCAmJiBtb2JpbGVPUy5tYWpvclZlcnNpb24gPiAyKSB8fCBtb2JpbGVPUy53cCkge1xuXHQgICAgICAgICAgICBzdXBwb3J0Lmhhc05hdGl2ZVNjcm9sbGluZyA9IG1vYmlsZU9TO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHN1cHBvcnQuZGVsYXllZENsaWNrID0gZnVuY3Rpb24oKSB7XG5cblx0ICAgICAgICAgICAgLy8gb25seSB0aGUgbW9iaWxlIGRldmljZXMgd2l0aCB0b3VjaCBldmVudHMgZG8gdGhpcy5cblx0ICAgICAgICAgICAgaWYgKHN1cHBvcnQudG91Y2gpIHtcblx0ICAgICAgICAgICAgICAgIC8vIEFsbCBpT1MgZGV2aWNlcyBzbyBmYXIgKGJ5IHRoZSB0aW1lIEkgYW0gd3JpdGluZyB0aGlzLCBpT1MgOS4wLjIgaXMgdGhlIGxhdGVzdCksXG5cdCAgICAgICAgICAgICAgICAvLyBkZWxheSB0aGVpciBjbGljayBldmVudHMuXG5cdCAgICAgICAgICAgICAgICBpZiAobW9iaWxlT1MuaW9zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChtb2JpbGVPUy5hbmRyb2lkKSB7XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXN1cHBvcnQuYnJvd3Nlci5jaHJvbWUpIHsgLy8gb2xkZXIgd2Via2l0cyBhbmQgd2Vidmlld3MgZGVsYXkgdGhlIGNsaWNrXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGZyb20gaGVyZSBvbiwgd2UgZGVhbCB3aXRoIENocm9tZSBvbiBBbmRyb2lkLlxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0LmJyb3dzZXIudmVyc2lvbiA8IDMyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWUgMzIrIGRvZXMgY29uZGl0aW9uYWwgZmFzdCBjbGlja3MgaWYgdGhlIHZpZXcgcG9ydCBpcyBub3QgdXNlciBzY2FsYWJsZS5cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gISgkKFwibWV0YVtuYW1lPXZpZXdwb3J0XVwiKS5hdHRyKFwiY29udGVudFwiKSB8fCBcIlwiKS5tYXRjaCgvdXNlci1zY2FsYWJsZT1uby9pKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgc3VwcG9ydC5tb3VzZUFuZFRvdWNoUHJlc2VudCA9IHN1cHBvcnQudG91Y2ggJiYgIShzdXBwb3J0Lm1vYmlsZU9TLmlvcyB8fCBzdXBwb3J0Lm1vYmlsZU9TLmFuZHJvaWQpO1xuXG5cdCAgICAgICAgc3VwcG9ydC5kZXRlY3RCcm93c2VyID0gZnVuY3Rpb24odWEpIHtcblx0ICAgICAgICAgICAgdmFyIGJyb3dzZXIgPSBmYWxzZSwgbWF0Y2ggPSBbXSxcblx0ICAgICAgICAgICAgICAgIGJyb3dzZXJSeHMgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZWRnZTogLyhlZGdlKVsgXFwvXShbXFx3Ll0rKS9pLFxuXHQgICAgICAgICAgICAgICAgICAgIHdlYmtpdDogLyhjaHJvbWV8Y3Jpb3MpWyBcXC9dKFtcXHcuXSspL2ksXG5cdCAgICAgICAgICAgICAgICAgICAgc2FmYXJpOiAvKHdlYmtpdClbIFxcL10oW1xcdy5dKykvaSxcblx0ICAgICAgICAgICAgICAgICAgICBvcGVyYTogLyhvcGVyYSkoPzouKnZlcnNpb258KVsgXFwvXShbXFx3Ll0rKS9pLFxuXHQgICAgICAgICAgICAgICAgICAgIG1zaWU6IC8obXNpZVxcc3x0cmlkZW50Lio/IHJ2OikoW1xcdy5dKykvaSxcblx0ICAgICAgICAgICAgICAgICAgICBtb3ppbGxhOiAvKG1vemlsbGEpKD86Lio/IHJ2OihbXFx3Ll0rKXwpL2lcblx0ICAgICAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgYWdlbnQgaW4gYnJvd3NlclJ4cykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGJyb3dzZXJSeHMuaGFzT3duUHJvcGVydHkoYWdlbnQpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSB1YS5tYXRjaChicm93c2VyUnhzW2FnZW50XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyb3dzZXIgPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJvd3NlclthZ2VudF0gPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicm93c2VyW21hdGNoWzFdLnRvTG93ZXJDYXNlKCkuc3BsaXQoXCIgXCIpWzBdLnNwbGl0KFwiL1wiKVswXV0gPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicm93c2VyLnZlcnNpb24gPSBwYXJzZUludChkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgbWF0Y2hbMl0sIDEwKTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gYnJvd3Nlcjtcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgc3VwcG9ydC5icm93c2VyID0gc3VwcG9ydC5kZXRlY3RCcm93c2VyKG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cdCAgICAgICAgc3VwcG9ydC5kZXRlY3RDbGlwYm9hcmRBY2Nlc3MgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIGNvbW1hbmRzID0ge1xuXHQgICAgICAgICAgICAgICAgY29weTogZG9jdW1lbnQucXVlcnlDb21tYW5kU3VwcG9ydGVkID8gZG9jdW1lbnQucXVlcnlDb21tYW5kU3VwcG9ydGVkKFwiY29weVwiKSA6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgY3V0OiBkb2N1bWVudC5xdWVyeUNvbW1hbmRTdXBwb3J0ZWQgPyBkb2N1bWVudC5xdWVyeUNvbW1hbmRTdXBwb3J0ZWQoXCJjdXRcIikgOiBmYWxzZSxcblx0ICAgICAgICAgICAgICAgIHBhc3RlIDogZG9jdW1lbnQucXVlcnlDb21tYW5kU3VwcG9ydGVkID8gZG9jdW1lbnQucXVlcnlDb21tYW5kU3VwcG9ydGVkKFwicGFzdGVcIikgOiBmYWxzZVxuXHQgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgIGlmIChzdXBwb3J0LmJyb3dzZXIuY2hyb21lKSB7XG5cdCAgICAgICAgICAgICAgICAvL25vdCB1c2luZyBxdWVyeUNvbW1hbmRTdXBwb3J0ZWQgZHVlIHRvIGNocm9taXVtIGlzc3VlcyA0NzY1MDggYW5kIDU0Mjk0OFxuXHQgICAgICAgICAgICAgICAgY29tbWFuZHMucGFzdGUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIGlmKHN1cHBvcnQuYnJvd3Nlci52ZXJzaW9uID49IDQzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29tbWFuZHMuY29weSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgY29tbWFuZHMuY3V0ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBjb21tYW5kcztcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgc3VwcG9ydC5jbGlwYm9hcmQgPSBzdXBwb3J0LmRldGVjdENsaXBib2FyZEFjY2VzcygpO1xuXG5cdCAgICAgICAgc3VwcG9ydC56b29tTGV2ZWwgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHZhciBicm93c2VyID0gc3VwcG9ydC5icm93c2VyO1xuXHQgICAgICAgICAgICAgICAgdmFyIGllMTFXaWR0aENvcnJlY3Rpb24gPSAwO1xuXHQgICAgICAgICAgICAgICAgdmFyIGRvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoYnJvd3Nlci5tc2llICYmIGJyb3dzZXIudmVyc2lvbiA9PSAxMSAmJiBkb2NFbC5zY3JvbGxIZWlnaHQgPiBkb2NFbC5jbGllbnRIZWlnaHQgJiYgIXN1cHBvcnQudG91Y2gpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZTExV2lkdGhDb3JyZWN0aW9uID0gc3VwcG9ydC5zY3JvbGxiYXIoKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnQudG91Y2ggPyAoZG9jRWwuY2xpZW50V2lkdGggLyB3aW5kb3cuaW5uZXJXaWR0aCkgOlxuXHQgICAgICAgICAgICAgICAgICAgICAgIGJyb3dzZXIubXNpZSAmJiBicm93c2VyLnZlcnNpb24gPj0gMTAgPyAoKCh0b3AgfHwgd2luZG93KS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub2Zmc2V0V2lkdGggKyBpZTExV2lkdGhDb3JyZWN0aW9uKSAvICh0b3AgfHwgd2luZG93KS5pbm5lcldpZHRoKSA6IDE7XG5cdCAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgc3VwcG9ydC5jc3NCb3JkZXJTcGFjaW5nID0gdHlwZW9mIGRvY1N0eWxlLmJvcmRlclNwYWNpbmcgIT0gXCJ1bmRlZmluZWRcIiAmJiAhKHN1cHBvcnQuYnJvd3Nlci5tc2llICYmIHN1cHBvcnQuYnJvd3Nlci52ZXJzaW9uIDwgOCk7XG5cblx0ICAgICAgICAoZnVuY3Rpb24oYnJvd3Nlcikge1xuXHQgICAgICAgICAgICAvLyBhZGQgYnJvd3Nlci1zcGVjaWZpYyBDU1MgY2xhc3Ncblx0ICAgICAgICAgICAgdmFyIGNzc0NsYXNzID0gXCJcIixcblx0ICAgICAgICAgICAgICAgIGRvY0VsZW1lbnQgPSAkKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCksXG5cdCAgICAgICAgICAgICAgICBtYWpvclZlcnNpb24gPSBwYXJzZUludChicm93c2VyLnZlcnNpb24sIDEwKTtcblxuXHQgICAgICAgICAgICBpZiAoYnJvd3Nlci5tc2llKSB7XG5cdCAgICAgICAgICAgICAgICBjc3NDbGFzcyA9IFwiaWVcIjtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChicm93c2VyLm1vemlsbGEpIHtcblx0ICAgICAgICAgICAgICAgIGNzc0NsYXNzID0gXCJmZlwiO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGJyb3dzZXIuc2FmYXJpKSB7XG5cdCAgICAgICAgICAgICAgICBjc3NDbGFzcyA9IFwic2FmYXJpXCI7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoYnJvd3Nlci53ZWJraXQpIHtcblx0ICAgICAgICAgICAgICAgIGNzc0NsYXNzID0gXCJ3ZWJraXRcIjtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChicm93c2VyLm9wZXJhKSB7XG5cdCAgICAgICAgICAgICAgICBjc3NDbGFzcyA9IFwib3BlcmFcIjtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChicm93c2VyLmVkZ2UpIHtcblx0ICAgICAgICAgICAgICAgIGNzc0NsYXNzID0gXCJlZGdlXCI7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoY3NzQ2xhc3MpIHtcblx0ICAgICAgICAgICAgICAgIGNzc0NsYXNzID0gXCJrLVwiICsgY3NzQ2xhc3MgKyBcIiBrLVwiICsgY3NzQ2xhc3MgKyBtYWpvclZlcnNpb247XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHN1cHBvcnQubW9iaWxlT1MpIHtcblx0ICAgICAgICAgICAgICAgIGNzc0NsYXNzICs9IFwiIGstbW9iaWxlXCI7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoIXN1cHBvcnQuY3NzRmxleGJveCkge1xuXHQgICAgICAgICAgICAgICAgY3NzQ2xhc3MgKz0gXCIgay1uby1mbGV4Ym94XCI7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBkb2NFbGVtZW50LmFkZENsYXNzKGNzc0NsYXNzKTtcblx0ICAgICAgICB9KShzdXBwb3J0LmJyb3dzZXIpO1xuXG5cdCAgICAgICAgc3VwcG9ydC5ldmVudENhcHR1cmUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcjtcblxuXHQgICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblxuXHQgICAgICAgIHN1cHBvcnQucGxhY2Vob2xkZXIgPSBcInBsYWNlaG9sZGVyXCIgaW4gaW5wdXQ7XG5cdCAgICAgICAgc3VwcG9ydC5wcm9wZXJ0eUNoYW5nZUV2ZW50ID0gXCJvbnByb3BlcnR5Y2hhbmdlXCIgaW4gaW5wdXQ7XG5cblx0ICAgICAgICBzdXBwb3J0LmlucHV0ID0gKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgdHlwZXMgPSBbXCJudW1iZXJcIiwgXCJkYXRlXCIsIFwidGltZVwiLCBcIm1vbnRoXCIsIFwid2Vla1wiLCBcImRhdGV0aW1lXCIsIFwiZGF0ZXRpbWUtbG9jYWxcIl07XG5cdCAgICAgICAgICAgIHZhciBsZW5ndGggPSB0eXBlcy5sZW5ndGg7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IFwidGVzdFwiO1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICAgICAgICAgIHZhciBpZHggPSAwO1xuXHQgICAgICAgICAgICB2YXIgdHlwZTtcblxuXHQgICAgICAgICAgICBmb3IgKDtpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICB0eXBlID0gdHlwZXNbaWR4XTtcblx0ICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgdHlwZSk7XG5cdCAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xuXG5cdCAgICAgICAgICAgICAgICByZXN1bHRbdHlwZS5yZXBsYWNlKFwiLVwiLCBcIlwiKV0gPSBpbnB1dC50eXBlICE9PSBcInRleHRcIiAmJiBpbnB1dC52YWx1ZSAhPT0gdmFsdWU7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH0pKCk7XG5cblx0ICAgICAgICBpbnB1dC5zdHlsZS5jc3NUZXh0ID0gXCJmbG9hdDpsZWZ0O1wiO1xuXG5cdCAgICAgICAgc3VwcG9ydC5jc3NGbG9hdCA9ICEhaW5wdXQuc3R5bGUuY3NzRmxvYXQ7XG5cblx0ICAgICAgICBpbnB1dCA9IG51bGw7XG5cblx0ICAgICAgICBzdXBwb3J0LnN0YWJsZVNvcnQgPSAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIC8vIENocm9tZSBzb3J0IGlzIG5vdCBzdGFibGUgZm9yIG1vcmUgdGhhbiAqMTAqIGl0ZW1zXG5cdCAgICAgICAgICAgIC8vIElFOSsgc29ydCBpcyBub3Qgc3RhYmxlIGZvciB0aGFuICo1MTIqIGl0ZW1zXG5cdCAgICAgICAgICAgIHZhciB0aHJlc2hvbGQgPSA1MTM7XG5cblx0ICAgICAgICAgICAgdmFyIHNvcnRlZCA9IFt7XG5cdCAgICAgICAgICAgICAgICBpbmRleDogMCxcblx0ICAgICAgICAgICAgICAgIGZpZWxkOiBcImJcIlxuXHQgICAgICAgICAgICB9XTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRocmVzaG9sZDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBzb3J0ZWQucHVzaCh7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG5cdCAgICAgICAgICAgICAgICAgICAgZmllbGQ6IFwiYVwiXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHNvcnRlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhLmZpZWxkID4gYi5maWVsZCA/IDEgOiAoYS5maWVsZCA8IGIuZmllbGQgPyAtMSA6IDApO1xuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICByZXR1cm4gc29ydGVkWzBdLmluZGV4ID09PSAxO1xuXHQgICAgICAgIH0pKCk7XG5cblx0ICAgICAgICBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IGVsZW1lbnRQcm90by53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZWxlbWVudFByb3RvLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGVsZW1lbnRQcm90by5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50UHJvdG8ubWF0Y2hlc1NlbGVjdG9yIHx8IGVsZW1lbnRQcm90by5tYXRjaGVzIHx8XG5cdCAgICAgICAgICBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdCAgICAgICAgICAgICAgdmFyIG5vZGVMaXN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCA/ICggdGhpcy5wYXJlbnROb2RlIHx8IGRvY3VtZW50ICkucXVlcnlTZWxlY3RvckFsbCggc2VsZWN0b3IgKSB8fCBbXSA6ICQoc2VsZWN0b3IpLFxuXHQgICAgICAgICAgICAgICAgICBpID0gbm9kZUxpc3QubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuXHQgICAgICAgICAgICAgICAgICBpZiAobm9kZUxpc3RbaV0gPT0gdGhpcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICB9O1xuXG5cdCAgICAgICAgc3VwcG9ydC5tYXRjaE1lZGlhID0gXCJtYXRjaE1lZGlhXCIgaW4gd2luZG93O1xuXG5cdCAgICAgICAgc3VwcG9ydC5wdXNoU3RhdGUgPSB3aW5kb3cuaGlzdG9yeSAmJiB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGU7XG5cblx0ICAgICAgICB2YXIgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xuXG5cdCAgICAgICAgc3VwcG9ydC5oYXNoQ2hhbmdlID0gKFwib25oYXNoY2hhbmdlXCIgaW4gd2luZG93KSAmJiAhKHN1cHBvcnQuYnJvd3Nlci5tc2llICYmICghZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50TW9kZSA8PSA4KSk7IC8vIG9sZCBJRSBkZXRlY3Rpb25cblxuXHQgICAgICAgIHN1cHBvcnQuY3VzdG9tRWxlbWVudHMgPSAoXCJyZWdpc3RlckVsZW1lbnRcIiBpbiB3aW5kb3cuZG9jdW1lbnQpO1xuXG5cdCAgICAgICAgdmFyIGNocm9tZSA9IHN1cHBvcnQuYnJvd3Nlci5jaHJvbWUsXG5cdCAgICAgICAgICAgIG1vemlsbGEgPSBzdXBwb3J0LmJyb3dzZXIubW96aWxsYTtcblx0ICAgICAgICBzdXBwb3J0Lm1zUG9pbnRlcnMgPSAhY2hyb21lICYmIHdpbmRvdy5NU1BvaW50ZXJFdmVudDtcblx0ICAgICAgICBzdXBwb3J0LnBvaW50ZXJzID0gIWNocm9tZSAmJiAhbW96aWxsYSAmJiB3aW5kb3cuUG9pbnRlckV2ZW50O1xuXHQgICAgICAgIHN1cHBvcnQua2luZXRpY1Njcm9sbE5lZWRlZCA9IG1vYmlsZU9TICYmIChzdXBwb3J0LnRvdWNoIHx8IHN1cHBvcnQubXNQb2ludGVycyB8fCBzdXBwb3J0LnBvaW50ZXJzKTtcblx0ICAgIH0pKCk7XG5cblxuXHQgICAgZnVuY3Rpb24gc2l6ZShvYmopIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gMCwga2V5O1xuXHQgICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuXHQgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkgJiYga2V5ICE9IFwidG9KU09OXCIpIHsgLy8gSWdub3JlIGZha2UgSUU3IHRvSlNPTi5cblx0ICAgICAgICAgICAgICAgIHJlc3VsdCsrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZ2V0T2Zmc2V0KGVsZW1lbnQsIHR5cGUsIHBvc2l0aW9uZWQpIHtcblx0ICAgICAgICBpZiAoIXR5cGUpIHtcblx0ICAgICAgICAgICAgdHlwZSA9IFwib2Zmc2V0XCI7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIG9mZnNldCA9IGVsZW1lbnRbdHlwZV0oKTtcblx0ICAgICAgICAvLyBjbG9uZSBDbGllbnRSZWN0IG9iamVjdCB0byBKUyBvYmplY3QgKGpRdWVyeTMpXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHtcblx0ICAgICAgICAgICAgdG9wOiBvZmZzZXQudG9wLFxuXHQgICAgICAgICAgICByaWdodDogb2Zmc2V0LnJpZ2h0LFxuXHQgICAgICAgICAgICBib3R0b206IG9mZnNldC5ib3R0b20sXG5cdCAgICAgICAgICAgIGxlZnQ6IG9mZnNldC5sZWZ0XG5cdCAgICAgICAgfTtcblxuXHQgICAgICAgIC8vIElFMTAgdG91Y2ggem9vbSBpcyBsaXZpbmcgaW4gYSBzZXBhcmF0ZSB2aWV3cG9ydFxuXHQgICAgICAgIGlmIChzdXBwb3J0LmJyb3dzZXIubXNpZSAmJiAoc3VwcG9ydC5wb2ludGVycyB8fCBzdXBwb3J0Lm1zUG9pbnRlcnMpICYmICFwb3NpdGlvbmVkKSB7XG5cdCAgICAgICAgICAgIHZhciBzaWduID0gc3VwcG9ydC5pc1J0bChlbGVtZW50KSA/IDEgOiAtMTtcblxuXHQgICAgICAgICAgICByZXN1bHQudG9wIC09ICh3aW5kb3cucGFnZVlPZmZzZXQgLSAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCkpO1xuXHQgICAgICAgICAgICByZXN1bHQubGVmdCAtPSAod2luZG93LnBhZ2VYT2Zmc2V0ICsgKHNpZ24gKiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cblx0ICAgIHZhciBkaXJlY3Rpb25zID0ge1xuXHQgICAgICAgIGxlZnQ6IHsgcmV2ZXJzZTogXCJyaWdodFwiIH0sXG5cdCAgICAgICAgcmlnaHQ6IHsgcmV2ZXJzZTogXCJsZWZ0XCIgfSxcblx0ICAgICAgICBkb3duOiB7IHJldmVyc2U6IFwidXBcIiB9LFxuXHQgICAgICAgIHVwOiB7IHJldmVyc2U6IFwiZG93blwiIH0sXG5cdCAgICAgICAgdG9wOiB7IHJldmVyc2U6IFwiYm90dG9tXCIgfSxcblx0ICAgICAgICBib3R0b206IHsgcmV2ZXJzZTogXCJ0b3BcIiB9LFxuXHQgICAgICAgIFwiaW5cIjogeyByZXZlcnNlOiBcIm91dFwiIH0sXG5cdCAgICAgICAgb3V0OiB7IHJldmVyc2U6IFwiaW5cIiB9XG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBwYXJzZUVmZmVjdHMoaW5wdXQpIHtcblx0ICAgICAgICB2YXIgZWZmZWN0cyA9IHt9O1xuXG5cdCAgICAgICAgZWFjaCgodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiID8gaW5wdXQuc3BsaXQoXCIgXCIpIDogaW5wdXQpLCBmdW5jdGlvbihpZHgpIHtcblx0ICAgICAgICAgICAgZWZmZWN0c1tpZHhdID0gdGhpcztcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIHJldHVybiBlZmZlY3RzO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBmeChlbGVtZW50KSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBrZW5kby5lZmZlY3RzLkVsZW1lbnQoZWxlbWVudCk7XG5cdCAgICB9XG5cblx0ICAgIHZhciBlZmZlY3RzID0ge307XG5cblx0ICAgICQuZXh0ZW5kKGVmZmVjdHMsIHtcblx0ICAgICAgICBlbmFibGVkOiB0cnVlLFxuXHQgICAgICAgIEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gJChlbGVtZW50KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgcHJvbWlzZTogZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuXHQgICAgICAgICAgICBpZiAoIWVsZW1lbnQuaXMoXCI6dmlzaWJsZVwiKSkge1xuXHQgICAgICAgICAgICAgICAgZWxlbWVudC5jc3MoeyBkaXNwbGF5OiBlbGVtZW50LmRhdGEoXCJvbGRkaXNwbGF5XCIpIHx8IFwiYmxvY2tcIiB9KS5jc3MoXCJkaXNwbGF5XCIpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGlkZSkge1xuXHQgICAgICAgICAgICAgICAgZWxlbWVudC5kYXRhKFwib2xkZGlzcGxheVwiLCBlbGVtZW50LmNzcyhcImRpc3BsYXlcIikpLmhpZGUoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmIChvcHRpb25zLmluaXQpIHtcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuaW5pdCgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMuY29tcGxldGVDYWxsYmFjaykge1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5jb21wbGV0ZUNhbGxiYWNrKGVsZW1lbnQpOyAvLyBjYWxsIHRoZSBleHRlcm5hbCBjb21wbGV0ZSBjYWxsYmFjayB3aXRoIHRoZSBlbGVtZW50XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBlbGVtZW50LmRlcXVldWUoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICB0aGlzLnByb21pc2UgPSB0aGlzLnByb21pc2VTaGltO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBlbmFibGU6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICB0aGlzLnByb21pc2UgPSB0aGlzLmFuaW1hdGVkUHJvbWlzZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZWZmZWN0cy5wcm9taXNlU2hpbSA9IGVmZmVjdHMucHJvbWlzZTtcblxuXHQgICAgZnVuY3Rpb24gcHJlcGFyZUFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucywgZHVyYXRpb24sIHJldmVyc2UsIGNvbXBsZXRlKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBTVFJJTkcpIHtcblx0ICAgICAgICAgICAgLy8gb3B0aW9ucyBpcyB0aGUgbGlzdCBvZiBlZmZlY3QgbmFtZXMgc2VwYXJhdGVkIGJ5IHNwYWNlIGUuZy4gYW5pbWF0ZShlbGVtZW50LCBcImZhZGVJbiBzbGlkZURvd25cIilcblxuXHQgICAgICAgICAgICAvLyBvbmx5IGNhbGxiYWNrIGlzIHByb3ZpZGVkIGUuZy4gYW5pbWF0ZShlbGVtZW50LCBvcHRpb25zLCBmdW5jdGlvbigpIHt9KTtcblx0ICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oZHVyYXRpb24pKSB7XG5cdCAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IGR1cmF0aW9uO1xuXHQgICAgICAgICAgICAgICAgZHVyYXRpb24gPSA0MDA7XG5cdCAgICAgICAgICAgICAgICByZXZlcnNlID0gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihyZXZlcnNlKSkge1xuXHQgICAgICAgICAgICAgICAgY29tcGxldGUgPSByZXZlcnNlO1xuXHQgICAgICAgICAgICAgICAgcmV2ZXJzZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gQk9PTEVBTil7XG5cdCAgICAgICAgICAgICAgICByZXZlcnNlID0gZHVyYXRpb247XG5cdCAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IDQwMDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSB7XG5cdCAgICAgICAgICAgICAgICBlZmZlY3RzOiBvcHRpb25zLFxuXHQgICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuXHQgICAgICAgICAgICAgICAgcmV2ZXJzZTogcmV2ZXJzZSxcblx0ICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBleHRlbmQoe1xuXHQgICAgICAgICAgICAvL2RlZmF1bHQgb3B0aW9uc1xuXHQgICAgICAgICAgICBlZmZlY3RzOiB7fSxcblx0ICAgICAgICAgICAgZHVyYXRpb246IDQwMCwgLy9qUXVlcnkgZGVmYXVsdCBkdXJhdGlvblxuXHQgICAgICAgICAgICByZXZlcnNlOiBmYWxzZSxcblx0ICAgICAgICAgICAgaW5pdDogbm9vcCxcblx0ICAgICAgICAgICAgdGVhcmRvd246IG5vb3AsXG5cdCAgICAgICAgICAgIGhpZGU6IGZhbHNlXG5cdCAgICAgICAgfSwgb3B0aW9ucywgeyBjb21wbGV0ZUNhbGxiYWNrOiBvcHRpb25zLmNvbXBsZXRlLCBjb21wbGV0ZTogbm9vcCB9KTsgLy8gTW92ZSBleHRlcm5hbCBjb21wbGV0ZSBjYWxsYmFjaywgc28gZGVmZXJyZWQucmVzb2x2ZSBjYW4gYmUgYWx3YXlzIGV4ZWN1dGVkLlxuXG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGFuaW1hdGUoZWxlbWVudCwgb3B0aW9ucywgZHVyYXRpb24sIHJldmVyc2UsIGNvbXBsZXRlKSB7XG5cdCAgICAgICAgdmFyIGlkeCA9IDAsXG5cdCAgICAgICAgICAgIGxlbmd0aCA9IGVsZW1lbnQubGVuZ3RoLFxuXHQgICAgICAgICAgICBpbnN0YW5jZTtcblxuXHQgICAgICAgIGZvciAoOyBpZHggPCBsZW5ndGg7IGlkeCArKykge1xuXHQgICAgICAgICAgICBpbnN0YW5jZSA9ICQoZWxlbWVudFtpZHhdKTtcblx0ICAgICAgICAgICAgaW5zdGFuY2UucXVldWUoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBlZmZlY3RzLnByb21pc2UoaW5zdGFuY2UsIHByZXBhcmVBbmltYXRpb25PcHRpb25zKG9wdGlvbnMsIGR1cmF0aW9uLCByZXZlcnNlLCBjb21wbGV0ZSkpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gZWxlbWVudDtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbWVudCwgY2xhc3Nlcywgb3B0aW9ucywgYWRkKSB7XG5cdCAgICAgICAgaWYgKGNsYXNzZXMpIHtcblx0ICAgICAgICAgICAgY2xhc3NlcyA9IGNsYXNzZXMuc3BsaXQoXCIgXCIpO1xuXG5cdCAgICAgICAgICAgIGVhY2goY2xhc3NlcywgZnVuY3Rpb24oaWR4LCB2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgZWxlbWVudC50b2dnbGVDbGFzcyh2YWx1ZSwgYWRkKTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG5cdCAgICB9XG5cblx0ICAgIGlmICghKFwia2VuZG9BbmltYXRlXCIgaW4gJC5mbikpIHtcblx0ICAgICAgICBleHRlbmQoJC5mbiwge1xuXHQgICAgICAgICAgICBrZW5kb1N0b3A6IGZ1bmN0aW9uKGNsZWFyUXVldWUsIGdvdG9FbmQpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0b3AoY2xlYXJRdWV1ZSwgZ290b0VuZCk7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAga2VuZG9BbmltYXRlOiBmdW5jdGlvbihvcHRpb25zLCBkdXJhdGlvbiwgcmV2ZXJzZSwgY29tcGxldGUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRlKHRoaXMsIG9wdGlvbnMsIGR1cmF0aW9uLCByZXZlcnNlLCBjb21wbGV0ZSk7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAga2VuZG9BZGRDbGFzczogZnVuY3Rpb24oY2xhc3Nlcywgb3B0aW9ucyl7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ga2VuZG8udG9nZ2xlQ2xhc3ModGhpcywgY2xhc3Nlcywgb3B0aW9ucywgdHJ1ZSk7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAga2VuZG9SZW1vdmVDbGFzczogZnVuY3Rpb24oY2xhc3Nlcywgb3B0aW9ucyl7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ga2VuZG8udG9nZ2xlQ2xhc3ModGhpcywgY2xhc3Nlcywgb3B0aW9ucywgZmFsc2UpO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBrZW5kb1RvZ2dsZUNsYXNzOiBmdW5jdGlvbihjbGFzc2VzLCBvcHRpb25zLCB0b2dnbGUpe1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGtlbmRvLnRvZ2dsZUNsYXNzKHRoaXMsIGNsYXNzZXMsIG9wdGlvbnMsIHRvZ2dsZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGFtcFJlZ0V4cCA9IC8mL2csXG5cdCAgICAgICAgbHRSZWdFeHAgPSAvPC9nLFxuXHQgICAgICAgIHF1b3RlUmVnRXhwID0gL1wiL2csXG5cdCAgICAgICAgYXBvc1JlZ0V4cCA9IC8nL2csXG5cdCAgICAgICAgZ3RSZWdFeHAgPSAvPi9nO1xuXHQgICAgZnVuY3Rpb24gaHRtbEVuY29kZSh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAoXCJcIiArIHZhbHVlKS5yZXBsYWNlKGFtcFJlZ0V4cCwgXCImYW1wO1wiKS5yZXBsYWNlKGx0UmVnRXhwLCBcIiZsdDtcIikucmVwbGFjZShndFJlZ0V4cCwgXCImZ3Q7XCIpLnJlcGxhY2UocXVvdGVSZWdFeHAsIFwiJnF1b3Q7XCIpLnJlcGxhY2UoYXBvc1JlZ0V4cCwgXCImIzM5O1wiKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICByZXR1cm4gZS50YXJnZXQ7XG5cdCAgICB9O1xuXG5cdCAgICBpZiAoc3VwcG9ydC50b3VjaCkge1xuXG5cdCAgICAgICAgZXZlbnRUYXJnZXQgPSBmdW5jdGlvbihlKSB7XG5cdCAgICAgICAgICAgIHZhciB0b3VjaGVzID0gXCJvcmlnaW5hbEV2ZW50XCIgaW4gZSA/IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlcyA6IFwiY2hhbmdlZFRvdWNoZXNcIiBpbiBlID8gZS5jaGFuZ2VkVG91Y2hlcyA6IG51bGw7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHRvdWNoZXMgPyBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoZXNbMF0uY2xpZW50WCwgdG91Y2hlc1swXS5jbGllbnRZKSA6IGUudGFyZ2V0O1xuXHQgICAgICAgIH07XG5cblx0ICAgICAgICBlYWNoKFtcInN3aXBlXCIsIFwic3dpcGVMZWZ0XCIsIFwic3dpcGVSaWdodFwiLCBcInN3aXBlVXBcIiwgXCJzd2lwZURvd25cIiwgXCJkb3VibGVUYXBcIiwgXCJ0YXBcIl0sIGZ1bmN0aW9uKG0sIHZhbHVlKSB7XG5cdCAgICAgICAgICAgICQuZm5bdmFsdWVdID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJpbmQodmFsdWUsIGNhbGxiYWNrKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHN1cHBvcnQudG91Y2gpIHtcblx0ICAgICAgICBpZiAoIXN1cHBvcnQubW9iaWxlT1MpIHtcblx0ICAgICAgICAgICAgc3VwcG9ydC5tb3VzZWRvd24gPSBcIm1vdXNlZG93biB0b3VjaHN0YXJ0XCI7XG5cdCAgICAgICAgICAgIHN1cHBvcnQubW91c2V1cCA9IFwibW91c2V1cCB0b3VjaGVuZFwiO1xuXHQgICAgICAgICAgICBzdXBwb3J0Lm1vdXNlbW92ZSA9IFwibW91c2Vtb3ZlIHRvdWNobW92ZVwiO1xuXHQgICAgICAgICAgICBzdXBwb3J0Lm1vdXNlY2FuY2VsID0gXCJtb3VzZWxlYXZlIHRvdWNoY2FuY2VsXCI7XG5cdCAgICAgICAgICAgIHN1cHBvcnQuY2xpY2sgPSBcImNsaWNrXCI7XG5cdCAgICAgICAgICAgIHN1cHBvcnQucmVzaXplID0gXCJyZXNpemVcIjtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICBzdXBwb3J0Lm1vdXNlZG93biA9IFwidG91Y2hzdGFydFwiO1xuXHQgICAgICAgICAgICBzdXBwb3J0Lm1vdXNldXAgPSBcInRvdWNoZW5kXCI7XG5cdCAgICAgICAgICAgIHN1cHBvcnQubW91c2Vtb3ZlID0gXCJ0b3VjaG1vdmVcIjtcblx0ICAgICAgICAgICAgc3VwcG9ydC5tb3VzZWNhbmNlbCA9IFwidG91Y2hjYW5jZWxcIjtcblx0ICAgICAgICAgICAgc3VwcG9ydC5jbGljayA9IFwidG91Y2hlbmRcIjtcblx0ICAgICAgICAgICAgc3VwcG9ydC5yZXNpemUgPSBcIm9yaWVudGF0aW9uY2hhbmdlXCI7XG5cdCAgICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChzdXBwb3J0LnBvaW50ZXJzKSB7XG5cdCAgICAgICAgc3VwcG9ydC5tb3VzZW1vdmUgPSBcInBvaW50ZXJtb3ZlXCI7XG5cdCAgICAgICAgc3VwcG9ydC5tb3VzZWRvd24gPSBcInBvaW50ZXJkb3duXCI7XG5cdCAgICAgICAgc3VwcG9ydC5tb3VzZXVwID0gXCJwb2ludGVydXBcIjtcblx0ICAgICAgICBzdXBwb3J0Lm1vdXNlY2FuY2VsID0gXCJwb2ludGVyY2FuY2VsXCI7XG5cdCAgICAgICAgc3VwcG9ydC5jbGljayA9IFwicG9pbnRlcnVwXCI7XG5cdCAgICAgICAgc3VwcG9ydC5yZXNpemUgPSBcIm9yaWVudGF0aW9uY2hhbmdlIHJlc2l6ZVwiO1xuXHQgICAgfSBlbHNlIGlmIChzdXBwb3J0Lm1zUG9pbnRlcnMpIHtcblx0ICAgICAgICBzdXBwb3J0Lm1vdXNlbW92ZSA9IFwiTVNQb2ludGVyTW92ZVwiO1xuXHQgICAgICAgIHN1cHBvcnQubW91c2Vkb3duID0gXCJNU1BvaW50ZXJEb3duXCI7XG5cdCAgICAgICAgc3VwcG9ydC5tb3VzZXVwID0gXCJNU1BvaW50ZXJVcFwiO1xuXHQgICAgICAgIHN1cHBvcnQubW91c2VjYW5jZWwgPSBcIk1TUG9pbnRlckNhbmNlbFwiO1xuXHQgICAgICAgIHN1cHBvcnQuY2xpY2sgPSBcIk1TUG9pbnRlclVwXCI7XG5cdCAgICAgICAgc3VwcG9ydC5yZXNpemUgPSBcIm9yaWVudGF0aW9uY2hhbmdlIHJlc2l6ZVwiO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgICBzdXBwb3J0Lm1vdXNlbW92ZSA9IFwibW91c2Vtb3ZlXCI7XG5cdCAgICAgICAgc3VwcG9ydC5tb3VzZWRvd24gPSBcIm1vdXNlZG93blwiO1xuXHQgICAgICAgIHN1cHBvcnQubW91c2V1cCA9IFwibW91c2V1cFwiO1xuXHQgICAgICAgIHN1cHBvcnQubW91c2VjYW5jZWwgPSBcIm1vdXNlbGVhdmVcIjtcblx0ICAgICAgICBzdXBwb3J0LmNsaWNrID0gXCJjbGlja1wiO1xuXHQgICAgICAgIHN1cHBvcnQucmVzaXplID0gXCJyZXNpemVcIjtcblx0ICAgIH1cblxuXHQgICAgdmFyIHdyYXBFeHByZXNzaW9uID0gZnVuY3Rpb24obWVtYmVycywgcGFyYW1OYW1lKSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHBhcmFtTmFtZSB8fCBcImRcIixcblx0ICAgICAgICAgICAgaW5kZXgsXG5cdCAgICAgICAgICAgIGlkeCxcblx0ICAgICAgICAgICAgbGVuZ3RoLFxuXHQgICAgICAgICAgICBtZW1iZXIsXG5cdCAgICAgICAgICAgIGNvdW50ID0gMTtcblxuXHQgICAgICAgIGZvciAoaWR4ID0gMCwgbGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgbWVtYmVyID0gbWVtYmVyc1tpZHhdO1xuXHQgICAgICAgICAgICBpZiAobWVtYmVyICE9PSBcIlwiKSB7XG5cdCAgICAgICAgICAgICAgICBpbmRleCA9IG1lbWJlci5pbmRleE9mKFwiW1wiKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlciA9IFwiLlwiICsgbWVtYmVyO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlciA9IFwiLlwiICsgbWVtYmVyLnN1YnN0cmluZygwLCBpbmRleCkgKyBcIiB8fCB7fSlcIiArIG1lbWJlci5zdWJzdHJpbmcoaW5kZXgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgY291bnQrKztcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCArPSBtZW1iZXIgKyAoKGlkeCA8IGxlbmd0aCAtIDEpID8gXCIgfHwge30pXCIgOiBcIilcIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyBBcnJheShjb3VudCkuam9pbihcIihcIikgKyByZXN1bHQ7XG5cdCAgICB9LFxuXHQgICAgbG9jYWxVcmxSZSA9IC9eKFthLXpdKzopP1xcL1xcLy9pO1xuXG5cdCAgICBleHRlbmQoa2VuZG8sIHtcblx0ICAgICAgICB3aWRnZXRzOiBbXSxcblx0ICAgICAgICBfd2lkZ2V0UmVnaXN0ZXJlZENhbGxiYWNrczogW10sXG5cdCAgICAgICAgdWk6IGtlbmRvLnVpIHx8IHt9LFxuXHQgICAgICAgIGZ4OiBrZW5kby5meCB8fCBmeCxcblx0ICAgICAgICBlZmZlY3RzOiBrZW5kby5lZmZlY3RzIHx8IGVmZmVjdHMsXG5cdCAgICAgICAgbW9iaWxlOiBrZW5kby5tb2JpbGUgfHwgeyB9LFxuXHQgICAgICAgIGRhdGE6IGtlbmRvLmRhdGEgfHwge30sXG5cdCAgICAgICAgZGF0YXZpejoga2VuZG8uZGF0YXZpeiB8fCB7fSxcblx0ICAgICAgICBkcmF3aW5nOiBrZW5kby5kcmF3aW5nIHx8IHt9LFxuXHQgICAgICAgIHNwcmVhZHNoZWV0OiB7IG1lc3NhZ2VzOiB7fSB9LFxuXHQgICAgICAgIGtleXM6IHtcblx0ICAgICAgICAgICAgSU5TRVJUOiA0NSxcblx0ICAgICAgICAgICAgREVMRVRFOiA0Nixcblx0ICAgICAgICAgICAgQkFDS1NQQUNFOiA4LFxuXHQgICAgICAgICAgICBUQUI6IDksXG5cdCAgICAgICAgICAgIEVOVEVSOiAxMyxcblx0ICAgICAgICAgICAgRVNDOiAyNyxcblx0ICAgICAgICAgICAgTEVGVDogMzcsXG5cdCAgICAgICAgICAgIFVQOiAzOCxcblx0ICAgICAgICAgICAgUklHSFQ6IDM5LFxuXHQgICAgICAgICAgICBET1dOOiA0MCxcblx0ICAgICAgICAgICAgRU5EOiAzNSxcblx0ICAgICAgICAgICAgSE9NRTogMzYsXG5cdCAgICAgICAgICAgIFNQQUNFQkFSOiAzMixcblx0ICAgICAgICAgICAgUEFHRVVQOiAzMyxcblx0ICAgICAgICAgICAgUEFHRURPV046IDM0LFxuXHQgICAgICAgICAgICBGMjogMTEzLFxuXHQgICAgICAgICAgICBGMTA6IDEyMSxcblx0ICAgICAgICAgICAgRjEyOiAxMjMsXG5cdCAgICAgICAgICAgIE5VTVBBRF9QTFVTOiAxMDcsXG5cdCAgICAgICAgICAgIE5VTVBBRF9NSU5VUzogMTA5LFxuXHQgICAgICAgICAgICBOVU1QQURfRE9UOiAxMTBcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHN1cHBvcnQ6IGtlbmRvLnN1cHBvcnQgfHwgc3VwcG9ydCxcblx0ICAgICAgICBhbmltYXRlOiBrZW5kby5hbmltYXRlIHx8IGFuaW1hdGUsXG5cdCAgICAgICAgbnM6IFwiXCIsXG5cdCAgICAgICAgYXR0cjogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwiZGF0YS1cIiArIGtlbmRvLm5zICsgdmFsdWU7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBnZXRTaGFkb3dzOiBnZXRTaGFkb3dzLFxuXHQgICAgICAgIHdyYXA6IHdyYXAsXG5cdCAgICAgICAgZGVlcEV4dGVuZDogZGVlcEV4dGVuZCxcblx0ICAgICAgICBnZXRDb21wdXRlZFN0eWxlczogZ2V0Q29tcHV0ZWRTdHlsZXMsXG5cdCAgICAgICAgd2ViQ29tcG9uZW50czoga2VuZG8ud2ViQ29tcG9uZW50cyB8fCBbXSxcblx0ICAgICAgICBpc1Njcm9sbGFibGU6IGlzU2Nyb2xsYWJsZSxcblx0ICAgICAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuXHQgICAgICAgIHNpemU6IHNpemUsXG5cdCAgICAgICAgdG9DYW1lbENhc2U6IHRvQ2FtZWxDYXNlLFxuXHQgICAgICAgIHRvSHlwaGVuczogdG9IeXBoZW5zLFxuXHQgICAgICAgIGdldE9mZnNldDoga2VuZG8uZ2V0T2Zmc2V0IHx8IGdldE9mZnNldCxcblx0ICAgICAgICBwYXJzZUVmZmVjdHM6IGtlbmRvLnBhcnNlRWZmZWN0cyB8fCBwYXJzZUVmZmVjdHMsXG5cdCAgICAgICAgdG9nZ2xlQ2xhc3M6IGtlbmRvLnRvZ2dsZUNsYXNzIHx8IHRvZ2dsZUNsYXNzLFxuXHQgICAgICAgIGRpcmVjdGlvbnM6IGtlbmRvLmRpcmVjdGlvbnMgfHwgZGlyZWN0aW9ucyxcblx0ICAgICAgICBPYnNlcnZhYmxlOiBPYnNlcnZhYmxlLFxuXHQgICAgICAgIENsYXNzOiBDbGFzcyxcblx0ICAgICAgICBUZW1wbGF0ZTogVGVtcGxhdGUsXG5cdCAgICAgICAgdGVtcGxhdGU6IHByb3h5KFRlbXBsYXRlLmNvbXBpbGUsIFRlbXBsYXRlKSxcblx0ICAgICAgICByZW5kZXI6IHByb3h5KFRlbXBsYXRlLnJlbmRlciwgVGVtcGxhdGUpLFxuXHQgICAgICAgIHN0cmluZ2lmeTogcHJveHkoSlNPTi5zdHJpbmdpZnksIEpTT04pLFxuXHQgICAgICAgIGV2ZW50VGFyZ2V0OiBldmVudFRhcmdldCxcblx0ICAgICAgICBodG1sRW5jb2RlOiBodG1sRW5jb2RlLFxuXHQgICAgICAgIGlzTG9jYWxVcmw6IGZ1bmN0aW9uKHVybCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdXJsICYmICFsb2NhbFVybFJlLnRlc3QodXJsKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZXhwcjogZnVuY3Rpb24oZXhwcmVzc2lvbiwgc2FmZSwgcGFyYW1OYW1lKSB7XG5cdCAgICAgICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uIHx8IFwiXCI7XG5cblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBzYWZlID09IFNUUklORykge1xuXHQgICAgICAgICAgICAgICAgcGFyYW1OYW1lID0gc2FmZTtcblx0ICAgICAgICAgICAgICAgIHNhZmUgPSBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHBhcmFtTmFtZSA9IHBhcmFtTmFtZSB8fCBcImRcIjtcblxuXHQgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbiAmJiBleHByZXNzaW9uLmNoYXJBdCgwKSAhPT0gXCJbXCIpIHtcblx0ICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBcIi5cIiArIGV4cHJlc3Npb247XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoc2FmZSkge1xuXHQgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ucmVwbGFjZSgvXCIoW14uXSopXFwuKFteXCJdKilcIi9nLCdcIiQxXyRET1QkXyQyXCInKTtcblx0ICAgICAgICAgICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLnJlcGxhY2UoLycoW14uXSopXFwuKFteJ10qKScvZyxcIickMV8kRE9UJF8kMidcIik7XG5cdCAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gd3JhcEV4cHJlc3Npb24oZXhwcmVzc2lvbi5zcGxpdChcIi5cIiksIHBhcmFtTmFtZSk7XG5cdCAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbi5yZXBsYWNlKC9fXFwkRE9UXFwkXy9nLCBcIi5cIik7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gcGFyYW1OYW1lICsgZXhwcmVzc2lvbjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBleHByZXNzaW9uO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBnZXR0ZXI6IGZ1bmN0aW9uKGV4cHJlc3Npb24sIHNhZmUpIHtcblx0ICAgICAgICAgICAgdmFyIGtleSA9IGV4cHJlc3Npb24gKyBzYWZlO1xuXHQgICAgICAgICAgICByZXR1cm4gZ2V0dGVyQ2FjaGVba2V5XSA9IGdldHRlckNhY2hlW2tleV0gfHwgbmV3IEZ1bmN0aW9uKFwiZFwiLCBcInJldHVybiBcIiArIGtlbmRvLmV4cHIoZXhwcmVzc2lvbiwgc2FmZSkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBzZXR0ZXI6IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNldHRlckNhY2hlW2V4cHJlc3Npb25dID0gc2V0dGVyQ2FjaGVbZXhwcmVzc2lvbl0gfHwgbmV3IEZ1bmN0aW9uKFwiZCx2YWx1ZVwiLCBrZW5kby5leHByKGV4cHJlc3Npb24pICsgXCI9dmFsdWVcIik7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGFjY2Vzc29yOiBmdW5jdGlvbihleHByZXNzaW9uKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBnZXQ6IGtlbmRvLmdldHRlcihleHByZXNzaW9uKSxcblx0ICAgICAgICAgICAgICAgIHNldDoga2VuZG8uc2V0dGVyKGV4cHJlc3Npb24pXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGd1aWQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgaWQgPSBcIlwiLCBpLCByYW5kb207XG5cblx0ICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHJhbmRvbSA9IG1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpID09IDggfHwgaSA9PSAxMiB8fCBpID09IDE2IHx8IGkgPT0gMjApIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZCArPSBcIi1cIjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlkICs9IChpID09IDEyID8gNCA6IChpID09IDE2ID8gKHJhbmRvbSAmIDMgfCA4KSA6IHJhbmRvbSkpLnRvU3RyaW5nKDE2KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBpZDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgcm9sZVNlbGVjdG9yOiBmdW5jdGlvbihyb2xlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiByb2xlLnJlcGxhY2UoLyhcXFMrKS9nLCBcIltcIiArIGtlbmRvLmF0dHIoXCJyb2xlXCIpICsgXCI9JDFdLFwiKS5zbGljZSgwLCAtMSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRpcmVjdGl2ZVNlbGVjdG9yOiBmdW5jdGlvbihkaXJlY3RpdmVzKSB7XG5cdCAgICAgICAgICAgIHZhciBzZWxlY3RvcnMgPSBkaXJlY3RpdmVzLnNwbGl0KFwiIFwiKTtcblxuXHQgICAgICAgICAgICBpZiAoc2VsZWN0b3JzKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvcnNbaV0gIT0gXCJ2aWV3XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzW2ldID0gc2VsZWN0b3JzW2ldLnJlcGxhY2UoLyhcXHcqKSh2aWV3fGJhcnxzdHJpcHxvdmVyKSQvLCBcIiQxLSQyXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBzZWxlY3RvcnMuam9pbihcIiBcIikucmVwbGFjZSgvKFxcUyspL2csIFwia2VuZG8tbW9iaWxlLSQxLFwiKS5zbGljZSgwLCAtMSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHRyaWdnZXJlZEJ5SW5wdXQ6IGZ1bmN0aW9uKGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICgvXihsYWJlbHxpbnB1dHx0ZXh0YXJlYXxzZWxlY3QpJC9pKS50ZXN0KGUudGFyZ2V0LnRhZ05hbWUpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBvbldpZGdldFJlZ2lzdGVyZWQ6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBrZW5kby53aWRnZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBjYWxsYmFjayhrZW5kby53aWRnZXRzW2ldKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGtlbmRvLl93aWRnZXRSZWdpc3RlcmVkQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBsb2dUb0NvbnNvbGU6IGZ1bmN0aW9uKG1lc3NhZ2UsIHR5cGUpIHtcblx0ICAgICAgICAgICAgdmFyIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcblxuXHQgICAgICAgICAgICBpZiAoIWtlbmRvLnN1cHByZXNzTG9nICYmIHR5cGVvZihjb25zb2xlKSAhPSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUubG9nKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zb2xlW3R5cGUgfHwgXCJsb2dcIl0obWVzc2FnZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgdmFyIFdpZGdldCA9IE9ic2VydmFibGUuZXh0ZW5kKCB7XG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgdGhhdC5lbGVtZW50ID0ga2VuZG8ualF1ZXJ5KGVsZW1lbnQpLmhhbmRsZXIodGhhdCk7XG5cblx0ICAgICAgICAgICAgdGhhdC5hbmd1bGFyKFwiaW5pdFwiLCBvcHRpb25zKTtcblxuXHQgICAgICAgICAgICBPYnNlcnZhYmxlLmZuLmluaXQuY2FsbCh0aGF0KTtcblxuXHQgICAgICAgICAgICB2YXIgZGF0YVNvdXJjZSA9IG9wdGlvbnMgPyBvcHRpb25zLmRhdGFTb3VyY2UgOiBudWxsO1xuXG5cdCAgICAgICAgICAgIGlmIChkYXRhU291cmNlKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBhdm9pZCBkZWVwIGNsb25pbmcgdGhlIGRhdGEgc291cmNlXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zLCB7IGRhdGFTb3VyY2U6IHt9IH0pO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgb3B0aW9ucyA9IHRoYXQub3B0aW9ucyA9IGV4dGVuZCh0cnVlLCB7fSwgdGhhdC5vcHRpb25zLCBvcHRpb25zKTtcblxuXHQgICAgICAgICAgICBpZiAoZGF0YVNvdXJjZSkge1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhU291cmNlID0gZGF0YVNvdXJjZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICghdGhhdC5lbGVtZW50LmF0dHIoa2VuZG8uYXR0cihcInJvbGVcIikpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGF0LmVsZW1lbnQuYXR0cihrZW5kby5hdHRyKFwicm9sZVwiKSwgKG9wdGlvbnMubmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoYXQuZWxlbWVudC5kYXRhKFwia2VuZG9cIiArIG9wdGlvbnMucHJlZml4ICsgb3B0aW9ucy5uYW1lLCB0aGF0KTtcblxuXHQgICAgICAgICAgICB0aGF0LmJpbmQodGhhdC5ldmVudHMsIG9wdGlvbnMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBldmVudHM6IFtdLFxuXG5cdCAgICAgICAgb3B0aW9uczoge1xuXHQgICAgICAgICAgICBwcmVmaXg6IFwiXCJcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2hhc0JpbmRpbmdUYXJnZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gISF0aGlzLmVsZW1lbnRbMF0ua2VuZG9CaW5kaW5nVGFyZ2V0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfdGFiaW5kZXg6IGZ1bmN0aW9uKHRhcmdldCkge1xuXHQgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgdGhpcy53cmFwcGVyO1xuXG5cdCAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuXHQgICAgICAgICAgICAgICAgVEFCSU5ERVggPSBcInRhYmluZGV4XCIsXG5cdCAgICAgICAgICAgICAgICB0YWJpbmRleCA9IHRhcmdldC5hdHRyKFRBQklOREVYKSB8fCBlbGVtZW50LmF0dHIoVEFCSU5ERVgpO1xuXG5cdCAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cihUQUJJTkRFWCk7XG5cblx0ICAgICAgICAgICAgdGFyZ2V0LmF0dHIoVEFCSU5ERVgsICFpc05hTih0YWJpbmRleCkgPyB0YWJpbmRleCA6IDApO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NldEV2ZW50cyhvcHRpb25zKTtcblx0ICAgICAgICAgICAgJC5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3NldEV2ZW50czogZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBpZHggPSAwLFxuXHQgICAgICAgICAgICAgICAgbGVuZ3RoID0gdGhhdC5ldmVudHMubGVuZ3RoLFxuXHQgICAgICAgICAgICAgICAgZTtcblxuXHQgICAgICAgICAgICBmb3IgKDsgaWR4IDwgbGVuZ3RoOyBpZHggKyspIHtcblx0ICAgICAgICAgICAgICAgIGUgPSB0aGF0LmV2ZW50c1tpZHhdO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9uc1tlXSAmJiBvcHRpb25zW2VdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC51bmJpbmQoZSwgdGhhdC5vcHRpb25zW2VdKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoYXQuYmluZCh0aGF0LmV2ZW50cywgb3B0aW9ucyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHJlc2l6ZTogZnVuY3Rpb24oZm9yY2UpIHtcblx0ICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFNpemUoKSxcblx0ICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplID0gdGhpcy5fc2l6ZTtcblxuXHQgICAgICAgICAgICBpZiAoZm9yY2UgfHwgKHNpemUud2lkdGggPiAwIHx8IHNpemUuaGVpZ2h0ID4gMCkgJiYgKCFjdXJyZW50U2l6ZSB8fCBzaXplLndpZHRoICE9PSBjdXJyZW50U2l6ZS53aWR0aCB8fCBzaXplLmhlaWdodCAhPT0gY3VycmVudFNpemUuaGVpZ2h0KSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yZXNpemUoc2l6ZSwgZm9yY2UpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwicmVzaXplXCIsIHNpemUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldFNpemU6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4ga2VuZG8uZGltZW5zaW9ucyh0aGlzLmVsZW1lbnQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBzaXplOiBmdW5jdGlvbihzaXplKSB7XG5cdCAgICAgICAgICAgIGlmICghc2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2l6ZSgpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5zZXRTaXplKHNpemUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHNldFNpemU6ICQubm9vcCxcblx0ICAgICAgICBfcmVzaXplOiAkLm5vb3AsXG5cblx0ICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG5cdCAgICAgICAgICAgIHRoYXQuZWxlbWVudC5yZW1vdmVEYXRhKFwia2VuZG9cIiArIHRoYXQub3B0aW9ucy5wcmVmaXggKyB0aGF0Lm9wdGlvbnMubmFtZSk7XG5cdCAgICAgICAgICAgIHRoYXQuZWxlbWVudC5yZW1vdmVEYXRhKFwiaGFuZGxlclwiKTtcblx0ICAgICAgICAgICAgdGhhdC51bmJpbmQoKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIF9kZXN0cm95OiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBhbmd1bGFyOiBmdW5jdGlvbigpe30sXG5cblx0ICAgICAgICBfbXV0ZUFuZ3VsYXJSZWJpbmQ6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX211dGVSZWJpbmQgPSB0cnVlO1xuXG5cdCAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgdGhpcy5fbXV0ZVJlYmluZCA9IGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICB2YXIgRGF0YUJvdW5kV2lkZ2V0ID0gV2lkZ2V0LmV4dGVuZCh7XG5cdCAgICAgICAgLy8gQW5ndWxhciBjb25zdW1lcyB0aGVzZS5cblx0ICAgICAgICBkYXRhSXRlbXM6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmZsYXRWaWV3KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9hbmd1bGFySXRlbXM6IGZ1bmN0aW9uKGNtZCkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cdCAgICAgICAgICAgIHRoYXQuYW5ndWxhcihjbWQsIGZ1bmN0aW9uKCl7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiB0aGF0Lml0ZW1zKCksXG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YTogJC5tYXAodGhhdC5kYXRhSXRlbXMoKSwgZnVuY3Rpb24oZGF0YUl0ZW0pe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhSXRlbTogZGF0YUl0ZW0gfTtcblx0ICAgICAgICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIGtlbmRvLmRpbWVuc2lvbnMgPSBmdW5jdGlvbihlbGVtZW50LCBkaW1lbnNpb25zKSB7XG5cdCAgICAgICAgdmFyIGRvbUVsZW1lbnQgPSBlbGVtZW50WzBdO1xuXG5cdCAgICAgICAgaWYgKGRpbWVuc2lvbnMpIHtcblx0ICAgICAgICAgICAgZWxlbWVudC5jc3MoZGltZW5zaW9ucyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHsgd2lkdGg6IGRvbUVsZW1lbnQub2Zmc2V0V2lkdGgsIGhlaWdodDogZG9tRWxlbWVudC5vZmZzZXRIZWlnaHQgfTtcblx0ICAgIH07XG5cblx0ICAgIGtlbmRvLm5vdGlmeSA9IG5vb3A7XG5cblx0ICAgIHZhciB0ZW1wbGF0ZVJlZ0V4cCA9IC90ZW1wbGF0ZSQvaSxcblx0ICAgICAgICBqc29uUmVnRXhwID0gL15cXHMqKD86XFx7KD86LnxcXHJcXG58XFxuKSpcXH18XFxbKD86LnxcXHJcXG58XFxuKSpcXF0pXFxzKiQvLFxuXHQgICAgICAgIGpzb25Gb3JtYXRSZWdFeHAgPSAvXlxceyhcXGQrKSg6W15cXH1dKyk/XFx9fF5cXFtbQS1aYS16X10rXFxdJC8sXG5cdCAgICAgICAgZGFzaFJlZ0V4cCA9IC8oW0EtWl0pL2c7XG5cblx0ICAgIGZ1bmN0aW9uIHBhcnNlT3B0aW9uKGVsZW1lbnQsIG9wdGlvbikge1xuXHQgICAgICAgIHZhciB2YWx1ZTtcblxuXHQgICAgICAgIGlmIChvcHRpb24uaW5kZXhPZihcImRhdGFcIikgPT09IDApIHtcblx0ICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uLnN1YnN0cmluZyg0KTtcblx0ICAgICAgICAgICAgb3B0aW9uID0gb3B0aW9uLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgb3B0aW9uLnN1YnN0cmluZygxKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBvcHRpb24gPSBvcHRpb24ucmVwbGFjZShkYXNoUmVnRXhwLCBcIi0kMVwiKTtcblx0ICAgICAgICB2YWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1cIiArIGtlbmRvLm5zICsgb3B0aW9uKTtcblxuXHQgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcblx0ICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBcIm51bGxcIikge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG5cdCAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB0cnVlO1xuXHQgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuXHQgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyUmVnRXhwLnRlc3QodmFsdWUpICYmIG9wdGlvbiAhPSBcIm1hc2tcIikge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoanNvblJlZ0V4cC50ZXN0KHZhbHVlKSAmJiAhanNvbkZvcm1hdFJlZ0V4cC50ZXN0KHZhbHVlKSkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IG5ldyBGdW5jdGlvbihcInJldHVybiAoXCIgKyB2YWx1ZSArIFwiKVwiKSgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gcGFyc2VPcHRpb25zKGVsZW1lbnQsIG9wdGlvbnMsIHNvdXJjZSkge1xuXHQgICAgICAgIHZhciByZXN1bHQgPSB7fSxcblx0ICAgICAgICAgICAgb3B0aW9uLFxuXHQgICAgICAgICAgICB2YWx1ZTtcblxuXHQgICAgICAgIGZvciAob3B0aW9uIGluIG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSBwYXJzZU9wdGlvbihlbGVtZW50LCBvcHRpb24pO1xuXG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cblx0ICAgICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZVJlZ0V4cC50ZXN0KG9wdGlvbikpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYoJChcIiNcIiArIHZhbHVlKS5sZW5ndGgpe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBrZW5kby50ZW1wbGF0ZSgkKFwiI1wiICsgdmFsdWUpLmh0bWwoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNlIGlmIChzb3VyY2Upe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBrZW5kby50ZW1wbGF0ZShzb3VyY2VbdmFsdWVdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUob3B0aW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHJlc3VsdFtvcHRpb25dID0gdmFsdWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXG5cdCAgICBrZW5kby5pbml0V2lkZ2V0ID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucywgcm9sZXMpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0LFxuXHQgICAgICAgICAgICBvcHRpb24sXG5cdCAgICAgICAgICAgIHdpZGdldCxcblx0ICAgICAgICAgICAgaWR4LFxuXHQgICAgICAgICAgICBsZW5ndGgsXG5cdCAgICAgICAgICAgIHJvbGUsXG5cdCAgICAgICAgICAgIHZhbHVlLFxuXHQgICAgICAgICAgICBkYXRhU291cmNlLFxuXHQgICAgICAgICAgICBmdWxsUGF0aCxcblx0ICAgICAgICAgICAgd2lkZ2V0S2V5UmVnRXhwO1xuXG5cdCAgICAgICAgLy8gUHJlc2VydmUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAoZWxlbWVudCwgb3B0aW9ucywgbmFtZXNwYWNlKSBzaWduYXR1cmUsIHdoZXJlIG5hbWVzcGFjZSB3YXMga2VuZG8udWlcblx0ICAgICAgICBpZiAoIXJvbGVzKSB7XG5cdCAgICAgICAgICAgIHJvbGVzID0ga2VuZG8udWkucm9sZXM7XG5cdCAgICAgICAgfSBlbHNlIGlmIChyb2xlcy5yb2xlcykge1xuXHQgICAgICAgICAgICByb2xlcyA9IHJvbGVzLnJvbGVzO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lm5vZGVUeXBlID8gZWxlbWVudCA6IGVsZW1lbnRbMF07XG5cblx0ICAgICAgICByb2xlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLVwiICsga2VuZG8ubnMgKyBcInJvbGVcIik7XG5cblx0ICAgICAgICBpZiAoIXJvbGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bGxQYXRoID0gcm9sZS5pbmRleE9mKFwiLlwiKSA9PT0gLTE7XG5cblx0ICAgICAgICAvLyBsb29rIGZvciBhbnkgd2lkZ2V0IHRoYXQgbWF5IGJlIGFscmVhZHkgaW5zdGFudGlhdGVkIGJhc2VkIG9uIHRoaXMgcm9sZS5cblx0ICAgICAgICAvLyBUaGUgcHJlZml4IHVzZWQgaXMgdW5rbm93biwgaGVuY2UgdGhlIHJlZ2V4cFxuXHQgICAgICAgIC8vXG5cblx0ICAgICAgICBpZiAoZnVsbFBhdGgpIHtcblx0ICAgICAgICAgICAgd2lkZ2V0ID0gcm9sZXNbcm9sZV07XG5cdCAgICAgICAgfSBlbHNlIHsgLy8gZnVsbCBuYW1lc3BhY2UgcGF0aCAtIGxpa2Uga2VuZG8udWkuV2lkZ2V0XG5cdCAgICAgICAgICAgIHdpZGdldCA9IGtlbmRvLmdldHRlcihyb2xlKSh3aW5kb3cpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBkYXRhID0gJChlbGVtZW50KS5kYXRhKCksXG5cdCAgICAgICAgICAgIHdpZGdldEtleSA9IHdpZGdldCA/IFwia2VuZG9cIiArIHdpZGdldC5mbi5vcHRpb25zLnByZWZpeCArIHdpZGdldC5mbi5vcHRpb25zLm5hbWUgOiBcIlwiO1xuXG5cdCAgICAgICAgaWYgKGZ1bGxQYXRoKSB7XG5cdCAgICAgICAgICAgIHdpZGdldEtleVJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJea2VuZG8uKlwiICsgcm9sZSArIFwiJFwiLCBcImlcIik7XG5cdCAgICAgICAgfSBlbHNlIHsgLy8gZnVsbCBuYW1lc3BhY2UgcGF0aCAtIGxpa2Uga2VuZG8udWkuV2lkZ2V0XG5cdCAgICAgICAgICAgIHdpZGdldEtleVJlZ0V4cCA9IG5ldyBSZWdFeHAoXCJeXCIgKyB3aWRnZXRLZXkgKyBcIiRcIiwgXCJpXCIpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZvcih2YXIga2V5IGluIGRhdGEpIHtcblx0ICAgICAgICAgICAgaWYgKGtleS5tYXRjaCh3aWRnZXRLZXlSZWdFeHApKSB7XG5cdCAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIGRldGVjdGVkIGEgd2lkZ2V0IG9mIHRoZSBzYW1lIGtpbmQgLSBzYXZlIGl0cyByZWZlcmVuY2UsIHdlIHdpbGwgc2V0IGl0cyBvcHRpb25zXG5cdCAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSB3aWRnZXRLZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBkYXRhW2tleV07XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2tleV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoIXdpZGdldCkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZGF0YVNvdXJjZSA9IHBhcnNlT3B0aW9uKGVsZW1lbnQsIFwiZGF0YVNvdXJjZVwiKTtcblxuXHQgICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgcGFyc2VPcHRpb25zKGVsZW1lbnQsIHdpZGdldC5mbi5vcHRpb25zKSwgb3B0aW9ucyk7XG5cblx0ICAgICAgICBpZiAoZGF0YVNvdXJjZSkge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGFTb3VyY2UgPT09IFNUUklORykge1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhU291cmNlID0ga2VuZG8uZ2V0dGVyKGRhdGFTb3VyY2UpKHdpbmRvdyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLmRhdGFTb3VyY2UgPSBkYXRhU291cmNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSB3aWRnZXQuZm4uZXZlbnRzLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICBvcHRpb24gPSB3aWRnZXQuZm4uZXZlbnRzW2lkeF07XG5cblx0ICAgICAgICAgICAgdmFsdWUgPSBwYXJzZU9wdGlvbihlbGVtZW50LCBvcHRpb24pO1xuXG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zW29wdGlvbl0gPSBrZW5kby5nZXR0ZXIodmFsdWUpKHdpbmRvdyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoIXJlc3VsdCkge1xuXHQgICAgICAgICAgICByZXN1bHQgPSBuZXcgd2lkZ2V0KGVsZW1lbnQsIG9wdGlvbnMpO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoISQuaXNFbXB0eU9iamVjdChvcHRpb25zKSkge1xuXHQgICAgICAgICAgICByZXN1bHQuc2V0T3B0aW9ucyhvcHRpb25zKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblxuXHQgICAga2VuZG8ucm9sZXNGcm9tTmFtZXNwYWNlcyA9IGZ1bmN0aW9uKG5hbWVzcGFjZXMpIHtcblx0ICAgICAgICB2YXIgcm9sZXMgPSBbXSxcblx0ICAgICAgICAgICAgaWR4LFxuXHQgICAgICAgICAgICBsZW5ndGg7XG5cblx0ICAgICAgICBpZiAoIW5hbWVzcGFjZXNbMF0pIHtcblx0ICAgICAgICAgICAgbmFtZXNwYWNlcyA9IFtrZW5kby51aSwga2VuZG8uZGF0YXZpei51aV07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSBuYW1lc3BhY2VzLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHggKyspIHtcblx0ICAgICAgICAgICAgcm9sZXNbaWR4XSA9IG5hbWVzcGFjZXNbaWR4XS5yb2xlcztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gZXh0ZW5kLmFwcGx5KG51bGwsIFt7fV0uY29uY2F0KHJvbGVzLnJldmVyc2UoKSkpO1xuXHQgICAgfTtcblxuXHQgICAga2VuZG8uaW5pdCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0ICAgICAgICB2YXIgcm9sZXMgPSBrZW5kby5yb2xlc0Zyb21OYW1lc3BhY2VzKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cblx0ICAgICAgICAkKGVsZW1lbnQpLmZpbmQoXCJbZGF0YS1cIiArIGtlbmRvLm5zICsgXCJyb2xlXVwiKS5hZGRCYWNrKCkuZWFjaChmdW5jdGlvbigpe1xuXHQgICAgICAgICAgICBrZW5kby5pbml0V2lkZ2V0KHRoaXMsIHt9LCByb2xlcyk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXG5cdCAgICBrZW5kby5kZXN0cm95ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuXHQgICAgICAgICQoZWxlbWVudCkuZmluZChcIltkYXRhLVwiICsga2VuZG8ubnMgKyBcInJvbGVdXCIpLmFkZEJhY2soKS5lYWNoKGZ1bmN0aW9uKCl7XG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gJCh0aGlzKS5kYXRhKCk7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZihcImtlbmRvXCIpID09PSAwICYmIHR5cGVvZiBkYXRhW2tleV0uZGVzdHJveSA9PT0gRlVOQ1RJT04pIHtcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhW2tleV0uZGVzdHJveSgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBjb250YWlubWVudENvbXBhcmVyKGEsIGIpIHtcblx0ICAgICAgICByZXR1cm4gJC5jb250YWlucyhhLCBiKSA/IC0xIDogMTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gcmVzaXphYmxlV2lkZ2V0KCkge1xuXHQgICAgICAgIHZhciB3aWRnZXQgPSAkKHRoaXMpO1xuXHQgICAgICAgIHJldHVybiAoJC5pbkFycmF5KHdpZGdldC5hdHRyKFwiZGF0YS1cIiArIGtlbmRvLm5zICsgXCJyb2xlXCIpLCBbXCJzbGlkZXJcIiwgXCJyYW5nZXNsaWRlclwiXSkgPiAtMSkgfHwgd2lkZ2V0LmlzKFwiOnZpc2libGVcIik7XG5cdCAgICB9XG5cblx0ICAgIGtlbmRvLnJlc2l6ZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIGZvcmNlKSB7XG5cdCAgICAgICAgdmFyIHdpZGdldHMgPSAkKGVsZW1lbnQpLmZpbmQoXCJbZGF0YS1cIiArIGtlbmRvLm5zICsgXCJyb2xlXVwiKS5hZGRCYWNrKCkuZmlsdGVyKHJlc2l6YWJsZVdpZGdldCk7XG5cblx0ICAgICAgICBpZiAoIXdpZGdldHMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBzb3J0IHdpZGdldHMgYmFzZWQgb24gdGhlaXIgcGFyZW50LWNoaWxkIHJlbGF0aW9uXG5cdCAgICAgICAgdmFyIHdpZGdldHNBcnJheSA9ICQubWFrZUFycmF5KHdpZGdldHMpO1xuXHQgICAgICAgIHdpZGdldHNBcnJheS5zb3J0KGNvbnRhaW5tZW50Q29tcGFyZXIpO1xuXG5cdCAgICAgICAgLy8gcmVzaXplIHdpZGdldHNcblx0ICAgICAgICAkLmVhY2god2lkZ2V0c0FycmF5LCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB3aWRnZXQgPSBrZW5kby53aWRnZXRJbnN0YW5jZSgkKHRoaXMpKTtcblx0ICAgICAgICAgICAgaWYgKHdpZGdldCkge1xuXHQgICAgICAgICAgICAgICAgd2lkZ2V0LnJlc2l6ZShmb3JjZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cblx0ICAgIGtlbmRvLnBhcnNlT3B0aW9ucyA9IHBhcnNlT3B0aW9ucztcblxuXHQgICAgZXh0ZW5kKGtlbmRvLnVpLCB7XG5cdCAgICAgICAgV2lkZ2V0OiBXaWRnZXQsXG5cdCAgICAgICAgRGF0YUJvdW5kV2lkZ2V0OiBEYXRhQm91bmRXaWRnZXQsXG5cdCAgICAgICAgcm9sZXM6IHt9LFxuXHQgICAgICAgIHByb2dyZXNzOiBmdW5jdGlvbihjb250YWluZXIsIHRvZ2dsZSwgb3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgbWFzayA9IGNvbnRhaW5lci5maW5kKFwiLmstbG9hZGluZy1tYXNrXCIpLFxuXHQgICAgICAgICAgICAgICAgc3VwcG9ydCA9IGtlbmRvLnN1cHBvcnQsXG5cdCAgICAgICAgICAgICAgICBicm93c2VyID0gc3VwcG9ydC5icm93c2VyLFxuXHQgICAgICAgICAgICAgICAgaXNSdGwsIGxlZnRSaWdodCwgd2Via2l0Q29ycmVjdGlvbiwgY29udGFpbmVyU2Nyb2xsTGVmdCwgY3NzQ2xhc3M7XG5cblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwge1xuXHQgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcblx0ICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuXHQgICAgICAgICAgICAgICAgICAgIHRvcDogY29udGFpbmVyLnNjcm9sbFRvcCgpLFxuXHQgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IGZhbHNlXG5cdCAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcblxuXHQgICAgICAgICAgICAgICAgY3NzQ2xhc3MgPSBvcHRpb25zLm9wYWNpdHkgPyAnay1sb2FkaW5nLW1hc2sgay1vcGFxdWUnIDogJ2stbG9hZGluZy1tYXNrJztcblxuXHQgICAgICAgICAgICBpZiAodG9nZ2xlKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW1hc2subGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaXNSdGwgPSBzdXBwb3J0LmlzUnRsKGNvbnRhaW5lcik7XG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdFJpZ2h0ID0gaXNSdGwgPyBcInJpZ2h0XCIgOiBcImxlZnRcIjtcblx0ICAgICAgICAgICAgICAgICAgICBjb250YWluZXJTY3JvbGxMZWZ0ID0gY29udGFpbmVyLnNjcm9sbExlZnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICB3ZWJraXRDb3JyZWN0aW9uID0gYnJvd3Nlci53ZWJraXQgPyAoIWlzUnRsID8gMCA6IGNvbnRhaW5lclswXS5zY3JvbGxXaWR0aCAtIGNvbnRhaW5lci53aWR0aCgpIC0gMiAqIGNvbnRhaW5lclNjcm9sbExlZnQpIDogMDtcblxuXHQgICAgICAgICAgICAgICAgICAgIG1hc2sgPSAkKGtlbmRvLmZvcm1hdChcIjxkaXYgY2xhc3M9J3swfSc+PHNwYW4gY2xhc3M9J2stbG9hZGluZy10ZXh0Jz57MX08L3NwYW4+PGRpdiBjbGFzcz0nay1sb2FkaW5nLWltYWdlJy8+PGRpdiBjbGFzcz0nay1sb2FkaW5nLWNvbG9yJy8+PC9kaXY+XCIsIGNzc0NsYXNzLCBrZW5kby51aS5wcm9ncmVzcy5tZXNzYWdlcy5sb2FkaW5nKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLndpZHRoKG9wdGlvbnMud2lkdGgpLmhlaWdodChvcHRpb25zLmhlaWdodClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmNzcyhcInRvcFwiLCBvcHRpb25zLnRvcClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLmNzcyhsZWZ0UmlnaHQsIE1hdGguYWJzKGNvbnRhaW5lclNjcm9sbExlZnQpICsgd2Via2l0Q29ycmVjdGlvbilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLnByZXBlbmRUbyhjb250YWluZXIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKG1hc2spIHtcblx0ICAgICAgICAgICAgICAgIG1hc2sucmVtb3ZlKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIHBsdWdpbjogZnVuY3Rpb24od2lkZ2V0LCByZWdpc3RlciwgcHJlZml4KSB7XG5cdCAgICAgICAgICAgIHZhciBuYW1lID0gd2lkZ2V0LmZuLm9wdGlvbnMubmFtZSxcblx0ICAgICAgICAgICAgICAgIGdldHRlcjtcblxuXHQgICAgICAgICAgICByZWdpc3RlciA9IHJlZ2lzdGVyIHx8IGtlbmRvLnVpO1xuXHQgICAgICAgICAgICBwcmVmaXggPSBwcmVmaXggfHwgXCJcIjtcblxuXHQgICAgICAgICAgICByZWdpc3RlcltuYW1lXSA9IHdpZGdldDtcblxuXHQgICAgICAgICAgICByZWdpc3Rlci5yb2xlc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gd2lkZ2V0O1xuXG5cdCAgICAgICAgICAgIGdldHRlciA9IFwiZ2V0S2VuZG9cIiArIHByZWZpeCArIG5hbWU7XG5cdCAgICAgICAgICAgIG5hbWUgPSBcImtlbmRvXCIgKyBwcmVmaXggKyBuYW1lO1xuXG5cdCAgICAgICAgICAgIHZhciB3aWRnZXRFbnRyeSA9IHsgbmFtZTogbmFtZSwgd2lkZ2V0OiB3aWRnZXQsIHByZWZpeDogcHJlZml4IHx8IFwiXCIgfTtcblx0ICAgICAgICAgICAga2VuZG8ud2lkZ2V0cy5wdXNoKHdpZGdldEVudHJ5KTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0ga2VuZG8uX3dpZGdldFJlZ2lzdGVyZWRDYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGtlbmRvLl93aWRnZXRSZWdpc3RlcmVkQ2FsbGJhY2tzW2ldKHdpZGdldEVudHJ5KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICQuZm5bbmFtZV0gPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgICAgIGFyZ3M7XG5cblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gU1RSSU5HKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkZ2V0ID0gJC5kYXRhKHRoaXMsIG5hbWUpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0O1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2lkZ2V0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioa2VuZG8uZm9ybWF0KFwiQ2Fubm90IGNhbGwgbWV0aG9kICd7MH0nIG9mIHsxfSBiZWZvcmUgaXQgaXMgaW5pdGlhbGl6ZWRcIiwgb3B0aW9ucywgbmFtZSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gd2lkZ2V0W29wdGlvbnNdO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSBGVU5DVElPTikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGtlbmRvLmZvcm1hdChcIkNhbm5vdCBmaW5kIG1ldGhvZCAnezB9JyBvZiB7MX1cIiwgb3B0aW9ucywgbmFtZSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbWV0aG9kLmFwcGx5KHdpZGdldCwgYXJncyk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2lkZ2V0KHRoaXMsIG9wdGlvbnMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgJC5mbltuYW1lXS53aWRnZXQgPSB3aWRnZXQ7XG5cblx0ICAgICAgICAgICAgJC5mbltnZXR0ZXJdID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhKG5hbWUpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBrZW5kby51aS5wcm9ncmVzcy5tZXNzYWdlcyA9IHtcblx0ICAgICAgICBsb2FkaW5nOiBcIkxvYWRpbmcuLi5cIlxuXHQgICAgfTtcblxuXHQgICAgdmFyIENvbnRhaW5lck51bGxPYmplY3QgPSB7IGJpbmQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIG51bGxPYmplY3Q6IHRydWUsIG9wdGlvbnM6IHt9IH07XG5cblx0ICAgIHZhciBNb2JpbGVXaWRnZXQgPSBXaWRnZXQuZXh0ZW5kKHtcblx0ICAgICAgICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIFdpZGdldC5mbi5pbml0LmNhbGwodGhpcywgZWxlbWVudCwgb3B0aW9ucyk7XG5cdCAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hdXRvQXBwbHlOUygpO1xuXHQgICAgICAgICAgICB0aGlzLndyYXBwZXIgPSB0aGlzLmVsZW1lbnQ7XG5cdCAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hZGRDbGFzcyhcImttLXdpZGdldFwiKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIFdpZGdldC5mbi5kZXN0cm95LmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIHRoaXMuZWxlbWVudC5rZW5kb0Rlc3Ryb3koKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgb3B0aW9uczoge1xuXHQgICAgICAgICAgICBwcmVmaXg6IFwiTW9iaWxlXCJcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZXZlbnRzOiBbXSxcblxuXHQgICAgICAgIHZpZXc6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgdmlld0VsZW1lbnQgPSB0aGlzLmVsZW1lbnQuY2xvc2VzdChrZW5kby5yb2xlU2VsZWN0b3IoXCJ2aWV3IHNwbGl0dmlldyBtb2RhbHZpZXcgZHJhd2VyXCIpKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGtlbmRvLndpZGdldEluc3RhbmNlKHZpZXdFbGVtZW50LCBrZW5kby5tb2JpbGUudWkpIHx8IENvbnRhaW5lck51bGxPYmplY3Q7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHZpZXdIYXNOYXRpdmVTY3JvbGxpbmc6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldygpO1xuXHQgICAgICAgICAgICByZXR1cm4gdmlldyAmJiB2aWV3Lm9wdGlvbnMudXNlTmF0aXZlU2Nyb2xsaW5nO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjb250YWluZXI6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudC5jbG9zZXN0KGtlbmRvLnJvbGVTZWxlY3RvcihcInZpZXcgbGF5b3V0IG1vZGFsdmlldyBkcmF3ZXIgc3BsaXR2aWV3XCIpKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGtlbmRvLndpZGdldEluc3RhbmNlKGVsZW1lbnQuZXEoMCksIGtlbmRvLm1vYmlsZS51aSkgfHwgQ29udGFpbmVyTnVsbE9iamVjdDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZXh0ZW5kKGtlbmRvLm1vYmlsZSwge1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0ICAgICAgICAgICAga2VuZG8uaW5pdChlbGVtZW50LCBrZW5kby5tb2JpbGUudWksIGtlbmRvLnVpLCBrZW5kby5kYXRhdml6LnVpKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYXBwTGV2ZWxOYXRpdmVTY3JvbGxpbmc6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4ga2VuZG8ubW9iaWxlLmFwcGxpY2F0aW9uICYmIGtlbmRvLm1vYmlsZS5hcHBsaWNhdGlvbi5vcHRpb25zICYmIGtlbmRvLm1vYmlsZS5hcHBsaWNhdGlvbi5vcHRpb25zLnVzZU5hdGl2ZVNjcm9sbGluZztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgcm9sZXM6IHt9LFxuXG5cdCAgICAgICAgdWk6IHtcblx0ICAgICAgICAgICAgV2lkZ2V0OiBNb2JpbGVXaWRnZXQsXG5cdCAgICAgICAgICAgIERhdGFCb3VuZFdpZGdldDogRGF0YUJvdW5kV2lkZ2V0LmV4dGVuZChNb2JpbGVXaWRnZXQucHJvdG90eXBlKSxcblx0ICAgICAgICAgICAgcm9sZXM6IHt9LFxuXHQgICAgICAgICAgICBwbHVnaW46IGZ1bmN0aW9uKHdpZGdldCkge1xuXHQgICAgICAgICAgICAgICAga2VuZG8udWkucGx1Z2luKHdpZGdldCwga2VuZG8ubW9iaWxlLnVpLCBcIk1vYmlsZVwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBkZWVwRXh0ZW5kKGtlbmRvLmRhdGF2aXosIHtcblx0ICAgICAgICBpbml0OiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdCAgICAgICAgICAgIGtlbmRvLmluaXQoZWxlbWVudCwga2VuZG8uZGF0YXZpei51aSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB1aToge1xuXHQgICAgICAgICAgICByb2xlczoge30sXG5cdCAgICAgICAgICAgIHRoZW1lczoge30sXG5cdCAgICAgICAgICAgIHZpZXdzOiBbXSxcblx0ICAgICAgICAgICAgcGx1Z2luOiBmdW5jdGlvbih3aWRnZXQpIHtcblx0ICAgICAgICAgICAgICAgIGtlbmRvLnVpLnBsdWdpbih3aWRnZXQsIGtlbmRvLmRhdGF2aXoudWkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICByb2xlczoge31cblx0ICAgIH0pO1xuXG5cdCAgICBrZW5kby50b3VjaFNjcm9sbGVyID0gZnVuY3Rpb24oZWxlbWVudHMsIG9wdGlvbnMpIHtcblx0ICAgICAgICAvLyByZXR1cm4gdGhlIGZpcnN0IHRvdWNoIHNjcm9sbGVyXG5cdCAgICAgICAgaWYgKCFvcHRpb25zKXsgb3B0aW9ucyA9IHt9OyB9XG5cblx0ICAgICAgICBvcHRpb25zLnVzZU5hdGl2ZSA9IHRydWU7XG5cblx0ICAgICAgICByZXR1cm4gJChlbGVtZW50cykubWFwKGZ1bmN0aW9uKGlkeCwgZWxlbWVudCkge1xuXHQgICAgICAgICAgICBlbGVtZW50ID0gJChlbGVtZW50KTtcblx0ICAgICAgICAgICAgaWYgKHN1cHBvcnQua2luZXRpY1Njcm9sbE5lZWRlZCAmJiBrZW5kby5tb2JpbGUudWkuU2Nyb2xsZXIgJiYgIWVsZW1lbnQuZGF0YShcImtlbmRvTW9iaWxlU2Nyb2xsZXJcIikpIHtcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnQua2VuZG9Nb2JpbGVTY3JvbGxlcihvcHRpb25zKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmRhdGEoXCJrZW5kb01vYmlsZVNjcm9sbGVyXCIpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSlbMF07XG5cdCAgICB9O1xuXG5cdCAgICBrZW5kby5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKGUpIHtcblx0ICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICB9O1xuXG5cdCAgICBrZW5kby53aWRnZXRJbnN0YW5jZSA9IGZ1bmN0aW9uKGVsZW1lbnQsIHN1aXRlcykge1xuXHQgICAgICAgIHZhciByb2xlID0gZWxlbWVudC5kYXRhKGtlbmRvLm5zICsgXCJyb2xlXCIpLFxuXHQgICAgICAgICAgICB3aWRnZXRzID0gW10sIGksIGxlbmd0aDtcblxuXHQgICAgICAgIGlmIChyb2xlKSB7XG5cdCAgICAgICAgICAgIC8vIEhBQ0shISEgbW9iaWxlIHZpZXcgc2Nyb2xsZXIgd2lkZ2V0cyBhcmUgaW5zdGFudGlhdGVkIG9uIGRhdGEtcm9sZT1cImNvbnRlbnRcIiBlbGVtZW50cy4gV2UgbmVlZCB0byBkaXNjb3ZlciB0aGVtIHdoZW4gcmVzaXppbmcuXG5cdCAgICAgICAgICAgIGlmIChyb2xlID09PSBcImNvbnRlbnRcIikge1xuXHQgICAgICAgICAgICAgICAgcm9sZSA9IFwic2Nyb2xsZXJcIjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIGtlbmRvRWRpdG9yVG9vbGJhciBpcyBub3QgYSBwdWJsaWMgcGx1Z2luLCB0aHVzIGl0IGRvZXMgbm90IGV4aXN0IGluIGtlbmRvLnVpLnJvbGVzLlxuXHQgICAgICAgICAgICAvLyBUaGVyZWZvcmUsIHRoaXMgaXMgbmVlZGVkIGluIG9yZGVyIHRvIGJlIHJlc2l6ZWQgd2hlbiBwbGFjZWQgaW4gS2VuZG8gV2luZG93LlxuXHQgICAgICAgICAgICBpZiAocm9sZSA9PT0gXCJlZGl0b3J0b29sYmFyXCIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBlZGl0b3JUb29sYmFyID0gZWxlbWVudC5kYXRhKFwia2VuZG9FZGl0b3JUb29sYmFyXCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGVkaXRvclRvb2xiYXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWRpdG9yVG9vbGJhcjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmIChzdWl0ZXMpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChzdWl0ZXNbMF0pIHtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBzdWl0ZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldHMucHVzaChzdWl0ZXNbaV0ucm9sZXNbcm9sZV0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgd2lkZ2V0cy5wdXNoKHN1aXRlcy5yb2xlc1tyb2xlXSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB3aWRnZXRzID0gWyBrZW5kby51aS5yb2xlc1tyb2xlXSwga2VuZG8uZGF0YXZpei51aS5yb2xlc1tyb2xlXSwgIGtlbmRvLm1vYmlsZS51aS5yb2xlc1tyb2xlXSBdO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHJvbGUuaW5kZXhPZihcIi5cIikgPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgd2lkZ2V0cyA9IFsga2VuZG8uZ2V0dGVyKHJvbGUpKHdpbmRvdykgXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHdpZGdldHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2lkZ2V0ID0gd2lkZ2V0c1tpXTtcblx0ICAgICAgICAgICAgICAgIGlmICh3aWRnZXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBlbGVtZW50LmRhdGEoXCJrZW5kb1wiICsgd2lkZ2V0LmZuLm9wdGlvbnMucHJlZml4ICsgd2lkZ2V0LmZuLm9wdGlvbnMubmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBrZW5kby5vblJlc2l6ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgdmFyIGhhbmRsZXIgPSBjYWxsYmFjaztcblx0ICAgICAgICBpZiAoc3VwcG9ydC5tb2JpbGVPUy5hbmRyb2lkKSB7XG5cdCAgICAgICAgICAgIGhhbmRsZXIgPSBmdW5jdGlvbigpIHsgc2V0VGltZW91dChjYWxsYmFjaywgNjAwKTsgfTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAkKHdpbmRvdykub24oc3VwcG9ydC5yZXNpemUsIGhhbmRsZXIpO1xuXHQgICAgICAgIHJldHVybiBoYW5kbGVyO1xuXHQgICAgfTtcblxuXHQgICAga2VuZG8udW5iaW5kUmVzaXplID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0ICAgICAgICAkKHdpbmRvdykub2ZmKHN1cHBvcnQucmVzaXplLCBjYWxsYmFjayk7XG5cdCAgICB9O1xuXG5cdCAgICBrZW5kby5hdHRyVmFsdWUgPSBmdW5jdGlvbihlbGVtZW50LCBrZXkpIHtcblx0ICAgICAgICByZXR1cm4gZWxlbWVudC5kYXRhKGtlbmRvLm5zICsga2V5KTtcblx0ICAgIH07XG5cblx0ICAgIGtlbmRvLmRheXMgPSB7XG5cdCAgICAgICAgU3VuZGF5OiAwLFxuXHQgICAgICAgIE1vbmRheTogMSxcblx0ICAgICAgICBUdWVzZGF5OiAyLFxuXHQgICAgICAgIFdlZG5lc2RheTogMyxcblx0ICAgICAgICBUaHVyc2RheTogNCxcblx0ICAgICAgICBGcmlkYXk6IDUsXG5cdCAgICAgICAgU2F0dXJkYXk6IDZcblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIGZvY3VzYWJsZShlbGVtZW50LCBpc1RhYkluZGV4Tm90TmFOKSB7XG5cdCAgICAgICAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdCAgICAgICAgcmV0dXJuICgvaW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbnxvYmplY3QvLnRlc3Qobm9kZU5hbWUpID9cblx0ICAgICAgICAgICAgICAgICFlbGVtZW50LmRpc2FibGVkIDpcblx0ICAgICAgICAgICAgICAgIFwiYVwiID09PSBub2RlTmFtZSA/XG5cdCAgICAgICAgICAgICAgICBlbGVtZW50LmhyZWYgfHwgaXNUYWJJbmRleE5vdE5hTiA6XG5cdCAgICAgICAgICAgICAgICBpc1RhYkluZGV4Tm90TmFOXG5cdCAgICAgICAgICAgICAgICkgJiZcblx0ICAgICAgICAgICAgdmlzaWJsZShlbGVtZW50KTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gdmlzaWJsZShlbGVtZW50KSB7XG5cdCAgICAgICAgcmV0dXJuICQuZXhwci5maWx0ZXJzLnZpc2libGUoZWxlbWVudCkgJiZcblx0ICAgICAgICAgICAgISQoZWxlbWVudCkucGFyZW50cygpLmFkZEJhY2soKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJC5jc3ModGhpcyxcInZpc2liaWxpdHlcIikgPT09IFwiaGlkZGVuXCI7XG5cdCAgICAgICAgICAgIH0pLmxlbmd0aDtcblx0ICAgIH1cblxuXHQgICAgJC5leHRlbmQoJC5leHByWyBcIjpcIiBdLCB7XG5cdCAgICAgICAga2VuZG9Gb2N1c2FibGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgdmFyIGlkeCA9ICQuYXR0cihlbGVtZW50LCBcInRhYmluZGV4XCIpO1xuXHQgICAgICAgICAgICByZXR1cm4gZm9jdXNhYmxlKGVsZW1lbnQsICFpc05hTihpZHgpICYmIGlkeCA+IC0xKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgdmFyIE1PVVNFX0VWRU5UUyA9IFtcIm1vdXNlZG93blwiLCBcIm1vdXNlbW92ZVwiLCBcIm1vdXNlZW50ZXJcIiwgXCJtb3VzZWxlYXZlXCIsIFwibW91c2VvdmVyXCIsIFwibW91c2VvdXRcIiwgXCJtb3VzZXVwXCIsIFwiY2xpY2tcIl07XG5cdCAgICB2YXIgRVhDTFVERV9CVVNUX0NMSUNLX1NFTEVDVE9SID0gXCJsYWJlbCwgaW5wdXQsIFtkYXRhLXJlbD1leHRlcm5hbF1cIjtcblxuXHQgICAgdmFyIE1vdXNlRXZlbnROb3JtYWxpemVyID0ge1xuXHQgICAgICAgIHNldHVwTW91c2VNdXRlOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIGlkeCA9IDAsXG5cdCAgICAgICAgICAgICAgICBsZW5ndGggPSBNT1VTRV9FVkVOVFMubGVuZ3RoLFxuXHQgICAgICAgICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXHQgICAgICAgICAgICBpZiAoTW91c2VFdmVudE5vcm1hbGl6ZXIubW91c2VUcmFwIHx8ICFzdXBwb3J0LmV2ZW50Q2FwdHVyZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgTW91c2VFdmVudE5vcm1hbGl6ZXIubW91c2VUcmFwID0gdHJ1ZTtcblxuXHQgICAgICAgICAgICBNb3VzZUV2ZW50Tm9ybWFsaXplci5idXN0Q2xpY2sgPSBmYWxzZTtcblx0ICAgICAgICAgICAgTW91c2VFdmVudE5vcm1hbGl6ZXIuY2FwdHVyZU1vdXNlID0gZmFsc2U7XG5cblx0ICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbihlKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoTW91c2VFdmVudE5vcm1hbGl6ZXIuY2FwdHVyZU1vdXNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJjbGlja1wiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNb3VzZUV2ZW50Tm9ybWFsaXplci5idXN0Q2xpY2sgJiYgISQoZS50YXJnZXQpLmlzKEVYQ0xVREVfQlVTVF9DTElDS19TRUxFQ1RPUikpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICBmb3IgKDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKE1PVVNFX0VWRU5UU1tpZHhdLCBoYW5kbGVyLCB0cnVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBtdXRlTW91c2U6IGZ1bmN0aW9uKGUpIHtcblx0ICAgICAgICAgICAgTW91c2VFdmVudE5vcm1hbGl6ZXIuY2FwdHVyZU1vdXNlID0gdHJ1ZTtcblx0ICAgICAgICAgICAgaWYgKGUuZGF0YS5idXN0Q2xpY2spIHtcblx0ICAgICAgICAgICAgICAgIE1vdXNlRXZlbnROb3JtYWxpemVyLmJ1c3RDbGljayA9IHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2xlYXJUaW1lb3V0KE1vdXNlRXZlbnROb3JtYWxpemVyLm1vdXNlVHJhcFRpbWVvdXRJRCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHVuTXV0ZU1vdXNlOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgY2xlYXJUaW1lb3V0KE1vdXNlRXZlbnROb3JtYWxpemVyLm1vdXNlVHJhcFRpbWVvdXRJRCk7XG5cdCAgICAgICAgICAgIE1vdXNlRXZlbnROb3JtYWxpemVyLm1vdXNlVHJhcFRpbWVvdXRJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBNb3VzZUV2ZW50Tm9ybWFsaXplci5jYXB0dXJlTW91c2UgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIE1vdXNlRXZlbnROb3JtYWxpemVyLmJ1c3RDbGljayA9IGZhbHNlO1xuXHQgICAgICAgICAgICB9LCA0MDApO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIHZhciBldmVudE1hcCA9IHtcblx0ICAgICAgICBkb3duOiBcInRvdWNoc3RhcnQgbW91c2Vkb3duXCIsXG5cdCAgICAgICAgbW92ZTogXCJtb3VzZW1vdmUgdG91Y2htb3ZlXCIsXG5cdCAgICAgICAgdXA6IFwibW91c2V1cCB0b3VjaGVuZCB0b3VjaGNhbmNlbFwiLFxuXHQgICAgICAgIGNhbmNlbDogXCJtb3VzZWxlYXZlIHRvdWNoY2FuY2VsXCJcblx0ICAgIH07XG5cblx0ICAgIGlmIChzdXBwb3J0LnRvdWNoICYmIChzdXBwb3J0Lm1vYmlsZU9TLmlvcyB8fCBzdXBwb3J0Lm1vYmlsZU9TLmFuZHJvaWQpKSB7XG5cdCAgICAgICAgZXZlbnRNYXAgPSB7XG5cdCAgICAgICAgICAgIGRvd246IFwidG91Y2hzdGFydFwiLFxuXHQgICAgICAgICAgICBtb3ZlOiBcInRvdWNobW92ZVwiLFxuXHQgICAgICAgICAgICB1cDogXCJ0b3VjaGVuZCB0b3VjaGNhbmNlbFwiLFxuXHQgICAgICAgICAgICBjYW5jZWw6IFwidG91Y2hjYW5jZWxcIlxuXHQgICAgICAgIH07XG5cdCAgICB9IGVsc2UgaWYgKHN1cHBvcnQucG9pbnRlcnMpIHtcblx0ICAgICAgICBldmVudE1hcCA9IHtcblx0ICAgICAgICAgICAgZG93bjogXCJwb2ludGVyZG93blwiLFxuXHQgICAgICAgICAgICBtb3ZlOiBcInBvaW50ZXJtb3ZlXCIsXG5cdCAgICAgICAgICAgIHVwOiBcInBvaW50ZXJ1cFwiLFxuXHQgICAgICAgICAgICBjYW5jZWw6IFwicG9pbnRlcmNhbmNlbCBwb2ludGVybGVhdmVcIlxuXHQgICAgICAgIH07XG5cdCAgICB9IGVsc2UgaWYgKHN1cHBvcnQubXNQb2ludGVycykge1xuXHQgICAgICAgIGV2ZW50TWFwID0ge1xuXHQgICAgICAgICAgICBkb3duOiBcIk1TUG9pbnRlckRvd25cIixcblx0ICAgICAgICAgICAgbW92ZTogXCJNU1BvaW50ZXJNb3ZlXCIsXG5cdCAgICAgICAgICAgIHVwOiBcIk1TUG9pbnRlclVwXCIsXG5cdCAgICAgICAgICAgIGNhbmNlbDogXCJNU1BvaW50ZXJDYW5jZWwgTVNQb2ludGVyTGVhdmVcIlxuXHQgICAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGlmIChzdXBwb3J0Lm1zUG9pbnRlcnMgJiYgIShcIm9ubXNwb2ludGVyZW50ZXJcIiBpbiB3aW5kb3cpKSB7IC8vIElFMTBcblx0ICAgICAgICAvLyBDcmVhdGUgTVNQb2ludGVyRW50ZXIvTVNQb2ludGVyTGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXG5cdCAgICAgICAgJC5lYWNoKHtcblx0ICAgICAgICAgICAgTVNQb2ludGVyRW50ZXI6IFwiTVNQb2ludGVyT3ZlclwiLFxuXHQgICAgICAgICAgICBNU1BvaW50ZXJMZWF2ZTogXCJNU1BvaW50ZXJPdXRcIlxuXHQgICAgICAgIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdCAgICAgICAgICAgICQuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHQgICAgICAgICAgICAgICAgZGVsZWdhdGVUeXBlOiBmaXgsXG5cdCAgICAgICAgICAgICAgICBiaW5kVHlwZTogZml4LFxuXG5cdCAgICAgICAgICAgICAgICBoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmV0LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRm9yIG1vdXNlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHQgICAgICAgICAgICAgICAgICAgIC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCAhcmVsYXRlZCB8fCAocmVsYXRlZCAhPT0gdGFyZ2V0ICYmICEkLmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSkgKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQudHlwZSA9IGZpeDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblxuXG5cdCAgICB2YXIgZ2V0RXZlbnRNYXAgPSBmdW5jdGlvbihlKSB7IHJldHVybiAoZXZlbnRNYXBbZV0gfHwgZSk7IH0sXG5cdCAgICAgICAgZXZlbnRSZWdFeCA9IC8oW14gXSspL2c7XG5cblx0ICAgIGtlbmRvLmFwcGx5RXZlbnRNYXAgPSBmdW5jdGlvbihldmVudHMsIG5zKSB7XG5cdCAgICAgICAgZXZlbnRzID0gZXZlbnRzLnJlcGxhY2UoZXZlbnRSZWdFeCwgZ2V0RXZlbnRNYXApO1xuXG5cdCAgICAgICAgaWYgKG5zKSB7XG5cdCAgICAgICAgICAgIGV2ZW50cyA9IGV2ZW50cy5yZXBsYWNlKGV2ZW50UmVnRXgsIFwiJDEuXCIgKyBucyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGV2ZW50cztcblx0ICAgIH07XG5cblx0ICAgIHZhciBvbiA9ICQuZm4ub247XG5cblx0ICAgIGZ1bmN0aW9uIGtlbmRvSlF1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0KSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBrZW5kb0pRdWVyeS5mbi5pbml0KHNlbGVjdG9yLCBjb250ZXh0KTtcblx0ICAgIH1cblxuXHQgICAgZXh0ZW5kKHRydWUsIGtlbmRvSlF1ZXJ5LCAkKTtcblxuXHQgICAga2VuZG9KUXVlcnkuZm4gPSBrZW5kb0pRdWVyeS5wcm90b3R5cGUgPSBuZXcgJCgpO1xuXG5cdCAgICBrZW5kb0pRdWVyeS5mbi5jb25zdHJ1Y3RvciA9IGtlbmRvSlF1ZXJ5O1xuXG5cdCAgICBrZW5kb0pRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQpIHtcblx0ICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0IGluc3RhbmNlb2YgJCAmJiAhKGNvbnRleHQgaW5zdGFuY2VvZiBrZW5kb0pRdWVyeSkpIHtcblx0ICAgICAgICAgICAgY29udGV4dCA9IGtlbmRvSlF1ZXJ5KGNvbnRleHQpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiAkLmZuLmluaXQuY2FsbCh0aGlzLCBzZWxlY3RvciwgY29udGV4dCwgcm9vdGpRdWVyeSk7XG5cdCAgICB9O1xuXG5cdCAgICBrZW5kb0pRdWVyeS5mbi5pbml0LnByb3RvdHlwZSA9IGtlbmRvSlF1ZXJ5LmZuO1xuXG5cdCAgICB2YXIgcm9vdGpRdWVyeSA9IGtlbmRvSlF1ZXJ5KGRvY3VtZW50KTtcblxuXHQgICAgZXh0ZW5kKGtlbmRvSlF1ZXJ5LmZuLCB7XG5cdCAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24oaGFuZGxlcikge1xuXHQgICAgICAgICAgICB0aGlzLmRhdGEoXCJoYW5kbGVyXCIsIGhhbmRsZXIpO1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYXV0b0FwcGx5TlM6IGZ1bmN0aW9uKG5zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZGF0YShcImtlbmRvTlNcIiwgbnMgfHwga2VuZG8uZ3VpZCgpKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIG9uOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgbnMgPSB0aGF0LmRhdGEoXCJrZW5kb05TXCIpO1xuXG5cdCAgICAgICAgICAgIC8vIHN1cHBvcnQgZm9yIGV2ZW50IG1hcCBzaWduYXR1cmVcblx0ICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBvbi5jYWxsKHRoYXQsIGFyZ3VtZW50c1swXSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoYXQsXG5cdCAgICAgICAgICAgICAgICBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtMV0gPT09IFVOREVGSU5FRCkge1xuXHQgICAgICAgICAgICAgICAgYXJncy5wb3AoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHZhciBjYWxsYmFjayA9ICBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0sXG5cdCAgICAgICAgICAgICAgICBldmVudHMgPSBrZW5kby5hcHBseUV2ZW50TWFwKGFyZ3NbMF0sIG5zKTtcblxuXHQgICAgICAgICAgICAvLyBzZXR1cCBtb3VzZSB0cmFwXG5cdCAgICAgICAgICAgIGlmIChzdXBwb3J0Lm1vdXNlQW5kVG91Y2hQcmVzZW50ICYmIGV2ZW50cy5zZWFyY2goL21vdXNlfGNsaWNrLykgPiAtMSAmJiB0aGlzWzBdICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgICAgIE1vdXNlRXZlbnROb3JtYWxpemVyLnNldHVwTW91c2VNdXRlKCk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IGFyZ3MubGVuZ3RoID09PSAyID8gbnVsbCA6IGFyZ3NbMV0sXG5cdCAgICAgICAgICAgICAgICAgICAgYnVzdENsaWNrID0gZXZlbnRzLmluZGV4T2YoXCJjbGlja1wiKSA+IC0xICYmIGV2ZW50cy5pbmRleE9mKFwidG91Y2hlbmRcIikgPiAtMTtcblxuXHQgICAgICAgICAgICAgICAgb24uY2FsbCh0aGlzLFxuXHQgICAgICAgICAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdG91Y2hzdGFydDogTW91c2VFdmVudE5vcm1hbGl6ZXIubXV0ZU1vdXNlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0b3VjaGVuZDogTW91c2VFdmVudE5vcm1hbGl6ZXIudW5NdXRlTW91c2Vcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLFxuXHQgICAgICAgICAgICAgICAgICAgIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnVzdENsaWNrOiBidXN0Q2xpY2tcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFNUUklORykge1xuXHQgICAgICAgICAgICAgICAgY29udGV4dCA9IHRoYXQuZGF0YShcImhhbmRsZXJcIik7XG5cdCAgICAgICAgICAgICAgICBjYWxsYmFjayA9IGNvbnRleHRbY2FsbGJhY2tdO1xuXG5cdCAgICAgICAgICAgICAgICBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPSBmdW5jdGlvbihlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBlKTtcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBhcmdzWzBdID0gZXZlbnRzO1xuXG5cdCAgICAgICAgICAgIG9uLmFwcGx5KHRoYXQsIGFyZ3MpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiB0aGF0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZW5kb0Rlc3Ryb3k6IGZ1bmN0aW9uKG5zKSB7XG5cdCAgICAgICAgICAgIG5zID0gbnMgfHwgdGhpcy5kYXRhKFwia2VuZG9OU1wiKTtcblxuXHQgICAgICAgICAgICBpZiAobnMpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMub2ZmKFwiLlwiICsgbnMpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIGtlbmRvLmpRdWVyeSA9IGtlbmRvSlF1ZXJ5O1xuXHQgICAga2VuZG8uZXZlbnRNYXAgPSBldmVudE1hcDtcblxuXHQgICAga2VuZG8udGltZXpvbmUgPSAoZnVuY3Rpb24oKXtcblx0ICAgICAgICB2YXIgbW9udGhzID0gIHsgSmFuOiAwLCBGZWI6IDEsIE1hcjogMiwgQXByOiAzLCBNYXk6IDQsIEp1bjogNSwgSnVsOiA2LCBBdWc6IDcsIFNlcDogOCwgT2N0OiA5LCBOb3Y6IDEwLCBEZWM6IDExIH07XG5cdCAgICAgICAgdmFyIGRheXMgPSB7IFN1bjogMCwgTW9uOiAxLCBUdWU6IDIsIFdlZDogMywgVGh1OiA0LCBGcmk6IDUsIFNhdDogNiB9O1xuXG5cdCAgICAgICAgZnVuY3Rpb24gcnVsZVRvRGF0ZSh5ZWFyLCBydWxlKSB7XG5cdCAgICAgICAgICAgIHZhciBkYXRlO1xuXHQgICAgICAgICAgICB2YXIgdGFyZ2V0RGF5O1xuXHQgICAgICAgICAgICB2YXIgb3VyRGF5O1xuXHQgICAgICAgICAgICB2YXIgbW9udGggPSBydWxlWzNdO1xuXHQgICAgICAgICAgICB2YXIgb24gPSBydWxlWzRdO1xuXHQgICAgICAgICAgICB2YXIgdGltZSA9IHJ1bGVbNV07XG5cdCAgICAgICAgICAgIHZhciBjYWNoZSA9IHJ1bGVbOF07XG5cblx0ICAgICAgICAgICAgaWYgKCFjYWNoZSkge1xuXHQgICAgICAgICAgICAgICAgcnVsZVs4XSA9IGNhY2hlID0ge307XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoY2FjaGVbeWVhcl0pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZVt5ZWFyXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICghaXNOYU4ob24pKSB7XG5cdCAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGhzW21vbnRoXSwgb24sIHRpbWVbMF0sIHRpbWVbMV0sIHRpbWVbMl0sIDApKTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChvbi5pbmRleE9mKFwibGFzdFwiKSA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoc1ttb250aF0gKyAxLCAxLCB0aW1lWzBdIC0gMjQsIHRpbWVbMV0sIHRpbWVbMl0sIDApKTtcblxuXHQgICAgICAgICAgICAgICAgdGFyZ2V0RGF5ID0gZGF5c1tvbi5zdWJzdHIoNCwgMyldO1xuXHQgICAgICAgICAgICAgICAgb3VyRGF5ID0gZGF0ZS5nZXRVVENEYXkoKTtcblxuXHQgICAgICAgICAgICAgICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgdGFyZ2V0RGF5IC0gb3VyRGF5IC0gKHRhcmdldERheSA+IG91ckRheSA/IDcgOiAwKSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAob24uaW5kZXhPZihcIj49XCIpID49IDApIHtcblx0ICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aHNbbW9udGhdLCBvbi5zdWJzdHIoNSksIHRpbWVbMF0sIHRpbWVbMV0sIHRpbWVbMl0sIDApKTtcblxuXHQgICAgICAgICAgICAgICAgdGFyZ2V0RGF5ID0gZGF5c1tvbi5zdWJzdHIoMCwgMyldO1xuXHQgICAgICAgICAgICAgICAgb3VyRGF5ID0gZGF0ZS5nZXRVVENEYXkoKTtcblxuXHQgICAgICAgICAgICAgICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgdGFyZ2V0RGF5IC0gb3VyRGF5ICsgKHRhcmdldERheSA8IG91ckRheSA/IDcgOiAwKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gY2FjaGVbeWVhcl0gPSBkYXRlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIGZpbmRSdWxlKHV0Y1RpbWUsIHJ1bGVzLCB6b25lKSB7XG5cdCAgICAgICAgICAgIHJ1bGVzID0gcnVsZXNbem9uZV07XG5cblx0ICAgICAgICAgICAgaWYgKCFydWxlcykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRpbWUgPSB6b25lLnNwbGl0KFwiOlwiKTtcblx0ICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAodGltZS5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGltZVswXSAqIDYwICsgTnVtYmVyKHRpbWVbMV0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gWy0xMDAwMDAwLCAnbWF4JywgJy0nLCAnSmFuJywgMSwgWzAsIDAsIDBdLCBvZmZzZXQsICctJ107XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB2YXIgeWVhciA9IG5ldyBEYXRlKHV0Y1RpbWUpLmdldFVUQ0Z1bGxZZWFyKCk7XG5cblx0ICAgICAgICAgICAgcnVsZXMgPSBqUXVlcnkuZ3JlcChydWxlcywgZnVuY3Rpb24ocnVsZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGZyb20gPSBydWxlWzBdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHRvID0gcnVsZVsxXTtcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZyb20gPD0geWVhciAmJiAodG8gPj0geWVhciB8fCAoZnJvbSA9PSB5ZWFyICYmIHRvID09IFwib25seVwiKSB8fCB0byA9PSBcIm1heFwiKTtcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgcnVsZXMucHVzaCh1dGNUaW1lKTtcblxuXHQgICAgICAgICAgICBydWxlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYSAhPSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYSA9IE51bWJlcihydWxlVG9EYXRlKHllYXIsIGEpKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBiICE9IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiID0gTnVtYmVyKHJ1bGVUb0RhdGUoeWVhciwgYikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYSAtIGI7XG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIHZhciBydWxlID0gcnVsZXNbalF1ZXJ5LmluQXJyYXkodXRjVGltZSwgcnVsZXMpIC0gMV0gfHwgcnVsZXNbcnVsZXMubGVuZ3RoIC0gMV07XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGlzTmFOKHJ1bGUpID8gcnVsZSA6IG51bGw7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gZmluZFpvbmUodXRjVGltZSwgem9uZXMsIHRpbWV6b25lKSB7XG5cdCAgICAgICAgICAgIHZhciB6b25lUnVsZXMgPSB6b25lc1t0aW1lem9uZV07XG5cblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiB6b25lUnVsZXMgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICAgIHpvbmVSdWxlcyA9IHpvbmVzW3pvbmVSdWxlc107XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoIXpvbmVSdWxlcykge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaW1lem9uZSBcIicgKyB0aW1lem9uZSArICdcIiBpcyBlaXRoZXIgaW5jb3JyZWN0LCBvciBrZW5kby50aW1lem9uZXMubWluLmpzIGlzIG5vdCBpbmNsdWRlZC4nKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGlkeCA9IHpvbmVSdWxlcy5sZW5ndGggLSAxOyBpZHggPj0gMDsgaWR4LS0pIHtcblx0ICAgICAgICAgICAgICAgIHZhciB1bnRpbCA9IHpvbmVSdWxlc1tpZHhdWzNdO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAodW50aWwgJiYgdXRjVGltZSA+IHVudGlsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB2YXIgem9uZSA9IHpvbmVSdWxlc1tpZHggKyAxXTtcblxuXHQgICAgICAgICAgICBpZiAoIXpvbmUpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGltZXpvbmUgXCInICsgdGltZXpvbmUgKyAnXCIgbm90IGZvdW5kIG9uICcgKyB1dGNUaW1lICsgXCIuXCIpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHpvbmU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gem9uZUFuZFJ1bGUodXRjVGltZSwgem9uZXMsIHJ1bGVzLCB0aW1lem9uZSkge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHV0Y1RpbWUgIT0gTlVNQkVSKSB7XG5cdCAgICAgICAgICAgICAgICB1dGNUaW1lID0gRGF0ZS5VVEModXRjVGltZS5nZXRGdWxsWWVhcigpLCB1dGNUaW1lLmdldE1vbnRoKCksXG5cdCAgICAgICAgICAgICAgICAgICAgdXRjVGltZS5nZXREYXRlKCksIHV0Y1RpbWUuZ2V0SG91cnMoKSwgdXRjVGltZS5nZXRNaW51dGVzKCksXG5cdCAgICAgICAgICAgICAgICAgICAgdXRjVGltZS5nZXRTZWNvbmRzKCksIHV0Y1RpbWUuZ2V0TWlsbGlzZWNvbmRzKCkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdmFyIHpvbmUgPSBmaW5kWm9uZSh1dGNUaW1lLCB6b25lcywgdGltZXpvbmUpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICB6b25lOiB6b25lLFxuXHQgICAgICAgICAgICAgICAgcnVsZTogZmluZFJ1bGUodXRjVGltZSwgcnVsZXMsIHpvbmVbMV0pXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gb2Zmc2V0KHV0Y1RpbWUsIHRpbWV6b25lKSB7XG5cdCAgICAgICAgICAgIGlmICh0aW1lem9uZSA9PSBcIkV0Yy9VVENcIiB8fCB0aW1lem9uZSA9PSBcIkV0Yy9HTVRcIikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB2YXIgaW5mbyA9IHpvbmVBbmRSdWxlKHV0Y1RpbWUsIHRoaXMuem9uZXMsIHRoaXMucnVsZXMsIHRpbWV6b25lKTtcblx0ICAgICAgICAgICAgdmFyIHpvbmUgPSBpbmZvLnpvbmU7XG5cdCAgICAgICAgICAgIHZhciBydWxlID0gaW5mby5ydWxlO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBrZW5kby5wYXJzZUZsb2F0KHJ1bGU/IHpvbmVbMF0gLSBydWxlWzZdIDogem9uZVswXSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gYWJicih1dGNUaW1lLCB0aW1lem9uZSkge1xuXHQgICAgICAgICAgICB2YXIgaW5mbyA9IHpvbmVBbmRSdWxlKHV0Y1RpbWUsIHRoaXMuem9uZXMsIHRoaXMucnVsZXMsIHRpbWV6b25lKTtcblx0ICAgICAgICAgICAgdmFyIHpvbmUgPSBpbmZvLnpvbmU7XG5cdCAgICAgICAgICAgIHZhciBydWxlID0gaW5mby5ydWxlO1xuXG5cdCAgICAgICAgICAgIHZhciBiYXNlID0gem9uZVsyXTtcblxuXHQgICAgICAgICAgICBpZiAoYmFzZS5pbmRleE9mKFwiL1wiKSA+PSAwKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYmFzZS5zcGxpdChcIi9cIilbcnVsZSAmJiArcnVsZVs2XSA/IDEgOiAwXTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChiYXNlLmluZGV4T2YoXCIlc1wiKSA+PSAwKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKFwiJXNcIiwgKCFydWxlIHx8IHJ1bGVbN10gPT0gXCItXCIpID8gJycgOiBydWxlWzddKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBiYXNlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIGNvbnZlcnQoZGF0ZSwgZnJvbU9mZnNldCwgdG9PZmZzZXQpIHtcblx0ICAgICAgICAgICAgdmFyIHRlbXBUb09mZnNldCA9IHRvT2Zmc2V0O1xuXHQgICAgICAgICAgICB2YXIgZGlmZjtcblxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGZyb21PZmZzZXQgPT0gU1RSSU5HKSB7XG5cdCAgICAgICAgICAgICAgICBmcm9tT2Zmc2V0ID0gdGhpcy5vZmZzZXQoZGF0ZSwgZnJvbU9mZnNldCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHRvT2Zmc2V0ID09IFNUUklORykge1xuXHQgICAgICAgICAgICAgICAgdG9PZmZzZXQgPSB0aGlzLm9mZnNldChkYXRlLCB0b09mZnNldCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB2YXIgZnJvbUxvY2FsT2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuXG5cdCAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSArIChmcm9tT2Zmc2V0IC0gdG9PZmZzZXQpICogNjAwMDApO1xuXG5cdCAgICAgICAgICAgIHZhciB0b0xvY2FsT2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcFRvT2Zmc2V0ID09IFNUUklORykge1xuXHQgICAgICAgICAgICAgICAgdGVtcFRvT2Zmc2V0ID0gdGhpcy5vZmZzZXQoZGF0ZSwgdGVtcFRvT2Zmc2V0KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGRpZmYgPSAodG9Mb2NhbE9mZnNldCAtIGZyb21Mb2NhbE9mZnNldCkgKyAodG9PZmZzZXQgLSB0ZW1wVG9PZmZzZXQpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSArIGRpZmYgKiA2MDAwMCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gYXBwbHkoZGF0ZSwgdGltZXpvbmUpIHtcblx0ICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0KGRhdGUsIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSwgdGltZXpvbmUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIHJlbW92ZShkYXRlLCB0aW1lem9uZSkge1xuXHQgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnQoZGF0ZSwgdGltZXpvbmUsIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gdG9Mb2NhbERhdGUodGltZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseShuZXcgRGF0ZSh0aW1lKSwgXCJFdGMvVVRDXCIpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgem9uZXM6IHt9LFxuXHQgICAgICAgICAgIHJ1bGVzOiB7fSxcblx0ICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcblx0ICAgICAgICAgICBjb252ZXJ0OiBjb252ZXJ0LFxuXHQgICAgICAgICAgIGFwcGx5OiBhcHBseSxcblx0ICAgICAgICAgICByZW1vdmU6IHJlbW92ZSxcblx0ICAgICAgICAgICBhYmJyOiBhYmJyLFxuXHQgICAgICAgICAgIHRvTG9jYWxEYXRlOiB0b0xvY2FsRGF0ZVxuXHQgICAgICAgIH07XG5cdCAgICB9KSgpO1xuXG5cdCAgICBrZW5kby5kYXRlID0gKGZ1bmN0aW9uKCl7XG5cdCAgICAgICAgdmFyIE1TX1BFUl9NSU5VVEUgPSA2MDAwMCxcblx0ICAgICAgICAgICAgTVNfUEVSX0RBWSA9IDg2NDAwMDAwO1xuXG5cdCAgICAgICAgZnVuY3Rpb24gYWRqdXN0RFNUKGRhdGUsIGhvdXJzKSB7XG5cdCAgICAgICAgICAgIGlmIChob3VycyA9PT0gMCAmJiBkYXRlLmdldEhvdXJzKCkgPT09IDIzKSB7XG5cdCAgICAgICAgICAgICAgICBkYXRlLnNldEhvdXJzKGRhdGUuZ2V0SG91cnMoKSArIDIpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gc2V0RGF5T2ZXZWVrKGRhdGUsIGRheSwgZGlyKSB7XG5cdCAgICAgICAgICAgIHZhciBob3VycyA9IGRhdGUuZ2V0SG91cnMoKTtcblxuXHQgICAgICAgICAgICBkaXIgPSBkaXIgfHwgMTtcblx0ICAgICAgICAgICAgZGF5ID0gKChkYXkgLSBkYXRlLmdldERheSgpKSArICg3ICogZGlyKSkgJSA3O1xuXG5cdCAgICAgICAgICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIGRheSk7XG5cdCAgICAgICAgICAgIGFkanVzdERTVChkYXRlLCBob3Vycyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gZGF5T2ZXZWVrKGRhdGUsIGRheSwgZGlyKSB7XG5cdCAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKTtcblx0ICAgICAgICAgICAgc2V0RGF5T2ZXZWVrKGRhdGUsIGRheSwgZGlyKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gZmlyc3REYXlPZk1vbnRoKGRhdGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKFxuXHQgICAgICAgICAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpLFxuXHQgICAgICAgICAgICAgICAgZGF0ZS5nZXRNb250aCgpLFxuXHQgICAgICAgICAgICAgICAgMVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIGxhc3REYXlPZk1vbnRoKGRhdGUpIHtcblx0ICAgICAgICAgICAgdmFyIGxhc3QgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSArIDEsIDApLFxuXHQgICAgICAgICAgICAgICAgZmlyc3QgPSBmaXJzdERheU9mTW9udGgoZGF0ZSksXG5cdCAgICAgICAgICAgICAgICB0aW1lT2Zmc2V0ID0gTWF0aC5hYnMobGFzdC5nZXRUaW1lem9uZU9mZnNldCgpIC0gZmlyc3QuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG5cblx0ICAgICAgICAgICAgaWYgKHRpbWVPZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIGxhc3Quc2V0SG91cnMoZmlyc3QuZ2V0SG91cnMoKSArICh0aW1lT2Zmc2V0IC8gNjApKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBsYXN0O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIG1vdmVEYXRlVG9XZWVrU3RhcnQoZGF0ZSwgd2Vla1N0YXJ0RGF5KSB7XG5cdCAgICAgICAgICAgIGlmICh3ZWVrU3RhcnREYXkgIT09IDEpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhZGREYXlzKGRheU9mV2VlayhkYXRlLCB3ZWVrU3RhcnREYXksIC0xKSwgNCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gYWRkRGF5cyhkYXRlLCAoNCAtIChkYXRlLmdldERheSgpIHx8IDcpKSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gY2FsY1dlZWtJblllYXIoZGF0ZSwgd2Vla1N0YXJ0RGF5KSB7XG5cdCAgICAgICAgICAgIHZhciBmaXJzdFdlZWtJblllYXIgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDEsIC02KTtcblxuXHQgICAgICAgICAgICB2YXIgbmV3RGF0ZSA9IG1vdmVEYXRlVG9XZWVrU3RhcnQoZGF0ZSwgd2Vla1N0YXJ0RGF5KTtcblxuXHQgICAgICAgICAgICB2YXIgZGlmZkluTVMgPSBuZXdEYXRlLmdldFRpbWUoKSAtIGZpcnN0V2Vla0luWWVhci5nZXRUaW1lKCk7XG5cblx0ICAgICAgICAgICAgdmFyIGRheXMgPSBNYXRoLmZsb29yKGRpZmZJbk1TIC8gTVNfUEVSX0RBWSk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIDEgKyBNYXRoLmZsb29yKGRheXMgLyA3KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmdW5jdGlvbiB3ZWVrSW5ZZWFyKGRhdGUsIHdlZWtTdGFydERheSkge1xuXHQgICAgICAgICAgICBpZih3ZWVrU3RhcnREYXkgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgd2Vla1N0YXJ0RGF5ID0ga2VuZG8uY3VsdHVyZSgpLmNhbGVuZGFyLmZpcnN0RGF5O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdmFyIHByZXZXZWVrRGF0ZSA9IGFkZERheXMoZGF0ZSwgLTcpO1xuXHQgICAgICAgICAgICB2YXIgbmV4dFdlZWtEYXRlID0gYWRkRGF5cyhkYXRlLCA3KTtcblxuXHQgICAgICAgICAgICB2YXIgd2Vla051bWJlciA9IGNhbGNXZWVrSW5ZZWFyKGRhdGUsIHdlZWtTdGFydERheSk7XG5cblx0ICAgICAgICAgICAgaWYgKHdlZWtOdW1iZXIgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjYWxjV2Vla0luWWVhcihwcmV2V2Vla0RhdGUsIHdlZWtTdGFydERheSkgKyAxO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHdlZWtOdW1iZXIgPT09IDUzICYmIGNhbGNXZWVrSW5ZZWFyKG5leHRXZWVrRGF0ZSwgd2Vla1N0YXJ0RGF5KSA+IDEpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHdlZWtOdW1iZXI7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0RGF0ZShkYXRlKSB7XG5cdCAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCksIDAsIDAsIDApO1xuXHQgICAgICAgICAgICBhZGp1c3REU1QoZGF0ZSwgMCk7XG5cdCAgICAgICAgICAgIHJldHVybiBkYXRlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIHRvVXRjVGltZShkYXRlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyhkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZS5nZXREYXRlKCksIGRhdGUuZ2V0SG91cnMoKSwgZGF0ZS5nZXRNaW51dGVzKCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUuZ2V0U2Vjb25kcygpLCBkYXRlLmdldE1pbGxpc2Vjb25kcygpKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmdW5jdGlvbiBnZXRNaWxsaXNlY29uZHMoZGF0ZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdG9JbnZhcmlhbnRUaW1lKGRhdGUpLmdldFRpbWUoKSAtIGdldERhdGUodG9JbnZhcmlhbnRUaW1lKGRhdGUpKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmdW5jdGlvbiBpc0luVGltZVJhbmdlKHZhbHVlLCBtaW4sIG1heCkge1xuXHQgICAgICAgICAgICB2YXIgbXNNaW4gPSBnZXRNaWxsaXNlY29uZHMobWluKSxcblx0ICAgICAgICAgICAgICAgIG1zTWF4ID0gZ2V0TWlsbGlzZWNvbmRzKG1heCksXG5cdCAgICAgICAgICAgICAgICBtc1ZhbHVlO1xuXG5cdCAgICAgICAgICAgIGlmICghdmFsdWUgfHwgbXNNaW4gPT0gbXNNYXgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKG1pbiA+PSBtYXgpIHtcblx0ICAgICAgICAgICAgICAgIG1heCArPSBNU19QRVJfREFZO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgbXNWYWx1ZSA9IGdldE1pbGxpc2Vjb25kcyh2YWx1ZSk7XG5cblx0ICAgICAgICAgICAgaWYgKG1zTWluID4gbXNWYWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgbXNWYWx1ZSArPSBNU19QRVJfREFZO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKG1zTWF4IDwgbXNNaW4pIHtcblx0ICAgICAgICAgICAgICAgIG1zTWF4ICs9IE1TX1BFUl9EQVk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbXNWYWx1ZSA+PSBtc01pbiAmJiBtc1ZhbHVlIDw9IG1zTWF4O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIGlzSW5EYXRlUmFuZ2UodmFsdWUsIG1pbiwgbWF4KSB7XG5cdCAgICAgICAgICAgIHZhciBtc01pbiA9IG1pbi5nZXRUaW1lKCksXG5cdCAgICAgICAgICAgICAgICBtc01heCA9IG1heC5nZXRUaW1lKCksXG5cdCAgICAgICAgICAgICAgICBtc1ZhbHVlO1xuXG5cdCAgICAgICAgICAgIGlmIChtc01pbiA+PSBtc01heCkge1xuXHQgICAgICAgICAgICAgICAgbXNNYXggKz0gTVNfUEVSX0RBWTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIG1zVmFsdWUgPSB2YWx1ZS5nZXRUaW1lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG1zVmFsdWUgPj0gbXNNaW4gJiYgbXNWYWx1ZSA8PSBtc01heDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmdW5jdGlvbiBhZGREYXlzKGRhdGUsIG9mZnNldCkge1xuXHQgICAgICAgICAgICB2YXIgaG91cnMgPSBkYXRlLmdldEhvdXJzKCk7XG5cdCAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XG5cblx0ICAgICAgICAgICAgc2V0VGltZShkYXRlLCBvZmZzZXQgKiBNU19QRVJfREFZKTtcblx0ICAgICAgICAgICAgYWRqdXN0RFNUKGRhdGUsIGhvdXJzKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gc2V0VGltZShkYXRlLCBtaWxsaXNlY29uZHMsIGlnbm9yZURTVCkge1xuXHQgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuXHQgICAgICAgICAgICB2YXIgZGlmZmVyZW5jZTtcblxuXHQgICAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyBtaWxsaXNlY29uZHMpO1xuXG5cdCAgICAgICAgICAgIGlmICghaWdub3JlRFNUKSB7XG5cdCAgICAgICAgICAgICAgICBkaWZmZXJlbmNlID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpIC0gb2Zmc2V0O1xuXHQgICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgZGlmZmVyZW5jZSAqIE1TX1BFUl9NSU5VVEUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gc2V0SG91cnMoZGF0ZSwgdGltZSkge1xuXHQgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoa2VuZG8uZGF0ZS5nZXREYXRlKGRhdGUpLmdldFRpbWUoKSArIGtlbmRvLmRhdGUuZ2V0TWlsbGlzZWNvbmRzKHRpbWUpKTtcblx0ICAgICAgICAgICAgYWRqdXN0RFNUKGRhdGUsIHRpbWUuZ2V0SG91cnMoKSk7XG5cdCAgICAgICAgICAgIHJldHVybiBkYXRlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIHRvZGF5KCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZ2V0RGF0ZShuZXcgRGF0ZSgpKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmdW5jdGlvbiBpc1RvZGF5KGRhdGUpIHtcblx0ICAgICAgICAgICByZXR1cm4gZ2V0RGF0ZShkYXRlKS5nZXRUaW1lKCkgPT0gdG9kYXkoKS5nZXRUaW1lKCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gdG9JbnZhcmlhbnRUaW1lKGRhdGUpIHtcblx0ICAgICAgICAgICAgdmFyIHN0YXRpY0RhdGUgPSBuZXcgRGF0ZSgxOTgwLCAxLCAxLCAwLCAwLCAwKTtcblxuXHQgICAgICAgICAgICBpZiAoZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgc3RhdGljRGF0ZS5zZXRIb3VycyhkYXRlLmdldEhvdXJzKCksIGRhdGUuZ2V0TWludXRlcygpLCBkYXRlLmdldFNlY29uZHMoKSwgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gc3RhdGljRGF0ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBhZGp1c3REU1Q6IGFkanVzdERTVCxcblx0ICAgICAgICAgICAgZGF5T2ZXZWVrOiBkYXlPZldlZWssXG5cdCAgICAgICAgICAgIHNldERheU9mV2Vlazogc2V0RGF5T2ZXZWVrLFxuXHQgICAgICAgICAgICBnZXREYXRlOiBnZXREYXRlLFxuXHQgICAgICAgICAgICBpc0luRGF0ZVJhbmdlOiBpc0luRGF0ZVJhbmdlLFxuXHQgICAgICAgICAgICBpc0luVGltZVJhbmdlOiBpc0luVGltZVJhbmdlLFxuXHQgICAgICAgICAgICBpc1RvZGF5OiBpc1RvZGF5LFxuXHQgICAgICAgICAgICBuZXh0RGF5OiBmdW5jdGlvbihkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYWRkRGF5cyhkYXRlLCAxKTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgcHJldmlvdXNEYXk6IGZ1bmN0aW9uKGRhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhZGREYXlzKGRhdGUsIC0xKTtcblx0ICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgdG9VdGNUaW1lOiB0b1V0Y1RpbWUsXG5cdCAgICAgICAgICAgIE1TX1BFUl9EQVk6IE1TX1BFUl9EQVksXG5cdCAgICAgICAgICAgIE1TX1BFUl9IT1VSOiA2MCAqIE1TX1BFUl9NSU5VVEUsXG5cdCAgICAgICAgICAgIE1TX1BFUl9NSU5VVEU6IE1TX1BFUl9NSU5VVEUsXG5cdCAgICAgICAgICAgIHNldFRpbWU6IHNldFRpbWUsXG5cdCAgICAgICAgICAgIHNldEhvdXJzOiBzZXRIb3Vycyxcblx0ICAgICAgICAgICAgYWRkRGF5czogYWRkRGF5cyxcblx0ICAgICAgICAgICAgdG9kYXk6IHRvZGF5LFxuXHQgICAgICAgICAgICB0b0ludmFyaWFudFRpbWU6IHRvSW52YXJpYW50VGltZSxcblx0ICAgICAgICAgICAgZmlyc3REYXlPZk1vbnRoOiBmaXJzdERheU9mTW9udGgsXG5cdCAgICAgICAgICAgIGxhc3REYXlPZk1vbnRoOiBsYXN0RGF5T2ZNb250aCxcblx0ICAgICAgICAgICAgd2Vla0luWWVhcjogd2Vla0luWWVhcixcblx0ICAgICAgICAgICAgZ2V0TWlsbGlzZWNvbmRzOiBnZXRNaWxsaXNlY29uZHNcblx0ICAgICAgICB9O1xuXHQgICAgfSkoKTtcblxuXG5cdCAgICBrZW5kby5zdHJpcFdoaXRlc3BhY2UgPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cdCAgICAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZU5vZGVJdGVyYXRvcikge1xuXHQgICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBkb2N1bWVudC5jcmVhdGVOb2RlSXRlcmF0b3IoZWxlbWVudCwgTm9kZUZpbHRlci5TSE9XX1RFWFQsIGZ1bmN0aW9uKG5vZGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlID09IGVsZW1lbnQgPyBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQgOiBOb2RlRmlsdGVyLkZJTFRFUl9SRUpFQ1Q7XG5cdCAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG5cblx0ICAgICAgICAgICAgd2hpbGUgKGl0ZXJhdG9yLm5leHROb2RlKCkpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvci5yZWZlcmVuY2VOb2RlICYmICFpdGVyYXRvci5yZWZlcmVuY2VOb2RlLnRleHRDb250ZW50LnRyaW0oKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnJlZmVyZW5jZU5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpdGVyYXRvci5yZWZlcmVuY2VOb2RlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7IC8vIElFNy84IHN1cHBvcnRcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuY2hpbGROb2Rlc1tpXTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDMgJiYgIS9cXFMvLnRlc3QoY2hpbGQubm9kZVZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuXHQgICAgICAgICAgICAgICAgICAgIGktLTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBrZW5kby5zdHJpcFdoaXRlc3BhY2UoY2hpbGQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgdmFyIGFuaW1hdGlvbkZyYW1lICA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgICAgfHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSAgICB8fFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgfHxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgICAgIHx8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oY2FsbGJhY2speyBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApOyB9O1xuXG5cdCAgICBrZW5kby5hbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgYW5pbWF0aW9uRnJhbWUuY2FsbCh3aW5kb3csIGNhbGxiYWNrKTtcblx0ICAgIH07XG5cblx0ICAgIHZhciBhbmltYXRpb25RdWV1ZSA9IFtdO1xuXG5cdCAgICBrZW5kby5xdWV1ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgYW5pbWF0aW9uUXVldWVbYW5pbWF0aW9uUXVldWUubGVuZ3RoXSA9IGNhbGxiYWNrO1xuXHQgICAgICAgIGlmIChhbmltYXRpb25RdWV1ZS5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgICAgICAga2VuZG8ucnVuTmV4dEFuaW1hdGlvbigpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGtlbmRvLnJ1bk5leHRBbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICBrZW5kby5hbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgaWYgKGFuaW1hdGlvblF1ZXVlWzBdKSB7XG5cdCAgICAgICAgICAgICAgICBhbmltYXRpb25RdWV1ZS5zaGlmdCgpKCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uUXVldWVbMF0pIHtcblx0ICAgICAgICAgICAgICAgICAgICBrZW5kby5ydW5OZXh0QW5pbWF0aW9uKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cblx0ICAgIGtlbmRvLnBhcnNlUXVlcnlTdHJpbmdQYXJhbXMgPSBmdW5jdGlvbih1cmwpIHtcblx0ICAgICAgICB2YXIgcXVlcnlTdHJpbmcgPSB1cmwuc3BsaXQoJz8nKVsxXSB8fCBcIlwiLFxuXHQgICAgICAgICAgICBwYXJhbXMgPSB7fSxcblx0ICAgICAgICAgICAgcGFyYW1QYXJ0cyA9IHF1ZXJ5U3RyaW5nLnNwbGl0KC8mfD0vKSxcblx0ICAgICAgICAgICAgbGVuZ3RoID0gcGFyYW1QYXJ0cy5sZW5ndGgsXG5cdCAgICAgICAgICAgIGlkeCA9IDA7XG5cblx0ICAgICAgICBmb3IgKDsgaWR4IDwgbGVuZ3RoOyBpZHggKz0gMikge1xuXHQgICAgICAgICAgICBpZihwYXJhbVBhcnRzW2lkeF0gIT09IFwiXCIpIHtcblx0ICAgICAgICAgICAgICAgIHBhcmFtc1tkZWNvZGVVUklDb21wb25lbnQocGFyYW1QYXJ0c1tpZHhdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFyYW1QYXJ0c1tpZHggKyAxXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcGFyYW1zO1xuXHQgICAgfTtcblxuXHQgICAga2VuZG8uZWxlbWVudFVuZGVyQ3Vyc29yID0gZnVuY3Rpb24oZSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgZS54LmNsaWVudCAhPSBcInVuZGVmaW5lZFwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGUueC5jbGllbnQsIGUueS5jbGllbnQpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGtlbmRvLndoZWVsRGVsdGFZID0gZnVuY3Rpb24oalF1ZXJ5RXZlbnQpIHtcblx0ICAgICAgICB2YXIgZSA9IGpRdWVyeUV2ZW50Lm9yaWdpbmFsRXZlbnQsXG5cdCAgICAgICAgICAgIGRlbHRhWSA9IGUud2hlZWxEZWx0YVksXG5cdCAgICAgICAgICAgIGRlbHRhO1xuXG5cdCAgICAgICAgICAgIGlmIChlLndoZWVsRGVsdGEpIHsgLy8gV2Via2l0IGFuZCBJRVxuXHQgICAgICAgICAgICAgICAgaWYgKGRlbHRhWSA9PT0gdW5kZWZpbmVkIHx8IGRlbHRhWSkgeyAvLyBJRSBkb2VzIG5vdCBoYXZlIGRlbHRhWSwgdGh1cyBhbHdheXMgc2Nyb2xsIChob3Jpem9udGFsIHNjcm9sbGluZyBpcyB0cmVhdGVkIGFzIHZlcnRpY2FsKVxuXHQgICAgICAgICAgICAgICAgICAgIGRlbHRhID0gZS53aGVlbERlbHRhO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGUuZGV0YWlsICYmIGUuYXhpcyA9PT0gZS5WRVJUSUNBTF9BWElTKSB7IC8vIEZpcmVmb3ggYW5kIE9wZXJhXG5cdCAgICAgICAgICAgICAgICBkZWx0YSA9ICgtZS5kZXRhaWwpICogMTA7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBkZWx0YTtcblx0ICAgIH07XG5cblx0ICAgIGtlbmRvLnRocm90dGxlID0gZnVuY3Rpb24oZm4sIGRlbGF5KSB7XG5cdCAgICAgICAgdmFyIHRpbWVvdXQ7XG5cdCAgICAgICAgdmFyIGxhc3RFeGVjVGltZSA9IDA7XG5cblx0ICAgICAgICBpZiAoIWRlbGF5IHx8IGRlbGF5IDw9IDApIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZuO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciB0aHJvdHRsZWQgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgZWxhcHNlZCA9ICtuZXcgRGF0ZSgpIC0gbGFzdEV4ZWNUaW1lO1xuXHQgICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblxuXHQgICAgICAgICAgICBmdW5jdGlvbiBleGVjKCkge1xuXHQgICAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG5cdCAgICAgICAgICAgICAgICBsYXN0RXhlY1RpbWUgPSArbmV3IERhdGUoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIGZpcnN0IGV4ZWN1dGlvblxuXHQgICAgICAgICAgICBpZiAoIWxhc3RFeGVjVGltZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWMoKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG5cdCAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoZWxhcHNlZCA+IGRlbGF5KSB7XG5cdCAgICAgICAgICAgICAgICBleGVjKCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChleGVjLCBkZWxheSAtIGVsYXBzZWQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblxuXHQgICAgICAgIHRocm90dGxlZC5jYW5jZWwgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHQgICAgICAgIH07XG5cblx0ICAgICAgICByZXR1cm4gdGhyb3R0bGVkO1xuXHQgICAgfTtcblxuXG5cdCAgICBrZW5kby5jYXJldCA9IGZ1bmN0aW9uIChlbGVtZW50LCBzdGFydCwgZW5kKSB7XG5cdCAgICAgICAgdmFyIHJhbmdlRWxlbWVudDtcblx0ICAgICAgICB2YXIgaXNQb3NpdGlvbiA9IHN0YXJ0ICE9PSB1bmRlZmluZWQ7XG5cblx0ICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgZW5kID0gc3RhcnQ7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGVsZW1lbnRbMF0pIHtcblx0ICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnRbMF07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGlzUG9zaXRpb24gJiYgZWxlbWVudC5kaXNhYmxlZCkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgaWYgKGVsZW1lbnQuc2VsZWN0aW9uU3RhcnQgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzUG9zaXRpb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1vYmlsZSA9IHN1cHBvcnQubW9iaWxlT1M7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYobW9iaWxlLndwIHx8IG1vYmlsZS5hbmRyb2lkKSB7Ly8gd2l0aG91dCB0aGUgdGltZW91dCB0aGUgY2FyZXQgaXMgYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgZWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZShzdGFydCwgZW5kKTsgfSwgMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldFNlbGVjdGlvblJhbmdlKHN0YXJ0LCBlbmQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBbZWxlbWVudC5zZWxlY3Rpb25TdGFydCwgZWxlbWVudC5zZWxlY3Rpb25FbmRdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbikge1xuXHQgICAgICAgICAgICAgICAgaWYgKCQoZWxlbWVudCkuaXMoXCI6dmlzaWJsZVwiKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgcmFuZ2VFbGVtZW50ID0gZWxlbWVudC5jcmVhdGVUZXh0UmFuZ2UoKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKGlzUG9zaXRpb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICByYW5nZUVsZW1lbnQuY29sbGFwc2UodHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmFuZ2VFbGVtZW50Lm1vdmVTdGFydChcImNoYXJhY3RlclwiLCBzdGFydCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmFuZ2VFbGVtZW50Lm1vdmVFbmQoXCJjaGFyYWN0ZXJcIiwgZW5kIC0gc3RhcnQpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJhbmdlRWxlbWVudC5zZWxlY3QoKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJhbmdlRHVwbGljYXRlZCA9IHJhbmdlRWxlbWVudC5kdXBsaWNhdGUoKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZDtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICByYW5nZUVsZW1lbnQubW92ZVRvQm9va21hcmsoZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCkuZ2V0Qm9va21hcmsoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlRHVwbGljYXRlZC5zZXRFbmRQb2ludCgnRW5kVG9TdGFydCcsIHJhbmdlRWxlbWVudCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0ID0gcmFuZ2VEdXBsaWNhdGVkLnRleHQubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb25FbmQgPSBzZWxlY3Rpb25TdGFydCArIHJhbmdlRWxlbWVudC50ZXh0Lmxlbmd0aDtcblxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gW3NlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmRdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSBjYXRjaChlKSB7XG5cdCAgICAgICAgICAgIC8qIGVsZW1lbnQgaXMgbm90IGZvY3VzZWQgb3IgaXQgaXMgbm90IGluIHRoZSBET00gKi9cblx0ICAgICAgICAgICAgc3RhcnQgPSBbXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gc3RhcnQ7XG5cdCAgICB9O1xuXG5cdCAgICBrZW5kby5jb21waWxlTW9iaWxlRGlyZWN0aXZlID0gZnVuY3Rpb24oZWxlbWVudCwgc2NvcGUpIHtcblx0ICAgICAgICB2YXIgYW5ndWxhciA9IHdpbmRvdy5hbmd1bGFyO1xuXG5cdCAgICAgICAgZWxlbWVudC5hdHRyKFwiZGF0YS1cIiArIGtlbmRvLm5zICsgXCJyb2xlXCIsIGVsZW1lbnRbMF0udGFnTmFtZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ2tlbmRvLW1vYmlsZS0nLCAnJykucmVwbGFjZSgnLScsICcnKSk7XG5cblx0ICAgICAgICBhbmd1bGFyLmVsZW1lbnQoZWxlbWVudCkuaW5qZWN0b3IoKS5pbnZva2UoW1wiJGNvbXBpbGVcIiwgZnVuY3Rpb24oJGNvbXBpbGUpIHtcblx0ICAgICAgICAgICAgJGNvbXBpbGUoZWxlbWVudCkoc2NvcGUpO1xuXG5cdCAgICAgICAgICAgIGlmICghL15cXCQoZGlnZXN0fGFwcGx5KSQvLnRlc3Qoc2NvcGUuJCRwaGFzZSkpIHtcblx0ICAgICAgICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1dKTtcblxuXHQgICAgICAgIHJldHVybiBrZW5kby53aWRnZXRJbnN0YW5jZShlbGVtZW50LCBrZW5kby5tb2JpbGUudWkpO1xuXHQgICAgfTtcblxuXHQgICAga2VuZG8uYW50aUZvcmdlcnlUb2tlbnMgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICB2YXIgdG9rZW5zID0geyB9LFxuXHQgICAgICAgICAgICBjc3JmX3Rva2VuID0gJChcIm1ldGFbbmFtZT1jc3JmLXRva2VuXSxtZXRhW25hbWU9X2NzcmZdXCIpLmF0dHIoXCJjb250ZW50XCIpLFxuXHQgICAgICAgICAgICBjc3JmX3BhcmFtID0gJChcIm1ldGFbbmFtZT1jc3JmLXBhcmFtXSxtZXRhW25hbWU9X2NzcmZfaGVhZGVyXVwiKS5hdHRyKFwiY29udGVudFwiKTtcblxuXHQgICAgICAgICQoXCJpbnB1dFtuYW1lXj0nX19SZXF1ZXN0VmVyaWZpY2F0aW9uVG9rZW4nXVwiKS5lYWNoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB0b2tlbnNbdGhpcy5uYW1lXSA9IHRoaXMudmFsdWU7XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBpZiAoY3NyZl9wYXJhbSAhPT0gdW5kZWZpbmVkICYmIGNzcmZfdG9rZW4gIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgdG9rZW5zW2NzcmZfcGFyYW1dID0gY3NyZl90b2tlbjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gdG9rZW5zO1xuXHQgICAgfTtcblxuXHQgICAga2VuZG8uY3ljbGVGb3JtID0gZnVuY3Rpb24oZm9ybSkge1xuXHQgICAgICAgIHZhciBmaXJzdEVsZW1lbnQgPSBmb3JtLmZpbmQoXCJpbnB1dCwgLmstd2lkZ2V0XCIpLmZpcnN0KCk7XG5cdCAgICAgICAgdmFyIGxhc3RFbGVtZW50ID0gZm9ybS5maW5kKFwiYnV0dG9uLCAuay1idXR0b25cIikubGFzdCgpO1xuXG5cdCAgICAgICAgZnVuY3Rpb24gZm9jdXMoZWwpIHtcblx0ICAgICAgICAgICAgdmFyIHdpZGdldCA9IGtlbmRvLndpZGdldEluc3RhbmNlKGVsKTtcblxuXHQgICAgICAgICAgICBpZiAod2lkZ2V0ICYmIHdpZGdldC5mb2N1cykge1xuXHQgICAgICAgICAgICAgIHdpZGdldC5mb2N1cygpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgIGVsLmZvY3VzKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBsYXN0RWxlbWVudC5vbihcImtleWRvd25cIiwgZnVuY3Rpb24oZSkge1xuXHQgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSBrZW5kby5rZXlzLlRBQiAmJiAhZS5zaGlmdEtleSkge1xuXHQgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICAgICAgICAgIGZvY3VzKGZpcnN0RWxlbWVudCk7XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBmaXJzdEVsZW1lbnQub24oXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGUpIHtcblx0ICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0ga2VuZG8ua2V5cy5UQUIgJiYgZS5zaGlmdEtleSkge1xuXHQgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICAgICAgICAgIGZvY3VzKGxhc3RFbGVtZW50KTtcblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cblx0ICAgIGtlbmRvLmZvY3VzRWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0ICAgICAgICB2YXIgc2Nyb2xsVG9wUG9zaXRpb25zID0gW107XG5cdCAgICAgICAgdmFyIHNjcm9sbGFibGVQYXJlbnRzID0gZWxlbWVudC5wYXJlbnRzVW50aWwoXCJib2R5XCIpXG5cdCAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGluZGV4LCBlbGVtZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSBrZW5kby5nZXRDb21wdXRlZFN0eWxlcyhlbGVtZW50LCBbXCJvdmVyZmxvd1wiXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXB1dGVkU3R5bGUub3ZlcmZsb3cgIT09IFwidmlzaWJsZVwiO1xuXHQgICAgICAgICAgICAgICAgfSlcblx0ICAgICAgICAgICAgICAgIC5hZGQod2luZG93KTtcblxuXHQgICAgICAgIHNjcm9sbGFibGVQYXJlbnRzLmVhY2goZnVuY3Rpb24oaW5kZXgsIHBhcmVudCkge1xuXHQgICAgICAgICAgICBzY3JvbGxUb3BQb3NpdGlvbnNbaW5kZXhdID0gJChwYXJlbnQpLnNjcm9sbFRvcCgpO1xuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgLy9UaGUgc2V0QWN0aXZlIG1ldGhvZCBkb2VzIG5vdCBjYXVzZSB0aGUgZG9jdW1lbnQgdG8gc2Nyb2xsIHRvIHRoZSBhY3RpdmUgb2JqZWN0IGluIHRoZSBjdXJyZW50IHBhZ2Vcblx0ICAgICAgICAgICAgZWxlbWVudFswXS5zZXRBY3RpdmUoKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgIGVsZW1lbnRbMF0uZm9jdXMoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBzY3JvbGxhYmxlUGFyZW50cy5lYWNoKGZ1bmN0aW9uKGluZGV4LCBwYXJlbnQpIHtcblx0ICAgICAgICAgICAgJChwYXJlbnQpLnNjcm9sbFRvcChzY3JvbGxUb3BQb3NpdGlvbnNbaW5kZXhdKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cblx0ICAgIGtlbmRvLm1hdGNoZXNNZWRpYSA9IGZ1bmN0aW9uKG1lZGlhUXVlcnkpIHtcblx0ICAgICAgICB2YXIgbWVkaWEgPSBrZW5kby5fYm9vdHN0cmFwVG9NZWRpYShtZWRpYVF1ZXJ5KSB8fCBtZWRpYVF1ZXJ5O1xuXHQgICAgICAgIHJldHVybiBzdXBwb3J0Lm1hdGNoTWVkaWEgJiYgd2luZG93Lm1hdGNoTWVkaWEobWVkaWEpLm1hdGNoZXM7XG5cdCAgICB9O1xuXG5cdCAgICBrZW5kby5fYm9vdHN0cmFwVG9NZWRpYSA9IGZ1bmN0aW9uKGJvb3RzdHJhcE1lZGlhKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgXCJ4c1wiOiBcIihtYXgtd2lkdGg6IDU3NnB4KVwiLFxuXHQgICAgICAgICAgICBcInNtXCI6IFwiKG1pbi13aWR0aDogNTc2cHgpXCIsXG5cdCAgICAgICAgICAgIFwibWRcIjogXCIobWluLXdpZHRoOiA3NjhweClcIixcblx0ICAgICAgICAgICAgXCJsZ1wiOiBcIihtaW4td2lkdGg6IDk5MnB4KVwiLFxuXHQgICAgICAgICAgICBcInhsXCI6IFwiKG1pbi13aWR0aDogMTIwMHB4KVwiXG5cdCAgICAgICAgfVtib290c3RyYXBNZWRpYV07XG5cdCAgICB9O1xuXG5cdCAgICAvLyBrZW5kby5zYXZlQXMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0ICAgIChmdW5jdGlvbigpIHtcblx0ICAgICAgICBmdW5jdGlvbiBwb3N0VG9Qcm94eShkYXRhVVJJLCBmaWxlTmFtZSwgcHJveHlVUkwsIHByb3h5VGFyZ2V0KSB7XG5cdCAgICAgICAgICAgIHZhciBmb3JtID0gJChcIjxmb3JtPlwiKS5hdHRyKHtcblx0ICAgICAgICAgICAgICAgIGFjdGlvbjogcHJveHlVUkwsXG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuXHQgICAgICAgICAgICAgICAgdGFyZ2V0OiBwcm94eVRhcmdldFxuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IGtlbmRvLmFudGlGb3JnZXJ5VG9rZW5zKCk7XG5cdCAgICAgICAgICAgIGRhdGEuZmlsZU5hbWUgPSBmaWxlTmFtZTtcblxuXHQgICAgICAgICAgICB2YXIgcGFydHMgPSBkYXRhVVJJLnNwbGl0KFwiO2Jhc2U2NCxcIik7XG5cdCAgICAgICAgICAgIGRhdGEuY29udGVudFR5cGUgPSBwYXJ0c1swXS5yZXBsYWNlKFwiZGF0YTpcIiwgXCJcIik7XG5cdCAgICAgICAgICAgIGRhdGEuYmFzZTY0ID0gcGFydHNbMV07XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBkYXRhKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICQoJzxpbnB1dD4nKS5hdHRyKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRhdGFbbmFtZV0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiaGlkZGVuXCJcblx0ICAgICAgICAgICAgICAgICAgICB9KS5hcHBlbmRUbyhmb3JtKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGZvcm0uYXBwZW5kVG8oXCJib2R5XCIpLnN1Ym1pdCgpLnJlbW92ZSgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBmaWxlU2F2ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcblx0ICAgICAgICB2YXIgZG93bmxvYWRBdHRyaWJ1dGUgPSBcImRvd25sb2FkXCIgaW4gZmlsZVNhdmVyICYmICFrZW5kby5zdXBwb3J0LmJyb3dzZXIuZWRnZTtcblxuXHQgICAgICAgIGZ1bmN0aW9uIHNhdmVBc0Jsb2IoZGF0YVVSSSwgZmlsZU5hbWUpIHtcblx0ICAgICAgICAgICAgdmFyIGJsb2IgPSBkYXRhVVJJOyAvLyBjb3VsZCBiZSBhIEJsb2Igb2JqZWN0XG5cblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhVVJJID09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IGRhdGFVUkkuc3BsaXQoXCI7YmFzZTY0LFwiKTtcblx0ICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IHBhcnRzWzBdO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJhc2U2NCA9IGF0b2IocGFydHNbMV0pO1xuXHQgICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYmFzZTY0Lmxlbmd0aCk7XG5cblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGJhc2U2NC5sZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYXJyYXlbaWR4XSA9IGJhc2U2NC5jaGFyQ29kZUF0KGlkeCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBibG9iID0gbmV3IEJsb2IoW2FycmF5LmJ1ZmZlcl0sIHsgdHlwZTogY29udGVudFR5cGUgfSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBuYXZpZ2F0b3IubXNTYXZlQmxvYihibG9iLCBmaWxlTmFtZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gc2F2ZUFzRGF0YVVSSShkYXRhVVJJLCBmaWxlTmFtZSkge1xuXHQgICAgICAgICAgICBpZiAod2luZG93LkJsb2IgJiYgZGF0YVVSSSBpbnN0YW5jZW9mIEJsb2IpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGFVUkkgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGRhdGFVUkkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZmlsZVNhdmVyLmRvd25sb2FkID0gZmlsZU5hbWU7XG5cdCAgICAgICAgICAgIGZpbGVTYXZlci5ocmVmID0gZGF0YVVSSTtcblxuXHQgICAgICAgICAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudHNcIik7XG5cdCAgICAgICAgICAgIGUuaW5pdE1vdXNlRXZlbnQoXCJjbGlja1wiLCB0cnVlLCBmYWxzZSwgd2luZG93LFxuXHQgICAgICAgICAgICAgICAgMCwgMCwgMCwgMCwgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuXG5cdCAgICAgICAgICAgIGZpbGVTYXZlci5kaXNwYXRjaEV2ZW50KGUpO1xuXHQgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdCAgICAgICAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGRhdGFVUkkpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBrZW5kby5zYXZlQXMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIHZhciBzYXZlID0gcG9zdFRvUHJveHk7XG5cblx0ICAgICAgICAgICAgaWYgKCFvcHRpb25zLmZvcmNlUHJveHkpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChkb3dubG9hZEF0dHJpYnV0ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHNhdmUgPSBzYXZlQXNEYXRhVVJJO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuYXZpZ2F0b3IubXNTYXZlQmxvYikge1xuXHQgICAgICAgICAgICAgICAgICAgIHNhdmUgPSBzYXZlQXNCbG9iO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgc2F2ZShvcHRpb25zLmRhdGFVUkksIG9wdGlvbnMuZmlsZU5hbWUsIG9wdGlvbnMucHJveHlVUkwsIG9wdGlvbnMucHJveHlUYXJnZXQpO1xuXHQgICAgICAgIH07XG5cdCAgICB9KSgpO1xuXG5cdCAgICAvLyBrZW5kbyBwcm94eVNldHRlcnNcblx0ICAgIGtlbmRvLnByb3h5TW9kZWxTZXR0ZXJzID0gZnVuY3Rpb24gcHJveHlNb2RlbFNldHRlcnMoZGF0YSkge1xuXHQgICAgICAgIHZhciBvYnNlcnZhYmxlID0ge307XG5cblx0ICAgICAgICBPYmplY3Qua2V5cyhkYXRhIHx8IHt9KS5mb3JFYWNoKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG5cdCAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JzZXJ2YWJsZSwgcHJvcGVydHksIHtcblx0ICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICByZXR1cm4gZGF0YVtwcm9wZXJ0eV07XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgICBkYXRhW3Byb3BlcnR5XSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgIGRhdGEuZGlydHkgPSB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblxuXHQgICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuXHQgICAgfTtcblxuXHR9KShqUXVlcnksIHdpbmRvdyk7XG5cblx0cmV0dXJuIHdpbmRvdy5rZW5kbztcblxuXHR9LCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcblxuXHQvKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwoZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXygxMDAzKSkpXG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///46d3985e259824d97676\n");

/***/ }),

/***/ "52de5ccd30df4e157d32":
/*!**************************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.treeview.draganddrop.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1340);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 1013:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.data */ \"f78db54954381e284430\");\n\n/***/ }),\n\n/***/ 1059:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.draganddrop */ \"b4c182ea2e2a8af62a4a\");\n\n/***/ }),\n\n/***/ 1340:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1013), __webpack_require__(1059) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: \"treeview.draganddrop\",\n\t    name: \"Hierarchical Drag & Drop\",\n\t    category: \"framework\",\n\t    depends: [ \"core\", \"draganddrop\" ],\n\t    advanced: true\n\t};\n\n\t(function($, undefined){\n\t    var kendo = window.kendo;\n\t    var ui = kendo.ui;\n\t    var proxy = $.proxy;\n\t    var extend = $.extend;\n\t    var VISIBILITY = \"visibility\";\n\t    var KSTATEHOVER = \"k-state-hover\";\n\t    var INPUTSELECTOR = \"input,a:not(.k-in),textarea,.k-multiselect-wrap,select,button,a.k-button>.k-icon,button.k-button>.k-icon,span.k-icon.k-i-arrow-60-right,span.k-icon.k-i-arrow-45-down-right\";\n\n\t    ui.HierarchicalDragAndDrop = kendo.Class.extend({\n\t        init: function (element, options) {\n\t            this.element = element;\n\t            this.hovered = element;\n\t            this.options = extend({\n\t                dragstart: $.noop, drag: $.noop, drop: $.noop, dragend: $.noop\n\t            }, options);\n\n\t            this._draggable = new ui.Draggable(element, {\n\t                ignore: INPUTSELECTOR,\n\t                filter: options.filter,\n\t                autoScroll: options.autoScroll,\n\t                cursorOffset: {\n\t                    left: 10,\n\t                    top: kendo.support.mobileOS ? -40 / kendo.support.zoomLevel() : 10\n\t                },\n\t                hint: proxy(this._hint, this),\n\t                dragstart: proxy(this.dragstart, this),\n\t                dragcancel: proxy(this.dragcancel, this),\n\t                drag: proxy(this.drag, this),\n\t                dragend: proxy(this.dragend, this),\n\t                $angular: options.$angular\n\t            });\n\t        },\n\n\t        _hint: function(element) {\n\t            return \"<div class='k-header k-drag-clue'>\" +\n\t                        \"<span class='k-icon k-drag-status' />\" +\n\t                        this.options.hintText(element) +\n\t                    \"</div>\";\n\t        },\n\n\t        _removeTouchHover: function() {\n\t            if (kendo.support.touch && this.hovered) {\n\t                this.hovered.find(\".\" + KSTATEHOVER).removeClass(KSTATEHOVER);\n\t                this.hovered = false;\n\t            }\n\t        },\n\n\t        _hintStatus: function(newStatus) {\n\t            var statusElement = this._draggable.hint.find(\".k-drag-status\")[0];\n\n\t            if (newStatus) {\n\t                statusElement.className = \"k-icon k-drag-status \" + newStatus;\n\t            } else {\n\t                return $.trim(statusElement.className.replace(/(p|k)-(icon|drag-status)/g, \"\"));\n\t            }\n\t        },\n\n\t        dragstart: function (e) {\n\t            this.source = e.currentTarget.closest(this.options.itemSelector);\n\n\t            if (this.options.dragstart(this.source)) {\n\t                e.preventDefault();\n\t            }\n\n\t            if (this.options.reorderable) {\n\t                this.dropHint = $(\"<div class='k-i-drag-and-drop' />\")\n\t                    .css(VISIBILITY, \"hidden\")\n\t                    .appendTo(this.element);\n\t            } else {\n\t                this.dropHint = $();\n\t            }\n\t        },\n\n\t        drag: function (e) {\n\t            var options = this.options;\n\t            var source = this.source;\n\t            var target = this.dropTarget = $(kendo.eventTarget(e));\n\t            var container = target.closest(options.allowedContainers);\n\t            var hoveredItem, itemHeight, itemTop, itemContent, delta;\n\t            var insertOnTop, insertOnBottom, addChild;\n\t            var itemData, position, status;\n\n\t            if (!container.length) {\n\t                // dragging outside of allowed elements\n\t                status = \"k-i-cancel\";\n\t                this._removeTouchHover();\n\t            } else if (source[0] == target[0] || options.contains(source[0], target[0])) {\n\t                // dragging item within itself\n\t                status = \"k-i-cancel\";\n\t            } else {\n\t                // moving or reordering item\n\t                status = \"k-i-insert-middle\";\n\n\t                itemData = options.itemFromTarget(target);\n\t                hoveredItem = itemData.item;\n\n\t                if (hoveredItem.length) {\n\t                    this._removeTouchHover();\n\t                    itemHeight = kendo._outerHeight(hoveredItem);\n\t                    itemContent = itemData.content;\n\n\t                    if (options.reorderable) {\n\t                        delta = itemHeight / (itemContent.length > 0 ? 4 : 2);\n\t                        itemTop = kendo.getOffset(hoveredItem).top;\n\n\t                        insertOnTop = e.y.location < (itemTop + delta);\n\t                        insertOnBottom = (itemTop + itemHeight - delta) < e.y.location;\n\t                        addChild = itemContent.length && !insertOnTop && !insertOnBottom;\n\t                    } else {\n\t                        addChild = true;\n\t                        insertOnTop = false;\n\t                        insertOnBottom = false;\n\t                    }\n\n\t                    this.hovered = addChild ? container : false;\n\n\t                    this.dropHint.css(VISIBILITY, addChild ? \"hidden\" : \"visible\");\n\n\t                    if (this._lastHover && this._lastHover[0] != itemContent[0]) {\n\t                        this._lastHover.removeClass(KSTATEHOVER);\n\t                    }\n\n\t                    this._lastHover = itemContent.toggleClass(KSTATEHOVER, addChild);\n\n\t                    if (addChild) {\n\t                        status = \"k-i-plus\";\n\t                    } else {\n\t                        position = hoveredItem.position();\n\t                        position.top += insertOnTop ? 0 : itemHeight;\n\n\t                        this.dropHint.css(position)\n\t                            [insertOnTop ? \"prependTo\" : \"appendTo\"]\n\t                            (options.dropHintContainer(hoveredItem));\n\n\t                        if (insertOnTop && itemData.first) {\n\t                            status = \"k-i-insert-up\";\n\t                        }\n\n\t                        if (insertOnBottom && itemData.last) {\n\t                            status = \"k-i-insert-down\";\n\t                        }\n\t                    }\n\t                } else if (target[0] != this.dropHint[0]) {\n\t                    if (this._lastHover) {\n\t                        this._lastHover.removeClass(KSTATEHOVER);\n\t                    }\n\n\t                    if (!$.contains(this.element[0], container[0])) {\n\t                        // moving node to different element\n\t                        status = \"k-i-plus\";\n\t                    } else {\n\t                        status = \"k-i-cancel\";\n\t                    }\n\t                }\n\t            }\n\n\t            this.options.drag({\n\t                originalEvent: e.originalEvent,\n\t                source: source,\n\t                target: target,\n\t                pageY: e.y.location,\n\t                pageX: e.x.location,\n\t                status: status.substring(2),\n\t                setStatus: function(value) {\n\t                    status = value;\n\t                }\n\t            });\n\n\t            if (status.indexOf(\"k-i-insert\") !== 0) {\n\t                this.dropHint.css(VISIBILITY, \"hidden\");\n\t            }\n\n\t            this._hintStatus(status);\n\t        },\n\n\t        dragcancel: function() {\n\t            this.dropHint.remove();\n\t        },\n\n\t        dragend: function (e) {\n\t            var position = \"over\",\n\t                source = this.source,\n\t                destination,\n\t                dropHint = this.dropHint,\n\t                dropTarget = this.dropTarget,\n\t                eventArgs, dropPrevented;\n\n\t            if (dropHint.css(VISIBILITY) == \"visible\") {\n\t                position = this.options.dropPositionFrom(dropHint);\n\t                destination = dropHint.closest(this.options.itemSelector);\n\t            } else if (dropTarget) {\n\t                destination = dropTarget.closest(this.options.itemSelector);\n\n\t                // moving node to root element\n\t                if (!destination.length) {\n\t                    destination = dropTarget.closest(this.options.allowedContainers);\n\t                }\n\t            }\n\n\t            eventArgs = {\n\t                originalEvent: e.originalEvent,\n\t                source: source[0],\n\t                destination: destination[0],\n\t                valid: this._hintStatus() != \"k-i-cancel\",\n\t                setValid: function(newValid) {\n\t                    this.valid = newValid;\n\t                },\n\t                dropTarget: dropTarget[0],\n\t                position: position\n\t            };\n\n\t            dropPrevented = this.options.drop(eventArgs);\n\n\t            dropHint.remove();\n\t            this._removeTouchHover();\n\t            if (this._lastHover) {\n\t                this._lastHover.removeClass(KSTATEHOVER);\n\t            }\n\n\t            if (!eventArgs.valid || dropPrevented) {\n\t                this._draggable.dropped = eventArgs.valid;\n\t                return;\n\t            }\n\n\t            this._draggable.dropped = true;\n\n\t            this.options.dragend({\n\t                originalEvent: e.originalEvent,\n\t                source: source,\n\t                destination: destination,\n\t                position: position\n\t            });\n\t        },\n\n\t        destroy: function() {\n\t            this._lastHover = this.hovered = null;\n\t            this._draggable.destroy();\n\t        }\n\t    });\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTJkZTVjY2QzMGRmNGUxNTdkMzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb2dyZXNzL2tlbmRvLXVpL2pzL2tlbmRvLnRyZWV2aWV3LmRyYWdhbmRkcm9wLmpzPzYxOTciXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPVxuLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gMDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTM0MCk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFwiZGVmaW5lIGNhbm5vdCBiZSB1c2VkIGluZGlyZWN0XCIpOyB9O1xyXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDEwMTM6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9rZW5kby5kYXRhXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMTA1OTpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2tlbmRvLmRyYWdhbmRkcm9wXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMTM0MDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsoZnVuY3Rpb24oZiwgZGVmaW5lKXtcblx0ICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFsgX193ZWJwYWNrX3JlcXVpcmVfXygxMDEzKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxMDU5KSBdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZiksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgPyAoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcblx0fSkoZnVuY3Rpb24oKXtcblxuXHR2YXIgX19tZXRhX18gPSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuXHQgICAgaWQ6IFwidHJlZXZpZXcuZHJhZ2FuZGRyb3BcIixcblx0ICAgIG5hbWU6IFwiSGllcmFyY2hpY2FsIERyYWcgJiBEcm9wXCIsXG5cdCAgICBjYXRlZ29yeTogXCJmcmFtZXdvcmtcIixcblx0ICAgIGRlcGVuZHM6IFsgXCJjb3JlXCIsIFwiZHJhZ2FuZGRyb3BcIiBdLFxuXHQgICAgYWR2YW5jZWQ6IHRydWVcblx0fTtcblxuXHQoZnVuY3Rpb24oJCwgdW5kZWZpbmVkKXtcblx0ICAgIHZhciBrZW5kbyA9IHdpbmRvdy5rZW5kbztcblx0ICAgIHZhciB1aSA9IGtlbmRvLnVpO1xuXHQgICAgdmFyIHByb3h5ID0gJC5wcm94eTtcblx0ICAgIHZhciBleHRlbmQgPSAkLmV4dGVuZDtcblx0ICAgIHZhciBWSVNJQklMSVRZID0gXCJ2aXNpYmlsaXR5XCI7XG5cdCAgICB2YXIgS1NUQVRFSE9WRVIgPSBcImstc3RhdGUtaG92ZXJcIjtcblx0ICAgIHZhciBJTlBVVFNFTEVDVE9SID0gXCJpbnB1dCxhOm5vdCguay1pbiksdGV4dGFyZWEsLmstbXVsdGlzZWxlY3Qtd3JhcCxzZWxlY3QsYnV0dG9uLGEuay1idXR0b24+LmstaWNvbixidXR0b24uay1idXR0b24+LmstaWNvbixzcGFuLmstaWNvbi5rLWktYXJyb3ctNjAtcmlnaHQsc3Bhbi5rLWljb24uay1pLWFycm93LTQ1LWRvd24tcmlnaHRcIjtcblxuXHQgICAgdWkuSGllcmFyY2hpY2FsRHJhZ0FuZERyb3AgPSBrZW5kby5DbGFzcy5leHRlbmQoe1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdCAgICAgICAgICAgIHRoaXMuaG92ZXJlZCA9IGVsZW1lbnQ7XG5cdCAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IGV4dGVuZCh7XG5cdCAgICAgICAgICAgICAgICBkcmFnc3RhcnQ6ICQubm9vcCwgZHJhZzogJC5ub29wLCBkcm9wOiAkLm5vb3AsIGRyYWdlbmQ6ICQubm9vcFxuXHQgICAgICAgICAgICB9LCBvcHRpb25zKTtcblxuXHQgICAgICAgICAgICB0aGlzLl9kcmFnZ2FibGUgPSBuZXcgdWkuRHJhZ2dhYmxlKGVsZW1lbnQsIHtcblx0ICAgICAgICAgICAgICAgIGlnbm9yZTogSU5QVVRTRUxFQ1RPUixcblx0ICAgICAgICAgICAgICAgIGZpbHRlcjogb3B0aW9ucy5maWx0ZXIsXG5cdCAgICAgICAgICAgICAgICBhdXRvU2Nyb2xsOiBvcHRpb25zLmF1dG9TY3JvbGwsXG5cdCAgICAgICAgICAgICAgICBjdXJzb3JPZmZzZXQ6IHtcblx0ICAgICAgICAgICAgICAgICAgICBsZWZ0OiAxMCxcblx0ICAgICAgICAgICAgICAgICAgICB0b3A6IGtlbmRvLnN1cHBvcnQubW9iaWxlT1MgPyAtNDAgLyBrZW5kby5zdXBwb3J0Lnpvb21MZXZlbCgpIDogMTBcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBoaW50OiBwcm94eSh0aGlzLl9oaW50LCB0aGlzKSxcblx0ICAgICAgICAgICAgICAgIGRyYWdzdGFydDogcHJveHkodGhpcy5kcmFnc3RhcnQsIHRoaXMpLFxuXHQgICAgICAgICAgICAgICAgZHJhZ2NhbmNlbDogcHJveHkodGhpcy5kcmFnY2FuY2VsLCB0aGlzKSxcblx0ICAgICAgICAgICAgICAgIGRyYWc6IHByb3h5KHRoaXMuZHJhZywgdGhpcyksXG5cdCAgICAgICAgICAgICAgICBkcmFnZW5kOiBwcm94eSh0aGlzLmRyYWdlbmQsIHRoaXMpLFxuXHQgICAgICAgICAgICAgICAgJGFuZ3VsYXI6IG9wdGlvbnMuJGFuZ3VsYXJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9oaW50OiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBcIjxkaXYgY2xhc3M9J2staGVhZGVyIGstZHJhZy1jbHVlJz5cIiArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFwiPHNwYW4gY2xhc3M9J2staWNvbiBrLWRyYWctc3RhdHVzJyAvPlwiICtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmhpbnRUZXh0KGVsZW1lbnQpICtcblx0ICAgICAgICAgICAgICAgICAgICBcIjwvZGl2PlwiO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfcmVtb3ZlVG91Y2hIb3ZlcjogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIGlmIChrZW5kby5zdXBwb3J0LnRvdWNoICYmIHRoaXMuaG92ZXJlZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5ob3ZlcmVkLmZpbmQoXCIuXCIgKyBLU1RBVEVIT1ZFUikucmVtb3ZlQ2xhc3MoS1NUQVRFSE9WRVIpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5ob3ZlcmVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2hpbnRTdGF0dXM6IGZ1bmN0aW9uKG5ld1N0YXR1cykge1xuXHQgICAgICAgICAgICB2YXIgc3RhdHVzRWxlbWVudCA9IHRoaXMuX2RyYWdnYWJsZS5oaW50LmZpbmQoXCIuay1kcmFnLXN0YXR1c1wiKVswXTtcblxuXHQgICAgICAgICAgICBpZiAobmV3U3RhdHVzKSB7XG5cdCAgICAgICAgICAgICAgICBzdGF0dXNFbGVtZW50LmNsYXNzTmFtZSA9IFwiay1pY29uIGstZHJhZy1zdGF0dXMgXCIgKyBuZXdTdGF0dXM7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gJC50cmltKHN0YXR1c0VsZW1lbnQuY2xhc3NOYW1lLnJlcGxhY2UoLyhwfGspLShpY29ufGRyYWctc3RhdHVzKS9nLCBcIlwiKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZHJhZ3N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHQgICAgICAgICAgICB0aGlzLnNvdXJjZSA9IGUuY3VycmVudFRhcmdldC5jbG9zZXN0KHRoaXMub3B0aW9ucy5pdGVtU2VsZWN0b3IpO1xuXG5cdCAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHJhZ3N0YXJ0KHRoaXMuc291cmNlKSkge1xuXHQgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZW9yZGVyYWJsZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5kcm9wSGludCA9ICQoXCI8ZGl2IGNsYXNzPSdrLWktZHJhZy1hbmQtZHJvcCcgLz5cIilcblx0ICAgICAgICAgICAgICAgICAgICAuY3NzKFZJU0lCSUxJVFksIFwiaGlkZGVuXCIpXG5cdCAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKHRoaXMuZWxlbWVudCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmRyb3BIaW50ID0gJCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRyYWc6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXHQgICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG5cdCAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmRyb3BUYXJnZXQgPSAkKGtlbmRvLmV2ZW50VGFyZ2V0KGUpKTtcblx0ICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRhcmdldC5jbG9zZXN0KG9wdGlvbnMuYWxsb3dlZENvbnRhaW5lcnMpO1xuXHQgICAgICAgICAgICB2YXIgaG92ZXJlZEl0ZW0sIGl0ZW1IZWlnaHQsIGl0ZW1Ub3AsIGl0ZW1Db250ZW50LCBkZWx0YTtcblx0ICAgICAgICAgICAgdmFyIGluc2VydE9uVG9wLCBpbnNlcnRPbkJvdHRvbSwgYWRkQ2hpbGQ7XG5cdCAgICAgICAgICAgIHZhciBpdGVtRGF0YSwgcG9zaXRpb24sIHN0YXR1cztcblxuXHQgICAgICAgICAgICBpZiAoIWNvbnRhaW5lci5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIC8vIGRyYWdnaW5nIG91dHNpZGUgb2YgYWxsb3dlZCBlbGVtZW50c1xuXHQgICAgICAgICAgICAgICAgc3RhdHVzID0gXCJrLWktY2FuY2VsXCI7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVUb3VjaEhvdmVyKCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlWzBdID09IHRhcmdldFswXSB8fCBvcHRpb25zLmNvbnRhaW5zKHNvdXJjZVswXSwgdGFyZ2V0WzBdKSkge1xuXHQgICAgICAgICAgICAgICAgLy8gZHJhZ2dpbmcgaXRlbSB3aXRoaW4gaXRzZWxmXG5cdCAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImstaS1jYW5jZWxcIjtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIG1vdmluZyBvciByZW9yZGVyaW5nIGl0ZW1cblx0ICAgICAgICAgICAgICAgIHN0YXR1cyA9IFwiay1pLWluc2VydC1taWRkbGVcIjtcblxuXHQgICAgICAgICAgICAgICAgaXRlbURhdGEgPSBvcHRpb25zLml0ZW1Gcm9tVGFyZ2V0KHRhcmdldCk7XG5cdCAgICAgICAgICAgICAgICBob3ZlcmVkSXRlbSA9IGl0ZW1EYXRhLml0ZW07XG5cblx0ICAgICAgICAgICAgICAgIGlmIChob3ZlcmVkSXRlbS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVUb3VjaEhvdmVyKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaXRlbUhlaWdodCA9IGtlbmRvLl9vdXRlckhlaWdodChob3ZlcmVkSXRlbSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaXRlbUNvbnRlbnQgPSBpdGVtRGF0YS5jb250ZW50O1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVvcmRlcmFibGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSBpdGVtSGVpZ2h0IC8gKGl0ZW1Db250ZW50Lmxlbmd0aCA+IDAgPyA0IDogMik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1Ub3AgPSBrZW5kby5nZXRPZmZzZXQoaG92ZXJlZEl0ZW0pLnRvcDtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRPblRvcCA9IGUueS5sb2NhdGlvbiA8IChpdGVtVG9wICsgZGVsdGEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRPbkJvdHRvbSA9IChpdGVtVG9wICsgaXRlbUhlaWdodCAtIGRlbHRhKSA8IGUueS5sb2NhdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2hpbGQgPSBpdGVtQ29udGVudC5sZW5ndGggJiYgIWluc2VydE9uVG9wICYmICFpbnNlcnRPbkJvdHRvbTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZGRDaGlsZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydE9uVG9wID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydE9uQm90dG9tID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3ZlcmVkID0gYWRkQ2hpbGQgPyBjb250YWluZXIgOiBmYWxzZTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcEhpbnQuY3NzKFZJU0lCSUxJVFksIGFkZENoaWxkID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0SG92ZXIgJiYgdGhpcy5fbGFzdEhvdmVyWzBdICE9IGl0ZW1Db250ZW50WzBdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RIb3Zlci5yZW1vdmVDbGFzcyhLU1RBVEVIT1ZFUik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdEhvdmVyID0gaXRlbUNvbnRlbnQudG9nZ2xlQ2xhc3MoS1NUQVRFSE9WRVIsIGFkZENoaWxkKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChhZGRDaGlsZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImstaS1wbHVzXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBob3ZlcmVkSXRlbS5wb3NpdGlvbigpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi50b3AgKz0gaW5zZXJ0T25Ub3AgPyAwIDogaXRlbUhlaWdodDtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BIaW50LmNzcyhwb3NpdGlvbilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpbnNlcnRPblRvcCA/IFwicHJlcGVuZFRvXCIgOiBcImFwcGVuZFRvXCJdXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3B0aW9ucy5kcm9wSGludENvbnRhaW5lcihob3ZlcmVkSXRlbSkpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnNlcnRPblRvcCAmJiBpdGVtRGF0YS5maXJzdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gXCJrLWktaW5zZXJ0LXVwXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0T25Cb3R0b20gJiYgaXRlbURhdGEubGFzdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gXCJrLWktaW5zZXJ0LWRvd25cIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0WzBdICE9IHRoaXMuZHJvcEhpbnRbMF0pIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGFzdEhvdmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RIb3Zlci5yZW1vdmVDbGFzcyhLU1RBVEVIT1ZFUik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEkLmNvbnRhaW5zKHRoaXMuZWxlbWVudFswXSwgY29udGFpbmVyWzBdKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3Zpbmcgbm9kZSB0byBkaWZmZXJlbnQgZWxlbWVudFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSBcImstaS1wbHVzXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gXCJrLWktY2FuY2VsXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRyYWcoe1xuXHQgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZS5vcmlnaW5hbEV2ZW50LFxuXHQgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG5cdCAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcblx0ICAgICAgICAgICAgICAgIHBhZ2VZOiBlLnkubG9jYXRpb24sXG5cdCAgICAgICAgICAgICAgICBwYWdlWDogZS54LmxvY2F0aW9uLFxuXHQgICAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMuc3Vic3RyaW5nKDIpLFxuXHQgICAgICAgICAgICAgICAgc2V0U3RhdHVzOiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICBpZiAoc3RhdHVzLmluZGV4T2YoXCJrLWktaW5zZXJ0XCIpICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmRyb3BIaW50LmNzcyhWSVNJQklMSVRZLCBcImhpZGRlblwiKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoaXMuX2hpbnRTdGF0dXMoc3RhdHVzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZHJhZ2NhbmNlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZHJvcEhpbnQucmVtb3ZlKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRyYWdlbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdCAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IFwib3ZlclwiLFxuXHQgICAgICAgICAgICAgICAgc291cmNlID0gdGhpcy5zb3VyY2UsXG5cdCAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbixcblx0ICAgICAgICAgICAgICAgIGRyb3BIaW50ID0gdGhpcy5kcm9wSGludCxcblx0ICAgICAgICAgICAgICAgIGRyb3BUYXJnZXQgPSB0aGlzLmRyb3BUYXJnZXQsXG5cdCAgICAgICAgICAgICAgICBldmVudEFyZ3MsIGRyb3BQcmV2ZW50ZWQ7XG5cblx0ICAgICAgICAgICAgaWYgKGRyb3BIaW50LmNzcyhWSVNJQklMSVRZKSA9PSBcInZpc2libGVcIikge1xuXHQgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLm9wdGlvbnMuZHJvcFBvc2l0aW9uRnJvbShkcm9wSGludCk7XG5cdCAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbiA9IGRyb3BIaW50LmNsb3Nlc3QodGhpcy5vcHRpb25zLml0ZW1TZWxlY3Rvcik7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoZHJvcFRhcmdldCkge1xuXHQgICAgICAgICAgICAgICAgZGVzdGluYXRpb24gPSBkcm9wVGFyZ2V0LmNsb3Nlc3QodGhpcy5vcHRpb25zLml0ZW1TZWxlY3Rvcik7XG5cblx0ICAgICAgICAgICAgICAgIC8vIG1vdmluZyBub2RlIHRvIHJvb3QgZWxlbWVudFxuXHQgICAgICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbi5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbiA9IGRyb3BUYXJnZXQuY2xvc2VzdCh0aGlzLm9wdGlvbnMuYWxsb3dlZENvbnRhaW5lcnMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZXZlbnRBcmdzID0ge1xuXHQgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZS5vcmlnaW5hbEV2ZW50LFxuXHQgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2VbMF0sXG5cdCAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb25bMF0sXG5cdCAgICAgICAgICAgICAgICB2YWxpZDogdGhpcy5faGludFN0YXR1cygpICE9IFwiay1pLWNhbmNlbFwiLFxuXHQgICAgICAgICAgICAgICAgc2V0VmFsaWQ6IGZ1bmN0aW9uKG5ld1ZhbGlkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy52YWxpZCA9IG5ld1ZhbGlkO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIGRyb3BUYXJnZXQ6IGRyb3BUYXJnZXRbMF0sXG5cdCAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cblx0ICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICBkcm9wUHJldmVudGVkID0gdGhpcy5vcHRpb25zLmRyb3AoZXZlbnRBcmdzKTtcblxuXHQgICAgICAgICAgICBkcm9wSGludC5yZW1vdmUoKTtcblx0ICAgICAgICAgICAgdGhpcy5fcmVtb3ZlVG91Y2hIb3ZlcigpO1xuXHQgICAgICAgICAgICBpZiAodGhpcy5fbGFzdEhvdmVyKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9sYXN0SG92ZXIucmVtb3ZlQ2xhc3MoS1NUQVRFSE9WRVIpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKCFldmVudEFyZ3MudmFsaWQgfHwgZHJvcFByZXZlbnRlZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZHJhZ2dhYmxlLmRyb3BwZWQgPSBldmVudEFyZ3MudmFsaWQ7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGlzLl9kcmFnZ2FibGUuZHJvcHBlZCA9IHRydWU7XG5cblx0ICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRyYWdlbmQoe1xuXHQgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZS5vcmlnaW5hbEV2ZW50LFxuXHQgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG5cdCAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbjogZGVzdGluYXRpb24sXG5cdCAgICAgICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9sYXN0SG92ZXIgPSB0aGlzLmhvdmVyZWQgPSBudWxsO1xuXHQgICAgICAgICAgICB0aGlzLl9kcmFnZ2FibGUuZGVzdHJveSgpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdH0pKHdpbmRvdy5rZW5kby5qUXVlcnkpO1xuXG5cdHJldHVybiB3aW5kb3cua2VuZG87XG5cblx0fSwgX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG5cblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///52de5ccd30df4e157d32\n");

/***/ }),

/***/ "9a0e40ed3a51a921e191":
/*!****************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.userevents.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1350);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 1004:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.core */ \"46d3985e259824d97676\");\n\n/***/ }),\n\n/***/ 1350:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1004) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: \"userevents\",\n\t    name: \"User Events\",\n\t    category: \"framework\",\n\t    depends: [ \"core\" ],\n\t    hidden: true\n\t};\n\n\t(function ($, undefined) {\n\t    var kendo = window.kendo,\n\t        support = kendo.support,\n\t        Class = kendo.Class,\n\t        Observable = kendo.Observable,\n\t        now = $.now,\n\t        extend = $.extend,\n\t        OS = support.mobileOS,\n\t        invalidZeroEvents = OS && OS.android,\n\t        DEFAULT_MIN_HOLD = 800,\n\t        CLICK_DELAY = 300,\n\t        DEFAULT_THRESHOLD = support.browser.msie ? 5 : 0, // WP8 and W8 are very sensitive and always report move.\n\n\t        // UserEvents events\n\t        PRESS = \"press\",\n\t        HOLD = \"hold\",\n\t        SELECT = \"select\",\n\t        START = \"start\",\n\t        MOVE = \"move\",\n\t        END = \"end\",\n\t        CANCEL = \"cancel\",\n\t        TAP = \"tap\",\n\t        DOUBLETAP = \"doubleTap\",\n\t        RELEASE = \"release\",\n\t        GESTURESTART = \"gesturestart\",\n\t        GESTURECHANGE = \"gesturechange\",\n\t        GESTUREEND = \"gestureend\",\n\t        GESTURETAP = \"gesturetap\";\n\n\t    var THRESHOLD = {\n\t        \"api\": 0,\n\t        \"touch\": 0,\n\t        \"mouse\": 9,\n\t        \"pointer\": 9\n\t    };\n\n\t    var ENABLE_GLOBAL_SURFACE = (!support.touch || support.mouseAndTouchPresent);\n\n\t    function touchDelta(touch1, touch2) {\n\t        var x1 = touch1.x.location,\n\t            y1 = touch1.y.location,\n\t            x2 = touch2.x.location,\n\t            y2 = touch2.y.location,\n\t            dx = x1 - x2,\n\t            dy = y1 - y2;\n\n\t        return {\n\t            center: {\n\t               x: (x1 + x2) / 2,\n\t               y: (y1 + y2) / 2\n\t            },\n\n\t            distance: Math.sqrt(dx*dx + dy*dy)\n\t        };\n\t    }\n\n\t    function getTouches(e) {\n\t        var touches = [],\n\t            originalEvent = e.originalEvent,\n\t            currentTarget = e.currentTarget,\n\t            idx = 0, length,\n\t            changedTouches,\n\t            touch;\n\n\t        if (e.api) {\n\t            touches.push({\n\t                id: 2,  // hardcoded ID for API call;\n\t                event: e,\n\t                target: e.target,\n\t                currentTarget: e.target,\n\t                location: e,\n\t                type: \"api\"\n\t            });\n\t        }\n\t        else if (e.type.match(/touch/)) {\n\t            changedTouches = originalEvent ? originalEvent.changedTouches : [];\n\t            for (length = changedTouches.length; idx < length; idx ++) {\n\t                touch = changedTouches[idx];\n\t                touches.push({\n\t                    location: touch,\n\t                    event: e,\n\t                    target: touch.target,\n\t                    currentTarget: currentTarget,\n\t                    id: touch.identifier,\n\t                    type: \"touch\"\n\t                });\n\t            }\n\t        }\n\t        else if (support.pointers || support.msPointers) {\n\t            touches.push({\n\t                location: originalEvent,\n\t                event: e,\n\t                target: e.target,\n\t                currentTarget: currentTarget,\n\t                id: originalEvent.pointerId,\n\t                type: \"pointer\"\n\t            });\n\t        } else {\n\t            touches.push({\n\t                id: 1, // hardcoded ID for mouse event;\n\t                event: e,\n\t                target: e.target,\n\t                currentTarget: currentTarget,\n\t                location: e,\n\t                type: \"mouse\"\n\t            });\n\t        }\n\n\t        return touches;\n\t    }\n\n\t    var TouchAxis = Class.extend({\n\t        init: function(axis, location) {\n\t            var that = this;\n\n\t            that.axis = axis;\n\n\t            that._updateLocationData(location);\n\n\t            that.startLocation = that.location;\n\t            that.velocity = that.delta = 0;\n\t            that.timeStamp = now();\n\t        },\n\n\t        move: function(location) {\n\t            var that = this,\n\t                offset = location[\"page\" + that.axis],\n\t                timeStamp = now(),\n\t                timeDelta = (timeStamp - that.timeStamp) || 1; // Firing manually events in tests can make this 0;\n\n\t            if (!offset && invalidZeroEvents) {\n\t                return;\n\t            }\n\n\t            that.delta = offset - that.location;\n\n\t            that._updateLocationData(location);\n\n\t            that.initialDelta = offset - that.startLocation;\n\t            that.velocity = that.delta / timeDelta;\n\t            that.timeStamp = timeStamp;\n\t        },\n\n\t        _updateLocationData: function(location) {\n\t            var that = this, axis = that.axis;\n\n\t            that.location = location[\"page\" + axis];\n\t            that.client = location[\"client\" + axis];\n\t            that.screen = location[\"screen\" + axis];\n\t        }\n\t    });\n\n\t    var Touch = Class.extend({\n\t        init: function(userEvents, target, touchInfo) {\n\t            extend(this, {\n\t                x: new TouchAxis(\"X\", touchInfo.location),\n\t                y: new TouchAxis(\"Y\", touchInfo.location),\n\t                type: touchInfo.type,\n\t                useClickAsTap: userEvents.useClickAsTap,\n\t                threshold: userEvents.threshold || THRESHOLD[touchInfo.type],\n\t                userEvents: userEvents,\n\t                target: target,\n\t                currentTarget: touchInfo.currentTarget,\n\t                initialTouch: touchInfo.target,\n\t                id: touchInfo.id,\n\t                pressEvent: touchInfo,\n\t                _clicks: userEvents._clicks,\n\t                supportDoubleTap: userEvents.supportDoubleTap,\n\t                _moved: false,\n\t                _finished: false\n\t            });\n\t        },\n\n\t        press: function() {\n\t            this._holdTimeout = setTimeout($.proxy(this, \"_hold\"), this.userEvents.minHold);\n\t            this._trigger(PRESS, this.pressEvent);\n\t        },\n\n\t        _tap: function(touchInfo) {\n\t            var that = this;\n\t            that.userEvents._clicks++;\n\t            if (that.userEvents._clicks == 1) {\n\t                that._clickTimeout = setTimeout(function() {\n\t                    if (that.userEvents._clicks == 1) {\n\t                        that._trigger(TAP, touchInfo);\n\t                    }\n\t                    else {\n\t                        that._trigger(DOUBLETAP, touchInfo);\n\t                    }\n\t                    that.userEvents._clicks = 0;\n\t                }, CLICK_DELAY);\n\t            }\n\t        },\n\n\t        _hold: function() {\n\t            this._trigger(HOLD, this.pressEvent);\n\t        },\n\n\t        move: function(touchInfo) {\n\t            var that = this;\n\n\t            if (that._finished) { return; }\n\n\t            that.x.move(touchInfo.location);\n\t            that.y.move(touchInfo.location);\n\n\t            if (!that._moved) {\n\t                if (that._withinIgnoreThreshold()) {\n\t                    return;\n\t                }\n\n\t                if (!UserEvents.current || UserEvents.current === that.userEvents) {\n\t                    that._start(touchInfo);\n\t                } else {\n\t                    return that.dispose();\n\t                }\n\t            }\n\n\t            // Event handlers may cancel the drag in the START event handler, hence the double check for pressed.\n\t            if (!that._finished) {\n\t                that._trigger(MOVE, touchInfo);\n\t            }\n\t        },\n\n\t        end: function(touchInfo) {\n\t            this.endTime = now();\n\n\t            if (this._finished) { return; }\n\n\t            // Mark the object as finished if there are blocking operations in the event handlers (alert/confirm)\n\t            this._finished = true;\n\n\t            this._trigger(RELEASE, touchInfo); // Release should be fired before TAP (as click is after mouseup/touchend)\n\n\t            if (this._moved) {\n\t                this._trigger(END, touchInfo);\n\t            } else {\n\t                if (!this.useClickAsTap) {\n\t                    if (this.supportDoubleTap) {\n\t                        this._tap(touchInfo);\n\t                    }\n\t                    else {\n\t                        this._trigger(TAP, touchInfo);\n\t                    }\n\t                }\n\t            }\n\n\t            clearTimeout(this._holdTimeout);\n\n\t            this.dispose();\n\t        },\n\n\t        dispose: function() {\n\t            var userEvents = this.userEvents,\n\t                activeTouches = userEvents.touches;\n\n\t            this._finished = true;\n\t            this.pressEvent = null;\n\t            clearTimeout(this._holdTimeout);\n\n\t            activeTouches.splice($.inArray(this, activeTouches), 1);\n\t        },\n\n\t        skip: function() {\n\t            this.dispose();\n\t        },\n\n\t        cancel: function() {\n\t            this.dispose();\n\t        },\n\n\t        isMoved: function() {\n\t            return this._moved;\n\t        },\n\n\t        _start: function(touchInfo) {\n\t            clearTimeout(this._holdTimeout);\n\n\t            this.startTime = now();\n\t            this._moved = true;\n\t            this._trigger(START, touchInfo);\n\t        },\n\n\t        _trigger: function(name, touchInfo) {\n\t            var that = this,\n\t                jQueryEvent = touchInfo.event,\n\t                data = {\n\t                    touch: that,\n\t                    x: that.x,\n\t                    y: that.y,\n\t                    target: that.target,\n\t                    event: jQueryEvent\n\t                };\n\n\t            if(that.userEvents.notify(name, data)) {\n\t                jQueryEvent.preventDefault();\n\t            }\n\t        },\n\n\t        _withinIgnoreThreshold: function() {\n\t            var xDelta = this.x.initialDelta,\n\t                yDelta = this.y.initialDelta;\n\n\t            return Math.sqrt(xDelta * xDelta + yDelta * yDelta) <= this.threshold;\n\t        }\n\t    });\n\n\t    function withEachUpEvent(callback) {\n\t        var downEvents = kendo.eventMap.up.split(\" \"),\n\t            idx = 0,\n\t            length = downEvents.length;\n\n\t        for(; idx < length; idx ++) {\n\t            callback(downEvents[idx]);\n\t        }\n\t    }\n\n\t    var UserEvents = Observable.extend({\n\t        init: function(element, options) {\n\t            var that = this,\n\t                filter,\n\t                ns = kendo.guid();\n\n\t            options = options || {};\n\t            filter = that.filter = options.filter;\n\t            that.threshold = options.threshold || DEFAULT_THRESHOLD;\n\t            that.minHold = options.minHold || DEFAULT_MIN_HOLD;\n\t            that.touches = [];\n\t            that._maxTouches = options.multiTouch ? 2 : 1;\n\t            that.allowSelection = options.allowSelection;\n\t            that.captureUpIfMoved = options.captureUpIfMoved;\n\t            that.useClickAsTap = !options.fastTap && !support.delayedClick();\n\t            that.eventNS = ns;\n\t            that._clicks = 0;\n\t            that.supportDoubleTap = options.supportDoubleTap;\n\n\t            element = $(element).handler(that);\n\t            Observable.fn.init.call(that);\n\n\t            extend(that, {\n\t                element: element,\n\t                // the touch events lock to the element anyway, so no need for the global setting\n\t                surface: options.global && ENABLE_GLOBAL_SURFACE ? $(element[0].ownerDocument.documentElement) : $(options.surface || element),\n\t                stopPropagation: options.stopPropagation,\n\t                pressed: false\n\t            });\n\n\t            that.surface.handler(that)\n\t                .on(kendo.applyEventMap(\"move\", ns), \"_move\")\n\t                .on(kendo.applyEventMap(\"up cancel\", ns), \"_end\");\n\n\t            element.on(kendo.applyEventMap(\"down\", ns), filter, \"_start\");\n\n\t            if (that.useClickAsTap) {\n\t                element.on(kendo.applyEventMap(\"click\", ns), filter, \"_click\");\n\t            }\n\n\t            if (support.pointers || support.msPointers) {\n\t                //touch-action:none will not work for IE10\n\t                if (support.browser.version < 11) {\n\t                    var defaultAction = \"pinch-zoom double-tap-zoom\";\n\t                    element.css(\"-ms-touch-action\", options.touchAction && options.touchAction != \"none\" ? defaultAction + \" \" + options.touchAction : defaultAction);\n\t                } else {\n\t                    element.css(\"touch-action\", options.touchAction || \"none\");\n\t                }\n\t            }\n\n\t            if (options.preventDragEvent) {\n\t                element.on(kendo.applyEventMap(\"dragstart\", ns), kendo.preventDefault);\n\t            }\n\n\t            element.on(kendo.applyEventMap(\"mousedown\", ns), filter, { root: element }, \"_select\");\n\n\t            if (that.captureUpIfMoved && support.eventCapture) {\n\t                var surfaceElement = that.surface[0],\n\t                    preventIfMovingProxy = $.proxy(that.preventIfMoving, that);\n\n\t                withEachUpEvent(function(eventName) {\n\t                    surfaceElement.addEventListener(eventName, preventIfMovingProxy, true);\n\t                });\n\t            }\n\n\t            that.bind([\n\t            PRESS,\n\t            HOLD,\n\t            TAP,\n\t            DOUBLETAP,\n\t            START,\n\t            MOVE,\n\t            END,\n\t            RELEASE,\n\t            CANCEL,\n\t            GESTURESTART,\n\t            GESTURECHANGE,\n\t            GESTUREEND,\n\t            GESTURETAP,\n\t            SELECT\n\t            ], options);\n\t        },\n\n\t        preventIfMoving: function(e) {\n\t            if (this._isMoved()) {\n\t                e.preventDefault();\n\t            }\n\t        },\n\n\t        destroy: function() {\n\t            var that = this;\n\n\t            if (that._destroyed) {\n\t                return;\n\t            }\n\n\t            that._destroyed = true;\n\n\t            if (that.captureUpIfMoved && support.eventCapture) {\n\t                var surfaceElement = that.surface[0];\n\t                withEachUpEvent(function(eventName) {\n\t                    surfaceElement.removeEventListener(eventName, that.preventIfMoving);\n\t                });\n\t            }\n\n\t            that.element.kendoDestroy(that.eventNS);\n\t            that.surface.kendoDestroy(that.eventNS);\n\t            that.element.removeData(\"handler\");\n\t            that.surface.removeData(\"handler\");\n\t            that._disposeAll();\n\n\t            that.unbind();\n\t            delete that.surface;\n\t            delete that.element;\n\t            delete that.currentTarget;\n\t        },\n\n\t        capture: function() {\n\t            UserEvents.current = this;\n\t        },\n\n\t        cancel: function() {\n\t            this._disposeAll();\n\t            this.trigger(CANCEL);\n\t        },\n\n\t        notify: function(eventName, data) {\n\t            var that = this,\n\t                touches = that.touches;\n\n\t            if (this._isMultiTouch()) {\n\t                switch(eventName) {\n\t                    case MOVE:\n\t                        eventName = GESTURECHANGE;\n\t                        break;\n\t                    case END:\n\t                        eventName = GESTUREEND;\n\t                        break;\n\t                    case TAP:\n\t                        eventName = GESTURETAP;\n\t                        break;\n\t                }\n\n\t                extend(data, {touches: touches}, touchDelta(touches[0], touches[1]));\n\t            }\n\n\t            return this.trigger(eventName, extend(data, {type: eventName}));\n\t        },\n\n\t        // API\n\t        press: function(x, y, target) {\n\t            this._apiCall(\"_start\", x, y, target);\n\t        },\n\n\t        move: function(x, y) {\n\t            this._apiCall(\"_move\", x, y);\n\t        },\n\n\t        end: function(x, y) {\n\t            this._apiCall(\"_end\", x, y);\n\t        },\n\n\t        _isMultiTouch: function() {\n\t            return this.touches.length > 1;\n\t        },\n\n\t        _maxTouchesReached: function() {\n\t            return this.touches.length >= this._maxTouches;\n\t        },\n\n\t        _disposeAll: function() {\n\t            var touches = this.touches;\n\t            while (touches.length > 0) {\n\t                touches.pop().dispose();\n\t            }\n\t        },\n\n\t        _isMoved: function() {\n\t            return $.grep(this.touches, function(touch) {\n\t                return touch.isMoved();\n\t            }).length;\n\t        },\n\n\t        _select: function(e) {\n\t           if (!this.allowSelection || this.trigger(SELECT, { event: e })) {\n\t               e.preventDefault();\n\t           }\n\t        },\n\n\t        _start: function(e) {\n\t            var that = this,\n\t                idx = 0,\n\t                filter = that.filter,\n\t                target,\n\t                touches = getTouches(e),\n\t                length = touches.length,\n\t                touch,\n\t                which = e.which;\n\n\t            if ((which && which > 1) || (that._maxTouchesReached())){\n\t                return;\n\t            }\n\n\t            UserEvents.current = null;\n\n\t            that.currentTarget = e.currentTarget;\n\n\t            if (that.stopPropagation) {\n\t                e.stopPropagation();\n\t            }\n\n\t            for (; idx < length; idx ++) {\n\t                if (that._maxTouchesReached()) {\n\t                    break;\n\t                }\n\n\t                touch = touches[idx];\n\n\t                if (filter) {\n\t                    target = $(touch.currentTarget); // target.is(filter) ? target : target.closest(filter, that.element);\n\t                } else {\n\t                    target = that.element;\n\t                }\n\n\t                if (!target.length) {\n\t                    continue;\n\t                }\n\n\t                touch = new Touch(that, target, touch);\n\t                that.touches.push(touch);\n\t                touch.press();\n\n\t                if (that._isMultiTouch()) {\n\t                    that.notify(\"gesturestart\", {});\n\t                }\n\t            }\n\t        },\n\n\t        _move: function(e) {\n\t            this._eachTouch(\"move\", e);\n\t        },\n\n\t        _end: function(e) {\n\t            this._eachTouch(\"end\", e);\n\t        },\n\n\t        _click: function(e) {\n\t            var data = {\n\t                touch: {\n\t                    initialTouch: e.target,\n\t                    target: $(e.currentTarget),\n\t                    endTime: now(),\n\t                    x: {\n\t                        location: e.pageX,\n\t                        client: e.clientX\n\t                    },\n\t                    y: {\n\t                        location: e.pageY,\n\t                        client: e.clientY\n\t                    }\n\t                },\n\t                x: e.pageX,\n\t                y: e.pageY,\n\t                target: $(e.currentTarget),\n\t                event: e,\n\t                type: \"tap\"\n\t            };\n\n\t            if (this.trigger(\"tap\", data)) {\n\t                e.preventDefault();\n\t            }\n\t        },\n\n\t        _eachTouch: function(methodName, e) {\n\t            var that = this,\n\t                dict = {},\n\t                touches = getTouches(e),\n\t                activeTouches = that.touches,\n\t                idx,\n\t                touch,\n\t                touchInfo,\n\t                matchingTouch;\n\n\t            for (idx = 0; idx < activeTouches.length; idx ++) {\n\t                touch = activeTouches[idx];\n\t                dict[touch.id] = touch;\n\t            }\n\n\t            for (idx = 0; idx < touches.length; idx ++) {\n\t                touchInfo = touches[idx];\n\t                matchingTouch = dict[touchInfo.id];\n\n\t                if (matchingTouch) {\n\t                    matchingTouch[methodName](touchInfo);\n\t                }\n\t            }\n\t        },\n\n\t        _apiCall: function(type, x, y, target) {\n\t            this[type]({\n\t                api: true,\n\t                pageX: x,\n\t                pageY: y,\n\t                clientX: x,\n\t                clientY: y,\n\t                target: $(target || this.element)[0],\n\t                stopPropagation: $.noop,\n\t                preventDefault: $.noop\n\t            });\n\t        }\n\t    });\n\n\t    UserEvents.defaultThreshold = function(value) {\n\t        DEFAULT_THRESHOLD = value;\n\t    };\n\n\t    UserEvents.minHold = function(value) {\n\t        DEFAULT_MIN_HOLD = value;\n\t    };\n\n\t    kendo.getTouches = getTouches;\n\t    kendo.touchDelta = touchDelta;\n\t    kendo.UserEvents = UserEvents;\n\t })(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOWEwZTQwZWQzYTUxYTkyMWUxOTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb2dyZXNzL2tlbmRvLXVpL2pzL2tlbmRvLnVzZXJldmVudHMuanM/ZTMxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuXG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyAwOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzUwKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJkZWZpbmUgY2Fubm90IGJlIHVzZWQgaW5kaXJlY3RcIik7IH07XHJcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTAwNDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2tlbmRvLmNvcmVcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMzUwOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyhmdW5jdGlvbihmLCBkZWZpbmUpe1xuXHQgICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gWyBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMDQpIF0sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/IChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXHR9KShmdW5jdGlvbigpe1xuXG5cdHZhciBfX21ldGFfXyA9IHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cdCAgICBpZDogXCJ1c2VyZXZlbnRzXCIsXG5cdCAgICBuYW1lOiBcIlVzZXIgRXZlbnRzXCIsXG5cdCAgICBjYXRlZ29yeTogXCJmcmFtZXdvcmtcIixcblx0ICAgIGRlcGVuZHM6IFsgXCJjb3JlXCIgXSxcblx0ICAgIGhpZGRlbjogdHJ1ZVxuXHR9O1xuXG5cdChmdW5jdGlvbiAoJCwgdW5kZWZpbmVkKSB7XG5cdCAgICB2YXIga2VuZG8gPSB3aW5kb3cua2VuZG8sXG5cdCAgICAgICAgc3VwcG9ydCA9IGtlbmRvLnN1cHBvcnQsXG5cdCAgICAgICAgQ2xhc3MgPSBrZW5kby5DbGFzcyxcblx0ICAgICAgICBPYnNlcnZhYmxlID0ga2VuZG8uT2JzZXJ2YWJsZSxcblx0ICAgICAgICBub3cgPSAkLm5vdyxcblx0ICAgICAgICBleHRlbmQgPSAkLmV4dGVuZCxcblx0ICAgICAgICBPUyA9IHN1cHBvcnQubW9iaWxlT1MsXG5cdCAgICAgICAgaW52YWxpZFplcm9FdmVudHMgPSBPUyAmJiBPUy5hbmRyb2lkLFxuXHQgICAgICAgIERFRkFVTFRfTUlOX0hPTEQgPSA4MDAsXG5cdCAgICAgICAgQ0xJQ0tfREVMQVkgPSAzMDAsXG5cdCAgICAgICAgREVGQVVMVF9USFJFU0hPTEQgPSBzdXBwb3J0LmJyb3dzZXIubXNpZSA/IDUgOiAwLCAvLyBXUDggYW5kIFc4IGFyZSB2ZXJ5IHNlbnNpdGl2ZSBhbmQgYWx3YXlzIHJlcG9ydCBtb3ZlLlxuXG5cdCAgICAgICAgLy8gVXNlckV2ZW50cyBldmVudHNcblx0ICAgICAgICBQUkVTUyA9IFwicHJlc3NcIixcblx0ICAgICAgICBIT0xEID0gXCJob2xkXCIsXG5cdCAgICAgICAgU0VMRUNUID0gXCJzZWxlY3RcIixcblx0ICAgICAgICBTVEFSVCA9IFwic3RhcnRcIixcblx0ICAgICAgICBNT1ZFID0gXCJtb3ZlXCIsXG5cdCAgICAgICAgRU5EID0gXCJlbmRcIixcblx0ICAgICAgICBDQU5DRUwgPSBcImNhbmNlbFwiLFxuXHQgICAgICAgIFRBUCA9IFwidGFwXCIsXG5cdCAgICAgICAgRE9VQkxFVEFQID0gXCJkb3VibGVUYXBcIixcblx0ICAgICAgICBSRUxFQVNFID0gXCJyZWxlYXNlXCIsXG5cdCAgICAgICAgR0VTVFVSRVNUQVJUID0gXCJnZXN0dXJlc3RhcnRcIixcblx0ICAgICAgICBHRVNUVVJFQ0hBTkdFID0gXCJnZXN0dXJlY2hhbmdlXCIsXG5cdCAgICAgICAgR0VTVFVSRUVORCA9IFwiZ2VzdHVyZWVuZFwiLFxuXHQgICAgICAgIEdFU1RVUkVUQVAgPSBcImdlc3R1cmV0YXBcIjtcblxuXHQgICAgdmFyIFRIUkVTSE9MRCA9IHtcblx0ICAgICAgICBcImFwaVwiOiAwLFxuXHQgICAgICAgIFwidG91Y2hcIjogMCxcblx0ICAgICAgICBcIm1vdXNlXCI6IDksXG5cdCAgICAgICAgXCJwb2ludGVyXCI6IDlcblx0ICAgIH07XG5cblx0ICAgIHZhciBFTkFCTEVfR0xPQkFMX1NVUkZBQ0UgPSAoIXN1cHBvcnQudG91Y2ggfHwgc3VwcG9ydC5tb3VzZUFuZFRvdWNoUHJlc2VudCk7XG5cblx0ICAgIGZ1bmN0aW9uIHRvdWNoRGVsdGEodG91Y2gxLCB0b3VjaDIpIHtcblx0ICAgICAgICB2YXIgeDEgPSB0b3VjaDEueC5sb2NhdGlvbixcblx0ICAgICAgICAgICAgeTEgPSB0b3VjaDEueS5sb2NhdGlvbixcblx0ICAgICAgICAgICAgeDIgPSB0b3VjaDIueC5sb2NhdGlvbixcblx0ICAgICAgICAgICAgeTIgPSB0b3VjaDIueS5sb2NhdGlvbixcblx0ICAgICAgICAgICAgZHggPSB4MSAtIHgyLFxuXHQgICAgICAgICAgICBkeSA9IHkxIC0geTI7XG5cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBjZW50ZXI6IHtcblx0ICAgICAgICAgICAgICAgeDogKHgxICsgeDIpIC8gMixcblx0ICAgICAgICAgICAgICAgeTogKHkxICsgeTIpIC8gMlxuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIGRpc3RhbmNlOiBNYXRoLnNxcnQoZHgqZHggKyBkeSpkeSlcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBnZXRUb3VjaGVzKGUpIHtcblx0ICAgICAgICB2YXIgdG91Y2hlcyA9IFtdLFxuXHQgICAgICAgICAgICBvcmlnaW5hbEV2ZW50ID0gZS5vcmlnaW5hbEV2ZW50LFxuXHQgICAgICAgICAgICBjdXJyZW50VGFyZ2V0ID0gZS5jdXJyZW50VGFyZ2V0LFxuXHQgICAgICAgICAgICBpZHggPSAwLCBsZW5ndGgsXG5cdCAgICAgICAgICAgIGNoYW5nZWRUb3VjaGVzLFxuXHQgICAgICAgICAgICB0b3VjaDtcblxuXHQgICAgICAgIGlmIChlLmFwaSkge1xuXHQgICAgICAgICAgICB0b3VjaGVzLnB1c2goe1xuXHQgICAgICAgICAgICAgICAgaWQ6IDIsICAvLyBoYXJkY29kZWQgSUQgZm9yIEFQSSBjYWxsO1xuXHQgICAgICAgICAgICAgICAgZXZlbnQ6IGUsXG5cdCAgICAgICAgICAgICAgICB0YXJnZXQ6IGUudGFyZ2V0LFxuXHQgICAgICAgICAgICAgICAgY3VycmVudFRhcmdldDogZS50YXJnZXQsXG5cdCAgICAgICAgICAgICAgICBsb2NhdGlvbjogZSxcblx0ICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBpXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGUudHlwZS5tYXRjaCgvdG91Y2gvKSkge1xuXHQgICAgICAgICAgICBjaGFuZ2VkVG91Y2hlcyA9IG9yaWdpbmFsRXZlbnQgPyBvcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzIDogW107XG5cdCAgICAgICAgICAgIGZvciAobGVuZ3RoID0gY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCArKykge1xuXHQgICAgICAgICAgICAgICAgdG91Y2ggPSBjaGFuZ2VkVG91Y2hlc1tpZHhdO1xuXHQgICAgICAgICAgICAgICAgdG91Y2hlcy5wdXNoKHtcblx0ICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogdG91Y2gsXG5cdCAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGUsXG5cdCAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0b3VjaC50YXJnZXQsXG5cdCAgICAgICAgICAgICAgICAgICAgY3VycmVudFRhcmdldDogY3VycmVudFRhcmdldCxcblx0ICAgICAgICAgICAgICAgICAgICBpZDogdG91Y2guaWRlbnRpZmllcixcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvdWNoXCJcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHN1cHBvcnQucG9pbnRlcnMgfHwgc3VwcG9ydC5tc1BvaW50ZXJzKSB7XG5cdCAgICAgICAgICAgIHRvdWNoZXMucHVzaCh7XG5cdCAgICAgICAgICAgICAgICBsb2NhdGlvbjogb3JpZ2luYWxFdmVudCxcblx0ICAgICAgICAgICAgICAgIGV2ZW50OiBlLFxuXHQgICAgICAgICAgICAgICAgdGFyZ2V0OiBlLnRhcmdldCxcblx0ICAgICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IGN1cnJlbnRUYXJnZXQsXG5cdCAgICAgICAgICAgICAgICBpZDogb3JpZ2luYWxFdmVudC5wb2ludGVySWQsXG5cdCAgICAgICAgICAgICAgICB0eXBlOiBcInBvaW50ZXJcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0b3VjaGVzLnB1c2goe1xuXHQgICAgICAgICAgICAgICAgaWQ6IDEsIC8vIGhhcmRjb2RlZCBJRCBmb3IgbW91c2UgZXZlbnQ7XG5cdCAgICAgICAgICAgICAgICBldmVudDogZSxcblx0ICAgICAgICAgICAgICAgIHRhcmdldDogZS50YXJnZXQsXG5cdCAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBjdXJyZW50VGFyZ2V0LFxuXHQgICAgICAgICAgICAgICAgbG9jYXRpb246IGUsXG5cdCAgICAgICAgICAgICAgICB0eXBlOiBcIm1vdXNlXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHRvdWNoZXM7XG5cdCAgICB9XG5cblx0ICAgIHZhciBUb3VjaEF4aXMgPSBDbGFzcy5leHRlbmQoe1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGF4aXMsIGxvY2F0aW9uKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuXHQgICAgICAgICAgICB0aGF0LmF4aXMgPSBheGlzO1xuXG5cdCAgICAgICAgICAgIHRoYXQuX3VwZGF0ZUxvY2F0aW9uRGF0YShsb2NhdGlvbik7XG5cblx0ICAgICAgICAgICAgdGhhdC5zdGFydExvY2F0aW9uID0gdGhhdC5sb2NhdGlvbjtcblx0ICAgICAgICAgICAgdGhhdC52ZWxvY2l0eSA9IHRoYXQuZGVsdGEgPSAwO1xuXHQgICAgICAgICAgICB0aGF0LnRpbWVTdGFtcCA9IG5vdygpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBtb3ZlOiBmdW5jdGlvbihsb2NhdGlvbikge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBvZmZzZXQgPSBsb2NhdGlvbltcInBhZ2VcIiArIHRoYXQuYXhpc10sXG5cdCAgICAgICAgICAgICAgICB0aW1lU3RhbXAgPSBub3coKSxcblx0ICAgICAgICAgICAgICAgIHRpbWVEZWx0YSA9ICh0aW1lU3RhbXAgLSB0aGF0LnRpbWVTdGFtcCkgfHwgMTsgLy8gRmlyaW5nIG1hbnVhbGx5IGV2ZW50cyBpbiB0ZXN0cyBjYW4gbWFrZSB0aGlzIDA7XG5cblx0ICAgICAgICAgICAgaWYgKCFvZmZzZXQgJiYgaW52YWxpZFplcm9FdmVudHMpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoYXQuZGVsdGEgPSBvZmZzZXQgLSB0aGF0LmxvY2F0aW9uO1xuXG5cdCAgICAgICAgICAgIHRoYXQuX3VwZGF0ZUxvY2F0aW9uRGF0YShsb2NhdGlvbik7XG5cblx0ICAgICAgICAgICAgdGhhdC5pbml0aWFsRGVsdGEgPSBvZmZzZXQgLSB0aGF0LnN0YXJ0TG9jYXRpb247XG5cdCAgICAgICAgICAgIHRoYXQudmVsb2NpdHkgPSB0aGF0LmRlbHRhIC8gdGltZURlbHRhO1xuXHQgICAgICAgICAgICB0aGF0LnRpbWVTdGFtcCA9IHRpbWVTdGFtcDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3VwZGF0ZUxvY2F0aW9uRGF0YTogZnVuY3Rpb24obG9jYXRpb24pIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLCBheGlzID0gdGhhdC5heGlzO1xuXG5cdCAgICAgICAgICAgIHRoYXQubG9jYXRpb24gPSBsb2NhdGlvbltcInBhZ2VcIiArIGF4aXNdO1xuXHQgICAgICAgICAgICB0aGF0LmNsaWVudCA9IGxvY2F0aW9uW1wiY2xpZW50XCIgKyBheGlzXTtcblx0ICAgICAgICAgICAgdGhhdC5zY3JlZW4gPSBsb2NhdGlvbltcInNjcmVlblwiICsgYXhpc107XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIHZhciBUb3VjaCA9IENsYXNzLmV4dGVuZCh7XG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24odXNlckV2ZW50cywgdGFyZ2V0LCB0b3VjaEluZm8pIHtcblx0ICAgICAgICAgICAgZXh0ZW5kKHRoaXMsIHtcblx0ICAgICAgICAgICAgICAgIHg6IG5ldyBUb3VjaEF4aXMoXCJYXCIsIHRvdWNoSW5mby5sb2NhdGlvbiksXG5cdCAgICAgICAgICAgICAgICB5OiBuZXcgVG91Y2hBeGlzKFwiWVwiLCB0b3VjaEluZm8ubG9jYXRpb24pLFxuXHQgICAgICAgICAgICAgICAgdHlwZTogdG91Y2hJbmZvLnR5cGUsXG5cdCAgICAgICAgICAgICAgICB1c2VDbGlja0FzVGFwOiB1c2VyRXZlbnRzLnVzZUNsaWNrQXNUYXAsXG5cdCAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IHVzZXJFdmVudHMudGhyZXNob2xkIHx8IFRIUkVTSE9MRFt0b3VjaEluZm8udHlwZV0sXG5cdCAgICAgICAgICAgICAgICB1c2VyRXZlbnRzOiB1c2VyRXZlbnRzLFxuXHQgICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG5cdCAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB0b3VjaEluZm8uY3VycmVudFRhcmdldCxcblx0ICAgICAgICAgICAgICAgIGluaXRpYWxUb3VjaDogdG91Y2hJbmZvLnRhcmdldCxcblx0ICAgICAgICAgICAgICAgIGlkOiB0b3VjaEluZm8uaWQsXG5cdCAgICAgICAgICAgICAgICBwcmVzc0V2ZW50OiB0b3VjaEluZm8sXG5cdCAgICAgICAgICAgICAgICBfY2xpY2tzOiB1c2VyRXZlbnRzLl9jbGlja3MsXG5cdCAgICAgICAgICAgICAgICBzdXBwb3J0RG91YmxlVGFwOiB1c2VyRXZlbnRzLnN1cHBvcnREb3VibGVUYXAsXG5cdCAgICAgICAgICAgICAgICBfbW92ZWQ6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgX2ZpbmlzaGVkOiBmYWxzZVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgcHJlc3M6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9ob2xkVGltZW91dCA9IHNldFRpbWVvdXQoJC5wcm94eSh0aGlzLCBcIl9ob2xkXCIpLCB0aGlzLnVzZXJFdmVudHMubWluSG9sZCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoUFJFU1MsIHRoaXMucHJlc3NFdmVudCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF90YXA6IGZ1bmN0aW9uKHRvdWNoSW5mbykge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cdCAgICAgICAgICAgIHRoYXQudXNlckV2ZW50cy5fY2xpY2tzKys7XG5cdCAgICAgICAgICAgIGlmICh0aGF0LnVzZXJFdmVudHMuX2NsaWNrcyA9PSAxKSB7XG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9jbGlja1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LnVzZXJFdmVudHMuX2NsaWNrcyA9PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3RyaWdnZXIoVEFQLCB0b3VjaEluZm8pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fdHJpZ2dlcihET1VCTEVUQVAsIHRvdWNoSW5mbyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQudXNlckV2ZW50cy5fY2xpY2tzID0gMDtcblx0ICAgICAgICAgICAgICAgIH0sIENMSUNLX0RFTEFZKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfaG9sZDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoSE9MRCwgdGhpcy5wcmVzc0V2ZW50KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgbW92ZTogZnVuY3Rpb24odG91Y2hJbmZvKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuXHQgICAgICAgICAgICBpZiAodGhhdC5fZmluaXNoZWQpIHsgcmV0dXJuOyB9XG5cblx0ICAgICAgICAgICAgdGhhdC54Lm1vdmUodG91Y2hJbmZvLmxvY2F0aW9uKTtcblx0ICAgICAgICAgICAgdGhhdC55Lm1vdmUodG91Y2hJbmZvLmxvY2F0aW9uKTtcblxuXHQgICAgICAgICAgICBpZiAoIXRoYXQuX21vdmVkKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhhdC5fd2l0aGluSWdub3JlVGhyZXNob2xkKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmICghVXNlckV2ZW50cy5jdXJyZW50IHx8IFVzZXJFdmVudHMuY3VycmVudCA9PT0gdGhhdC51c2VyRXZlbnRzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC5fc3RhcnQodG91Y2hJbmZvKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuZGlzcG9zZSgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gRXZlbnQgaGFuZGxlcnMgbWF5IGNhbmNlbCB0aGUgZHJhZyBpbiB0aGUgU1RBUlQgZXZlbnQgaGFuZGxlciwgaGVuY2UgdGhlIGRvdWJsZSBjaGVjayBmb3IgcHJlc3NlZC5cblx0ICAgICAgICAgICAgaWYgKCF0aGF0Ll9maW5pc2hlZCkge1xuXHQgICAgICAgICAgICAgICAgdGhhdC5fdHJpZ2dlcihNT1ZFLCB0b3VjaEluZm8pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGVuZDogZnVuY3Rpb24odG91Y2hJbmZvKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZW5kVGltZSA9IG5vdygpO1xuXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9maW5pc2hlZCkgeyByZXR1cm47IH1cblxuXHQgICAgICAgICAgICAvLyBNYXJrIHRoZSBvYmplY3QgYXMgZmluaXNoZWQgaWYgdGhlcmUgYXJlIGJsb2NraW5nIG9wZXJhdGlvbnMgaW4gdGhlIGV2ZW50IGhhbmRsZXJzIChhbGVydC9jb25maXJtKVxuXHQgICAgICAgICAgICB0aGlzLl9maW5pc2hlZCA9IHRydWU7XG5cblx0ICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcihSRUxFQVNFLCB0b3VjaEluZm8pOyAvLyBSZWxlYXNlIHNob3VsZCBiZSBmaXJlZCBiZWZvcmUgVEFQIChhcyBjbGljayBpcyBhZnRlciBtb3VzZXVwL3RvdWNoZW5kKVxuXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9tb3ZlZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcihFTkQsIHRvdWNoSW5mbyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoaXMudXNlQ2xpY2tBc1RhcCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1cHBvcnREb3VibGVUYXApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGFwKHRvdWNoSW5mbyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyKFRBUCwgdG91Y2hJbmZvKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXG5cdCAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIHVzZXJFdmVudHMgPSB0aGlzLnVzZXJFdmVudHMsXG5cdCAgICAgICAgICAgICAgICBhY3RpdmVUb3VjaGVzID0gdXNlckV2ZW50cy50b3VjaGVzO1xuXG5cdCAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgdGhpcy5wcmVzc0V2ZW50ID0gbnVsbDtcblx0ICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcblxuXHQgICAgICAgICAgICBhY3RpdmVUb3VjaGVzLnNwbGljZSgkLmluQXJyYXkodGhpcywgYWN0aXZlVG91Y2hlcyksIDEpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBza2lwOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBpc01vdmVkOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vdmVkO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfc3RhcnQ6IGZ1bmN0aW9uKHRvdWNoSW5mbykge1xuXHQgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xuXG5cdCAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbm93KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX21vdmVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcihTVEFSVCwgdG91Y2hJbmZvKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3RyaWdnZXI6IGZ1bmN0aW9uKG5hbWUsIHRvdWNoSW5mbykge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBqUXVlcnlFdmVudCA9IHRvdWNoSW5mby5ldmVudCxcblx0ICAgICAgICAgICAgICAgIGRhdGEgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdG91Y2g6IHRoYXQsXG5cdCAgICAgICAgICAgICAgICAgICAgeDogdGhhdC54LFxuXHQgICAgICAgICAgICAgICAgICAgIHk6IHRoYXQueSxcblx0ICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHRoYXQudGFyZ2V0LFxuXHQgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBqUXVlcnlFdmVudFxuXHQgICAgICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICBpZih0aGF0LnVzZXJFdmVudHMubm90aWZ5KG5hbWUsIGRhdGEpKSB7XG5cdCAgICAgICAgICAgICAgICBqUXVlcnlFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF93aXRoaW5JZ25vcmVUaHJlc2hvbGQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgeERlbHRhID0gdGhpcy54LmluaXRpYWxEZWx0YSxcblx0ICAgICAgICAgICAgICAgIHlEZWx0YSA9IHRoaXMueS5pbml0aWFsRGVsdGE7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4RGVsdGEgKiB4RGVsdGEgKyB5RGVsdGEgKiB5RGVsdGEpIDw9IHRoaXMudGhyZXNob2xkO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBmdW5jdGlvbiB3aXRoRWFjaFVwRXZlbnQoY2FsbGJhY2spIHtcblx0ICAgICAgICB2YXIgZG93bkV2ZW50cyA9IGtlbmRvLmV2ZW50TWFwLnVwLnNwbGl0KFwiIFwiKSxcblx0ICAgICAgICAgICAgaWR4ID0gMCxcblx0ICAgICAgICAgICAgbGVuZ3RoID0gZG93bkV2ZW50cy5sZW5ndGg7XG5cblx0ICAgICAgICBmb3IoOyBpZHggPCBsZW5ndGg7IGlkeCArKykge1xuXHQgICAgICAgICAgICBjYWxsYmFjayhkb3duRXZlbnRzW2lkeF0pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIFVzZXJFdmVudHMgPSBPYnNlcnZhYmxlLmV4dGVuZCh7XG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBmaWx0ZXIsXG5cdCAgICAgICAgICAgICAgICBucyA9IGtlbmRvLmd1aWQoKTtcblxuXHQgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0ICAgICAgICAgICAgZmlsdGVyID0gdGhhdC5maWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcblx0ICAgICAgICAgICAgdGhhdC50aHJlc2hvbGQgPSBvcHRpb25zLnRocmVzaG9sZCB8fCBERUZBVUxUX1RIUkVTSE9MRDtcblx0ICAgICAgICAgICAgdGhhdC5taW5Ib2xkID0gb3B0aW9ucy5taW5Ib2xkIHx8IERFRkFVTFRfTUlOX0hPTEQ7XG5cdCAgICAgICAgICAgIHRoYXQudG91Y2hlcyA9IFtdO1xuXHQgICAgICAgICAgICB0aGF0Ll9tYXhUb3VjaGVzID0gb3B0aW9ucy5tdWx0aVRvdWNoID8gMiA6IDE7XG5cdCAgICAgICAgICAgIHRoYXQuYWxsb3dTZWxlY3Rpb24gPSBvcHRpb25zLmFsbG93U2VsZWN0aW9uO1xuXHQgICAgICAgICAgICB0aGF0LmNhcHR1cmVVcElmTW92ZWQgPSBvcHRpb25zLmNhcHR1cmVVcElmTW92ZWQ7XG5cdCAgICAgICAgICAgIHRoYXQudXNlQ2xpY2tBc1RhcCA9ICFvcHRpb25zLmZhc3RUYXAgJiYgIXN1cHBvcnQuZGVsYXllZENsaWNrKCk7XG5cdCAgICAgICAgICAgIHRoYXQuZXZlbnROUyA9IG5zO1xuXHQgICAgICAgICAgICB0aGF0Ll9jbGlja3MgPSAwO1xuXHQgICAgICAgICAgICB0aGF0LnN1cHBvcnREb3VibGVUYXAgPSBvcHRpb25zLnN1cHBvcnREb3VibGVUYXA7XG5cblx0ICAgICAgICAgICAgZWxlbWVudCA9ICQoZWxlbWVudCkuaGFuZGxlcih0aGF0KTtcblx0ICAgICAgICAgICAgT2JzZXJ2YWJsZS5mbi5pbml0LmNhbGwodGhhdCk7XG5cblx0ICAgICAgICAgICAgZXh0ZW5kKHRoYXQsIHtcblx0ICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG5cdCAgICAgICAgICAgICAgICAvLyB0aGUgdG91Y2ggZXZlbnRzIGxvY2sgdG8gdGhlIGVsZW1lbnQgYW55d2F5LCBzbyBubyBuZWVkIGZvciB0aGUgZ2xvYmFsIHNldHRpbmdcblx0ICAgICAgICAgICAgICAgIHN1cmZhY2U6IG9wdGlvbnMuZ2xvYmFsICYmIEVOQUJMRV9HTE9CQUxfU1VSRkFDRSA/ICQoZWxlbWVudFswXS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkgOiAkKG9wdGlvbnMuc3VyZmFjZSB8fCBlbGVtZW50KSxcblx0ICAgICAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbjogb3B0aW9ucy5zdG9wUHJvcGFnYXRpb24sXG5cdCAgICAgICAgICAgICAgICBwcmVzc2VkOiBmYWxzZVxuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICB0aGF0LnN1cmZhY2UuaGFuZGxlcih0aGF0KVxuXHQgICAgICAgICAgICAgICAgLm9uKGtlbmRvLmFwcGx5RXZlbnRNYXAoXCJtb3ZlXCIsIG5zKSwgXCJfbW92ZVwiKVxuXHQgICAgICAgICAgICAgICAgLm9uKGtlbmRvLmFwcGx5RXZlbnRNYXAoXCJ1cCBjYW5jZWxcIiwgbnMpLCBcIl9lbmRcIik7XG5cblx0ICAgICAgICAgICAgZWxlbWVudC5vbihrZW5kby5hcHBseUV2ZW50TWFwKFwiZG93blwiLCBucyksIGZpbHRlciwgXCJfc3RhcnRcIik7XG5cblx0ICAgICAgICAgICAgaWYgKHRoYXQudXNlQ2xpY2tBc1RhcCkge1xuXHQgICAgICAgICAgICAgICAgZWxlbWVudC5vbihrZW5kby5hcHBseUV2ZW50TWFwKFwiY2xpY2tcIiwgbnMpLCBmaWx0ZXIsIFwiX2NsaWNrXCIpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHN1cHBvcnQucG9pbnRlcnMgfHwgc3VwcG9ydC5tc1BvaW50ZXJzKSB7XG5cdCAgICAgICAgICAgICAgICAvL3RvdWNoLWFjdGlvbjpub25lIHdpbGwgbm90IHdvcmsgZm9yIElFMTBcblx0ICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0LmJyb3dzZXIudmVyc2lvbiA8IDExKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRBY3Rpb24gPSBcInBpbmNoLXpvb20gZG91YmxlLXRhcC16b29tXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jc3MoXCItbXMtdG91Y2gtYWN0aW9uXCIsIG9wdGlvbnMudG91Y2hBY3Rpb24gJiYgb3B0aW9ucy50b3VjaEFjdGlvbiAhPSBcIm5vbmVcIiA/IGRlZmF1bHRBY3Rpb24gKyBcIiBcIiArIG9wdGlvbnMudG91Y2hBY3Rpb24gOiBkZWZhdWx0QWN0aW9uKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jc3MoXCJ0b3VjaC1hY3Rpb25cIiwgb3B0aW9ucy50b3VjaEFjdGlvbiB8fCBcIm5vbmVcIik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAob3B0aW9ucy5wcmV2ZW50RHJhZ0V2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICBlbGVtZW50Lm9uKGtlbmRvLmFwcGx5RXZlbnRNYXAoXCJkcmFnc3RhcnRcIiwgbnMpLCBrZW5kby5wcmV2ZW50RGVmYXVsdCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBlbGVtZW50Lm9uKGtlbmRvLmFwcGx5RXZlbnRNYXAoXCJtb3VzZWRvd25cIiwgbnMpLCBmaWx0ZXIsIHsgcm9vdDogZWxlbWVudCB9LCBcIl9zZWxlY3RcIik7XG5cblx0ICAgICAgICAgICAgaWYgKHRoYXQuY2FwdHVyZVVwSWZNb3ZlZCAmJiBzdXBwb3J0LmV2ZW50Q2FwdHVyZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHN1cmZhY2VFbGVtZW50ID0gdGhhdC5zdXJmYWNlWzBdLFxuXHQgICAgICAgICAgICAgICAgICAgIHByZXZlbnRJZk1vdmluZ1Byb3h5ID0gJC5wcm94eSh0aGF0LnByZXZlbnRJZk1vdmluZywgdGhhdCk7XG5cblx0ICAgICAgICAgICAgICAgIHdpdGhFYWNoVXBFdmVudChmdW5jdGlvbihldmVudE5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdXJmYWNlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgcHJldmVudElmTW92aW5nUHJveHksIHRydWUpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGF0LmJpbmQoW1xuXHQgICAgICAgICAgICBQUkVTUyxcblx0ICAgICAgICAgICAgSE9MRCxcblx0ICAgICAgICAgICAgVEFQLFxuXHQgICAgICAgICAgICBET1VCTEVUQVAsXG5cdCAgICAgICAgICAgIFNUQVJULFxuXHQgICAgICAgICAgICBNT1ZFLFxuXHQgICAgICAgICAgICBFTkQsXG5cdCAgICAgICAgICAgIFJFTEVBU0UsXG5cdCAgICAgICAgICAgIENBTkNFTCxcblx0ICAgICAgICAgICAgR0VTVFVSRVNUQVJULFxuXHQgICAgICAgICAgICBHRVNUVVJFQ0hBTkdFLFxuXHQgICAgICAgICAgICBHRVNUVVJFRU5ELFxuXHQgICAgICAgICAgICBHRVNUVVJFVEFQLFxuXHQgICAgICAgICAgICBTRUxFQ1Rcblx0ICAgICAgICAgICAgXSwgb3B0aW9ucyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHByZXZlbnRJZk1vdmluZzogZnVuY3Rpb24oZSkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5faXNNb3ZlZCgpKSB7XG5cdCAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuXHQgICAgICAgICAgICBpZiAodGhhdC5fZGVzdHJveWVkKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGF0Ll9kZXN0cm95ZWQgPSB0cnVlO1xuXG5cdCAgICAgICAgICAgIGlmICh0aGF0LmNhcHR1cmVVcElmTW92ZWQgJiYgc3VwcG9ydC5ldmVudENhcHR1cmUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzdXJmYWNlRWxlbWVudCA9IHRoYXQuc3VyZmFjZVswXTtcblx0ICAgICAgICAgICAgICAgIHdpdGhFYWNoVXBFdmVudChmdW5jdGlvbihldmVudE5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdXJmYWNlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdGhhdC5wcmV2ZW50SWZNb3ZpbmcpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGF0LmVsZW1lbnQua2VuZG9EZXN0cm95KHRoYXQuZXZlbnROUyk7XG5cdCAgICAgICAgICAgIHRoYXQuc3VyZmFjZS5rZW5kb0Rlc3Ryb3kodGhhdC5ldmVudE5TKTtcblx0ICAgICAgICAgICAgdGhhdC5lbGVtZW50LnJlbW92ZURhdGEoXCJoYW5kbGVyXCIpO1xuXHQgICAgICAgICAgICB0aGF0LnN1cmZhY2UucmVtb3ZlRGF0YShcImhhbmRsZXJcIik7XG5cdCAgICAgICAgICAgIHRoYXQuX2Rpc3Bvc2VBbGwoKTtcblxuXHQgICAgICAgICAgICB0aGF0LnVuYmluZCgpO1xuXHQgICAgICAgICAgICBkZWxldGUgdGhhdC5zdXJmYWNlO1xuXHQgICAgICAgICAgICBkZWxldGUgdGhhdC5lbGVtZW50O1xuXHQgICAgICAgICAgICBkZWxldGUgdGhhdC5jdXJyZW50VGFyZ2V0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjYXB0dXJlOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgVXNlckV2ZW50cy5jdXJyZW50ID0gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZGlzcG9zZUFsbCgpO1xuXHQgICAgICAgICAgICB0aGlzLnRyaWdnZXIoQ0FOQ0VMKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgbm90aWZ5OiBmdW5jdGlvbihldmVudE5hbWUsIGRhdGEpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgdG91Y2hlcyA9IHRoYXQudG91Y2hlcztcblxuXHQgICAgICAgICAgICBpZiAodGhpcy5faXNNdWx0aVRvdWNoKCkpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaChldmVudE5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIE1PVkU6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IEdFU1RVUkVDSEFOR0U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgRU5EOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUgPSBHRVNUVVJFRU5EO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIFRBUDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lID0gR0VTVFVSRVRBUDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGV4dGVuZChkYXRhLCB7dG91Y2hlczogdG91Y2hlc30sIHRvdWNoRGVsdGEodG91Y2hlc1swXSwgdG91Y2hlc1sxXSkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihldmVudE5hbWUsIGV4dGVuZChkYXRhLCB7dHlwZTogZXZlbnROYW1lfSkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvLyBBUElcblx0ICAgICAgICBwcmVzczogZnVuY3Rpb24oeCwgeSwgdGFyZ2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2FwaUNhbGwoXCJfc3RhcnRcIiwgeCwgeSwgdGFyZ2V0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgbW92ZTogZnVuY3Rpb24oeCwgeSkge1xuXHQgICAgICAgICAgICB0aGlzLl9hcGlDYWxsKFwiX21vdmVcIiwgeCwgeSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGVuZDogZnVuY3Rpb24oeCwgeSkge1xuXHQgICAgICAgICAgICB0aGlzLl9hcGlDYWxsKFwiX2VuZFwiLCB4LCB5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2lzTXVsdGlUb3VjaDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnRvdWNoZXMubGVuZ3RoID4gMTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX21heFRvdWNoZXNSZWFjaGVkOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudG91Y2hlcy5sZW5ndGggPj0gdGhpcy5fbWF4VG91Y2hlcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2Rpc3Bvc2VBbGw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgdG91Y2hlcyA9IHRoaXMudG91Y2hlcztcblx0ICAgICAgICAgICAgd2hpbGUgKHRvdWNoZXMubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgdG91Y2hlcy5wb3AoKS5kaXNwb3NlKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2lzTW92ZWQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gJC5ncmVwKHRoaXMudG91Y2hlcywgZnVuY3Rpb24odG91Y2gpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0b3VjaC5pc01vdmVkKCk7XG5cdCAgICAgICAgICAgIH0pLmxlbmd0aDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3NlbGVjdDogZnVuY3Rpb24oZSkge1xuXHQgICAgICAgICAgIGlmICghdGhpcy5hbGxvd1NlbGVjdGlvbiB8fCB0aGlzLnRyaWdnZXIoU0VMRUNULCB7IGV2ZW50OiBlIH0pKSB7XG5cdCAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblx0ICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9zdGFydDogZnVuY3Rpb24oZSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBpZHggPSAwLFxuXHQgICAgICAgICAgICAgICAgZmlsdGVyID0gdGhhdC5maWx0ZXIsXG5cdCAgICAgICAgICAgICAgICB0YXJnZXQsXG5cdCAgICAgICAgICAgICAgICB0b3VjaGVzID0gZ2V0VG91Y2hlcyhlKSxcblx0ICAgICAgICAgICAgICAgIGxlbmd0aCA9IHRvdWNoZXMubGVuZ3RoLFxuXHQgICAgICAgICAgICAgICAgdG91Y2gsXG5cdCAgICAgICAgICAgICAgICB3aGljaCA9IGUud2hpY2g7XG5cblx0ICAgICAgICAgICAgaWYgKCh3aGljaCAmJiB3aGljaCA+IDEpIHx8ICh0aGF0Ll9tYXhUb3VjaGVzUmVhY2hlZCgpKSl7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBVc2VyRXZlbnRzLmN1cnJlbnQgPSBudWxsO1xuXG5cdCAgICAgICAgICAgIHRoYXQuY3VycmVudFRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcblxuXHQgICAgICAgICAgICBpZiAodGhhdC5zdG9wUHJvcGFnYXRpb24pIHtcblx0ICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBmb3IgKDsgaWR4IDwgbGVuZ3RoOyBpZHggKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9tYXhUb3VjaGVzUmVhY2hlZCgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHRvdWNoID0gdG91Y2hlc1tpZHhdO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoZmlsdGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gJCh0b3VjaC5jdXJyZW50VGFyZ2V0KTsgLy8gdGFyZ2V0LmlzKGZpbHRlcikgPyB0YXJnZXQgOiB0YXJnZXQuY2xvc2VzdChmaWx0ZXIsIHRoYXQuZWxlbWVudCk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoYXQuZWxlbWVudDtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHRvdWNoID0gbmV3IFRvdWNoKHRoYXQsIHRhcmdldCwgdG91Y2gpO1xuXHQgICAgICAgICAgICAgICAgdGhhdC50b3VjaGVzLnB1c2godG91Y2gpO1xuXHQgICAgICAgICAgICAgICAgdG91Y2gucHJlc3MoKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHRoYXQuX2lzTXVsdGlUb3VjaCgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC5ub3RpZnkoXCJnZXN0dXJlc3RhcnRcIiwge30pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9tb3ZlOiBmdW5jdGlvbihlKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2VhY2hUb3VjaChcIm1vdmVcIiwgZSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9lbmQ6IGZ1bmN0aW9uKGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZWFjaFRvdWNoKFwiZW5kXCIsIGUpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfY2xpY2s6IGZ1bmN0aW9uKGUpIHtcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG5cdCAgICAgICAgICAgICAgICB0b3VjaDoge1xuXHQgICAgICAgICAgICAgICAgICAgIGluaXRpYWxUb3VjaDogZS50YXJnZXQsXG5cdCAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiAkKGUuY3VycmVudFRhcmdldCksXG5cdCAgICAgICAgICAgICAgICAgICAgZW5kVGltZTogbm93KCksXG5cdCAgICAgICAgICAgICAgICAgICAgeDoge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbjogZS5wYWdlWCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50OiBlLmNsaWVudFhcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIHk6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGUucGFnZVksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudDogZS5jbGllbnRZXG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIHg6IGUucGFnZVgsXG5cdCAgICAgICAgICAgICAgICB5OiBlLnBhZ2VZLFxuXHQgICAgICAgICAgICAgICAgdGFyZ2V0OiAkKGUuY3VycmVudFRhcmdldCksXG5cdCAgICAgICAgICAgICAgICBldmVudDogZSxcblx0ICAgICAgICAgICAgICAgIHR5cGU6IFwidGFwXCJcblx0ICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICBpZiAodGhpcy50cmlnZ2VyKFwidGFwXCIsIGRhdGEpKSB7XG5cdCAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2VhY2hUb3VjaDogZnVuY3Rpb24obWV0aG9kTmFtZSwgZSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBkaWN0ID0ge30sXG5cdCAgICAgICAgICAgICAgICB0b3VjaGVzID0gZ2V0VG91Y2hlcyhlKSxcblx0ICAgICAgICAgICAgICAgIGFjdGl2ZVRvdWNoZXMgPSB0aGF0LnRvdWNoZXMsXG5cdCAgICAgICAgICAgICAgICBpZHgsXG5cdCAgICAgICAgICAgICAgICB0b3VjaCxcblx0ICAgICAgICAgICAgICAgIHRvdWNoSW5mbyxcblx0ICAgICAgICAgICAgICAgIG1hdGNoaW5nVG91Y2g7XG5cblx0ICAgICAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBhY3RpdmVUb3VjaGVzLmxlbmd0aDsgaWR4ICsrKSB7XG5cdCAgICAgICAgICAgICAgICB0b3VjaCA9IGFjdGl2ZVRvdWNoZXNbaWR4XTtcblx0ICAgICAgICAgICAgICAgIGRpY3RbdG91Y2guaWRdID0gdG91Y2g7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IHRvdWNoZXMubGVuZ3RoOyBpZHggKyspIHtcblx0ICAgICAgICAgICAgICAgIHRvdWNoSW5mbyA9IHRvdWNoZXNbaWR4XTtcblx0ICAgICAgICAgICAgICAgIG1hdGNoaW5nVG91Y2ggPSBkaWN0W3RvdWNoSW5mby5pZF07XG5cblx0ICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZ1RvdWNoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbWF0Y2hpbmdUb3VjaFttZXRob2ROYW1lXSh0b3VjaEluZm8pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9hcGlDYWxsOiBmdW5jdGlvbih0eXBlLCB4LCB5LCB0YXJnZXQpIHtcblx0ICAgICAgICAgICAgdGhpc1t0eXBlXSh7XG5cdCAgICAgICAgICAgICAgICBhcGk6IHRydWUsXG5cdCAgICAgICAgICAgICAgICBwYWdlWDogeCxcblx0ICAgICAgICAgICAgICAgIHBhZ2VZOiB5LFxuXHQgICAgICAgICAgICAgICAgY2xpZW50WDogeCxcblx0ICAgICAgICAgICAgICAgIGNsaWVudFk6IHksXG5cdCAgICAgICAgICAgICAgICB0YXJnZXQ6ICQodGFyZ2V0IHx8IHRoaXMuZWxlbWVudClbMF0sXG5cdCAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246ICQubm9vcCxcblx0ICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiAkLm5vb3Bcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIFVzZXJFdmVudHMuZGVmYXVsdFRocmVzaG9sZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgREVGQVVMVF9USFJFU0hPTEQgPSB2YWx1ZTtcblx0ICAgIH07XG5cblx0ICAgIFVzZXJFdmVudHMubWluSG9sZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgREVGQVVMVF9NSU5fSE9MRCA9IHZhbHVlO1xuXHQgICAgfTtcblxuXHQgICAga2VuZG8uZ2V0VG91Y2hlcyA9IGdldFRvdWNoZXM7XG5cdCAgICBrZW5kby50b3VjaERlbHRhID0gdG91Y2hEZWx0YTtcblx0ICAgIGtlbmRvLlVzZXJFdmVudHMgPSBVc2VyRXZlbnRzO1xuXHQgfSkod2luZG93LmtlbmRvLmpRdWVyeSk7XG5cblx0cmV0dXJuIHdpbmRvdy5rZW5kbztcblxuXHR9LCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyB9KTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9a0e40ed3a51a921e191\n");

/***/ }),

/***/ "b4c182ea2e2a8af62a4a":
/*!*****************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.draganddrop.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1123);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 1004:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.core */ \"46d3985e259824d97676\");\n\n/***/ }),\n\n/***/ 1038:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.userevents */ \"9a0e40ed3a51a921e191\");\n\n/***/ }),\n\n/***/ 1123:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1004), __webpack_require__(1038) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\tvar __meta__ = { // jshint ignore:line\r\n\t    id: \"draganddrop\",\r\n\t    name: \"Drag & drop\",\r\n\t    category: \"framework\",\r\n\t    description: \"Drag & drop functionality for any DOM element.\",\r\n\t    depends: [ \"core\", \"userevents\" ]\r\n\t};\r\n\r\n\t(function ($, undefined) {\r\n\t    var kendo = window.kendo,\r\n\t        support = kendo.support,\r\n\t        document = window.document,\r\n\t        $window = $(window),\r\n\t        Class = kendo.Class,\r\n\t        Widget = kendo.ui.Widget,\r\n\t        Observable = kendo.Observable,\r\n\t        UserEvents = kendo.UserEvents,\r\n\t        proxy = $.proxy,\r\n\t        extend = $.extend,\r\n\t        getOffset = kendo.getOffset,\r\n\t        draggables = {},\r\n\t        dropTargets = {},\r\n\t        dropAreas = {},\r\n\t        lastDropTarget,\r\n\t        elementUnderCursor = kendo.elementUnderCursor,\r\n\t        KEYUP = \"keyup\",\r\n\t        CHANGE = \"change\",\r\n\r\n\t        // Draggable events\r\n\t        DRAGSTART = \"dragstart\",\r\n\t        HOLD = \"hold\",\r\n\t        DRAG = \"drag\",\r\n\t        DRAGEND = \"dragend\",\r\n\t        DRAGCANCEL = \"dragcancel\",\r\n\t        HINTDESTROYED = \"hintDestroyed\",\r\n\r\n\t        // DropTarget events\r\n\t        DRAGENTER = \"dragenter\",\r\n\t        DRAGLEAVE = \"dragleave\",\r\n\t        DROP = \"drop\";\r\n\r\n\t    function contains(parent, child) {\r\n\t        try {\r\n\t            return $.contains(parent, child) || parent == child;\r\n\t        } catch (e) {\r\n\t            return false;\r\n\t        }\r\n\t    }\r\n\r\n\t    function numericCssPropery(element, property) {\r\n\t        return parseInt(element.css(property), 10) || 0;\r\n\t    }\r\n\r\n\t    function within(value, range) {\r\n\t        return Math.min(Math.max(value, range.min), range.max);\r\n\t    }\r\n\r\n\t    function containerBoundaries(container, element) {\r\n\t        var offset = getOffset(container),\r\n\t            outerWidth = kendo._outerWidth,\r\n\t            outerHeight = kendo._outerHeight,\r\n\t            minX = offset.left + numericCssPropery(container, \"borderLeftWidth\") + numericCssPropery(container, \"paddingLeft\"),\r\n\t            minY = offset.top + numericCssPropery(container, \"borderTopWidth\") + numericCssPropery(container, \"paddingTop\"),\r\n\t            maxX = minX + container.width() - outerWidth(element, true),\r\n\t            maxY = minY + container.height() - outerHeight(element, true);\r\n\r\n\t        return {\r\n\t            x: { min: minX, max: maxX },\r\n\t            y: { min: minY, max: maxY }\r\n\t        };\r\n\t    }\r\n\r\n\t    function checkTarget(target, targets, areas) {\r\n\t        var theTarget, theFilter, i = 0,\r\n\t            targetLen = targets && targets.length,\r\n\t            areaLen = areas && areas.length;\r\n\r\n\t        while (target && target.parentNode) {\r\n\t            for (i = 0; i < targetLen; i ++) {\r\n\t                theTarget = targets[i];\r\n\t                if (theTarget.element[0] === target) {\r\n\t                    return { target: theTarget, targetElement: target };\r\n\t                }\r\n\t            }\r\n\r\n\t            for (i = 0; i < areaLen; i ++) {\r\n\t                theFilter = areas[i];\r\n\t                if ($.contains(theFilter.element[0], target) && support.matchesSelector.call(target, theFilter.options.filter)) {\r\n\t                    return { target: theFilter, targetElement: target };\r\n\t                }\r\n\t            }\r\n\r\n\t            target = target.parentNode;\r\n\t        }\r\n\r\n\t        return undefined;\r\n\t    }\r\n\r\n\t    var TapCapture = Observable.extend({\r\n\t        init: function(element, options) {\r\n\t            var that = this,\r\n\t                domElement = element[0];\r\n\r\n\t            that.capture = false;\r\n\r\n\t            if (domElement.addEventListener) {\r\n\t                $.each(kendo.eventMap.down.split(\" \"), function() {\r\n\t                    domElement.addEventListener(this, proxy(that._press, that), true);\r\n\t                });\r\n\t                $.each(kendo.eventMap.up.split(\" \"), function() {\r\n\t                    domElement.addEventListener(this, proxy(that._release, that), true);\r\n\t                });\r\n\t            } else {\r\n\t                $.each(kendo.eventMap.down.split(\" \"), function() {\r\n\t                    domElement.attachEvent(this, proxy(that._press, that));\r\n\t                });\r\n\t                $.each(kendo.eventMap.up.split(\" \"), function() {\r\n\t                    domElement.attachEvent(this, proxy(that._release, that));\r\n\t                });\r\n\t            }\r\n\r\n\t            Observable.fn.init.call(that);\r\n\r\n\t            that.bind([\"press\", \"release\"], options || {});\r\n\t        },\r\n\r\n\t        captureNext: function() {\r\n\t            this.capture = true;\r\n\t        },\r\n\r\n\t        cancelCapture: function() {\r\n\t            this.capture = false;\r\n\t        },\r\n\r\n\t        _press: function(e) {\r\n\t            var that = this;\r\n\t            that.trigger(\"press\");\r\n\t            if (that.capture) {\r\n\t                e.preventDefault();\r\n\t            }\r\n\t        },\r\n\r\n\t        _release: function(e) {\r\n\t            var that = this;\r\n\t            that.trigger(\"release\");\r\n\r\n\t            if (that.capture) {\r\n\t                e.preventDefault();\r\n\t                that.cancelCapture();\r\n\t            }\r\n\t        }\r\n\t    });\r\n\r\n\t    var PaneDimension = Observable.extend({\r\n\t        init: function(options) {\r\n\t            var that = this;\r\n\t            Observable.fn.init.call(that);\r\n\r\n\t            that.forcedEnabled = false;\r\n\r\n\t            $.extend(that, options);\r\n\r\n\t            that.scale = 1;\r\n\r\n\t            if (that.horizontal) {\r\n\t                that.measure = \"offsetWidth\";\r\n\t                that.scrollSize = \"scrollWidth\";\r\n\t                that.axis = \"x\";\r\n\t            } else {\r\n\t                that.measure = \"offsetHeight\";\r\n\t                that.scrollSize = \"scrollHeight\";\r\n\t                that.axis = \"y\";\r\n\t            }\r\n\t        },\r\n\r\n\t        makeVirtual: function() {\r\n\t            $.extend(this, {\r\n\t                virtual: true,\r\n\t                forcedEnabled: true,\r\n\t                _virtualMin: 0,\r\n\t                _virtualMax: 0\r\n\t            });\r\n\t        },\r\n\r\n\t        virtualSize: function(min, max) {\r\n\t            if (this._virtualMin !== min || this._virtualMax !== max) {\r\n\t                this._virtualMin = min;\r\n\t                this._virtualMax = max;\r\n\t                this.update();\r\n\t            }\r\n\t        },\r\n\r\n\t        outOfBounds: function(offset) {\r\n\t            return offset > this.max || offset < this.min;\r\n\t        },\r\n\r\n\t        forceEnabled: function() {\r\n\t            this.forcedEnabled = true;\r\n\t        },\r\n\r\n\t        getSize: function() {\r\n\t            return this.container[0][this.measure];\r\n\t        },\r\n\r\n\t        getTotal: function() {\r\n\t            return this.element[0][this.scrollSize];\r\n\t        },\r\n\r\n\t        rescale: function(scale) {\r\n\t            this.scale = scale;\r\n\t        },\r\n\r\n\t        update: function(silent) {\r\n\t            var that = this,\r\n\t                total = that.virtual ? that._virtualMax : that.getTotal(),\r\n\t                scaledTotal = total * that.scale,\r\n\t                size = that.getSize();\r\n\r\n\t            if (total === 0 && !that.forcedEnabled) {\r\n\t                return; // we are not visible.\r\n\t            }\r\n\r\n\t            that.max = that.virtual ? -that._virtualMin : 0;\r\n\t            that.size = size;\r\n\t            that.total = scaledTotal;\r\n\t            that.min = Math.min(that.max, size - scaledTotal);\r\n\t            that.minScale = size / total;\r\n\t            that.centerOffset = (scaledTotal - size) / 2;\r\n\r\n\t            that.enabled = that.forcedEnabled || (scaledTotal > size);\r\n\r\n\t            if (!silent) {\r\n\t                that.trigger(CHANGE, that);\r\n\t            }\r\n\t        }\r\n\t    });\r\n\r\n\t    var PaneDimensions = Observable.extend({\r\n\t        init: function(options) {\r\n\t            var that = this;\r\n\r\n\t            Observable.fn.init.call(that);\r\n\r\n\t            that.x = new PaneDimension(extend({horizontal: true}, options));\r\n\t            that.y = new PaneDimension(extend({horizontal: false}, options));\r\n\t            that.container = options.container;\r\n\t            that.forcedMinScale = options.minScale;\r\n\t            that.maxScale = options.maxScale || 100;\r\n\r\n\t            that.bind(CHANGE, options);\r\n\t        },\r\n\r\n\t        rescale: function(newScale) {\r\n\t            this.x.rescale(newScale);\r\n\t            this.y.rescale(newScale);\r\n\t            this.refresh();\r\n\t        },\r\n\r\n\t        centerCoordinates: function() {\r\n\t            return { x: Math.min(0, -this.x.centerOffset), y: Math.min(0, -this.y.centerOffset) };\r\n\t        },\r\n\r\n\t        refresh: function() {\r\n\t            var that = this;\r\n\t            that.x.update();\r\n\t            that.y.update();\r\n\t            that.enabled = that.x.enabled || that.y.enabled;\r\n\t            that.minScale = that.forcedMinScale || Math.min(that.x.minScale, that.y.minScale);\r\n\t            that.fitScale = Math.max(that.x.minScale, that.y.minScale);\r\n\t            that.trigger(CHANGE);\r\n\t        }\r\n\t    });\r\n\r\n\t    var PaneAxis = Observable.extend({\r\n\t        init: function(options) {\r\n\t            var that = this;\r\n\t            extend(that, options);\r\n\t            Observable.fn.init.call(that);\r\n\t        },\r\n\r\n\t        outOfBounds: function() {\r\n\t            return this.dimension.outOfBounds(this.movable[this.axis]);\r\n\t        },\r\n\r\n\t        dragMove: function(delta) {\r\n\t            var that = this,\r\n\t                dimension = that.dimension,\r\n\t                axis = that.axis,\r\n\t                movable = that.movable,\r\n\t                position = movable[axis] + delta;\r\n\r\n\t            if (!dimension.enabled) {\r\n\t                return;\r\n\t            }\r\n\r\n\t            if ((position < dimension.min && delta < 0) || (position > dimension.max && delta > 0)) {\r\n\t                delta *= that.resistance;\r\n\t            }\r\n\r\n\t            movable.translateAxis(axis, delta);\r\n\t            that.trigger(CHANGE, that);\r\n\t        }\r\n\t    });\r\n\r\n\t    var Pane = Class.extend({\r\n\r\n\t        init: function(options) {\r\n\t            var that = this,\r\n\t                x,\r\n\t                y,\r\n\t                resistance,\r\n\t                movable;\r\n\r\n\t            extend(that, {elastic: true}, options);\r\n\r\n\t            resistance = that.elastic ? 0.5 : 0;\r\n\t            movable = that.movable;\r\n\r\n\t            that.x = x = new PaneAxis({\r\n\t                axis: \"x\",\r\n\t                dimension: that.dimensions.x,\r\n\t                resistance: resistance,\r\n\t                movable: movable\r\n\t            });\r\n\r\n\t            that.y = y = new PaneAxis({\r\n\t                axis: \"y\",\r\n\t                dimension: that.dimensions.y,\r\n\t                resistance: resistance,\r\n\t                movable: movable\r\n\t            });\r\n\r\n\t            that.userEvents.bind([\"press\", \"move\", \"end\", \"gesturestart\", \"gesturechange\"], {\r\n\t                gesturestart: function(e) {\r\n\t                    that.gesture = e;\r\n\t                    that.offset = that.dimensions.container.offset();\r\n\t                },\r\n\r\n\t                press: function(e) {\r\n\t                    if ($(e.event.target).closest(\"a\").is(\"[data-navigate-on-press=true]\")) {\r\n\t                        e.sender.cancel();\r\n\t                    }\r\n\t                },\r\n\r\n\t                gesturechange: function(e) {\r\n\t                    var previousGesture = that.gesture,\r\n\t                        previousCenter = previousGesture.center,\r\n\r\n\t                        center = e.center,\r\n\r\n\t                        scaleDelta = e.distance / previousGesture.distance,\r\n\r\n\t                        minScale = that.dimensions.minScale,\r\n\t                        maxScale = that.dimensions.maxScale,\r\n\t                        coordinates;\r\n\r\n\t                    if (movable.scale <= minScale && scaleDelta < 1) {\r\n\t                        // Resist shrinking. Instead of shrinking from 1 to 0.5, it will shrink to 0.5 + (1 /* minScale */ - 0.5) * 0.8 = 0.9;\r\n\t                        scaleDelta += (1 - scaleDelta) * 0.8;\r\n\t                    }\r\n\r\n\t                    if (movable.scale * scaleDelta >= maxScale) {\r\n\t                        scaleDelta = maxScale / movable.scale;\r\n\t                    }\r\n\r\n\t                    var offsetX = movable.x + that.offset.left,\r\n\t                        offsetY = movable.y + that.offset.top;\r\n\r\n\t                    coordinates = {\r\n\t                        x: (offsetX - previousCenter.x) * scaleDelta + center.x - offsetX,\r\n\t                        y: (offsetY - previousCenter.y) * scaleDelta + center.y - offsetY\r\n\t                    };\r\n\r\n\t                    movable.scaleWith(scaleDelta);\r\n\r\n\t                    x.dragMove(coordinates.x);\r\n\t                    y.dragMove(coordinates.y);\r\n\r\n\t                    that.dimensions.rescale(movable.scale);\r\n\t                    that.gesture = e;\r\n\t                    e.preventDefault();\r\n\t                },\r\n\r\n\t                move: function(e) {\r\n\t                    if (e.event.target.tagName.match(/textarea|input/i)) {\r\n\t                        return;\r\n\t                    }\r\n\r\n\t                    if (x.dimension.enabled || y.dimension.enabled) {\r\n\t                        x.dragMove(e.x.delta);\r\n\t                        y.dragMove(e.y.delta);\r\n\t                        e.preventDefault();\r\n\t                    } else {\r\n\t                        e.touch.skip();\r\n\t                    }\r\n\t                },\r\n\r\n\t                end: function(e) {\r\n\t                    e.preventDefault();\r\n\t                }\r\n\t            });\r\n\t        }\r\n\t    });\r\n\r\n\t    var TRANSFORM_STYLE = support.transitions.prefix + \"Transform\",\r\n\t        translate;\r\n\r\n\r\n\t    if (support.hasHW3D) {\r\n\t        translate = function(x, y, scale) {\r\n\t            return \"translate3d(\" + x + \"px,\" + y +\"px,0) scale(\" + scale + \")\";\r\n\t        };\r\n\t    } else {\r\n\t        translate = function(x, y, scale) {\r\n\t            return \"translate(\" + x + \"px,\" + y +\"px) scale(\" + scale + \")\";\r\n\t        };\r\n\t    }\r\n\r\n\t    var Movable = Observable.extend({\r\n\t        init: function(element) {\r\n\t            var that = this;\r\n\r\n\t            Observable.fn.init.call(that);\r\n\r\n\t            that.element = $(element);\r\n\t            that.element[0].style.webkitTransformOrigin = \"left top\";\r\n\t            that.x = 0;\r\n\t            that.y = 0;\r\n\t            that.scale = 1;\r\n\t            that._saveCoordinates(translate(that.x, that.y, that.scale));\r\n\t        },\r\n\r\n\t        translateAxis: function(axis, by) {\r\n\t            this[axis] += by;\r\n\t            this.refresh();\r\n\t        },\r\n\r\n\t        scaleTo: function(scale) {\r\n\t            this.scale = scale;\r\n\t            this.refresh();\r\n\t        },\r\n\r\n\t        scaleWith: function(scaleDelta) {\r\n\t            this.scale *= scaleDelta;\r\n\t            this.refresh();\r\n\t        },\r\n\r\n\t        translate: function(coordinates) {\r\n\t            this.x += coordinates.x;\r\n\t            this.y += coordinates.y;\r\n\t            this.refresh();\r\n\t        },\r\n\r\n\t        moveAxis: function(axis, value) {\r\n\t            this[axis] = value;\r\n\t            this.refresh();\r\n\t        },\r\n\r\n\t        moveTo: function(coordinates) {\r\n\t            extend(this, coordinates);\r\n\t            this.refresh();\r\n\t        },\r\n\r\n\t        refresh: function() {\r\n\t            var that = this,\r\n\t                x = that.x,\r\n\t                y = that.y,\r\n\t                newCoordinates;\r\n\r\n\t            if (that.round) {\r\n\t                x = Math.round(x);\r\n\t                y = Math.round(y);\r\n\t            }\r\n\r\n\t            newCoordinates = translate(x, y, that.scale);\r\n\r\n\t            if (newCoordinates != that.coordinates) {\r\n\t                if (kendo.support.browser.msie && kendo.support.browser.version < 10) {\r\n\t                    that.element[0].style.position = \"absolute\";\r\n\t                    that.element[0].style.left = that.x + \"px\";\r\n\t                    that.element[0].style.top = that.y + \"px\";\r\n\r\n\t                } else {\r\n\t                    that.element[0].style[TRANSFORM_STYLE] = newCoordinates;\r\n\t                }\r\n\t                that._saveCoordinates(newCoordinates);\r\n\t                that.trigger(CHANGE);\r\n\t            }\r\n\t        },\r\n\r\n\t        _saveCoordinates: function(coordinates) {\r\n\t            this.coordinates = coordinates;\r\n\t        }\r\n\t    });\r\n\r\n\t    function destroyDroppable(collection, widget) {\r\n\t        var groupName = widget.options.group,\r\n\t        droppables = collection[groupName],\r\n\t        i;\r\n\r\n\t        Widget.fn.destroy.call(widget);\r\n\r\n\t        if (droppables.length > 1) {\r\n\t            for (i = 0; i < droppables.length; i++) {\r\n\t                if (droppables[i] == widget) {\r\n\t                    droppables.splice(i, 1);\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t        } else {\r\n\t            droppables.length = 0; // WTF, porting this from the previous destroyGroup\r\n\t            delete collection[groupName];\r\n\t        }\r\n\t    }\r\n\r\n\t    var DropTarget = Widget.extend({\r\n\t        init: function(element, options) {\r\n\t            var that = this;\r\n\r\n\t            Widget.fn.init.call(that, element, options);\r\n\r\n\t            var group = that.options.group;\r\n\r\n\t            if (!(group in dropTargets)) {\r\n\t                dropTargets[group] = [ that ];\r\n\t            } else {\r\n\t                dropTargets[group].push( that );\r\n\t            }\r\n\t        },\r\n\r\n\t        events: [\r\n\t            DRAGENTER,\r\n\t            DRAGLEAVE,\r\n\t            DROP\r\n\t        ],\r\n\r\n\t        options: {\r\n\t            name: \"DropTarget\",\r\n\t            group: \"default\"\r\n\t        },\r\n\r\n\t        destroy: function() {\r\n\t            destroyDroppable(dropTargets, this);\r\n\t        },\r\n\r\n\t        _trigger: function(eventName, e) {\r\n\t            var that = this,\r\n\t                draggable = draggables[that.options.group];\r\n\r\n\t            if (draggable) {\r\n\t                return that.trigger(eventName, extend({}, e.event, {\r\n\t                           draggable: draggable,\r\n\t                           dropTarget: e.dropTarget\r\n\t                       }));\r\n\t            }\r\n\t        },\r\n\r\n\t        _over: function(e) {\r\n\t            this._trigger(DRAGENTER, e);\r\n\t        },\r\n\r\n\t        _out: function(e) {\r\n\t            this._trigger(DRAGLEAVE, e);\r\n\t        },\r\n\r\n\t        _drop: function(e) {\r\n\t            var that = this,\r\n\t                draggable = draggables[that.options.group];\r\n\r\n\t            if (draggable) {\r\n\t                draggable.dropped = !that._trigger(DROP, e);\r\n\t            }\r\n\t        }\r\n\t    });\r\n\r\n\t    DropTarget.destroyGroup = function(groupName) {\r\n\t        var group = dropTargets[groupName] || dropAreas[groupName],\r\n\t            i;\r\n\r\n\t        if (group) {\r\n\t            for (i = 0; i < group.length; i++) {\r\n\t                Widget.fn.destroy.call(group[i]);\r\n\t            }\r\n\r\n\t            group.length = 0;\r\n\t            delete dropTargets[groupName];\r\n\t            delete dropAreas[groupName];\r\n\t        }\r\n\t    };\r\n\r\n\t    DropTarget._cache = dropTargets;\r\n\r\n\t    var DropTargetArea = DropTarget.extend({\r\n\t        init: function(element, options) {\r\n\t            var that = this;\r\n\r\n\t            Widget.fn.init.call(that, element, options);\r\n\r\n\t            var group = that.options.group;\r\n\r\n\t            if (!(group in dropAreas)) {\r\n\t                dropAreas[group] = [ that ];\r\n\t            } else {\r\n\t                dropAreas[group].push( that );\r\n\t            }\r\n\t        },\r\n\r\n\t        destroy: function() {\r\n\t            destroyDroppable(dropAreas, this);\r\n\t        },\r\n\r\n\t        options: {\r\n\t            name: \"DropTargetArea\",\r\n\t            group: \"default\",\r\n\t            filter: null\r\n\t        }\r\n\t    });\r\n\r\n\t    var Draggable = Widget.extend({\r\n\t        init: function (element, options) {\r\n\t            var that = this;\r\n\r\n\t            Widget.fn.init.call(that, element, options);\r\n\r\n\t            that._activated = false;\r\n\r\n\t            that.userEvents = new UserEvents(that.element, {\r\n\t                global: true,\r\n\t                allowSelection: true,\r\n\t                filter: that.options.filter,\r\n\t                threshold: that.options.distance,\r\n\t                start: proxy(that._start, that),\r\n\t                hold: proxy(that._hold, that),\r\n\t                move: proxy(that._drag, that),\r\n\t                end: proxy(that._end, that),\r\n\t                cancel: proxy(that._cancel, that),\r\n\t                select: proxy(that._select, that)\r\n\t            });\r\n\r\n\t            that._afterEndHandler = proxy(that._afterEnd, that);\r\n\t            that._captureEscape = proxy(that._captureEscape, that);\r\n\t        },\r\n\r\n\t        events: [\r\n\t            HOLD,\r\n\t            DRAGSTART,\r\n\t            DRAG,\r\n\t            DRAGEND,\r\n\t            DRAGCANCEL,\r\n\t            HINTDESTROYED\r\n\t        ],\r\n\r\n\t        options: {\r\n\t            name: \"Draggable\",\r\n\t            distance: ( kendo.support.touch ? 0 : 5),\r\n\t            group: \"default\",\r\n\t            cursorOffset: null,\r\n\t            axis: null,\r\n\t            container: null,\r\n\t            filter: null,\r\n\t            ignore: null,\r\n\t            holdToDrag: false,\r\n\t            autoScroll: false,\r\n\t            dropped: false\r\n\t        },\r\n\r\n\t        cancelHold: function() {\r\n\t            this._activated = false;\r\n\t        },\r\n\r\n\t        _captureEscape: function(e) {\r\n\t            var that = this;\r\n\r\n\t            if (e.keyCode === kendo.keys.ESC) {\r\n\t                that._trigger(DRAGCANCEL, { event: e });\r\n\t                that.userEvents.cancel();\r\n\t            }\r\n\t        },\r\n\r\n\t        _updateHint: function(e) {\r\n\t            var that = this,\r\n\t                coordinates,\r\n\t                options = that.options,\r\n\t                boundaries = that.boundaries,\r\n\t                axis = options.axis,\r\n\t                cursorOffset = that.options.cursorOffset;\r\n\r\n\t            if (cursorOffset) {\r\n\t               coordinates = { left: e.x.location + cursorOffset.left, top: e.y.location + cursorOffset.top };\r\n\t            } else {\r\n\t                that.hintOffset.left += e.x.delta;\r\n\t                that.hintOffset.top += e.y.delta;\r\n\t                coordinates = $.extend({}, that.hintOffset);\r\n\t            }\r\n\r\n\t            if (boundaries) {\r\n\t                coordinates.top = within(coordinates.top, boundaries.y);\r\n\t                coordinates.left = within(coordinates.left, boundaries.x);\r\n\t            }\r\n\r\n\t            if (axis === \"x\") {\r\n\t                delete coordinates.top;\r\n\t            } else if (axis === \"y\") {\r\n\t                delete coordinates.left;\r\n\t            }\r\n\r\n\t            that.hint.css(coordinates);\r\n\t        },\r\n\r\n\t        _shouldIgnoreTarget: function(target) {\r\n\t            var ignoreSelector = this.options.ignore;\r\n\t            return ignoreSelector && $(target).is(ignoreSelector);\r\n\t        },\r\n\r\n\t        _select: function(e) {\r\n\t            if (!this._shouldIgnoreTarget(e.event.target)) {\r\n\t                e.preventDefault();\r\n\t            }\r\n\t        },\r\n\r\n\t        _start: function(e) {\r\n\t            var that = this,\r\n\t                options = that.options,\r\n\t                container = options.container ? $(options.container): null,\r\n\t                hint = options.hint;\r\n\r\n\t            if (this._shouldIgnoreTarget(e.touch.initialTouch) || (options.holdToDrag && !that._activated)) {\r\n\t                that.userEvents.cancel();\r\n\t                return;\r\n\t            }\r\n\r\n\t            that.currentTarget = e.target;\r\n\t            that.currentTargetOffset = getOffset(that.currentTarget);\r\n\r\n\t            if (hint) {\r\n\t                if (that.hint) {\r\n\t                    that.hint.stop(true, true).remove();\r\n\t                }\r\n\r\n\t                that.hint = kendo.isFunction(hint) ? $(hint.call(that, that.currentTarget)) : hint;\r\n\r\n\t                var offset = getOffset(that.currentTarget);\r\n\t                that.hintOffset = offset;\r\n\r\n\t                that.hint.css( {\r\n\t                    position: \"absolute\",\r\n\t                    zIndex: 20000, // the Window's z-index is 10000 and can be raised because of z-stacking\r\n\t                    left: offset.left,\r\n\t                    top: offset.top\r\n\t                })\r\n\t                .appendTo(document.body);\r\n\r\n\t                that.angular(\"compile\", function(){\r\n\t                    that.hint.removeAttr(\"ng-repeat\");\r\n\t                    var scopeTarget = $(e.target);\r\n\r\n\t                    while (!scopeTarget.data(\"$$kendoScope\") && scopeTarget.length) {\r\n\t                        scopeTarget = scopeTarget.parent();\r\n\t                    }\r\n\r\n\t                    return {\r\n\t                        elements: that.hint.get(),\r\n\t                        scopeFrom: scopeTarget.data(\"$$kendoScope\")\r\n\t                    };\r\n\t                });\r\n\t            }\r\n\r\n\t            draggables[options.group] = that;\r\n\r\n\t            that.dropped = false;\r\n\r\n\t            if (container) {\r\n\t                that.boundaries = containerBoundaries(container, that.hint);\r\n\t            }\r\n\r\n\t            $(document).on(KEYUP, that._captureEscape);\r\n\r\n\t            if (that._trigger(DRAGSTART, e)) {\r\n\t                that.userEvents.cancel();\r\n\t                that._afterEnd();\r\n\t            }\r\n\r\n\t            that.userEvents.capture();\r\n\t        },\r\n\r\n\t        _hold: function(e) {\r\n\t            this.currentTarget = e.target;\r\n\r\n\t            if (this._trigger(HOLD, e)) {\r\n\t                this.userEvents.cancel();\r\n\t            } else {\r\n\t                this._activated = true;\r\n\t            }\r\n\t        },\r\n\r\n\t        _drag: function(e) {\r\n\t            e.preventDefault();\r\n\r\n\t            var cursorElement = this._elementUnderCursor(e);\r\n\r\n\t            if (this.options.autoScroll && this._cursorElement !== cursorElement) {\r\n\t                this._scrollableParent = findScrollableParent(cursorElement);\r\n\t                this._cursorElement = cursorElement;\r\n\t            }\r\n\r\n\t            this._lastEvent = e;\r\n\t            this._processMovement(e, cursorElement);\r\n\r\n\t            if (this.options.autoScroll) {\r\n\t                // chrome seems to trigger mousemove when mouse is moved outside of the window (over the Chrome), too.\r\n\t                if (this._scrollableParent[0]) {\r\n\t                    var velocity = autoScrollVelocity(e.x.location, e.y.location, scrollableViewPort(this._scrollableParent));\r\n\r\n\r\n\t                    this._scrollCompenstation = $.extend({}, this.hintOffset);\r\n\t                    this._scrollVelocity = velocity;\r\n\r\n\t                    if (velocity.y === 0 && velocity.x === 0) {\r\n\t                        clearInterval(this._scrollInterval);\r\n\t                        this._scrollInterval = null;\r\n\t                    } else if(!this._scrollInterval) {\r\n\t                        this._scrollInterval = setInterval($.proxy(this, \"_autoScroll\"), 50);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\r\n\t            if (this.hint) {\r\n\t                this._updateHint(e);\r\n\t            }\r\n\t        },\r\n\r\n\t        _processMovement: function(e, cursorElement) {\r\n\t            this._withDropTarget(cursorElement, function(target, targetElement) {\r\n\t                if (!target) {\r\n\t                    if (lastDropTarget) {\r\n\t                        lastDropTarget._trigger(DRAGLEAVE, extend(e, { dropTarget: $(lastDropTarget.targetElement) }));\r\n\t                        lastDropTarget = null;\r\n\t                    }\r\n\t                    return;\r\n\t                }\r\n\r\n\t                if (lastDropTarget) {\r\n\t                    if (targetElement === lastDropTarget.targetElement) {\r\n\t                        return;\r\n\t                    }\r\n\r\n\t                    lastDropTarget._trigger(DRAGLEAVE, extend(e, { dropTarget: $(lastDropTarget.targetElement) }));\r\n\t                }\r\n\r\n\t                target._trigger(DRAGENTER, extend(e, { dropTarget: $(targetElement) }));\r\n\t                lastDropTarget = extend(target, { targetElement: targetElement });\r\n\t            });\r\n\r\n\t            this._trigger(DRAG, extend(e, { dropTarget: lastDropTarget, elementUnderCursor: cursorElement }));\r\n\t        },\r\n\r\n\t        _autoScroll: function() {\r\n\t            var parent = this._scrollableParent[0],\r\n\t                velocity = this._scrollVelocity,\r\n\t                compensation = this._scrollCompenstation;\r\n\r\n\t            if (!parent) {\r\n\t                return;\r\n\t            }\r\n\r\n\t            var cursorElement = this._elementUnderCursor(this._lastEvent);\r\n\t            this._processMovement(this._lastEvent, cursorElement);\r\n\r\n\t            var yIsScrollable, xIsScrollable;\r\n\r\n\t            var isRootNode = parent === scrollableRoot()[0];\r\n\r\n\t            if (isRootNode) {\r\n\t                yIsScrollable = document.body.scrollHeight > $window.height();\r\n\t                xIsScrollable = document.body.scrollWidth > $window.width();\r\n\t            } else {\r\n\t                yIsScrollable = parent.offsetHeight <= parent.scrollHeight;\r\n\t                xIsScrollable = parent.offsetWidth <= parent.scrollWidth;\r\n\t            }\r\n\r\n\t            var yDelta = parent.scrollTop + velocity.y;\r\n\t            var yInBounds = yIsScrollable && yDelta > 0 && yDelta < parent.scrollHeight;\r\n\r\n\t            var xDelta = parent.scrollLeft + velocity.x;\r\n\t            var xInBounds = xIsScrollable && xDelta > 0 && xDelta < parent.scrollWidth;\r\n\r\n\t            if (yInBounds) {\r\n\t                parent.scrollTop += velocity.y;\r\n\t            }\r\n\r\n\t            if (xInBounds) {\r\n\t                parent.scrollLeft += velocity.x;\r\n\t            }\r\n\r\n\t            if (this.hint && isRootNode && (xInBounds || yInBounds)) {\r\n\t                if (yInBounds) {\r\n\t                    compensation.top += velocity.y;\r\n\t                }\r\n\r\n\t                if (xInBounds) {\r\n\t                    compensation.left += velocity.x;\r\n\t                }\r\n\r\n\t                this.hint.css(compensation);\r\n\t            }\r\n\t        },\r\n\r\n\t        _end: function(e) {\r\n\t            this._withDropTarget(this._elementUnderCursor(e), function(target, targetElement) {\r\n\t                if (target) {\r\n\t                    target._drop(extend({}, e, { dropTarget: $(targetElement) }));\r\n\t                    lastDropTarget = null;\r\n\t                }\r\n\t            });\r\n\r\n\t            this._cancel(this._trigger(DRAGEND, e));\r\n\t        },\r\n\r\n\t        _cancel: function(isDefaultPrevented) {\r\n\t            var that = this;\r\n\r\n\t            that._scrollableParent = null;\r\n\t            this._cursorElement = null;\r\n\t            clearInterval(this._scrollInterval);\r\n\t            that._activated = false;\r\n\r\n\t            if (that.hint && !that.dropped) {\r\n\t                setTimeout(function() {\r\n\t                    that.hint.stop(true, true);\r\n\r\n\t                    if (isDefaultPrevented) {\r\n\t                        that._afterEndHandler();\r\n\t                    } else {\r\n\t                        that.hint.animate(that.currentTargetOffset, \"fast\", that._afterEndHandler);\r\n\t                    }\r\n\t                }, 0);\r\n\r\n\t            } else {\r\n\t                that._afterEnd();\r\n\t            }\r\n\t        },\r\n\r\n\t        _trigger: function(eventName, e) {\r\n\t            var that = this;\r\n\r\n\t            return that.trigger(\r\n\t                eventName, extend(\r\n\t                {},\r\n\t                e.event,\r\n\t                {\r\n\t                    x: e.x,\r\n\t                    y: e.y,\r\n\t                    currentTarget: that.currentTarget,\r\n\t                    initialTarget: e.touch ? e.touch.initialTouch : null,\r\n\t                    dropTarget: e.dropTarget,\r\n\t                    elementUnderCursor: e.elementUnderCursor\r\n\t                }\r\n\t            ));\r\n\t        },\r\n\r\n\t        _elementUnderCursor: function(e) {\r\n\t            var target = elementUnderCursor(e),\r\n\t                hint = this.hint;\r\n\r\n\t            if (hint && contains(hint[0], target)) {\r\n\t                hint.hide();\r\n\t                target = elementUnderCursor(e);\r\n\t                // IE8 does not return the element in iframe from first attempt\r\n\t                if (!target) {\r\n\t                    target = elementUnderCursor(e);\r\n\t                }\r\n\t                hint.show();\r\n\t            }\r\n\r\n\t            return target;\r\n\t        },\r\n\r\n\t        _withDropTarget: function(element, callback) {\r\n\t            var result,\r\n\t                group = this.options.group,\r\n\t                targets = dropTargets[group],\r\n\t                areas = dropAreas[group];\r\n\r\n\t            if (targets && targets.length || areas && areas.length) {\r\n\t                result = checkTarget(element, targets, areas);\r\n\r\n\t                if (result) {\r\n\t                    callback(result.target, result.targetElement);\r\n\t                } else {\r\n\t                    callback();\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        destroy: function() {\r\n\t            var that = this;\r\n\r\n\t            Widget.fn.destroy.call(that);\r\n\r\n\t            that._afterEnd();\r\n\r\n\t            that.userEvents.destroy();\r\n\r\n\t            this._scrollableParent = null;\r\n\t            this._cursorElement = null;\r\n\t            clearInterval(this._scrollInterval);\r\n\r\n\t            that.currentTarget = null;\r\n\t        },\r\n\r\n\t        _afterEnd: function() {\r\n\t            var that = this;\r\n\r\n\t            if (that.hint) {\r\n\t                that.hint.remove();\r\n\t            }\r\n\r\n\t            delete draggables[that.options.group];\r\n\r\n\t            that.trigger(\"destroy\");\r\n\t            that.trigger(HINTDESTROYED);\r\n\t            $(document).off(KEYUP, that._captureEscape);\r\n\t        }\r\n\t    });\r\n\r\n\t    kendo.ui.plugin(DropTarget);\r\n\t    kendo.ui.plugin(DropTargetArea);\r\n\t    kendo.ui.plugin(Draggable);\r\n\t    kendo.TapCapture = TapCapture;\r\n\t    kendo.containerBoundaries = containerBoundaries;\r\n\r\n\t    extend(kendo.ui, {\r\n\t        Pane: Pane,\r\n\t        PaneDimensions: PaneDimensions,\r\n\t        Movable: Movable\r\n\t    });\r\n\r\n\t    function scrollableViewPort(element) {\r\n\t        var root = scrollableRoot()[0],\r\n\t            offset,\r\n\t            top,\r\n\t            left;\r\n\r\n\t        if (element[0] === root) {\r\n\t            top = root.scrollTop;\r\n\t            left = root.scrollLeft;\r\n\r\n\t            return {\r\n\t                top: top,\r\n\t                left: left,\r\n\t                bottom: top + $window.height(),\r\n\t                right: left + $window.width()\r\n\t            };\r\n\t        } else {\r\n\t            offset = element.offset();\r\n\t            offset.bottom = offset.top + element.height();\r\n\t            offset.right =  offset.left + element.width();\r\n\t            return offset;\r\n\t        }\r\n\t    }\r\n\r\n\t    function scrollableRoot() {\r\n\t        return $(kendo.support.browser.edge || kendo.support.browser.safari ? document.body : document.documentElement);\r\n\t    }\r\n\r\n\t    function findScrollableParent(element) {\r\n\t        var root = scrollableRoot();\r\n\r\n\t        if (!element || element === document.body || element === document.documentElement) {\r\n\t            return root;\r\n\t        }\r\n\r\n\t        var parent = $(element)[0];\r\n\r\n\t        while (parent && !kendo.isScrollable(parent) && parent !== document.body) {\r\n\t            parent = parent.parentNode;\r\n\t        }\r\n\r\n\t        if (parent === document.body) {\r\n\t            return root;\r\n\t        }\r\n\r\n\t        return $(parent);\r\n\t    }\r\n\r\n\t    function autoScrollVelocity(mouseX, mouseY, rect) {\r\n\t        var velocity = { x: 0, y: 0 };\r\n\r\n\t        var AUTO_SCROLL_AREA = 50;\r\n\r\n\t        if (mouseX - rect.left < AUTO_SCROLL_AREA) {\r\n\t            velocity.x = -(AUTO_SCROLL_AREA - (mouseX - rect.left));\r\n\t        } else if (rect.right - mouseX < AUTO_SCROLL_AREA) {\r\n\t            velocity.x = AUTO_SCROLL_AREA - (rect.right - mouseX);\r\n\t        }\r\n\r\n\t        if (mouseY - rect.top < AUTO_SCROLL_AREA) {\r\n\t            velocity.y = -(AUTO_SCROLL_AREA - (mouseY - rect.top));\r\n\t        } else if (rect.bottom - mouseY < AUTO_SCROLL_AREA) {\r\n\t            velocity.y = AUTO_SCROLL_AREA - (rect.bottom - mouseY);\r\n\t        }\r\n\r\n\t        return velocity;\r\n\t    }\r\n\r\n\t    // export for testing\r\n\t    kendo.ui.Draggable.utils = {\r\n\t        autoScrollVelocity: autoScrollVelocity,\r\n\t        scrollableViewPort: scrollableViewPort,\r\n\t        findScrollableParent: findScrollableParent\r\n\t    };\r\n\r\n\t })(window.kendo.jQuery);\r\n\r\n\treturn window.kendo;\r\n\r\n\t}, __webpack_require__(3));\r\n\n\n/***/ })\n\n/******/ });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYjRjMTgyZWEyZTJhOGFmNjJhNGEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb2dyZXNzL2tlbmRvLXVpL2pzL2tlbmRvLmRyYWdhbmRkcm9wLmpzP2FjMDIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPVxuLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gMDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEyMyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFwiZGVmaW5lIGNhbm5vdCBiZSB1c2VkIGluZGlyZWN0XCIpOyB9O1xyXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDEwMDQ6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9rZW5kby5jb3JlXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMTAzODpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2tlbmRvLnVzZXJldmVudHNcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMTIzOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyhmdW5jdGlvbihmLCBkZWZpbmUpe1xyXG5cdCAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbIF9fd2VicGFja19yZXF1aXJlX18oMTAwNCksIF9fd2VicGFja19yZXF1aXJlX18oMTAzOCkgXSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID0gKGYpLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyA9ICh0eXBlb2YgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fID09PSAnZnVuY3Rpb24nID8gKF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXy5hcHBseShleHBvcnRzLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fKSkgOiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18pLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXyAhPT0gdW5kZWZpbmVkICYmIChtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fKSk7XHJcblx0fSkoZnVuY3Rpb24oKXtcclxuXHJcblx0dmFyIF9fbWV0YV9fID0geyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcclxuXHQgICAgaWQ6IFwiZHJhZ2FuZGRyb3BcIixcclxuXHQgICAgbmFtZTogXCJEcmFnICYgZHJvcFwiLFxyXG5cdCAgICBjYXRlZ29yeTogXCJmcmFtZXdvcmtcIixcclxuXHQgICAgZGVzY3JpcHRpb246IFwiRHJhZyAmIGRyb3AgZnVuY3Rpb25hbGl0eSBmb3IgYW55IERPTSBlbGVtZW50LlwiLFxyXG5cdCAgICBkZXBlbmRzOiBbIFwiY29yZVwiLCBcInVzZXJldmVudHNcIiBdXHJcblx0fTtcclxuXHJcblx0KGZ1bmN0aW9uICgkLCB1bmRlZmluZWQpIHtcclxuXHQgICAgdmFyIGtlbmRvID0gd2luZG93LmtlbmRvLFxyXG5cdCAgICAgICAgc3VwcG9ydCA9IGtlbmRvLnN1cHBvcnQsXHJcblx0ICAgICAgICBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcclxuXHQgICAgICAgICR3aW5kb3cgPSAkKHdpbmRvdyksXHJcblx0ICAgICAgICBDbGFzcyA9IGtlbmRvLkNsYXNzLFxyXG5cdCAgICAgICAgV2lkZ2V0ID0ga2VuZG8udWkuV2lkZ2V0LFxyXG5cdCAgICAgICAgT2JzZXJ2YWJsZSA9IGtlbmRvLk9ic2VydmFibGUsXHJcblx0ICAgICAgICBVc2VyRXZlbnRzID0ga2VuZG8uVXNlckV2ZW50cyxcclxuXHQgICAgICAgIHByb3h5ID0gJC5wcm94eSxcclxuXHQgICAgICAgIGV4dGVuZCA9ICQuZXh0ZW5kLFxyXG5cdCAgICAgICAgZ2V0T2Zmc2V0ID0ga2VuZG8uZ2V0T2Zmc2V0LFxyXG5cdCAgICAgICAgZHJhZ2dhYmxlcyA9IHt9LFxyXG5cdCAgICAgICAgZHJvcFRhcmdldHMgPSB7fSxcclxuXHQgICAgICAgIGRyb3BBcmVhcyA9IHt9LFxyXG5cdCAgICAgICAgbGFzdERyb3BUYXJnZXQsXHJcblx0ICAgICAgICBlbGVtZW50VW5kZXJDdXJzb3IgPSBrZW5kby5lbGVtZW50VW5kZXJDdXJzb3IsXHJcblx0ICAgICAgICBLRVlVUCA9IFwia2V5dXBcIixcclxuXHQgICAgICAgIENIQU5HRSA9IFwiY2hhbmdlXCIsXHJcblxyXG5cdCAgICAgICAgLy8gRHJhZ2dhYmxlIGV2ZW50c1xyXG5cdCAgICAgICAgRFJBR1NUQVJUID0gXCJkcmFnc3RhcnRcIixcclxuXHQgICAgICAgIEhPTEQgPSBcImhvbGRcIixcclxuXHQgICAgICAgIERSQUcgPSBcImRyYWdcIixcclxuXHQgICAgICAgIERSQUdFTkQgPSBcImRyYWdlbmRcIixcclxuXHQgICAgICAgIERSQUdDQU5DRUwgPSBcImRyYWdjYW5jZWxcIixcclxuXHQgICAgICAgIEhJTlRERVNUUk9ZRUQgPSBcImhpbnREZXN0cm95ZWRcIixcclxuXHJcblx0ICAgICAgICAvLyBEcm9wVGFyZ2V0IGV2ZW50c1xyXG5cdCAgICAgICAgRFJBR0VOVEVSID0gXCJkcmFnZW50ZXJcIixcclxuXHQgICAgICAgIERSQUdMRUFWRSA9IFwiZHJhZ2xlYXZlXCIsXHJcblx0ICAgICAgICBEUk9QID0gXCJkcm9wXCI7XHJcblxyXG5cdCAgICBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XHJcblx0ICAgICAgICB0cnkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiAkLmNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHx8IHBhcmVudCA9PSBjaGlsZDtcclxuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGZ1bmN0aW9uIG51bWVyaWNDc3NQcm9wZXJ5KGVsZW1lbnQsIHByb3BlcnR5KSB7XHJcblx0ICAgICAgICByZXR1cm4gcGFyc2VJbnQoZWxlbWVudC5jc3MocHJvcGVydHkpLCAxMCkgfHwgMDtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgZnVuY3Rpb24gd2l0aGluKHZhbHVlLCByYW5nZSkge1xyXG5cdCAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCByYW5nZS5taW4pLCByYW5nZS5tYXgpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBmdW5jdGlvbiBjb250YWluZXJCb3VuZGFyaWVzKGNvbnRhaW5lciwgZWxlbWVudCkge1xyXG5cdCAgICAgICAgdmFyIG9mZnNldCA9IGdldE9mZnNldChjb250YWluZXIpLFxyXG5cdCAgICAgICAgICAgIG91dGVyV2lkdGggPSBrZW5kby5fb3V0ZXJXaWR0aCxcclxuXHQgICAgICAgICAgICBvdXRlckhlaWdodCA9IGtlbmRvLl9vdXRlckhlaWdodCxcclxuXHQgICAgICAgICAgICBtaW5YID0gb2Zmc2V0LmxlZnQgKyBudW1lcmljQ3NzUHJvcGVyeShjb250YWluZXIsIFwiYm9yZGVyTGVmdFdpZHRoXCIpICsgbnVtZXJpY0Nzc1Byb3BlcnkoY29udGFpbmVyLCBcInBhZGRpbmdMZWZ0XCIpLFxyXG5cdCAgICAgICAgICAgIG1pblkgPSBvZmZzZXQudG9wICsgbnVtZXJpY0Nzc1Byb3BlcnkoY29udGFpbmVyLCBcImJvcmRlclRvcFdpZHRoXCIpICsgbnVtZXJpY0Nzc1Byb3BlcnkoY29udGFpbmVyLCBcInBhZGRpbmdUb3BcIiksXHJcblx0ICAgICAgICAgICAgbWF4WCA9IG1pblggKyBjb250YWluZXIud2lkdGgoKSAtIG91dGVyV2lkdGgoZWxlbWVudCwgdHJ1ZSksXHJcblx0ICAgICAgICAgICAgbWF4WSA9IG1pblkgKyBjb250YWluZXIuaGVpZ2h0KCkgLSBvdXRlckhlaWdodChlbGVtZW50LCB0cnVlKTtcclxuXHJcblx0ICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgIHg6IHsgbWluOiBtaW5YLCBtYXg6IG1heFggfSxcclxuXHQgICAgICAgICAgICB5OiB7IG1pbjogbWluWSwgbWF4OiBtYXhZIH1cclxuXHQgICAgICAgIH07XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGZ1bmN0aW9uIGNoZWNrVGFyZ2V0KHRhcmdldCwgdGFyZ2V0cywgYXJlYXMpIHtcclxuXHQgICAgICAgIHZhciB0aGVUYXJnZXQsIHRoZUZpbHRlciwgaSA9IDAsXHJcblx0ICAgICAgICAgICAgdGFyZ2V0TGVuID0gdGFyZ2V0cyAmJiB0YXJnZXRzLmxlbmd0aCxcclxuXHQgICAgICAgICAgICBhcmVhTGVuID0gYXJlYXMgJiYgYXJlYXMubGVuZ3RoO1xyXG5cclxuXHQgICAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0LnBhcmVudE5vZGUpIHtcclxuXHQgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0TGVuOyBpICsrKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoZVRhcmdldCA9IHRhcmdldHNbaV07XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGVUYXJnZXQuZWxlbWVudFswXSA9PT0gdGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0YXJnZXQ6IHRoZVRhcmdldCwgdGFyZ2V0RWxlbWVudDogdGFyZ2V0IH07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmVhTGVuOyBpICsrKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoZUZpbHRlciA9IGFyZWFzW2ldO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoJC5jb250YWlucyh0aGVGaWx0ZXIuZWxlbWVudFswXSwgdGFyZ2V0KSAmJiBzdXBwb3J0Lm1hdGNoZXNTZWxlY3Rvci5jYWxsKHRhcmdldCwgdGhlRmlsdGVyLm9wdGlvbnMuZmlsdGVyKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdGFyZ2V0OiB0aGVGaWx0ZXIsIHRhcmdldEVsZW1lbnQ6IHRhcmdldCB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcclxuXHQgICAgICAgIH1cclxuXHJcblx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICB2YXIgVGFwQ2FwdHVyZSA9IE9ic2VydmFibGUuZXh0ZW5kKHtcclxuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcclxuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXHJcblx0ICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQgPSBlbGVtZW50WzBdO1xyXG5cclxuXHQgICAgICAgICAgICB0aGF0LmNhcHR1cmUgPSBmYWxzZTtcclxuXHJcblx0ICAgICAgICAgICAgaWYgKGRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG5cdCAgICAgICAgICAgICAgICAkLmVhY2goa2VuZG8uZXZlbnRNYXAuZG93bi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHByb3h5KHRoYXQuX3ByZXNzLCB0aGF0KSwgdHJ1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAkLmVhY2goa2VuZG8uZXZlbnRNYXAudXAuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLCBwcm94eSh0aGF0Ll9yZWxlYXNlLCB0aGF0KSwgdHJ1ZSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICQuZWFjaChrZW5kby5ldmVudE1hcC5kb3duLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBkb21FbGVtZW50LmF0dGFjaEV2ZW50KHRoaXMsIHByb3h5KHRoYXQuX3ByZXNzLCB0aGF0KSk7XHJcblx0ICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAkLmVhY2goa2VuZG8uZXZlbnRNYXAudXAuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQuYXR0YWNoRXZlbnQodGhpcywgcHJveHkodGhhdC5fcmVsZWFzZSwgdGhhdCkpO1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIE9ic2VydmFibGUuZm4uaW5pdC5jYWxsKHRoYXQpO1xyXG5cclxuXHQgICAgICAgICAgICB0aGF0LmJpbmQoW1wicHJlc3NcIiwgXCJyZWxlYXNlXCJdLCBvcHRpb25zIHx8IHt9KTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgY2FwdHVyZU5leHQ6IGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuY2FwdHVyZSA9IHRydWU7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIGNhbmNlbENhcHR1cmU6IGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuY2FwdHVyZSA9IGZhbHNlO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBfcHJlc3M6IGZ1bmN0aW9uKGUpIHtcclxuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblx0ICAgICAgICAgICAgdGhhdC50cmlnZ2VyKFwicHJlc3NcIik7XHJcblx0ICAgICAgICAgICAgaWYgKHRoYXQuY2FwdHVyZSkge1xyXG5cdCAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBfcmVsZWFzZTogZnVuY3Rpb24oZSkge1xyXG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHQgICAgICAgICAgICB0aGF0LnRyaWdnZXIoXCJyZWxlYXNlXCIpO1xyXG5cclxuXHQgICAgICAgICAgICBpZiAodGhhdC5jYXB0dXJlKSB7XHJcblx0ICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHQgICAgICAgICAgICAgICAgdGhhdC5jYW5jZWxDYXB0dXJlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9KTtcclxuXHJcblx0ICAgIHZhciBQYW5lRGltZW5zaW9uID0gT2JzZXJ2YWJsZS5leHRlbmQoe1xyXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHQgICAgICAgICAgICBPYnNlcnZhYmxlLmZuLmluaXQuY2FsbCh0aGF0KTtcclxuXHJcblx0ICAgICAgICAgICAgdGhhdC5mb3JjZWRFbmFibGVkID0gZmFsc2U7XHJcblxyXG5cdCAgICAgICAgICAgICQuZXh0ZW5kKHRoYXQsIG9wdGlvbnMpO1xyXG5cclxuXHQgICAgICAgICAgICB0aGF0LnNjYWxlID0gMTtcclxuXHJcblx0ICAgICAgICAgICAgaWYgKHRoYXQuaG9yaXpvbnRhbCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGF0Lm1lYXN1cmUgPSBcIm9mZnNldFdpZHRoXCI7XHJcblx0ICAgICAgICAgICAgICAgIHRoYXQuc2Nyb2xsU2l6ZSA9IFwic2Nyb2xsV2lkdGhcIjtcclxuXHQgICAgICAgICAgICAgICAgdGhhdC5heGlzID0gXCJ4XCI7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhhdC5tZWFzdXJlID0gXCJvZmZzZXRIZWlnaHRcIjtcclxuXHQgICAgICAgICAgICAgICAgdGhhdC5zY3JvbGxTaXplID0gXCJzY3JvbGxIZWlnaHRcIjtcclxuXHQgICAgICAgICAgICAgICAgdGhhdC5heGlzID0gXCJ5XCI7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBtYWtlVmlydHVhbDogZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgJC5leHRlbmQodGhpcywge1xyXG5cdCAgICAgICAgICAgICAgICB2aXJ0dWFsOiB0cnVlLFxyXG5cdCAgICAgICAgICAgICAgICBmb3JjZWRFbmFibGVkOiB0cnVlLFxyXG5cdCAgICAgICAgICAgICAgICBfdmlydHVhbE1pbjogMCxcclxuXHQgICAgICAgICAgICAgICAgX3ZpcnR1YWxNYXg6IDBcclxuXHQgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgdmlydHVhbFNpemU6IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3ZpcnR1YWxNaW4gIT09IG1pbiB8fCB0aGlzLl92aXJ0dWFsTWF4ICE9PSBtYXgpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5fdmlydHVhbE1pbiA9IG1pbjtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5fdmlydHVhbE1heCA9IG1heDtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIG91dE9mQm91bmRzOiBmdW5jdGlvbihvZmZzZXQpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ID4gdGhpcy5tYXggfHwgb2Zmc2V0IDwgdGhpcy5taW47XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIGZvcmNlRW5hYmxlZDogZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5mb3JjZWRFbmFibGVkID0gdHJ1ZTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgZ2V0U2l6ZTogZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyWzBdW3RoaXMubWVhc3VyZV07XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIGdldFRvdGFsOiBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50WzBdW3RoaXMuc2Nyb2xsU2l6ZV07XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIHJlc2NhbGU6IGZ1bmN0aW9uKHNjYWxlKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKHNpbGVudCkge1xyXG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcclxuXHQgICAgICAgICAgICAgICAgdG90YWwgPSB0aGF0LnZpcnR1YWwgPyB0aGF0Ll92aXJ0dWFsTWF4IDogdGhhdC5nZXRUb3RhbCgpLFxyXG5cdCAgICAgICAgICAgICAgICBzY2FsZWRUb3RhbCA9IHRvdGFsICogdGhhdC5zY2FsZSxcclxuXHQgICAgICAgICAgICAgICAgc2l6ZSA9IHRoYXQuZ2V0U2l6ZSgpO1xyXG5cclxuXHQgICAgICAgICAgICBpZiAodG90YWwgPT09IDAgJiYgIXRoYXQuZm9yY2VkRW5hYmxlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47IC8vIHdlIGFyZSBub3QgdmlzaWJsZS5cclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIHRoYXQubWF4ID0gdGhhdC52aXJ0dWFsID8gLXRoYXQuX3ZpcnR1YWxNaW4gOiAwO1xyXG5cdCAgICAgICAgICAgIHRoYXQuc2l6ZSA9IHNpemU7XHJcblx0ICAgICAgICAgICAgdGhhdC50b3RhbCA9IHNjYWxlZFRvdGFsO1xyXG5cdCAgICAgICAgICAgIHRoYXQubWluID0gTWF0aC5taW4odGhhdC5tYXgsIHNpemUgLSBzY2FsZWRUb3RhbCk7XHJcblx0ICAgICAgICAgICAgdGhhdC5taW5TY2FsZSA9IHNpemUgLyB0b3RhbDtcclxuXHQgICAgICAgICAgICB0aGF0LmNlbnRlck9mZnNldCA9IChzY2FsZWRUb3RhbCAtIHNpemUpIC8gMjtcclxuXHJcblx0ICAgICAgICAgICAgdGhhdC5lbmFibGVkID0gdGhhdC5mb3JjZWRFbmFibGVkIHx8IChzY2FsZWRUb3RhbCA+IHNpemUpO1xyXG5cclxuXHQgICAgICAgICAgICBpZiAoIXNpbGVudCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXIoQ0hBTkdFLCB0aGF0KTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0pO1xyXG5cclxuXHQgICAgdmFyIFBhbmVEaW1lbnNpb25zID0gT2JzZXJ2YWJsZS5leHRlbmQoe1xyXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcblx0ICAgICAgICAgICAgT2JzZXJ2YWJsZS5mbi5pbml0LmNhbGwodGhhdCk7XHJcblxyXG5cdCAgICAgICAgICAgIHRoYXQueCA9IG5ldyBQYW5lRGltZW5zaW9uKGV4dGVuZCh7aG9yaXpvbnRhbDogdHJ1ZX0sIG9wdGlvbnMpKTtcclxuXHQgICAgICAgICAgICB0aGF0LnkgPSBuZXcgUGFuZURpbWVuc2lvbihleHRlbmQoe2hvcml6b250YWw6IGZhbHNlfSwgb3B0aW9ucykpO1xyXG5cdCAgICAgICAgICAgIHRoYXQuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XHJcblx0ICAgICAgICAgICAgdGhhdC5mb3JjZWRNaW5TY2FsZSA9IG9wdGlvbnMubWluU2NhbGU7XHJcblx0ICAgICAgICAgICAgdGhhdC5tYXhTY2FsZSA9IG9wdGlvbnMubWF4U2NhbGUgfHwgMTAwO1xyXG5cclxuXHQgICAgICAgICAgICB0aGF0LmJpbmQoQ0hBTkdFLCBvcHRpb25zKTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgcmVzY2FsZTogZnVuY3Rpb24obmV3U2NhbGUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLngucmVzY2FsZShuZXdTY2FsZSk7XHJcblx0ICAgICAgICAgICAgdGhpcy55LnJlc2NhbGUobmV3U2NhbGUpO1xyXG5cdCAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBjZW50ZXJDb29yZGluYXRlczogZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHsgeDogTWF0aC5taW4oMCwgLXRoaXMueC5jZW50ZXJPZmZzZXQpLCB5OiBNYXRoLm1pbigwLCAtdGhpcy55LmNlbnRlck9mZnNldCkgfTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgcmVmcmVzaDogZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cdCAgICAgICAgICAgIHRoYXQueC51cGRhdGUoKTtcclxuXHQgICAgICAgICAgICB0aGF0LnkudXBkYXRlKCk7XHJcblx0ICAgICAgICAgICAgdGhhdC5lbmFibGVkID0gdGhhdC54LmVuYWJsZWQgfHwgdGhhdC55LmVuYWJsZWQ7XHJcblx0ICAgICAgICAgICAgdGhhdC5taW5TY2FsZSA9IHRoYXQuZm9yY2VkTWluU2NhbGUgfHwgTWF0aC5taW4odGhhdC54Lm1pblNjYWxlLCB0aGF0LnkubWluU2NhbGUpO1xyXG5cdCAgICAgICAgICAgIHRoYXQuZml0U2NhbGUgPSBNYXRoLm1heCh0aGF0LngubWluU2NhbGUsIHRoYXQueS5taW5TY2FsZSk7XHJcblx0ICAgICAgICAgICAgdGhhdC50cmlnZ2VyKENIQU5HRSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0pO1xyXG5cclxuXHQgICAgdmFyIFBhbmVBeGlzID0gT2JzZXJ2YWJsZS5leHRlbmQoe1xyXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHQgICAgICAgICAgICBleHRlbmQodGhhdCwgb3B0aW9ucyk7XHJcblx0ICAgICAgICAgICAgT2JzZXJ2YWJsZS5mbi5pbml0LmNhbGwodGhhdCk7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIG91dE9mQm91bmRzOiBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5kaW1lbnNpb24ub3V0T2ZCb3VuZHModGhpcy5tb3ZhYmxlW3RoaXMuYXhpc10pO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBkcmFnTW92ZTogZnVuY3Rpb24oZGVsdGEpIHtcclxuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXHJcblx0ICAgICAgICAgICAgICAgIGRpbWVuc2lvbiA9IHRoYXQuZGltZW5zaW9uLFxyXG5cdCAgICAgICAgICAgICAgICBheGlzID0gdGhhdC5heGlzLFxyXG5cdCAgICAgICAgICAgICAgICBtb3ZhYmxlID0gdGhhdC5tb3ZhYmxlLFxyXG5cdCAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IG1vdmFibGVbYXhpc10gKyBkZWx0YTtcclxuXHJcblx0ICAgICAgICAgICAgaWYgKCFkaW1lbnNpb24uZW5hYmxlZCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICBpZiAoKHBvc2l0aW9uIDwgZGltZW5zaW9uLm1pbiAmJiBkZWx0YSA8IDApIHx8IChwb3NpdGlvbiA+IGRpbWVuc2lvbi5tYXggJiYgZGVsdGEgPiAwKSkge1xyXG5cdCAgICAgICAgICAgICAgICBkZWx0YSAqPSB0aGF0LnJlc2lzdGFuY2U7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICBtb3ZhYmxlLnRyYW5zbGF0ZUF4aXMoYXhpcywgZGVsdGEpO1xyXG5cdCAgICAgICAgICAgIHRoYXQudHJpZ2dlcihDSEFOR0UsIHRoYXQpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9KTtcclxuXHJcblx0ICAgIHZhciBQYW5lID0gQ2xhc3MuZXh0ZW5kKHtcclxuXHJcblx0ICAgICAgICBpbml0OiBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxyXG5cdCAgICAgICAgICAgICAgICB4LFxyXG5cdCAgICAgICAgICAgICAgICB5LFxyXG5cdCAgICAgICAgICAgICAgICByZXNpc3RhbmNlLFxyXG5cdCAgICAgICAgICAgICAgICBtb3ZhYmxlO1xyXG5cclxuXHQgICAgICAgICAgICBleHRlbmQodGhhdCwge2VsYXN0aWM6IHRydWV9LCBvcHRpb25zKTtcclxuXHJcblx0ICAgICAgICAgICAgcmVzaXN0YW5jZSA9IHRoYXQuZWxhc3RpYyA/IDAuNSA6IDA7XHJcblx0ICAgICAgICAgICAgbW92YWJsZSA9IHRoYXQubW92YWJsZTtcclxuXHJcblx0ICAgICAgICAgICAgdGhhdC54ID0geCA9IG5ldyBQYW5lQXhpcyh7XHJcblx0ICAgICAgICAgICAgICAgIGF4aXM6IFwieFwiLFxyXG5cdCAgICAgICAgICAgICAgICBkaW1lbnNpb246IHRoYXQuZGltZW5zaW9ucy54LFxyXG5cdCAgICAgICAgICAgICAgICByZXNpc3RhbmNlOiByZXNpc3RhbmNlLFxyXG5cdCAgICAgICAgICAgICAgICBtb3ZhYmxlOiBtb3ZhYmxlXHJcblx0ICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgIHRoYXQueSA9IHkgPSBuZXcgUGFuZUF4aXMoe1xyXG5cdCAgICAgICAgICAgICAgICBheGlzOiBcInlcIixcclxuXHQgICAgICAgICAgICAgICAgZGltZW5zaW9uOiB0aGF0LmRpbWVuc2lvbnMueSxcclxuXHQgICAgICAgICAgICAgICAgcmVzaXN0YW5jZTogcmVzaXN0YW5jZSxcclxuXHQgICAgICAgICAgICAgICAgbW92YWJsZTogbW92YWJsZVxyXG5cdCAgICAgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgICAgICB0aGF0LnVzZXJFdmVudHMuYmluZChbXCJwcmVzc1wiLCBcIm1vdmVcIiwgXCJlbmRcIiwgXCJnZXN0dXJlc3RhcnRcIiwgXCJnZXN0dXJlY2hhbmdlXCJdLCB7XHJcblx0ICAgICAgICAgICAgICAgIGdlc3R1cmVzdGFydDogZnVuY3Rpb24oZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC5nZXN0dXJlID0gZTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQub2Zmc2V0ID0gdGhhdC5kaW1lbnNpb25zLmNvbnRhaW5lci5vZmZzZXQoKTtcclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgICAgIHByZXNzOiBmdW5jdGlvbihlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoJChlLmV2ZW50LnRhcmdldCkuY2xvc2VzdChcImFcIikuaXMoXCJbZGF0YS1uYXZpZ2F0ZS1vbi1wcmVzcz10cnVlXVwiKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGUuc2VuZGVyLmNhbmNlbCgpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgZ2VzdHVyZWNoYW5nZTogZnVuY3Rpb24oZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzR2VzdHVyZSA9IHRoYXQuZ2VzdHVyZSxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0NlbnRlciA9IHByZXZpb3VzR2VzdHVyZS5jZW50ZXIsXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlciA9IGUuY2VudGVyLFxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZURlbHRhID0gZS5kaXN0YW5jZSAvIHByZXZpb3VzR2VzdHVyZS5kaXN0YW5jZSxcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWluU2NhbGUgPSB0aGF0LmRpbWVuc2lvbnMubWluU2NhbGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWF4U2NhbGUgPSB0aGF0LmRpbWVuc2lvbnMubWF4U2NhbGUsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmFibGUuc2NhbGUgPD0gbWluU2NhbGUgJiYgc2NhbGVEZWx0YSA8IDEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNpc3Qgc2hyaW5raW5nLiBJbnN0ZWFkIG9mIHNocmlua2luZyBmcm9tIDEgdG8gMC41LCBpdCB3aWxsIHNocmluayB0byAwLjUgKyAoMSAvKiBtaW5TY2FsZSAqLyAtIDAuNSkgKiAwLjggPSAwLjk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVEZWx0YSArPSAoMSAtIHNjYWxlRGVsdGEpICogMC44O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChtb3ZhYmxlLnNjYWxlICogc2NhbGVEZWx0YSA+PSBtYXhTY2FsZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlRGVsdGEgPSBtYXhTY2FsZSAvIG1vdmFibGUuc2NhbGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldFggPSBtb3ZhYmxlLnggKyB0aGF0Lm9mZnNldC5sZWZ0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldFkgPSBtb3ZhYmxlLnkgKyB0aGF0Lm9mZnNldC50b3A7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMgPSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeDogKG9mZnNldFggLSBwcmV2aW91c0NlbnRlci54KSAqIHNjYWxlRGVsdGEgKyBjZW50ZXIueCAtIG9mZnNldFgsXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeTogKG9mZnNldFkgLSBwcmV2aW91c0NlbnRlci55KSAqIHNjYWxlRGVsdGEgKyBjZW50ZXIueSAtIG9mZnNldFlcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgbW92YWJsZS5zY2FsZVdpdGgoc2NhbGVEZWx0YSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgeC5kcmFnTW92ZShjb29yZGluYXRlcy54KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHkuZHJhZ01vdmUoY29vcmRpbmF0ZXMueSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC5kaW1lbnNpb25zLnJlc2NhbGUobW92YWJsZS5zY2FsZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0Lmdlc3R1cmUgPSBlO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdCAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAgICAgbW92ZTogZnVuY3Rpb24oZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGUuZXZlbnQudGFyZ2V0LnRhZ05hbWUubWF0Y2goL3RleHRhcmVhfGlucHV0L2kpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh4LmRpbWVuc2lvbi5lbmFibGVkIHx8IHkuZGltZW5zaW9uLmVuYWJsZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB4LmRyYWdNb3ZlKGUueC5kZWx0YSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgeS5kcmFnTW92ZShlLnkuZGVsdGEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZS50b3VjaC5za2lwKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICBlbmQ6IGZ1bmN0aW9uKGUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9KTtcclxuXHJcblx0ICAgIHZhciBUUkFOU0ZPUk1fU1RZTEUgPSBzdXBwb3J0LnRyYW5zaXRpb25zLnByZWZpeCArIFwiVHJhbnNmb3JtXCIsXHJcblx0ICAgICAgICB0cmFuc2xhdGU7XHJcblxyXG5cclxuXHQgICAgaWYgKHN1cHBvcnQuaGFzSFczRCkge1xyXG5cdCAgICAgICAgdHJhbnNsYXRlID0gZnVuY3Rpb24oeCwgeSwgc2NhbGUpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcInB4LFwiICsgeSArXCJweCwwKSBzY2FsZShcIiArIHNjYWxlICsgXCIpXCI7XHJcblx0ICAgICAgICB9O1xyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgdHJhbnNsYXRlID0gZnVuY3Rpb24oeCwgeSwgc2NhbGUpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCxcIiArIHkgK1wicHgpIHNjYWxlKFwiICsgc2NhbGUgKyBcIilcIjtcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIHZhciBNb3ZhYmxlID0gT2JzZXJ2YWJsZS5leHRlbmQoe1xyXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcblx0ICAgICAgICAgICAgT2JzZXJ2YWJsZS5mbi5pbml0LmNhbGwodGhhdCk7XHJcblxyXG5cdCAgICAgICAgICAgIHRoYXQuZWxlbWVudCA9ICQoZWxlbWVudCk7XHJcblx0ICAgICAgICAgICAgdGhhdC5lbGVtZW50WzBdLnN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9IFwibGVmdCB0b3BcIjtcclxuXHQgICAgICAgICAgICB0aGF0LnggPSAwO1xyXG5cdCAgICAgICAgICAgIHRoYXQueSA9IDA7XHJcblx0ICAgICAgICAgICAgdGhhdC5zY2FsZSA9IDE7XHJcblx0ICAgICAgICAgICAgdGhhdC5fc2F2ZUNvb3JkaW5hdGVzKHRyYW5zbGF0ZSh0aGF0LngsIHRoYXQueSwgdGhhdC5zY2FsZSkpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICB0cmFuc2xhdGVBeGlzOiBmdW5jdGlvbihheGlzLCBieSkge1xyXG5cdCAgICAgICAgICAgIHRoaXNbYXhpc10gKz0gYnk7XHJcblx0ICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIHNjYWxlVG86IGZ1bmN0aW9uKHNjYWxlKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xyXG5cdCAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBzY2FsZVdpdGg6IGZ1bmN0aW9uKHNjYWxlRGVsdGEpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnNjYWxlICo9IHNjYWxlRGVsdGE7XHJcblx0ICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcclxuXHQgICAgICAgICAgICB0aGlzLnggKz0gY29vcmRpbmF0ZXMueDtcclxuXHQgICAgICAgICAgICB0aGlzLnkgKz0gY29vcmRpbmF0ZXMueTtcclxuXHQgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgbW92ZUF4aXM6IGZ1bmN0aW9uKGF4aXMsIHZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgdGhpc1theGlzXSA9IHZhbHVlO1xyXG5cdCAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBtb3ZlVG86IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XHJcblx0ICAgICAgICAgICAgZXh0ZW5kKHRoaXMsIGNvb3JkaW5hdGVzKTtcclxuXHQgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgcmVmcmVzaDogZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxyXG5cdCAgICAgICAgICAgICAgICB4ID0gdGhhdC54LFxyXG5cdCAgICAgICAgICAgICAgICB5ID0gdGhhdC55LFxyXG5cdCAgICAgICAgICAgICAgICBuZXdDb29yZGluYXRlcztcclxuXHJcblx0ICAgICAgICAgICAgaWYgKHRoYXQucm91bmQpIHtcclxuXHQgICAgICAgICAgICAgICAgeCA9IE1hdGgucm91bmQoeCk7XHJcblx0ICAgICAgICAgICAgICAgIHkgPSBNYXRoLnJvdW5kKHkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgbmV3Q29vcmRpbmF0ZXMgPSB0cmFuc2xhdGUoeCwgeSwgdGhhdC5zY2FsZSk7XHJcblxyXG5cdCAgICAgICAgICAgIGlmIChuZXdDb29yZGluYXRlcyAhPSB0aGF0LmNvb3JkaW5hdGVzKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChrZW5kby5zdXBwb3J0LmJyb3dzZXIubXNpZSAmJiBrZW5kby5zdXBwb3J0LmJyb3dzZXIudmVyc2lvbiA8IDEwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LmVsZW1lbnRbMF0uc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LmVsZW1lbnRbMF0uc3R5bGUubGVmdCA9IHRoYXQueCArIFwicHhcIjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuZWxlbWVudFswXS5zdHlsZS50b3AgPSB0aGF0LnkgKyBcInB4XCI7XHJcblxyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC5lbGVtZW50WzBdLnN0eWxlW1RSQU5TRk9STV9TVFlMRV0gPSBuZXdDb29yZGluYXRlcztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9zYXZlQ29vcmRpbmF0ZXMobmV3Q29vcmRpbmF0ZXMpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXIoQ0hBTkdFKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIF9zYXZlQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9KTtcclxuXHJcblx0ICAgIGZ1bmN0aW9uIGRlc3Ryb3lEcm9wcGFibGUoY29sbGVjdGlvbiwgd2lkZ2V0KSB7XHJcblx0ICAgICAgICB2YXIgZ3JvdXBOYW1lID0gd2lkZ2V0Lm9wdGlvbnMuZ3JvdXAsXHJcblx0ICAgICAgICBkcm9wcGFibGVzID0gY29sbGVjdGlvbltncm91cE5hbWVdLFxyXG5cdCAgICAgICAgaTtcclxuXHJcblx0ICAgICAgICBXaWRnZXQuZm4uZGVzdHJveS5jYWxsKHdpZGdldCk7XHJcblxyXG5cdCAgICAgICAgaWYgKGRyb3BwYWJsZXMubGVuZ3RoID4gMSkge1xyXG5cdCAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkcm9wcGFibGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChkcm9wcGFibGVzW2ldID09IHdpZGdldCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZHJvcHBhYmxlcy5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgZHJvcHBhYmxlcy5sZW5ndGggPSAwOyAvLyBXVEYsIHBvcnRpbmcgdGhpcyBmcm9tIHRoZSBwcmV2aW91cyBkZXN0cm95R3JvdXBcclxuXHQgICAgICAgICAgICBkZWxldGUgY29sbGVjdGlvbltncm91cE5hbWVdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblxyXG5cdCAgICB2YXIgRHJvcFRhcmdldCA9IFdpZGdldC5leHRlbmQoe1xyXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xyXG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcblx0ICAgICAgICAgICAgV2lkZ2V0LmZuLmluaXQuY2FsbCh0aGF0LCBlbGVtZW50LCBvcHRpb25zKTtcclxuXHJcblx0ICAgICAgICAgICAgdmFyIGdyb3VwID0gdGhhdC5vcHRpb25zLmdyb3VwO1xyXG5cclxuXHQgICAgICAgICAgICBpZiAoIShncm91cCBpbiBkcm9wVGFyZ2V0cykpIHtcclxuXHQgICAgICAgICAgICAgICAgZHJvcFRhcmdldHNbZ3JvdXBdID0gWyB0aGF0IF07XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgZHJvcFRhcmdldHNbZ3JvdXBdLnB1c2goIHRoYXQgKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIGV2ZW50czogW1xyXG5cdCAgICAgICAgICAgIERSQUdFTlRFUixcclxuXHQgICAgICAgICAgICBEUkFHTEVBVkUsXHJcblx0ICAgICAgICAgICAgRFJPUFxyXG5cdCAgICAgICAgXSxcclxuXHJcblx0ICAgICAgICBvcHRpb25zOiB7XHJcblx0ICAgICAgICAgICAgbmFtZTogXCJEcm9wVGFyZ2V0XCIsXHJcblx0ICAgICAgICAgICAgZ3JvdXA6IFwiZGVmYXVsdFwiXHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgIGRlc3Ryb3lEcm9wcGFibGUoZHJvcFRhcmdldHMsIHRoaXMpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBfdHJpZ2dlcjogZnVuY3Rpb24oZXZlbnROYW1lLCBlKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxyXG5cdCAgICAgICAgICAgICAgICBkcmFnZ2FibGUgPSBkcmFnZ2FibGVzW3RoYXQub3B0aW9ucy5ncm91cF07XHJcblxyXG5cdCAgICAgICAgICAgIGlmIChkcmFnZ2FibGUpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQudHJpZ2dlcihldmVudE5hbWUsIGV4dGVuZCh7fSwgZS5ldmVudCwge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogZHJhZ2dhYmxlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BUYXJnZXQ6IGUuZHJvcFRhcmdldFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgX292ZXI6IGZ1bmN0aW9uKGUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLl90cmlnZ2VyKERSQUdFTlRFUiwgZSk7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIF9vdXQ6IGZ1bmN0aW9uKGUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLl90cmlnZ2VyKERSQUdMRUFWRSwgZSk7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIF9kcm9wOiBmdW5jdGlvbihlKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxyXG5cdCAgICAgICAgICAgICAgICBkcmFnZ2FibGUgPSBkcmFnZ2FibGVzW3RoYXQub3B0aW9ucy5ncm91cF07XHJcblxyXG5cdCAgICAgICAgICAgIGlmIChkcmFnZ2FibGUpIHtcclxuXHQgICAgICAgICAgICAgICAgZHJhZ2dhYmxlLmRyb3BwZWQgPSAhdGhhdC5fdHJpZ2dlcihEUk9QLCBlKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0pO1xyXG5cclxuXHQgICAgRHJvcFRhcmdldC5kZXN0cm95R3JvdXAgPSBmdW5jdGlvbihncm91cE5hbWUpIHtcclxuXHQgICAgICAgIHZhciBncm91cCA9IGRyb3BUYXJnZXRzW2dyb3VwTmFtZV0gfHwgZHJvcEFyZWFzW2dyb3VwTmFtZV0sXHJcblx0ICAgICAgICAgICAgaTtcclxuXHJcblx0ICAgICAgICBpZiAoZ3JvdXApIHtcclxuXHQgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgV2lkZ2V0LmZuLmRlc3Ryb3kuY2FsbChncm91cFtpXSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICBncm91cC5sZW5ndGggPSAwO1xyXG5cdCAgICAgICAgICAgIGRlbGV0ZSBkcm9wVGFyZ2V0c1tncm91cE5hbWVdO1xyXG5cdCAgICAgICAgICAgIGRlbGV0ZSBkcm9wQXJlYXNbZ3JvdXBOYW1lXTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHJcblx0ICAgIERyb3BUYXJnZXQuX2NhY2hlID0gZHJvcFRhcmdldHM7XHJcblxyXG5cdCAgICB2YXIgRHJvcFRhcmdldEFyZWEgPSBEcm9wVGFyZ2V0LmV4dGVuZCh7XHJcblx0ICAgICAgICBpbml0OiBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuXHQgICAgICAgICAgICBXaWRnZXQuZm4uaW5pdC5jYWxsKHRoYXQsIGVsZW1lbnQsIG9wdGlvbnMpO1xyXG5cclxuXHQgICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGF0Lm9wdGlvbnMuZ3JvdXA7XHJcblxyXG5cdCAgICAgICAgICAgIGlmICghKGdyb3VwIGluIGRyb3BBcmVhcykpIHtcclxuXHQgICAgICAgICAgICAgICAgZHJvcEFyZWFzW2dyb3VwXSA9IFsgdGhhdCBdO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGRyb3BBcmVhc1tncm91cF0ucHVzaCggdGhhdCApO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgZGVzdHJveURyb3BwYWJsZShkcm9wQXJlYXMsIHRoaXMpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBvcHRpb25zOiB7XHJcblx0ICAgICAgICAgICAgbmFtZTogXCJEcm9wVGFyZ2V0QXJlYVwiLFxyXG5cdCAgICAgICAgICAgIGdyb3VwOiBcImRlZmF1bHRcIixcclxuXHQgICAgICAgICAgICBmaWx0ZXI6IG51bGxcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSk7XHJcblxyXG5cdCAgICB2YXIgRHJhZ2dhYmxlID0gV2lkZ2V0LmV4dGVuZCh7XHJcblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xyXG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcblx0ICAgICAgICAgICAgV2lkZ2V0LmZuLmluaXQuY2FsbCh0aGF0LCBlbGVtZW50LCBvcHRpb25zKTtcclxuXHJcblx0ICAgICAgICAgICAgdGhhdC5fYWN0aXZhdGVkID0gZmFsc2U7XHJcblxyXG5cdCAgICAgICAgICAgIHRoYXQudXNlckV2ZW50cyA9IG5ldyBVc2VyRXZlbnRzKHRoYXQuZWxlbWVudCwge1xyXG5cdCAgICAgICAgICAgICAgICBnbG9iYWw6IHRydWUsXHJcblx0ICAgICAgICAgICAgICAgIGFsbG93U2VsZWN0aW9uOiB0cnVlLFxyXG5cdCAgICAgICAgICAgICAgICBmaWx0ZXI6IHRoYXQub3B0aW9ucy5maWx0ZXIsXHJcblx0ICAgICAgICAgICAgICAgIHRocmVzaG9sZDogdGhhdC5vcHRpb25zLmRpc3RhbmNlLFxyXG5cdCAgICAgICAgICAgICAgICBzdGFydDogcHJveHkodGhhdC5fc3RhcnQsIHRoYXQpLFxyXG5cdCAgICAgICAgICAgICAgICBob2xkOiBwcm94eSh0aGF0Ll9ob2xkLCB0aGF0KSxcclxuXHQgICAgICAgICAgICAgICAgbW92ZTogcHJveHkodGhhdC5fZHJhZywgdGhhdCksXHJcblx0ICAgICAgICAgICAgICAgIGVuZDogcHJveHkodGhhdC5fZW5kLCB0aGF0KSxcclxuXHQgICAgICAgICAgICAgICAgY2FuY2VsOiBwcm94eSh0aGF0Ll9jYW5jZWwsIHRoYXQpLFxyXG5cdCAgICAgICAgICAgICAgICBzZWxlY3Q6IHByb3h5KHRoYXQuX3NlbGVjdCwgdGhhdClcclxuXHQgICAgICAgICAgICB9KTtcclxuXHJcblx0ICAgICAgICAgICAgdGhhdC5fYWZ0ZXJFbmRIYW5kbGVyID0gcHJveHkodGhhdC5fYWZ0ZXJFbmQsIHRoYXQpO1xyXG5cdCAgICAgICAgICAgIHRoYXQuX2NhcHR1cmVFc2NhcGUgPSBwcm94eSh0aGF0Ll9jYXB0dXJlRXNjYXBlLCB0aGF0KTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgZXZlbnRzOiBbXHJcblx0ICAgICAgICAgICAgSE9MRCxcclxuXHQgICAgICAgICAgICBEUkFHU1RBUlQsXHJcblx0ICAgICAgICAgICAgRFJBRyxcclxuXHQgICAgICAgICAgICBEUkFHRU5ELFxyXG5cdCAgICAgICAgICAgIERSQUdDQU5DRUwsXHJcblx0ICAgICAgICAgICAgSElOVERFU1RST1lFRFxyXG5cdCAgICAgICAgXSxcclxuXHJcblx0ICAgICAgICBvcHRpb25zOiB7XHJcblx0ICAgICAgICAgICAgbmFtZTogXCJEcmFnZ2FibGVcIixcclxuXHQgICAgICAgICAgICBkaXN0YW5jZTogKCBrZW5kby5zdXBwb3J0LnRvdWNoID8gMCA6IDUpLFxyXG5cdCAgICAgICAgICAgIGdyb3VwOiBcImRlZmF1bHRcIixcclxuXHQgICAgICAgICAgICBjdXJzb3JPZmZzZXQ6IG51bGwsXHJcblx0ICAgICAgICAgICAgYXhpczogbnVsbCxcclxuXHQgICAgICAgICAgICBjb250YWluZXI6IG51bGwsXHJcblx0ICAgICAgICAgICAgZmlsdGVyOiBudWxsLFxyXG5cdCAgICAgICAgICAgIGlnbm9yZTogbnVsbCxcclxuXHQgICAgICAgICAgICBob2xkVG9EcmFnOiBmYWxzZSxcclxuXHQgICAgICAgICAgICBhdXRvU2Nyb2xsOiBmYWxzZSxcclxuXHQgICAgICAgICAgICBkcm9wcGVkOiBmYWxzZVxyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBjYW5jZWxIb2xkOiBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICB0aGlzLl9hY3RpdmF0ZWQgPSBmYWxzZTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgX2NhcHR1cmVFc2NhcGU6IGZ1bmN0aW9uKGUpIHtcclxuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG5cdCAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IGtlbmRvLmtleXMuRVNDKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoYXQuX3RyaWdnZXIoRFJBR0NBTkNFTCwgeyBldmVudDogZSB9KTtcclxuXHQgICAgICAgICAgICAgICAgdGhhdC51c2VyRXZlbnRzLmNhbmNlbCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgX3VwZGF0ZUhpbnQ6IGZ1bmN0aW9uKGUpIHtcclxuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXHJcblx0ICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzLFxyXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zID0gdGhhdC5vcHRpb25zLFxyXG5cdCAgICAgICAgICAgICAgICBib3VuZGFyaWVzID0gdGhhdC5ib3VuZGFyaWVzLFxyXG5cdCAgICAgICAgICAgICAgICBheGlzID0gb3B0aW9ucy5heGlzLFxyXG5cdCAgICAgICAgICAgICAgICBjdXJzb3JPZmZzZXQgPSB0aGF0Lm9wdGlvbnMuY3Vyc29yT2Zmc2V0O1xyXG5cclxuXHQgICAgICAgICAgICBpZiAoY3Vyc29yT2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMgPSB7IGxlZnQ6IGUueC5sb2NhdGlvbiArIGN1cnNvck9mZnNldC5sZWZ0LCB0b3A6IGUueS5sb2NhdGlvbiArIGN1cnNvck9mZnNldC50b3AgfTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGF0LmhpbnRPZmZzZXQubGVmdCArPSBlLnguZGVsdGE7XHJcblx0ICAgICAgICAgICAgICAgIHRoYXQuaGludE9mZnNldC50b3AgKz0gZS55LmRlbHRhO1xyXG5cdCAgICAgICAgICAgICAgICBjb29yZGluYXRlcyA9ICQuZXh0ZW5kKHt9LCB0aGF0LmhpbnRPZmZzZXQpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgaWYgKGJvdW5kYXJpZXMpIHtcclxuXHQgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMudG9wID0gd2l0aGluKGNvb3JkaW5hdGVzLnRvcCwgYm91bmRhcmllcy55KTtcclxuXHQgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMubGVmdCA9IHdpdGhpbihjb29yZGluYXRlcy5sZWZ0LCBib3VuZGFyaWVzLngpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgaWYgKGF4aXMgPT09IFwieFwiKSB7XHJcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSBjb29yZGluYXRlcy50b3A7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChheGlzID09PSBcInlcIikge1xyXG5cdCAgICAgICAgICAgICAgICBkZWxldGUgY29vcmRpbmF0ZXMubGVmdDtcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIHRoYXQuaGludC5jc3MoY29vcmRpbmF0ZXMpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBfc2hvdWxkSWdub3JlVGFyZ2V0OiBmdW5jdGlvbih0YXJnZXQpIHtcclxuXHQgICAgICAgICAgICB2YXIgaWdub3JlU2VsZWN0b3IgPSB0aGlzLm9wdGlvbnMuaWdub3JlO1xyXG5cdCAgICAgICAgICAgIHJldHVybiBpZ25vcmVTZWxlY3RvciAmJiAkKHRhcmdldCkuaXMoaWdub3JlU2VsZWN0b3IpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBfc2VsZWN0OiBmdW5jdGlvbihlKSB7XHJcblx0ICAgICAgICAgICAgaWYgKCF0aGlzLl9zaG91bGRJZ25vcmVUYXJnZXQoZS5ldmVudC50YXJnZXQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIF9zdGFydDogZnVuY3Rpb24oZSkge1xyXG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcclxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucyA9IHRoYXQub3B0aW9ucyxcclxuXHQgICAgICAgICAgICAgICAgY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXIgPyAkKG9wdGlvbnMuY29udGFpbmVyKTogbnVsbCxcclxuXHQgICAgICAgICAgICAgICAgaGludCA9IG9wdGlvbnMuaGludDtcclxuXHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3VsZElnbm9yZVRhcmdldChlLnRvdWNoLmluaXRpYWxUb3VjaCkgfHwgKG9wdGlvbnMuaG9sZFRvRHJhZyAmJiAhdGhhdC5fYWN0aXZhdGVkKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGF0LnVzZXJFdmVudHMuY2FuY2VsKCk7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIHRoYXQuY3VycmVudFRhcmdldCA9IGUudGFyZ2V0O1xyXG5cdCAgICAgICAgICAgIHRoYXQuY3VycmVudFRhcmdldE9mZnNldCA9IGdldE9mZnNldCh0aGF0LmN1cnJlbnRUYXJnZXQpO1xyXG5cclxuXHQgICAgICAgICAgICBpZiAoaGludCkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGhhdC5oaW50KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LmhpbnQuc3RvcCh0cnVlLCB0cnVlKS5yZW1vdmUoKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgdGhhdC5oaW50ID0ga2VuZG8uaXNGdW5jdGlvbihoaW50KSA/ICQoaGludC5jYWxsKHRoYXQsIHRoYXQuY3VycmVudFRhcmdldCkpIDogaGludDtcclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBnZXRPZmZzZXQodGhhdC5jdXJyZW50VGFyZ2V0KTtcclxuXHQgICAgICAgICAgICAgICAgdGhhdC5oaW50T2Zmc2V0ID0gb2Zmc2V0O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgdGhhdC5oaW50LmNzcygge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcclxuXHQgICAgICAgICAgICAgICAgICAgIHpJbmRleDogMjAwMDAsIC8vIHRoZSBXaW5kb3cncyB6LWluZGV4IGlzIDEwMDAwIGFuZCBjYW4gYmUgcmFpc2VkIGJlY2F1c2Ugb2Ygei1zdGFja2luZ1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdDogb2Zmc2V0LmxlZnQsXHJcblx0ICAgICAgICAgICAgICAgICAgICB0b3A6IG9mZnNldC50b3BcclxuXHQgICAgICAgICAgICAgICAgfSlcclxuXHQgICAgICAgICAgICAgICAgLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgdGhhdC5hbmd1bGFyKFwiY29tcGlsZVwiLCBmdW5jdGlvbigpe1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC5oaW50LnJlbW92ZUF0dHIoXCJuZy1yZXBlYXRcIik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2NvcGVUYXJnZXQgPSAkKGUudGFyZ2V0KTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIXNjb3BlVGFyZ2V0LmRhdGEoXCIkJGtlbmRvU2NvcGVcIikgJiYgc2NvcGVUYXJnZXQubGVuZ3RoKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVUYXJnZXQgPSBzY29wZVRhcmdldC5wYXJlbnQoKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiB0aGF0LmhpbnQuZ2V0KCksXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVGcm9tOiBzY29wZVRhcmdldC5kYXRhKFwiJCRrZW5kb1Njb3BlXCIpXHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIGRyYWdnYWJsZXNbb3B0aW9ucy5ncm91cF0gPSB0aGF0O1xyXG5cclxuXHQgICAgICAgICAgICB0aGF0LmRyb3BwZWQgPSBmYWxzZTtcclxuXHJcblx0ICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xyXG5cdCAgICAgICAgICAgICAgICB0aGF0LmJvdW5kYXJpZXMgPSBjb250YWluZXJCb3VuZGFyaWVzKGNvbnRhaW5lciwgdGhhdC5oaW50KTtcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKEtFWVVQLCB0aGF0Ll9jYXB0dXJlRXNjYXBlKTtcclxuXHJcblx0ICAgICAgICAgICAgaWYgKHRoYXQuX3RyaWdnZXIoRFJBR1NUQVJULCBlKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGF0LnVzZXJFdmVudHMuY2FuY2VsKCk7XHJcblx0ICAgICAgICAgICAgICAgIHRoYXQuX2FmdGVyRW5kKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICB0aGF0LnVzZXJFdmVudHMuY2FwdHVyZSgpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBfaG9sZDogZnVuY3Rpb24oZSkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuY3VycmVudFRhcmdldCA9IGUudGFyZ2V0O1xyXG5cclxuXHQgICAgICAgICAgICBpZiAodGhpcy5fdHJpZ2dlcihIT0xELCBlKSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLnVzZXJFdmVudHMuY2FuY2VsKCk7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZhdGVkID0gdHJ1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIF9kcmFnOiBmdW5jdGlvbihlKSB7XHJcblx0ICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuXHQgICAgICAgICAgICB2YXIgY3Vyc29yRWxlbWVudCA9IHRoaXMuX2VsZW1lbnRVbmRlckN1cnNvcihlKTtcclxuXHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvU2Nyb2xsICYmIHRoaXMuX2N1cnNvckVsZW1lbnQgIT09IGN1cnNvckVsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5fc2Nyb2xsYWJsZVBhcmVudCA9IGZpbmRTY3JvbGxhYmxlUGFyZW50KGN1cnNvckVsZW1lbnQpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jdXJzb3JFbGVtZW50ID0gY3Vyc29yRWxlbWVudDtcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIHRoaXMuX2xhc3RFdmVudCA9IGU7XHJcblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc01vdmVtZW50KGUsIGN1cnNvckVsZW1lbnQpO1xyXG5cclxuXHQgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9TY3JvbGwpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gY2hyb21lIHNlZW1zIHRvIHRyaWdnZXIgbW91c2Vtb3ZlIHdoZW4gbW91c2UgaXMgbW92ZWQgb3V0c2lkZSBvZiB0aGUgd2luZG93IChvdmVyIHRoZSBDaHJvbWUpLCB0b28uXHJcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zY3JvbGxhYmxlUGFyZW50WzBdKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdmVsb2NpdHkgPSBhdXRvU2Nyb2xsVmVsb2NpdHkoZS54LmxvY2F0aW9uLCBlLnkubG9jYXRpb24sIHNjcm9sbGFibGVWaWV3UG9ydCh0aGlzLl9zY3JvbGxhYmxlUGFyZW50KSk7XHJcblxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbENvbXBlbnN0YXRpb24gPSAkLmV4dGVuZCh7fSwgdGhpcy5oaW50T2Zmc2V0KTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbFZlbG9jaXR5ID0gdmVsb2NpdHk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHZlbG9jaXR5LnkgPT09IDAgJiYgdmVsb2NpdHkueCA9PT0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fc2Nyb2xsSW50ZXJ2YWwpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Njcm9sbEludGVydmFsID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZighdGhpcy5fc2Nyb2xsSW50ZXJ2YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY3JvbGxJbnRlcnZhbCA9IHNldEludGVydmFsKCQucHJveHkodGhpcywgXCJfYXV0b1Njcm9sbFwiKSwgNTApO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICBpZiAodGhpcy5oaW50KSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUhpbnQoZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBfcHJvY2Vzc01vdmVtZW50OiBmdW5jdGlvbihlLCBjdXJzb3JFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5fd2l0aERyb3BUYXJnZXQoY3Vyc29yRWxlbWVudCwgZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobGFzdERyb3BUYXJnZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsYXN0RHJvcFRhcmdldC5fdHJpZ2dlcihEUkFHTEVBVkUsIGV4dGVuZChlLCB7IGRyb3BUYXJnZXQ6ICQobGFzdERyb3BUYXJnZXQudGFyZ2V0RWxlbWVudCkgfSkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxhc3REcm9wVGFyZ2V0ID0gbnVsbDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgaWYgKGxhc3REcm9wVGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWxlbWVudCA9PT0gbGFzdERyb3BUYXJnZXQudGFyZ2V0RWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBsYXN0RHJvcFRhcmdldC5fdHJpZ2dlcihEUkFHTEVBVkUsIGV4dGVuZChlLCB7IGRyb3BUYXJnZXQ6ICQobGFzdERyb3BUYXJnZXQudGFyZ2V0RWxlbWVudCkgfSkpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICB0YXJnZXQuX3RyaWdnZXIoRFJBR0VOVEVSLCBleHRlbmQoZSwgeyBkcm9wVGFyZ2V0OiAkKHRhcmdldEVsZW1lbnQpIH0pKTtcclxuXHQgICAgICAgICAgICAgICAgbGFzdERyb3BUYXJnZXQgPSBleHRlbmQodGFyZ2V0LCB7IHRhcmdldEVsZW1lbnQ6IHRhcmdldEVsZW1lbnQgfSk7XHJcblx0ICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoRFJBRywgZXh0ZW5kKGUsIHsgZHJvcFRhcmdldDogbGFzdERyb3BUYXJnZXQsIGVsZW1lbnRVbmRlckN1cnNvcjogY3Vyc29yRWxlbWVudCB9KSk7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIF9hdXRvU2Nyb2xsOiBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fc2Nyb2xsYWJsZVBhcmVudFswXSxcclxuXHQgICAgICAgICAgICAgICAgdmVsb2NpdHkgPSB0aGlzLl9zY3JvbGxWZWxvY2l0eSxcclxuXHQgICAgICAgICAgICAgICAgY29tcGVuc2F0aW9uID0gdGhpcy5fc2Nyb2xsQ29tcGVuc3RhdGlvbjtcclxuXHJcblx0ICAgICAgICAgICAgaWYgKCFwYXJlbnQpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgdmFyIGN1cnNvckVsZW1lbnQgPSB0aGlzLl9lbGVtZW50VW5kZXJDdXJzb3IodGhpcy5fbGFzdEV2ZW50KTtcclxuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzTW92ZW1lbnQodGhpcy5fbGFzdEV2ZW50LCBjdXJzb3JFbGVtZW50KTtcclxuXHJcblx0ICAgICAgICAgICAgdmFyIHlJc1Njcm9sbGFibGUsIHhJc1Njcm9sbGFibGU7XHJcblxyXG5cdCAgICAgICAgICAgIHZhciBpc1Jvb3ROb2RlID0gcGFyZW50ID09PSBzY3JvbGxhYmxlUm9vdCgpWzBdO1xyXG5cclxuXHQgICAgICAgICAgICBpZiAoaXNSb290Tm9kZSkge1xyXG5cdCAgICAgICAgICAgICAgICB5SXNTY3JvbGxhYmxlID0gZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQgPiAkd2luZG93LmhlaWdodCgpO1xyXG5cdCAgICAgICAgICAgICAgICB4SXNTY3JvbGxhYmxlID0gZG9jdW1lbnQuYm9keS5zY3JvbGxXaWR0aCA+ICR3aW5kb3cud2lkdGgoKTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB5SXNTY3JvbGxhYmxlID0gcGFyZW50Lm9mZnNldEhlaWdodCA8PSBwYXJlbnQuc2Nyb2xsSGVpZ2h0O1xyXG5cdCAgICAgICAgICAgICAgICB4SXNTY3JvbGxhYmxlID0gcGFyZW50Lm9mZnNldFdpZHRoIDw9IHBhcmVudC5zY3JvbGxXaWR0aDtcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIHZhciB5RGVsdGEgPSBwYXJlbnQuc2Nyb2xsVG9wICsgdmVsb2NpdHkueTtcclxuXHQgICAgICAgICAgICB2YXIgeUluQm91bmRzID0geUlzU2Nyb2xsYWJsZSAmJiB5RGVsdGEgPiAwICYmIHlEZWx0YSA8IHBhcmVudC5zY3JvbGxIZWlnaHQ7XHJcblxyXG5cdCAgICAgICAgICAgIHZhciB4RGVsdGEgPSBwYXJlbnQuc2Nyb2xsTGVmdCArIHZlbG9jaXR5Lng7XHJcblx0ICAgICAgICAgICAgdmFyIHhJbkJvdW5kcyA9IHhJc1Njcm9sbGFibGUgJiYgeERlbHRhID4gMCAmJiB4RGVsdGEgPCBwYXJlbnQuc2Nyb2xsV2lkdGg7XHJcblxyXG5cdCAgICAgICAgICAgIGlmICh5SW5Cb3VuZHMpIHtcclxuXHQgICAgICAgICAgICAgICAgcGFyZW50LnNjcm9sbFRvcCArPSB2ZWxvY2l0eS55O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgaWYgKHhJbkJvdW5kcykge1xyXG5cdCAgICAgICAgICAgICAgICBwYXJlbnQuc2Nyb2xsTGVmdCArPSB2ZWxvY2l0eS54O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaGludCAmJiBpc1Jvb3ROb2RlICYmICh4SW5Cb3VuZHMgfHwgeUluQm91bmRzKSkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoeUluQm91bmRzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjb21wZW5zYXRpb24udG9wICs9IHZlbG9jaXR5Lnk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgIGlmICh4SW5Cb3VuZHMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGNvbXBlbnNhdGlvbi5sZWZ0ICs9IHZlbG9jaXR5Lng7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuaGludC5jc3MoY29tcGVuc2F0aW9uKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIF9lbmQ6IGZ1bmN0aW9uKGUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLl93aXRoRHJvcFRhcmdldCh0aGlzLl9lbGVtZW50VW5kZXJDdXJzb3IoZSksIGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0RWxlbWVudCkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodGFyZ2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0YXJnZXQuX2Ryb3AoZXh0ZW5kKHt9LCBlLCB7IGRyb3BUYXJnZXQ6ICQodGFyZ2V0RWxlbWVudCkgfSkpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbGFzdERyb3BUYXJnZXQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgICAgIHRoaXMuX2NhbmNlbCh0aGlzLl90cmlnZ2VyKERSQUdFTkQsIGUpKTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgX2NhbmNlbDogZnVuY3Rpb24oaXNEZWZhdWx0UHJldmVudGVkKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuXHQgICAgICAgICAgICB0aGF0Ll9zY3JvbGxhYmxlUGFyZW50ID0gbnVsbDtcclxuXHQgICAgICAgICAgICB0aGlzLl9jdXJzb3JFbGVtZW50ID0gbnVsbDtcclxuXHQgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3Njcm9sbEludGVydmFsKTtcclxuXHQgICAgICAgICAgICB0aGF0Ll9hY3RpdmF0ZWQgPSBmYWxzZTtcclxuXHJcblx0ICAgICAgICAgICAgaWYgKHRoYXQuaGludCAmJiAhdGhhdC5kcm9wcGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LmhpbnQuc3RvcCh0cnVlLCB0cnVlKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWZhdWx0UHJldmVudGVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fYWZ0ZXJFbmRIYW5kbGVyKCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuaGludC5hbmltYXRlKHRoYXQuY3VycmVudFRhcmdldE9mZnNldCwgXCJmYXN0XCIsIHRoYXQuX2FmdGVyRW5kSGFuZGxlcik7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIH0sIDApO1xyXG5cclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9hZnRlckVuZCgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgX3RyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50TmFtZSwgZSkge1xyXG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoYXQudHJpZ2dlcihcclxuXHQgICAgICAgICAgICAgICAgZXZlbnROYW1lLCBleHRlbmQoXHJcblx0ICAgICAgICAgICAgICAgIHt9LFxyXG5cdCAgICAgICAgICAgICAgICBlLmV2ZW50LFxyXG5cdCAgICAgICAgICAgICAgICB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB4OiBlLngsXHJcblx0ICAgICAgICAgICAgICAgICAgICB5OiBlLnksXHJcblx0ICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB0aGF0LmN1cnJlbnRUYXJnZXQsXHJcblx0ICAgICAgICAgICAgICAgICAgICBpbml0aWFsVGFyZ2V0OiBlLnRvdWNoID8gZS50b3VjaC5pbml0aWFsVG91Y2ggOiBudWxsLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgZHJvcFRhcmdldDogZS5kcm9wVGFyZ2V0LFxyXG5cdCAgICAgICAgICAgICAgICAgICAgZWxlbWVudFVuZGVyQ3Vyc29yOiBlLmVsZW1lbnRVbmRlckN1cnNvclxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgKSk7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIF9lbGVtZW50VW5kZXJDdXJzb3I6IGZ1bmN0aW9uKGUpIHtcclxuXHQgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZWxlbWVudFVuZGVyQ3Vyc29yKGUpLFxyXG5cdCAgICAgICAgICAgICAgICBoaW50ID0gdGhpcy5oaW50O1xyXG5cclxuXHQgICAgICAgICAgICBpZiAoaGludCAmJiBjb250YWlucyhoaW50WzBdLCB0YXJnZXQpKSB7XHJcblx0ICAgICAgICAgICAgICAgIGhpbnQuaGlkZSgpO1xyXG5cdCAgICAgICAgICAgICAgICB0YXJnZXQgPSBlbGVtZW50VW5kZXJDdXJzb3IoZSk7XHJcblx0ICAgICAgICAgICAgICAgIC8vIElFOCBkb2VzIG5vdCByZXR1cm4gdGhlIGVsZW1lbnQgaW4gaWZyYW1lIGZyb20gZmlyc3QgYXR0ZW1wdFxyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRhcmdldCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gZWxlbWVudFVuZGVyQ3Vyc29yKGUpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGhpbnQuc2hvdygpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgX3dpdGhEcm9wVGFyZ2V0OiBmdW5jdGlvbihlbGVtZW50LCBjYWxsYmFjaykge1xyXG5cdCAgICAgICAgICAgIHZhciByZXN1bHQsXHJcblx0ICAgICAgICAgICAgICAgIGdyb3VwID0gdGhpcy5vcHRpb25zLmdyb3VwLFxyXG5cdCAgICAgICAgICAgICAgICB0YXJnZXRzID0gZHJvcFRhcmdldHNbZ3JvdXBdLFxyXG5cdCAgICAgICAgICAgICAgICBhcmVhcyA9IGRyb3BBcmVhc1tncm91cF07XHJcblxyXG5cdCAgICAgICAgICAgIGlmICh0YXJnZXRzICYmIHRhcmdldHMubGVuZ3RoIHx8IGFyZWFzICYmIGFyZWFzLmxlbmd0aCkge1xyXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBjaGVja1RhcmdldChlbGVtZW50LCB0YXJnZXRzLCBhcmVhcyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXN1bHQudGFyZ2V0LCByZXN1bHQudGFyZ2V0RWxlbWVudCk7XHJcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcclxuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG5cdCAgICAgICAgICAgIFdpZGdldC5mbi5kZXN0cm95LmNhbGwodGhhdCk7XHJcblxyXG5cdCAgICAgICAgICAgIHRoYXQuX2FmdGVyRW5kKCk7XHJcblxyXG5cdCAgICAgICAgICAgIHRoYXQudXNlckV2ZW50cy5kZXN0cm95KCk7XHJcblxyXG5cdCAgICAgICAgICAgIHRoaXMuX3Njcm9sbGFibGVQYXJlbnQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgIHRoaXMuX2N1cnNvckVsZW1lbnQgPSBudWxsO1xyXG5cdCAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fc2Nyb2xsSW50ZXJ2YWwpO1xyXG5cclxuXHQgICAgICAgICAgICB0aGF0LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBfYWZ0ZXJFbmQ6IGZ1bmN0aW9uKCkge1xyXG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuXHJcblx0ICAgICAgICAgICAgaWYgKHRoYXQuaGludCkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGF0LmhpbnQucmVtb3ZlKCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICBkZWxldGUgZHJhZ2dhYmxlc1t0aGF0Lm9wdGlvbnMuZ3JvdXBdO1xyXG5cclxuXHQgICAgICAgICAgICB0aGF0LnRyaWdnZXIoXCJkZXN0cm95XCIpO1xyXG5cdCAgICAgICAgICAgIHRoYXQudHJpZ2dlcihISU5UREVTVFJPWUVEKTtcclxuXHQgICAgICAgICAgICAkKGRvY3VtZW50KS5vZmYoS0VZVVAsIHRoYXQuX2NhcHR1cmVFc2NhcGUpO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9KTtcclxuXHJcblx0ICAgIGtlbmRvLnVpLnBsdWdpbihEcm9wVGFyZ2V0KTtcclxuXHQgICAga2VuZG8udWkucGx1Z2luKERyb3BUYXJnZXRBcmVhKTtcclxuXHQgICAga2VuZG8udWkucGx1Z2luKERyYWdnYWJsZSk7XHJcblx0ICAgIGtlbmRvLlRhcENhcHR1cmUgPSBUYXBDYXB0dXJlO1xyXG5cdCAgICBrZW5kby5jb250YWluZXJCb3VuZGFyaWVzID0gY29udGFpbmVyQm91bmRhcmllcztcclxuXHJcblx0ICAgIGV4dGVuZChrZW5kby51aSwge1xyXG5cdCAgICAgICAgUGFuZTogUGFuZSxcclxuXHQgICAgICAgIFBhbmVEaW1lbnNpb25zOiBQYW5lRGltZW5zaW9ucyxcclxuXHQgICAgICAgIE1vdmFibGU6IE1vdmFibGVcclxuXHQgICAgfSk7XHJcblxyXG5cdCAgICBmdW5jdGlvbiBzY3JvbGxhYmxlVmlld1BvcnQoZWxlbWVudCkge1xyXG5cdCAgICAgICAgdmFyIHJvb3QgPSBzY3JvbGxhYmxlUm9vdCgpWzBdLFxyXG5cdCAgICAgICAgICAgIG9mZnNldCxcclxuXHQgICAgICAgICAgICB0b3AsXHJcblx0ICAgICAgICAgICAgbGVmdDtcclxuXHJcblx0ICAgICAgICBpZiAoZWxlbWVudFswXSA9PT0gcm9vdCkge1xyXG5cdCAgICAgICAgICAgIHRvcCA9IHJvb3Quc2Nyb2xsVG9wO1xyXG5cdCAgICAgICAgICAgIGxlZnQgPSByb290LnNjcm9sbExlZnQ7XHJcblxyXG5cdCAgICAgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgICAgIHRvcDogdG9wLFxyXG5cdCAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxyXG5cdCAgICAgICAgICAgICAgICBib3R0b206IHRvcCArICR3aW5kb3cuaGVpZ2h0KCksXHJcblx0ICAgICAgICAgICAgICAgIHJpZ2h0OiBsZWZ0ICsgJHdpbmRvdy53aWR0aCgpXHJcblx0ICAgICAgICAgICAgfTtcclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgb2Zmc2V0ID0gZWxlbWVudC5vZmZzZXQoKTtcclxuXHQgICAgICAgICAgICBvZmZzZXQuYm90dG9tID0gb2Zmc2V0LnRvcCArIGVsZW1lbnQuaGVpZ2h0KCk7XHJcblx0ICAgICAgICAgICAgb2Zmc2V0LnJpZ2h0ID0gIG9mZnNldC5sZWZ0ICsgZWxlbWVudC53aWR0aCgpO1xyXG5cdCAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGZ1bmN0aW9uIHNjcm9sbGFibGVSb290KCkge1xyXG5cdCAgICAgICAgcmV0dXJuICQoa2VuZG8uc3VwcG9ydC5icm93c2VyLmVkZ2UgfHwga2VuZG8uc3VwcG9ydC5icm93c2VyLnNhZmFyaSA/IGRvY3VtZW50LmJvZHkgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBmdW5jdGlvbiBmaW5kU2Nyb2xsYWJsZVBhcmVudChlbGVtZW50KSB7XHJcblx0ICAgICAgICB2YXIgcm9vdCA9IHNjcm9sbGFibGVSb290KCk7XHJcblxyXG5cdCAgICAgICAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkgfHwgZWxlbWVudCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XHJcblx0ICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgdmFyIHBhcmVudCA9ICQoZWxlbWVudClbMF07XHJcblxyXG5cdCAgICAgICAgd2hpbGUgKHBhcmVudCAmJiAha2VuZG8uaXNTY3JvbGxhYmxlKHBhcmVudCkgJiYgcGFyZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XHJcblx0ICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XHJcblx0ICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgaWYgKHBhcmVudCA9PT0gZG9jdW1lbnQuYm9keSkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiByb290O1xyXG5cdCAgICAgICAgfVxyXG5cclxuXHQgICAgICAgIHJldHVybiAkKHBhcmVudCk7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGZ1bmN0aW9uIGF1dG9TY3JvbGxWZWxvY2l0eShtb3VzZVgsIG1vdXNlWSwgcmVjdCkge1xyXG5cdCAgICAgICAgdmFyIHZlbG9jaXR5ID0geyB4OiAwLCB5OiAwIH07XHJcblxyXG5cdCAgICAgICAgdmFyIEFVVE9fU0NST0xMX0FSRUEgPSA1MDtcclxuXHJcblx0ICAgICAgICBpZiAobW91c2VYIC0gcmVjdC5sZWZ0IDwgQVVUT19TQ1JPTExfQVJFQSkge1xyXG5cdCAgICAgICAgICAgIHZlbG9jaXR5LnggPSAtKEFVVE9fU0NST0xMX0FSRUEgLSAobW91c2VYIC0gcmVjdC5sZWZ0KSk7XHJcblx0ICAgICAgICB9IGVsc2UgaWYgKHJlY3QucmlnaHQgLSBtb3VzZVggPCBBVVRPX1NDUk9MTF9BUkVBKSB7XHJcblx0ICAgICAgICAgICAgdmVsb2NpdHkueCA9IEFVVE9fU0NST0xMX0FSRUEgLSAocmVjdC5yaWdodCAtIG1vdXNlWCk7XHJcblx0ICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgaWYgKG1vdXNlWSAtIHJlY3QudG9wIDwgQVVUT19TQ1JPTExfQVJFQSkge1xyXG5cdCAgICAgICAgICAgIHZlbG9jaXR5LnkgPSAtKEFVVE9fU0NST0xMX0FSRUEgLSAobW91c2VZIC0gcmVjdC50b3ApKTtcclxuXHQgICAgICAgIH0gZWxzZSBpZiAocmVjdC5ib3R0b20gLSBtb3VzZVkgPCBBVVRPX1NDUk9MTF9BUkVBKSB7XHJcblx0ICAgICAgICAgICAgdmVsb2NpdHkueSA9IEFVVE9fU0NST0xMX0FSRUEgLSAocmVjdC5ib3R0b20gLSBtb3VzZVkpO1xyXG5cdCAgICAgICAgfVxyXG5cclxuXHQgICAgICAgIHJldHVybiB2ZWxvY2l0eTtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgLy8gZXhwb3J0IGZvciB0ZXN0aW5nXHJcblx0ICAgIGtlbmRvLnVpLkRyYWdnYWJsZS51dGlscyA9IHtcclxuXHQgICAgICAgIGF1dG9TY3JvbGxWZWxvY2l0eTogYXV0b1Njcm9sbFZlbG9jaXR5LFxyXG5cdCAgICAgICAgc2Nyb2xsYWJsZVZpZXdQb3J0OiBzY3JvbGxhYmxlVmlld1BvcnQsXHJcblx0ICAgICAgICBmaW5kU2Nyb2xsYWJsZVBhcmVudDogZmluZFNjcm9sbGFibGVQYXJlbnRcclxuXHQgICAgfTtcclxuXHJcblx0IH0pKHdpbmRvdy5rZW5kby5qUXVlcnkpO1xyXG5cclxuXHRyZXR1cm4gd2luZG93LmtlbmRvO1xyXG5cclxuXHR9LCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcclxuXG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///b4c182ea2e2a8af62a4a\n");

/***/ }),

/***/ "c138e55a31f3f8960e99":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYzEzOGU1NWEzMWYzZjg5NjBlOTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///c138e55a31f3f8960e99\n");

/***/ }),

/***/ "c4b523a40f8c9d1f237b":
/*!****************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.data.odata.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1049);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 1004:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.core */ \"46d3985e259824d97676\");\n\n/***/ }),\n\n/***/ 1049:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1004) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: \"data.odata\",\n\t    name: \"OData\",\n\t    category: \"framework\",\n\t    depends: [ \"core\" ],\n\t    hidden: true\n\t};\n\n\t(function($, undefined) {\n\t    var kendo = window.kendo,\n\t        extend = $.extend,\n\t        NEWLINE = \"\\r\\n\",\n\t        DOUBLELINE = \"\\r\\n\\r\\n\",\n\t        isFunction = kendo.isFunction,\n\t        odataFilters = {\n\t            eq: \"eq\",\n\t            neq: \"ne\",\n\t            gt: \"gt\",\n\t            gte: \"ge\",\n\t            lt: \"lt\",\n\t            lte: \"le\",\n\t            contains : \"substringof\",\n\t            doesnotcontain: \"substringof\",\n\t            endswith: \"endswith\",\n\t            startswith: \"startswith\",\n\t            isnull: \"eq\",\n\t            isnotnull: \"ne\",\n\t            isnullorempty: \"eq\",\n\t            isnotnullorempty: \"ne\",\n\t            isempty: \"eq\",\n\t            isnotempty: \"ne\"\n\t        },\n\t        odataFiltersVersionFour = extend({}, odataFilters, {\n\t            contains: \"contains\"\n\t        }),\n\t        mappers = {\n\t            pageSize: $.noop,\n\t            page: $.noop,\n\t            filter: function(params, filter, useVersionFour) {\n\t                if (filter) {\n\t                    filter = toOdataFilter(filter, useVersionFour);\n\t                    if (filter) {\n\t                        params.$filter = filter;\n\t                    }\n\t                }\n\t            },\n\t            sort: function(params, orderby) {\n\t                var expr = $.map(orderby, function(value) {\n\t                    var order = value.field.replace(/\\./g, \"/\");\n\n\t                    if (value.dir === \"desc\") {\n\t                        order += \" desc\";\n\t                    }\n\n\t                    return order;\n\t                }).join(\",\");\n\n\t                if (expr) {\n\t                    params.$orderby = expr;\n\t                }\n\t            },\n\t            skip: function(params, skip) {\n\t                if (skip) {\n\t                    params.$skip = skip;\n\t                }\n\t            },\n\t            take: function(params, take) {\n\t                if (take) {\n\t                    params.$top = take;\n\t                }\n\t            }\n\t        },\n\t        defaultDataType = {\n\t            read: {\n\t                dataType: \"jsonp\"\n\t            }\n\t        };\n\n\t    function toOdataFilter(filter, useOdataFour) {\n\t        var result = [],\n\t            logic = filter.logic || \"and\",\n\t            idx,\n\t            length,\n\t            field,\n\t            type,\n\t            format,\n\t            operator,\n\t            value,\n\t            ignoreCase,\n\t            filters = filter.filters;\n\n\t        for (idx = 0, length = filters.length; idx < length; idx++) {\n\t            filter = filters[idx];\n\t            field = filter.field;\n\t            value = filter.value;\n\t            operator = filter.operator;\n\n\t            if (filter.filters) {\n\t                filter = toOdataFilter(filter, useOdataFour);\n\t            } else {\n\t                ignoreCase = filter.ignoreCase;\n\t                field = field.replace(/\\./g, \"/\");\n\t                filter = odataFilters[operator];\n\t                if (useOdataFour) {\n\t                    filter = odataFiltersVersionFour[operator];\n\t                }\n\n\t                if (operator === \"isnullorempty\") {\n\t                    filter = kendo.format(\"{0} {1} null or {0} {1} ''\", field, filter);\n\t                } else if(operator === \"isnotnullorempty\") {\n\t                    filter = kendo.format(\"{0} {1} null and {0} {1} ''\", field, filter);\n\t                } else if (operator === \"isnull\" || operator === \"isnotnull\") {\n\t                    filter = kendo.format(\"{0} {1} null\", field, filter);\n\t                } else if (operator === \"isempty\" || operator === \"isnotempty\") {\n\t                    filter = kendo.format(\"{0} {1} ''\", field, filter);\n\t                } else if (filter && value !== undefined) {\n\t                    type = $.type(value);\n\t                    if (type === \"string\") {\n\t                        format = \"'{1}'\";\n\t                        value = value.replace(/'/g, \"''\");\n\n\t                        if (ignoreCase === true) {\n\t                            field = \"tolower(\" + field + \")\";\n\t                        }\n\n\t                    } else if (type === \"date\") {\n\t                        if (useOdataFour) {\n\t                            format = \"{1:yyyy-MM-ddTHH:mm:ss+00:00}\";\n\t                            value = kendo.timezone.apply(value, 'Etc/UTC');\n\t                        } else {\n\t                            format = \"datetime'{1:yyyy-MM-ddTHH:mm:ss}'\";\n\t                        }\n\t                    } else {\n\t                        format = \"{1}\";\n\t                    }\n\n\t                    if (filter.length > 3) {\n\t                        if (filter !== \"substringof\") {\n\t                            format = \"{0}({2},\" + format + \")\";\n\t                        } else {\n\t                            format = \"{0}(\" + format + \",{2})\";\n\t                            if (operator === \"doesnotcontain\") {\n\t                                if (useOdataFour) {\n\t                                    format = \"{0}({2},'{1}') eq -1\";\n\t                                    filter = \"indexof\";\n\t                                } else {\n\t                                    format += \" eq false\";\n\t                                }\n\t                            }\n\t                        }\n\t                    } else {\n\t                        format = \"{2} {0} \" + format;\n\t                    }\n\n\t                    filter = kendo.format(format, filter, value, field);\n\t                }\n\t            }\n\n\t            result.push(filter);\n\t        }\n\n\t        filter = result.join(\" \" + logic + \" \");\n\n\t        if (result.length > 1) {\n\t            filter = \"(\" + filter + \")\";\n\t        }\n\n\t        return filter;\n\t    }\n\n\t    function stripMetadata(obj) {\n\t        for (var name in obj) {\n\t            if(name.indexOf(\"@odata\") === 0) {\n\t                delete obj[name];\n\t            }\n\t        }\n\t    }\n\n\t    function hex16() {\n\t        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substr(1);\n\t    }\n\n\t    function createBoundary(prefix) {\n\t        return prefix + hex16() + '-' + hex16() + '-' + hex16();\n\t    }\n\n\t    function createDelimeter(boundary, close) {\n\t        var result = NEWLINE + \"--\" + boundary;\n\n\t        if (close) {\n\t            result += \"--\";\n\t        }\n\n\t        return result;\n\t    }\n\n\t    function createCommand(transport, item, httpVerb, command) {\n\t         var transportUrl = transport.options[command].url;\n\t         var commandPrefix = kendo.format(\"{0} \", httpVerb);\n\n\t         if (isFunction(transportUrl)) {\n\t             return commandPrefix + transportUrl(item);\n\t         } else {\n\t             return commandPrefix + transportUrl;\n\t         }\n\t    }\n\n\t    function getOperationHeader(changeset, changeId) {\n\t        var header = \"\";\n\n\t        header += createDelimeter(changeset, false);\n\t        header += NEWLINE + 'Content-Type: application/http';\n\t        header += NEWLINE + 'Content-Transfer-Encoding: binary';\n\t        header += NEWLINE + 'Content-ID: ' + changeId;\n\n\t        return header;\n\t    }\n\n\t    function getOperationContent(item) {\n\t        var content = \"\";\n\n\t        content += NEWLINE + \"Content-Type: application/json;odata=minimalmetadata\";\n\t        content += NEWLINE + \"Prefer: return=representation\";\n\t        content += DOUBLELINE + kendo.stringify(item);\n\n\t        return content;\n\t    }\n\n\t    function getOperations(collection, changeset, changeId, command, transport, skipContent) {\n\t        var requestBody = \"\";\n\n\t        for (var i = 0; i < collection.length; i++) {\n\t            requestBody += getOperationHeader(changeset, changeId);\n\t            requestBody += DOUBLELINE + createCommand(transport, collection[i], transport.options[command].type, command) + ' HTTP/1.1';\n\t            if (!skipContent) {\n\t                requestBody += getOperationContent(collection[i]);\n\t            }\n\t            requestBody += NEWLINE;\n\t            changeId++;\n\t        }\n\n\t        return requestBody;\n\t    }\n\n\t    function processCollection(colection, boundary, changeset, changeId, transport, command, skipContent) {\n\t        var requestBody = \"\";\n\n\t        requestBody += getBoundary(boundary, changeset);\n\t        requestBody += getOperations(colection, changeset, changeId, command, transport, skipContent);\n\t        requestBody += createDelimeter(changeset, true);\n\t        requestBody += NEWLINE;\n\n\t        return requestBody;\n\t    }\n\n\t    function getBoundary(boundary,changeset) {\n\t        var requestBody = \"\";\n\n\t        requestBody += \"--\" + boundary + NEWLINE;\n\t        requestBody += \"Content-Type: multipart/mixed; boundary=\" + changeset + NEWLINE;\n\n\t        return requestBody;\n\t    }\n\n\t    function createBatchRequest(transport, colections) {\n\t        var options = {};\n\t        var boundary = createBoundary(\"sf_batch_\");\n\t        var requestBody = \"\";\n\t        var changeId = 0;\n\t        var batchURL = transport.options.batch.url;\n\t        var changeset = createBoundary(\"sf_changeset_\");\n\n\t        options.type = transport.options.batch.type;\n\t        options.url = isFunction(batchURL) ? batchURL() : batchURL;\n\t        options.headers = {\n\t            \"Content-Type\": \"multipart/mixed; boundary=\" + boundary\n\t        };\n\n\t        if (colections.updated.length) {\n\t            requestBody += processCollection(colections.updated, boundary, changeset, changeId, transport, \"update\", false);\n\t            changeId += colections.updated.length;\n\t            changeset = createBoundary(\"sf_changeset_\");\n\t        }\n\n\t        if (colections.destroyed.length) {\n\t            requestBody += processCollection(colections.destroyed, boundary, changeset, changeId, transport, \"destroy\", true);\n\t            changeId += colections.destroyed.length;\n\t            changeset = createBoundary(\"sf_changeset_\");\n\t        }\n\n\t        if (colections.created.length) {\n\t            requestBody += processCollection(colections.created, boundary, changeset, changeId, transport, \"create\", false);\n\t        }\n\n\t        requestBody += createDelimeter(boundary, true);\n\n\t        options.data = requestBody;\n\n\t        return options;\n\t    }\n\n\t    function parseBatchResponse(responseText) {\n\t        var responseMarkers = responseText.match(/--changesetresponse_[a-z0-9-]+$/gm);\n\t        var markerIndex = 0;\n\t        var collections = [];\n\t        var changeBody;\n\t        var status;\n\t        var code;\n\t        var marker;\n\t        var jsonModel;\n\n\t        collections.push({ models: [], passed: true });\n\n\t        for (var i = 0; i < responseMarkers.length; i++) {\n\t            marker = responseMarkers[i];\n\t            if (marker.lastIndexOf('--', marker.length - 1)) {\n\t                if (i < responseMarkers.length - 1) {\n\t                    collections.push({ models: [], passed: true });\n\t                }\n\t                continue;\n\t            }\n\n\t            if (!markerIndex) {\n\t                markerIndex = responseText.indexOf(marker);\n\t            } else {\n\t                markerIndex = responseText.indexOf(marker, markerIndex + marker.length);\n\t            }\n\n\t            changeBody = responseText.substring(markerIndex, responseText.indexOf(\"--\", markerIndex + 1));\n\t            status = changeBody.match(/^HTTP\\/1\\.\\d (\\d{3}) (.*)$/gm).pop();\n\t            code = kendo.parseFloat(status.match(/\\d{3}/g).pop());\n\n\t            if (code >= 200 && code <= 299) {\n\t                jsonModel = changeBody.match(/\\{.*\\}/gm);\n\t                if (jsonModel) {\n\t                    collections[collections.length - 1].models.push(JSON.parse(jsonModel[0]));\n\t                }\n\t            } else {\n\t                collections[collections.length - 1].passed = false;\n\t            }\n\n\t        }\n\n\t        return collections;\n\t    }\n\n\t    extend(true, kendo.data, {\n\t        schemas: {\n\t            odata: {\n\t                type: \"json\",\n\t                data: function(data) {\n\t                    return data.d.results || [data.d];\n\t                },\n\t                total: \"d.__count\"\n\t            }\n\t        },\n\t        transports: {\n\t            odata: {\n\t                read: {\n\t                    cache: true, // to prevent jQuery from adding cache buster\n\t                    dataType: \"jsonp\",\n\t                    jsonp: \"$callback\"\n\t                },\n\t                update: {\n\t                    cache: true,\n\t                    dataType: \"json\",\n\t                    contentType: \"application/json\", // to inform the server the the request body is JSON encoded\n\t                    type: \"PUT\" // can be PUT or MERGE\n\t                },\n\t                create: {\n\t                    cache: true,\n\t                    dataType: \"json\",\n\t                    contentType: \"application/json\",\n\t                    type: \"POST\" // must be POST to create new entity\n\t                },\n\t                destroy: {\n\t                    cache: true,\n\t                    dataType: \"json\",\n\t                    type: \"DELETE\"\n\t                },\n\t                parameterMap: function(options, type, useVersionFour) {\n\t                    var params,\n\t                        value,\n\t                        option,\n\t                        dataType;\n\n\t                    options = options || {};\n\t                    type = type || \"read\";\n\t                    dataType = (this.options || defaultDataType)[type];\n\t                    dataType = dataType ? dataType.dataType : \"json\";\n\n\t                    if (type === \"read\") {\n\t                        params = {\n\t                            $inlinecount: \"allpages\"\n\t                        };\n\n\t                        if (dataType != \"json\") {\n\t                            params.$format = \"json\";\n\t                        }\n\n\t                        for (option in options) {\n\t                            if (mappers[option]) {\n\t                                mappers[option](params, options[option], useVersionFour);\n\t                            } else {\n\t                                params[option] = options[option];\n\t                            }\n\t                        }\n\t                    } else {\n\t                        if (dataType !== \"json\") {\n\t                            throw new Error(\"Only json dataType can be used for \" + type + \" operation.\");\n\t                        }\n\n\t                        if (type !== \"destroy\") {\n\t                            for (option in options) {\n\t                                value = options[option];\n\t                                if (typeof value === \"number\") {\n\t                                    options[option] = value + \"\";\n\t                                }\n\t                            }\n\n\t                            params = kendo.stringify(options);\n\t                        }\n\t                    }\n\n\t                    return params;\n\t                }\n\t            }\n\t        }\n\t    });\n\n\t    extend(true, kendo.data, {\n\t        schemas: {\n\t            \"odata-v4\": {\n\t                type: \"json\",\n\t                data: function(data) {\n\t                    if ($.isArray(data)) {\n\t                        for (var i = 0; i < data.length; i++) {\n\t                            stripMetadata(data[i]);\n\t                        }\n\t                        return data;\n\t                    } else {\n\t                        data = $.extend({}, data);\n\t                        stripMetadata(data);\n\n\t                        if (data.value) {\n\t                            return data.value;\n\t                        }\n\t                        return [data];\n\t                    }\n\t                },\n\t                total: function(data) {\n\t                    return data[\"@odata.count\"];\n\t                }\n\t            }\n\t        },\n\t        transports: {\n\t            \"odata-v4\": {\n\t                batch: {\n\t                    type: \"POST\"\n\t                },\n\t                read: {\n\t                    cache: true, // to prevent jQuery from adding cache buster\n\t                    dataType: \"json\"\n\t                },\n\t                update: {\n\t                    cache: true,\n\t                    dataType: \"json\",\n\t                    contentType: \"application/json;IEEE754Compatible=true\", // to inform the server the the request body is JSON encoded\n\t                    type: \"PUT\" // can be PUT or MERGE\n\t                },\n\t                create: {\n\t                    cache: true,\n\t                    dataType: \"json\",\n\t                    contentType: \"application/json;IEEE754Compatible=true\",\n\t                    type: \"POST\" // must be POST to create new entity\n\t                },\n\t                destroy: {\n\t                    cache: true,\n\t                    dataType: \"json\",\n\t                    type: \"DELETE\"\n\t                },\n\t                parameterMap: function(options, type) {\n\t                    var result = kendo.data.transports.odata.parameterMap(options, type, true);\n\t                    if (type == \"read\") {\n\t                        result.$count = true;\n\t                        delete result.$inlinecount;\n\t                    }\n\n\t                    return result;\n\t                },\n\t                submit: function(e) {\n\t                    var that = this;\n\t                    var options = createBatchRequest(that, e.data);\n\t                    var collections = e.data;\n\n\t                    if (!collections.updated.length && !collections.destroyed.length && !collections.created.length) {\n\t                        return;\n\t                    }\n\n\t                    $.ajax(extend(true, {}, {\n\t                        success: function (response) {\n\t                            var responses = parseBatchResponse(response);\n\t                            var index = 0;\n\t                            var current;\n\n\t                            if (collections.updated.length) {\n\t                                current = responses[index];\n\t                                if (current.passed) {\n\t                                    // Pass either the obtained models or an empty array if only status codes are returned.\n\t                                    e.success(current.models.length ? current.models : [], \"update\");\n\t                                }\n\t                                index++;\n\t                            }\n\t                            if (collections.destroyed.length) {\n\t                                current = responses[index];\n\t                                if (current.passed) {\n\t                                    // For delete operations OData returns only status codes.\n\t                                    // Passing empty array to datasource will force it to correctly remove the deleted items from the pristine collection.\n\t                                    e.success([], \"destroy\");\n\t                                }\n\t                                index++;\n\t                            }\n\t                            if (collections.created.length) {\n\t                                current = responses[index];\n\t                                if (current.passed) {\n\t                                    e.success(current.models, \"create\");\n\t                                }\n\t                            }\n\t                        },\n\t                        error: function (response, status, error) {\n\t                            e.error(response, status, error);\n\t                        }\n\t                    }, options));\n\t                }\n\t            }\n\t        }\n\t    });\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYzRiNTIzYTQwZjhjOWQxZjIzN2IuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb2dyZXNzL2tlbmRvLXVpL2pzL2tlbmRvLmRhdGEub2RhdGEuanM/Mjg5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuXG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyAwOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDQ5KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJkZWZpbmUgY2Fubm90IGJlIHVzZWQgaW5kaXJlY3RcIik7IH07XHJcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTAwNDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2tlbmRvLmNvcmVcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMDQ5OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyhmdW5jdGlvbihmLCBkZWZpbmUpe1xuXHQgICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gWyBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMDQpIF0sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/IChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXHR9KShmdW5jdGlvbigpe1xuXG5cdHZhciBfX21ldGFfXyA9IHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cdCAgICBpZDogXCJkYXRhLm9kYXRhXCIsXG5cdCAgICBuYW1lOiBcIk9EYXRhXCIsXG5cdCAgICBjYXRlZ29yeTogXCJmcmFtZXdvcmtcIixcblx0ICAgIGRlcGVuZHM6IFsgXCJjb3JlXCIgXSxcblx0ICAgIGhpZGRlbjogdHJ1ZVxuXHR9O1xuXG5cdChmdW5jdGlvbigkLCB1bmRlZmluZWQpIHtcblx0ICAgIHZhciBrZW5kbyA9IHdpbmRvdy5rZW5kbyxcblx0ICAgICAgICBleHRlbmQgPSAkLmV4dGVuZCxcblx0ICAgICAgICBORVdMSU5FID0gXCJcXHJcXG5cIixcblx0ICAgICAgICBET1VCTEVMSU5FID0gXCJcXHJcXG5cXHJcXG5cIixcblx0ICAgICAgICBpc0Z1bmN0aW9uID0ga2VuZG8uaXNGdW5jdGlvbixcblx0ICAgICAgICBvZGF0YUZpbHRlcnMgPSB7XG5cdCAgICAgICAgICAgIGVxOiBcImVxXCIsXG5cdCAgICAgICAgICAgIG5lcTogXCJuZVwiLFxuXHQgICAgICAgICAgICBndDogXCJndFwiLFxuXHQgICAgICAgICAgICBndGU6IFwiZ2VcIixcblx0ICAgICAgICAgICAgbHQ6IFwibHRcIixcblx0ICAgICAgICAgICAgbHRlOiBcImxlXCIsXG5cdCAgICAgICAgICAgIGNvbnRhaW5zIDogXCJzdWJzdHJpbmdvZlwiLFxuXHQgICAgICAgICAgICBkb2Vzbm90Y29udGFpbjogXCJzdWJzdHJpbmdvZlwiLFxuXHQgICAgICAgICAgICBlbmRzd2l0aDogXCJlbmRzd2l0aFwiLFxuXHQgICAgICAgICAgICBzdGFydHN3aXRoOiBcInN0YXJ0c3dpdGhcIixcblx0ICAgICAgICAgICAgaXNudWxsOiBcImVxXCIsXG5cdCAgICAgICAgICAgIGlzbm90bnVsbDogXCJuZVwiLFxuXHQgICAgICAgICAgICBpc251bGxvcmVtcHR5OiBcImVxXCIsXG5cdCAgICAgICAgICAgIGlzbm90bnVsbG9yZW1wdHk6IFwibmVcIixcblx0ICAgICAgICAgICAgaXNlbXB0eTogXCJlcVwiLFxuXHQgICAgICAgICAgICBpc25vdGVtcHR5OiBcIm5lXCJcblx0ICAgICAgICB9LFxuXHQgICAgICAgIG9kYXRhRmlsdGVyc1ZlcnNpb25Gb3VyID0gZXh0ZW5kKHt9LCBvZGF0YUZpbHRlcnMsIHtcblx0ICAgICAgICAgICAgY29udGFpbnM6IFwiY29udGFpbnNcIlxuXHQgICAgICAgIH0pLFxuXHQgICAgICAgIG1hcHBlcnMgPSB7XG5cdCAgICAgICAgICAgIHBhZ2VTaXplOiAkLm5vb3AsXG5cdCAgICAgICAgICAgIHBhZ2U6ICQubm9vcCxcblx0ICAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbihwYXJhbXMsIGZpbHRlciwgdXNlVmVyc2lvbkZvdXIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSB0b09kYXRhRmlsdGVyKGZpbHRlciwgdXNlVmVyc2lvbkZvdXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLiRmaWx0ZXIgPSBmaWx0ZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBzb3J0OiBmdW5jdGlvbihwYXJhbXMsIG9yZGVyYnkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBleHByID0gJC5tYXAob3JkZXJieSwgZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb3JkZXIgPSB2YWx1ZS5maWVsZC5yZXBsYWNlKC9cXC4vZywgXCIvXCIpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmRpciA9PT0gXCJkZXNjXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXIgKz0gXCIgZGVzY1wiO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmRlcjtcblx0ICAgICAgICAgICAgICAgIH0pLmpvaW4oXCIsXCIpO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoZXhwcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHBhcmFtcy4kb3JkZXJieSA9IGV4cHI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIHNraXA6IGZ1bmN0aW9uKHBhcmFtcywgc2tpcCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHNraXApIHtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbXMuJHNraXAgPSBza2lwO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICB0YWtlOiBmdW5jdGlvbihwYXJhbXMsIHRha2UpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0YWtlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcGFyYW1zLiR0b3AgPSB0YWtlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBkZWZhdWx0RGF0YVR5cGUgPSB7XG5cdCAgICAgICAgICAgIHJlYWQ6IHtcblx0ICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25wXCJcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIHRvT2RhdGFGaWx0ZXIoZmlsdGVyLCB1c2VPZGF0YUZvdXIpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gW10sXG5cdCAgICAgICAgICAgIGxvZ2ljID0gZmlsdGVyLmxvZ2ljIHx8IFwiYW5kXCIsXG5cdCAgICAgICAgICAgIGlkeCxcblx0ICAgICAgICAgICAgbGVuZ3RoLFxuXHQgICAgICAgICAgICBmaWVsZCxcblx0ICAgICAgICAgICAgdHlwZSxcblx0ICAgICAgICAgICAgZm9ybWF0LFxuXHQgICAgICAgICAgICBvcGVyYXRvcixcblx0ICAgICAgICAgICAgdmFsdWUsXG5cdCAgICAgICAgICAgIGlnbm9yZUNhc2UsXG5cdCAgICAgICAgICAgIGZpbHRlcnMgPSBmaWx0ZXIuZmlsdGVycztcblxuXHQgICAgICAgIGZvciAoaWR4ID0gMCwgbGVuZ3RoID0gZmlsdGVycy5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgZmlsdGVyID0gZmlsdGVyc1tpZHhdO1xuXHQgICAgICAgICAgICBmaWVsZCA9IGZpbHRlci5maWVsZDtcblx0ICAgICAgICAgICAgdmFsdWUgPSBmaWx0ZXIudmFsdWU7XG5cdCAgICAgICAgICAgIG9wZXJhdG9yID0gZmlsdGVyLm9wZXJhdG9yO1xuXG5cdCAgICAgICAgICAgIGlmIChmaWx0ZXIuZmlsdGVycykge1xuXHQgICAgICAgICAgICAgICAgZmlsdGVyID0gdG9PZGF0YUZpbHRlcihmaWx0ZXIsIHVzZU9kYXRhRm91cik7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBpZ25vcmVDYXNlID0gZmlsdGVyLmlnbm9yZUNhc2U7XG5cdCAgICAgICAgICAgICAgICBmaWVsZCA9IGZpZWxkLnJlcGxhY2UoL1xcLi9nLCBcIi9cIik7XG5cdCAgICAgICAgICAgICAgICBmaWx0ZXIgPSBvZGF0YUZpbHRlcnNbb3BlcmF0b3JdO1xuXHQgICAgICAgICAgICAgICAgaWYgKHVzZU9kYXRhRm91cikge1xuXHQgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IG9kYXRhRmlsdGVyc1ZlcnNpb25Gb3VyW29wZXJhdG9yXTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yID09PSBcImlzbnVsbG9yZW1wdHlcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IGtlbmRvLmZvcm1hdChcInswfSB7MX0gbnVsbCBvciB7MH0gezF9ICcnXCIsIGZpZWxkLCBmaWx0ZXIpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmKG9wZXJhdG9yID09PSBcImlzbm90bnVsbG9yZW1wdHlcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IGtlbmRvLmZvcm1hdChcInswfSB7MX0gbnVsbCBhbmQgezB9IHsxfSAnJ1wiLCBmaWVsZCwgZmlsdGVyKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09IFwiaXNudWxsXCIgfHwgb3BlcmF0b3IgPT09IFwiaXNub3RudWxsXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSBrZW5kby5mb3JtYXQoXCJ7MH0gezF9IG51bGxcIiwgZmllbGQsIGZpbHRlcik7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdG9yID09PSBcImlzZW1wdHlcIiB8fCBvcGVyYXRvciA9PT0gXCJpc25vdGVtcHR5XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSBrZW5kby5mb3JtYXQoXCJ7MH0gezF9ICcnXCIsIGZpZWxkLCBmaWx0ZXIpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWx0ZXIgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAkLnR5cGUodmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IFwiJ3sxfSdcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC8nL2csIFwiJydcIik7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZUNhc2UgPT09IHRydWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkID0gXCJ0b2xvd2VyKFwiICsgZmllbGQgKyBcIilcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImRhdGVcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNlT2RhdGFGb3VyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBcInsxOnl5eXktTU0tZGRUSEg6bW06c3MrMDA6MDB9XCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGtlbmRvLnRpbWV6b25lLmFwcGx5KHZhbHVlLCAnRXRjL1VUQycpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gXCJkYXRldGltZSd7MTp5eXl5LU1NLWRkVEhIOm1tOnNzfSdcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IFwiezF9XCI7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlci5sZW5ndGggPiAzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIgIT09IFwic3Vic3RyaW5nb2ZcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0ID0gXCJ7MH0oezJ9LFwiICsgZm9ybWF0ICsgXCIpXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBcInswfShcIiArIGZvcm1hdCArIFwiLHsyfSlcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRvciA9PT0gXCJkb2Vzbm90Y29udGFpblwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZU9kYXRhRm91cikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSBcInswfSh7Mn0sJ3sxfScpIGVxIC0xXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IFwiaW5kZXhvZlwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdCArPSBcIiBlcSBmYWxzZVwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IFwiezJ9IHswfSBcIiArIGZvcm1hdDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBmaWx0ZXIgPSBrZW5kby5mb3JtYXQoZm9ybWF0LCBmaWx0ZXIsIHZhbHVlLCBmaWVsZCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXN1bHQucHVzaChmaWx0ZXIpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZpbHRlciA9IHJlc3VsdC5qb2luKFwiIFwiICsgbG9naWMgKyBcIiBcIik7XG5cblx0ICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgZmlsdGVyID0gXCIoXCIgKyBmaWx0ZXIgKyBcIilcIjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gZmlsdGVyO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBzdHJpcE1ldGFkYXRhKG9iaikge1xuXHQgICAgICAgIGZvciAodmFyIG5hbWUgaW4gb2JqKSB7XG5cdCAgICAgICAgICAgIGlmKG5hbWUuaW5kZXhPZihcIkBvZGF0YVwiKSA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIG9ialtuYW1lXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaGV4MTYoKSB7XG5cdCAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZUJvdW5kYXJ5KHByZWZpeCkge1xuXHQgICAgICAgIHJldHVybiBwcmVmaXggKyBoZXgxNigpICsgJy0nICsgaGV4MTYoKSArICctJyArIGhleDE2KCk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZURlbGltZXRlcihib3VuZGFyeSwgY2xvc2UpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gTkVXTElORSArIFwiLS1cIiArIGJvdW5kYXJ5O1xuXG5cdCAgICAgICAgaWYgKGNsb3NlKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdCArPSBcIi0tXCI7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY3JlYXRlQ29tbWFuZCh0cmFuc3BvcnQsIGl0ZW0sIGh0dHBWZXJiLCBjb21tYW5kKSB7XG5cdCAgICAgICAgIHZhciB0cmFuc3BvcnRVcmwgPSB0cmFuc3BvcnQub3B0aW9uc1tjb21tYW5kXS51cmw7XG5cdCAgICAgICAgIHZhciBjb21tYW5kUHJlZml4ID0ga2VuZG8uZm9ybWF0KFwiezB9IFwiLCBodHRwVmVyYik7XG5cblx0ICAgICAgICAgaWYgKGlzRnVuY3Rpb24odHJhbnNwb3J0VXJsKSkge1xuXHQgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRQcmVmaXggKyB0cmFuc3BvcnRVcmwoaXRlbSk7XG5cdCAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICByZXR1cm4gY29tbWFuZFByZWZpeCArIHRyYW5zcG9ydFVybDtcblx0ICAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBnZXRPcGVyYXRpb25IZWFkZXIoY2hhbmdlc2V0LCBjaGFuZ2VJZCkge1xuXHQgICAgICAgIHZhciBoZWFkZXIgPSBcIlwiO1xuXG5cdCAgICAgICAgaGVhZGVyICs9IGNyZWF0ZURlbGltZXRlcihjaGFuZ2VzZXQsIGZhbHNlKTtcblx0ICAgICAgICBoZWFkZXIgKz0gTkVXTElORSArICdDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2h0dHAnO1xuXHQgICAgICAgIGhlYWRlciArPSBORVdMSU5FICsgJ0NvbnRlbnQtVHJhbnNmZXItRW5jb2Rpbmc6IGJpbmFyeSc7XG5cdCAgICAgICAgaGVhZGVyICs9IE5FV0xJTkUgKyAnQ29udGVudC1JRDogJyArIGNoYW5nZUlkO1xuXG5cdCAgICAgICAgcmV0dXJuIGhlYWRlcjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gZ2V0T3BlcmF0aW9uQ29udGVudChpdGVtKSB7XG5cdCAgICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuXG5cdCAgICAgICAgY29udGVudCArPSBORVdMSU5FICsgXCJDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb247b2RhdGE9bWluaW1hbG1ldGFkYXRhXCI7XG5cdCAgICAgICAgY29udGVudCArPSBORVdMSU5FICsgXCJQcmVmZXI6IHJldHVybj1yZXByZXNlbnRhdGlvblwiO1xuXHQgICAgICAgIGNvbnRlbnQgKz0gRE9VQkxFTElORSArIGtlbmRvLnN0cmluZ2lmeShpdGVtKTtcblxuXHQgICAgICAgIHJldHVybiBjb250ZW50O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBnZXRPcGVyYXRpb25zKGNvbGxlY3Rpb24sIGNoYW5nZXNldCwgY2hhbmdlSWQsIGNvbW1hbmQsIHRyYW5zcG9ydCwgc2tpcENvbnRlbnQpIHtcblx0ICAgICAgICB2YXIgcmVxdWVzdEJvZHkgPSBcIlwiO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHJlcXVlc3RCb2R5ICs9IGdldE9wZXJhdGlvbkhlYWRlcihjaGFuZ2VzZXQsIGNoYW5nZUlkKTtcblx0ICAgICAgICAgICAgcmVxdWVzdEJvZHkgKz0gRE9VQkxFTElORSArIGNyZWF0ZUNvbW1hbmQodHJhbnNwb3J0LCBjb2xsZWN0aW9uW2ldLCB0cmFuc3BvcnQub3B0aW9uc1tjb21tYW5kXS50eXBlLCBjb21tYW5kKSArICcgSFRUUC8xLjEnO1xuXHQgICAgICAgICAgICBpZiAoIXNraXBDb250ZW50KSB7XG5cdCAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keSArPSBnZXRPcGVyYXRpb25Db250ZW50KGNvbGxlY3Rpb25baV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJlcXVlc3RCb2R5ICs9IE5FV0xJTkU7XG5cdCAgICAgICAgICAgIGNoYW5nZUlkKys7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHJlcXVlc3RCb2R5O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBwcm9jZXNzQ29sbGVjdGlvbihjb2xlY3Rpb24sIGJvdW5kYXJ5LCBjaGFuZ2VzZXQsIGNoYW5nZUlkLCB0cmFuc3BvcnQsIGNvbW1hbmQsIHNraXBDb250ZW50KSB7XG5cdCAgICAgICAgdmFyIHJlcXVlc3RCb2R5ID0gXCJcIjtcblxuXHQgICAgICAgIHJlcXVlc3RCb2R5ICs9IGdldEJvdW5kYXJ5KGJvdW5kYXJ5LCBjaGFuZ2VzZXQpO1xuXHQgICAgICAgIHJlcXVlc3RCb2R5ICs9IGdldE9wZXJhdGlvbnMoY29sZWN0aW9uLCBjaGFuZ2VzZXQsIGNoYW5nZUlkLCBjb21tYW5kLCB0cmFuc3BvcnQsIHNraXBDb250ZW50KTtcblx0ICAgICAgICByZXF1ZXN0Qm9keSArPSBjcmVhdGVEZWxpbWV0ZXIoY2hhbmdlc2V0LCB0cnVlKTtcblx0ICAgICAgICByZXF1ZXN0Qm9keSArPSBORVdMSU5FO1xuXG5cdCAgICAgICAgcmV0dXJuIHJlcXVlc3RCb2R5O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBnZXRCb3VuZGFyeShib3VuZGFyeSxjaGFuZ2VzZXQpIHtcblx0ICAgICAgICB2YXIgcmVxdWVzdEJvZHkgPSBcIlwiO1xuXG5cdCAgICAgICAgcmVxdWVzdEJvZHkgKz0gXCItLVwiICsgYm91bmRhcnkgKyBORVdMSU5FO1xuXHQgICAgICAgIHJlcXVlc3RCb2R5ICs9IFwiQ29udGVudC1UeXBlOiBtdWx0aXBhcnQvbWl4ZWQ7IGJvdW5kYXJ5PVwiICsgY2hhbmdlc2V0ICsgTkVXTElORTtcblxuXHQgICAgICAgIHJldHVybiByZXF1ZXN0Qm9keTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY3JlYXRlQmF0Y2hSZXF1ZXN0KHRyYW5zcG9ydCwgY29sZWN0aW9ucykge1xuXHQgICAgICAgIHZhciBvcHRpb25zID0ge307XG5cdCAgICAgICAgdmFyIGJvdW5kYXJ5ID0gY3JlYXRlQm91bmRhcnkoXCJzZl9iYXRjaF9cIik7XG5cdCAgICAgICAgdmFyIHJlcXVlc3RCb2R5ID0gXCJcIjtcblx0ICAgICAgICB2YXIgY2hhbmdlSWQgPSAwO1xuXHQgICAgICAgIHZhciBiYXRjaFVSTCA9IHRyYW5zcG9ydC5vcHRpb25zLmJhdGNoLnVybDtcblx0ICAgICAgICB2YXIgY2hhbmdlc2V0ID0gY3JlYXRlQm91bmRhcnkoXCJzZl9jaGFuZ2VzZXRfXCIpO1xuXG5cdCAgICAgICAgb3B0aW9ucy50eXBlID0gdHJhbnNwb3J0Lm9wdGlvbnMuYmF0Y2gudHlwZTtcblx0ICAgICAgICBvcHRpb25zLnVybCA9IGlzRnVuY3Rpb24oYmF0Y2hVUkwpID8gYmF0Y2hVUkwoKSA6IGJhdGNoVVJMO1xuXHQgICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IHtcblx0ICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJtdWx0aXBhcnQvbWl4ZWQ7IGJvdW5kYXJ5PVwiICsgYm91bmRhcnlcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgaWYgKGNvbGVjdGlvbnMudXBkYXRlZC5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgcmVxdWVzdEJvZHkgKz0gcHJvY2Vzc0NvbGxlY3Rpb24oY29sZWN0aW9ucy51cGRhdGVkLCBib3VuZGFyeSwgY2hhbmdlc2V0LCBjaGFuZ2VJZCwgdHJhbnNwb3J0LCBcInVwZGF0ZVwiLCBmYWxzZSk7XG5cdCAgICAgICAgICAgIGNoYW5nZUlkICs9IGNvbGVjdGlvbnMudXBkYXRlZC5sZW5ndGg7XG5cdCAgICAgICAgICAgIGNoYW5nZXNldCA9IGNyZWF0ZUJvdW5kYXJ5KFwic2ZfY2hhbmdlc2V0X1wiKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoY29sZWN0aW9ucy5kZXN0cm95ZWQubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHJlcXVlc3RCb2R5ICs9IHByb2Nlc3NDb2xsZWN0aW9uKGNvbGVjdGlvbnMuZGVzdHJveWVkLCBib3VuZGFyeSwgY2hhbmdlc2V0LCBjaGFuZ2VJZCwgdHJhbnNwb3J0LCBcImRlc3Ryb3lcIiwgdHJ1ZSk7XG5cdCAgICAgICAgICAgIGNoYW5nZUlkICs9IGNvbGVjdGlvbnMuZGVzdHJveWVkLmxlbmd0aDtcblx0ICAgICAgICAgICAgY2hhbmdlc2V0ID0gY3JlYXRlQm91bmRhcnkoXCJzZl9jaGFuZ2VzZXRfXCIpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChjb2xlY3Rpb25zLmNyZWF0ZWQubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHJlcXVlc3RCb2R5ICs9IHByb2Nlc3NDb2xsZWN0aW9uKGNvbGVjdGlvbnMuY3JlYXRlZCwgYm91bmRhcnksIGNoYW5nZXNldCwgY2hhbmdlSWQsIHRyYW5zcG9ydCwgXCJjcmVhdGVcIiwgZmFsc2UpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJlcXVlc3RCb2R5ICs9IGNyZWF0ZURlbGltZXRlcihib3VuZGFyeSwgdHJ1ZSk7XG5cblx0ICAgICAgICBvcHRpb25zLmRhdGEgPSByZXF1ZXN0Qm9keTtcblxuXHQgICAgICAgIHJldHVybiBvcHRpb25zO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBwYXJzZUJhdGNoUmVzcG9uc2UocmVzcG9uc2VUZXh0KSB7XG5cdCAgICAgICAgdmFyIHJlc3BvbnNlTWFya2VycyA9IHJlc3BvbnNlVGV4dC5tYXRjaCgvLS1jaGFuZ2VzZXRyZXNwb25zZV9bYS16MC05LV0rJC9nbSk7XG5cdCAgICAgICAgdmFyIG1hcmtlckluZGV4ID0gMDtcblx0ICAgICAgICB2YXIgY29sbGVjdGlvbnMgPSBbXTtcblx0ICAgICAgICB2YXIgY2hhbmdlQm9keTtcblx0ICAgICAgICB2YXIgc3RhdHVzO1xuXHQgICAgICAgIHZhciBjb2RlO1xuXHQgICAgICAgIHZhciBtYXJrZXI7XG5cdCAgICAgICAgdmFyIGpzb25Nb2RlbDtcblxuXHQgICAgICAgIGNvbGxlY3Rpb25zLnB1c2goeyBtb2RlbHM6IFtdLCBwYXNzZWQ6IHRydWUgfSk7XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3BvbnNlTWFya2Vycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBtYXJrZXIgPSByZXNwb25zZU1hcmtlcnNbaV07XG5cdCAgICAgICAgICAgIGlmIChtYXJrZXIubGFzdEluZGV4T2YoJy0tJywgbWFya2VyLmxlbmd0aCAtIDEpKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IHJlc3BvbnNlTWFya2Vycy5sZW5ndGggLSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbnMucHVzaCh7IG1vZGVsczogW10sIHBhc3NlZDogdHJ1ZSB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKCFtYXJrZXJJbmRleCkge1xuXHQgICAgICAgICAgICAgICAgbWFya2VySW5kZXggPSByZXNwb25zZVRleHQuaW5kZXhPZihtYXJrZXIpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbWFya2VySW5kZXggPSByZXNwb25zZVRleHQuaW5kZXhPZihtYXJrZXIsIG1hcmtlckluZGV4ICsgbWFya2VyLmxlbmd0aCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBjaGFuZ2VCb2R5ID0gcmVzcG9uc2VUZXh0LnN1YnN0cmluZyhtYXJrZXJJbmRleCwgcmVzcG9uc2VUZXh0LmluZGV4T2YoXCItLVwiLCBtYXJrZXJJbmRleCArIDEpKTtcblx0ICAgICAgICAgICAgc3RhdHVzID0gY2hhbmdlQm9keS5tYXRjaCgvXkhUVFBcXC8xXFwuXFxkIChcXGR7M30pICguKikkL2dtKS5wb3AoKTtcblx0ICAgICAgICAgICAgY29kZSA9IGtlbmRvLnBhcnNlRmxvYXQoc3RhdHVzLm1hdGNoKC9cXGR7M30vZykucG9wKCkpO1xuXG5cdCAgICAgICAgICAgIGlmIChjb2RlID49IDIwMCAmJiBjb2RlIDw9IDI5OSkge1xuXHQgICAgICAgICAgICAgICAganNvbk1vZGVsID0gY2hhbmdlQm9keS5tYXRjaCgvXFx7LipcXH0vZ20pO1xuXHQgICAgICAgICAgICAgICAgaWYgKGpzb25Nb2RlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25zW2NvbGxlY3Rpb25zLmxlbmd0aCAtIDFdLm1vZGVscy5wdXNoKEpTT04ucGFyc2UoanNvbk1vZGVsWzBdKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBjb2xsZWN0aW9uc1tjb2xsZWN0aW9ucy5sZW5ndGggLSAxXS5wYXNzZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25zO1xuXHQgICAgfVxuXG5cdCAgICBleHRlbmQodHJ1ZSwga2VuZG8uZGF0YSwge1xuXHQgICAgICAgIHNjaGVtYXM6IHtcblx0ICAgICAgICAgICAgb2RhdGE6IHtcblx0ICAgICAgICAgICAgICAgIHR5cGU6IFwianNvblwiLFxuXHQgICAgICAgICAgICAgICAgZGF0YTogZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmQucmVzdWx0cyB8fCBbZGF0YS5kXTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICB0b3RhbDogXCJkLl9fY291bnRcIlxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB0cmFuc3BvcnRzOiB7XG5cdCAgICAgICAgICAgIG9kYXRhOiB7XG5cdCAgICAgICAgICAgICAgICByZWFkOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHRydWUsIC8vIHRvIHByZXZlbnQgalF1ZXJ5IGZyb20gYWRkaW5nIGNhY2hlIGJ1c3RlclxuXHQgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25wXCIsXG5cdCAgICAgICAgICAgICAgICAgICAganNvbnA6IFwiJGNhbGxiYWNrXCJcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICB1cGRhdGU6IHtcblx0ICAgICAgICAgICAgICAgICAgICBjYWNoZTogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLCAvLyB0byBpbmZvcm0gdGhlIHNlcnZlciB0aGUgdGhlIHJlcXVlc3QgYm9keSBpcyBKU09OIGVuY29kZWRcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlBVVFwiIC8vIGNhbiBiZSBQVVQgb3IgTUVSR0Vcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBjcmVhdGU6IHtcblx0ICAgICAgICAgICAgICAgICAgICBjYWNoZTogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuXHQgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUE9TVFwiIC8vIG11c3QgYmUgUE9TVCB0byBjcmVhdGUgbmV3IGVudGl0eVxuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIGRlc3Ryb3k6IHtcblx0ICAgICAgICAgICAgICAgICAgICBjYWNoZTogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJERUxFVEVcIlxuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIHBhcmFtZXRlck1hcDogZnVuY3Rpb24ob3B0aW9ucywgdHlwZSwgdXNlVmVyc2lvbkZvdXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTtcblxuXHQgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQgICAgICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IFwicmVhZFwiO1xuXHQgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlID0gKHRoaXMub3B0aW9ucyB8fCBkZWZhdWx0RGF0YVR5cGUpW3R5cGVdO1xuXHQgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlID0gZGF0YVR5cGUgPyBkYXRhVHlwZS5kYXRhVHlwZSA6IFwianNvblwiO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwicmVhZFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpbmxpbmVjb3VudDogXCJhbGxwYWdlc1wiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFUeXBlICE9IFwianNvblwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuJGZvcm1hdCA9IFwianNvblwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChvcHRpb24gaW4gb3B0aW9ucykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHBlcnNbb3B0aW9uXSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBlcnNbb3B0aW9uXShwYXJhbXMsIG9wdGlvbnNbb3B0aW9uXSwgdXNlVmVyc2lvbkZvdXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNbb3B0aW9uXSA9IG9wdGlvbnNbb3B0aW9uXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVHlwZSAhPT0gXCJqc29uXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9ubHkganNvbiBkYXRhVHlwZSBjYW4gYmUgdXNlZCBmb3IgXCIgKyB0eXBlICsgXCIgb3BlcmF0aW9uLlwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlICE9PSBcImRlc3Ryb3lcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChvcHRpb24gaW4gb3B0aW9ucykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb3B0aW9uc1tvcHRpb25dO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1tvcHRpb25dID0gdmFsdWUgKyBcIlwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0ga2VuZG8uc3RyaW5naWZ5KG9wdGlvbnMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBleHRlbmQodHJ1ZSwga2VuZG8uZGF0YSwge1xuXHQgICAgICAgIHNjaGVtYXM6IHtcblx0ICAgICAgICAgICAgXCJvZGF0YS12NFwiOiB7XG5cdCAgICAgICAgICAgICAgICB0eXBlOiBcImpzb25cIixcblx0ICAgICAgICAgICAgICAgIGRhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc0FycmF5KGRhdGEpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyaXBNZXRhZGF0YShkYXRhW2ldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gJC5leHRlbmQoe30sIGRhdGEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdHJpcE1ldGFkYXRhKGRhdGEpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS52YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2RhdGFdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICB0b3RhbDogZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW1wiQG9kYXRhLmNvdW50XCJdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB0cmFuc3BvcnRzOiB7XG5cdCAgICAgICAgICAgIFwib2RhdGEtdjRcIjoge1xuXHQgICAgICAgICAgICAgICAgYmF0Y2g6IHtcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlBPU1RcIlxuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIHJlYWQ6IHtcblx0ICAgICAgICAgICAgICAgICAgICBjYWNoZTogdHJ1ZSwgLy8gdG8gcHJldmVudCBqUXVlcnkgZnJvbSBhZGRpbmcgY2FjaGUgYnVzdGVyXG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiXG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgdXBkYXRlOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHRydWUsXG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247SUVFRTc1NENvbXBhdGlibGU9dHJ1ZVwiLCAvLyB0byBpbmZvcm0gdGhlIHNlcnZlciB0aGUgdGhlIHJlcXVlc3QgYm9keSBpcyBKU09OIGVuY29kZWRcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlBVVFwiIC8vIGNhbiBiZSBQVVQgb3IgTUVSR0Vcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBjcmVhdGU6IHtcblx0ICAgICAgICAgICAgICAgICAgICBjYWNoZTogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjtJRUVFNzU0Q29tcGF0aWJsZT10cnVlXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJQT1NUXCIgLy8gbXVzdCBiZSBQT1NUIHRvIGNyZWF0ZSBuZXcgZW50aXR5XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgZGVzdHJveToge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhY2hlOiB0cnVlLFxuXHQgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25cIixcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkRFTEVURVwiXG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgcGFyYW1ldGVyTWFwOiBmdW5jdGlvbihvcHRpb25zLCB0eXBlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGtlbmRvLmRhdGEudHJhbnNwb3J0cy5vZGF0YS5wYXJhbWV0ZXJNYXAob3B0aW9ucywgdHlwZSwgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gXCJyZWFkXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LiRjb3VudCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHQuJGlubGluZWNvdW50O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgc3VibWl0OiBmdW5jdGlvbihlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb25zID0gY3JlYXRlQmF0Y2hSZXF1ZXN0KHRoYXQsIGUuZGF0YSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb25zID0gZS5kYXRhO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2xsZWN0aW9ucy51cGRhdGVkLmxlbmd0aCAmJiAhY29sbGVjdGlvbnMuZGVzdHJveWVkLmxlbmd0aCAmJiAhY29sbGVjdGlvbnMuY3JlYXRlZC5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgICQuYWpheChleHRlbmQodHJ1ZSwge30sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2VzID0gcGFyc2VCYXRjaFJlc3BvbnNlKHJlc3BvbnNlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudDtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb25zLnVwZGF0ZWQubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHJlc3BvbnNlc1tpbmRleF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQucGFzc2VkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgZWl0aGVyIHRoZSBvYnRhaW5lZCBtb2RlbHMgb3IgYW4gZW1wdHkgYXJyYXkgaWYgb25seSBzdGF0dXMgY29kZXMgYXJlIHJldHVybmVkLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN1Y2Nlc3MoY3VycmVudC5tb2RlbHMubGVuZ3RoID8gY3VycmVudC5tb2RlbHMgOiBbXSwgXCJ1cGRhdGVcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGVjdGlvbnMuZGVzdHJveWVkLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSByZXNwb25zZXNbaW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnBhc3NlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZGVsZXRlIG9wZXJhdGlvbnMgT0RhdGEgcmV0dXJucyBvbmx5IHN0YXR1cyBjb2Rlcy5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFzc2luZyBlbXB0eSBhcnJheSB0byBkYXRhc291cmNlIHdpbGwgZm9yY2UgaXQgdG8gY29ycmVjdGx5IHJlbW92ZSB0aGUgZGVsZXRlZCBpdGVtcyBmcm9tIHRoZSBwcmlzdGluZSBjb2xsZWN0aW9uLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN1Y2Nlc3MoW10sIFwiZGVzdHJveVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsZWN0aW9ucy5jcmVhdGVkLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSByZXNwb25zZXNbaW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnBhc3NlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN1Y2Nlc3MoY3VycmVudC5tb2RlbHMsIFwiY3JlYXRlXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChyZXNwb25zZSwgc3RhdHVzLCBlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5lcnJvcihyZXNwb25zZSwgc3RhdHVzLCBlcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHR9KSh3aW5kb3cua2VuZG8ualF1ZXJ5KTtcblxuXHRyZXR1cm4gd2luZG93LmtlbmRvO1xuXG5cdH0sIF9fd2VicGFja19yZXF1aXJlX18oMykpO1xuXG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///c4b523a40f8c9d1f237b\n");

/***/ }),

/***/ "cd5975204d58830e8b52":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/css-loader!./src/vendor/Anakeen/SmartStructures/Iuser/Render/changeGroupView.css ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../../../../../node_modules/css-loader/lib/css-base.js */ \"c138e55a31f3f8960e99\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"#listOfGroups .k-checkbox:checked + .k-checkbox-label:before {\\n    background-color: #007bff;\\n}\\n\\n.hasChildChecked {\\n    border-bottom: solid 1px #007bff;\\n}\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Q1OTc1MjA0ZDU4ODMwZThiNTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9yL0FuYWtlZW4vU21hcnRTdHJ1Y3R1cmVzL0l1c2VyL1JlbmRlci9jaGFuZ2VHcm91cFZpZXcuY3NzP2U4OGUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKShmYWxzZSk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIjbGlzdE9mR3JvdXBzIC5rLWNoZWNrYm94OmNoZWNrZWQgKyAuay1jaGVja2JveC1sYWJlbDpiZWZvcmUge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDA3YmZmO1xcbn1cXG5cXG4uaGFzQ2hpbGRDaGVja2VkIHtcXG4gICAgYm9yZGVyLWJvdHRvbTogc29saWQgMXB4ICMwMDdiZmY7XFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///cd5975204d58830e8b52\n");

/***/ }),

/***/ "e5de476db2ea45d6ed4e":
/*!*****************************************************************************!*\
  !*** ./src/vendor/Anakeen/SmartStructures/Iuser/Render/changeGroupView.css ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../../../../../node_modules/css-loader!./changeGroupView.css */ \"cd5975204d58830e8b52\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../../../../../node_modules/style-loader/lib/addStyles.js */ \"1e4534d1d62a11482e97\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZTVkZTQ3NmRiMmVhNDVkNmVkNGUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9yL0FuYWtlZW4vU21hcnRTdHJ1Y3R1cmVzL0l1c2VyL1JlbmRlci9jaGFuZ2VHcm91cFZpZXcuY3NzPzA0NDEiXSwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vY2hhbmdlR3JvdXBWaWV3LmNzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9jaGFuZ2VHcm91cFZpZXcuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9jaGFuZ2VHcm91cFZpZXcuY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///e5de476db2ea45d6ed4e\n");

/***/ }),

/***/ "ed7ea6f7dc20380e2940":
/*!****************************************************************************!*\
  !*** ./src/vendor/Anakeen/SmartStructures/Iuser/Render/changeGroupView.js ***!
  \****************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _progress_kendo_ui_js_kendo_treeview__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @progress/kendo-ui/js/kendo.treeview */ \"04065e00ab361f322eef\");\n/* harmony import */ var _progress_kendo_ui_js_kendo_treeview__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_progress_kendo_ui_js_kendo_treeview__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _changeGroupView_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./changeGroupView.css */ \"e5de476db2ea45d6ed4e\");\n/* harmony import */ var _changeGroupView_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_changeGroupView_css__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n{\n  let getGroupTreeSource;\n  let checkedGroups;\n\n  const getGroups = () => {\n    return fetch(\"/api/v2/admin/account/groups/\", {\n      credentials: \"same-origin\"\n    })\n      .then(response => {\n        return response.json();\n      })\n      .then(response => {\n        return response.groups;\n      });\n  };\n\n  const initTreeGroup = groups => () => {\n    return new kendo.data.HierarchicalDataSource({\n      filter: {},\n      transport: {\n        read: options => {\n          groups\n            .then(groups => {\n              Object.values(groups).forEach(currentData => {\n                currentData.expanded = true;\n                currentData.items = currentData.items || [];\n                currentData.parents.forEach(parentData => {\n                  try {\n                    groups[parentData].items = groups[parentData].items || [];\n                    groups[parentData].items.push(currentData);\n                  } catch (e) {\n                    //no need to handle the error\n                  }\n                });\n              });\n              //Suppress first level elements\n              Object.values(groups).forEach(currentData => {\n                if (currentData.parents.length > 0) {\n                  delete groups[currentData.accountId];\n                }\n              });\n\n              try {\n                //Suppress refs elements and keep only values\n                groups = Object.values(JSON.parse(JSON.stringify(groups)));\n              } catch (e) {\n                groups = [];\n              }\n              const addUniqId = (currentElement, id = \"\") => {\n                currentElement.hierarchicalId = id\n                  ? id + \"/\" + currentElement.documentId\n                  : currentElement.documentId;\n                if (currentElement.items) {\n                  currentElement.items.forEach(childrenElement => {\n                    addUniqId(childrenElement, currentElement.hierarchicalId);\n                  });\n                }\n              };\n              groups.forEach(currentGroup => {\n                addUniqId(currentGroup);\n              });\n              const restoreCheckedTree = checked => {\n                return function analyzeChecked(data) {\n                  data.forEach(currentData => {\n                    currentData.checked = false;\n                    if (checked[currentData.accountId]) {\n                      currentData.checked = true;\n                    }\n                    if (currentData.items && currentData.items.length) {\n                      analyzeChecked(currentData.items);\n                    }\n                  });\n                };\n              };\n              if (checkedGroups) {\n                restoreCheckedTree(checkedGroups)(groups);\n              }\n              const hasChildChecked = data => {\n                return data.reduce((accumulator, currentData) => {\n                  if (currentData.items && currentData.items.length) {\n                    if (hasChildChecked(currentData.items)) {\n                      currentData.hasChildChecked = true;\n                      return true;\n                    }\n                  }\n                  return accumulator || currentData.checked;\n                }, false);\n              };\n              hasChildChecked(groups);\n\n              options.success(groups);\n            })\n            .catch(error => {\n              console.error(\"Unable to get group\", error);\n            });\n        }\n      },\n      schema: {\n        model: {\n          id: \"hierarchicalId\",\n          children: \"items\"\n        }\n      }\n    });\n  };\n\n  window.dcp.document.documentController(\n    \"addEventListener\",\n    \"beforeRender\",\n    {\n      name: \"changeGroupBeforeRender.changeGroup\",\n      documentCheck: documentObject => {\n        const serverData = window.dcp.document.documentController(\n          \"getCustomServerData\"\n        );\n        return (\n          documentObject.renderMode === \"edit\" && serverData[\"GROUP_ANALYZE\"]\n        );\n      }\n    },\n    () => {\n      if (!getGroupTreeSource) {\n        getGroupTreeSource = initTreeGroup(getGroups());\n      }\n    }\n  );\n\n  window.dcp.document.documentController(\n    \"addEventListener\",\n    \"ready\",\n    {\n      name: \"changeGroupReady.changeGroup\",\n      documentCheck: documentObject => {\n        const serverData = window.dcp.document.documentController(\n          \"getCustomServerData\"\n        );\n        return (\n          documentObject.renderMode === \"edit\" && serverData[\"GROUP_ANALYZE\"]\n        );\n      }\n    },\n    () => {\n      const serverData = window.dcp.document.documentController(\n        \"getCustomServerData\"\n      );\n      checkedGroups = serverData.groups;\n      let filterTitle = null;\n\n      const updateTreeSource = kendoTree => {\n        return (force = false) => {\n          let groupTreeSource = kendoTree.dataSource;\n          const filter = filterTitle\n            ? { field: \"title\", operator: \"contains\", value: filterTitle }\n            : {};\n          if (force) {\n            const newTreeSource = getGroupTreeSource();\n            newTreeSource.read().then(() => {\n              kendoTree.setDataSource(newTreeSource);\n              newTreeSource.filter(filter);\n            });\n          } else {\n            groupTreeSource.filter(filter);\n          }\n        };\n      };\n\n      const getChecked = checked => currentEventNode => {\n        return function analyzeChecked(dataSource) {\n          const data =\n            dataSource instanceof kendo.data.HierarchicalDataSource &&\n            dataSource.data();\n          if (data === false) {\n            return;\n          }\n          data.forEach(currentNode => {\n            let isChecked = null;\n            if (currentEventNode.accountId === currentNode.accountId) {\n              isChecked = currentEventNode.checked;\n            }\n            if (\n              isChecked === null &&\n              currentNode.accountId &&\n              currentNode.checked\n            ) {\n              isChecked = true;\n            }\n            if (isChecked) {\n              checked[currentNode.accountId] = true;\n            }\n            if (currentNode.children) {\n              analyzeChecked(currentNode.children);\n            }\n          });\n        };\n      };\n\n      let updateListOfGroup;\n\n      $(\"#listOfGroups\").kendoTreeView({\n        checkboxes: true,\n        dataSource: getGroupTreeSource(),\n        select: event => {\n          event.preventDefault();\n        },\n        template:\n          \"<span # if(item.hasChildChecked) {# class='hasChildChecked' #}# data-accountId='#= item.accountId #' data-se-id='#= item.documentId #'>#= item.title # (#= item.nbUser #) </span>\",\n        check: function onTreeCheck(event) {\n          const eventNode = this.dataItem(event.node);\n          const checked = {};\n          getChecked(checked)(eventNode)(event.sender.dataSource);\n          checkedGroups = checked;\n          window.dcp.document.documentController(\"addCustomClientData\", {\n            parentGroups: checkedGroups\n          });\n          updateListOfGroup(true);\n        }\n      });\n\n      $(\"#formFilter\").on(\"submit\", event => {\n        event.preventDefault();\n        filterTitle = document.getElementById(\"filterTree\").value\n          ? document.getElementById(\"filterTree\").value.toLowerCase()\n          : \"\";\n        updateListOfGroup();\n      });\n\n      updateListOfGroup = updateTreeSource(\n        $(\"#listOfGroups\").data(\"kendoTreeView\")\n      );\n    }\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWQ3ZWE2ZjdkYzIwMzgwZTI5NDAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9yL0FuYWtlZW4vU21hcnRTdHJ1Y3R1cmVzL0l1c2VyL1JlbmRlci9jaGFuZ2VHcm91cFZpZXcuanM/NjgxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXCJAcHJvZ3Jlc3Mva2VuZG8tdWkvanMva2VuZG8udHJlZXZpZXdcIjtcbmltcG9ydCBcIi4vY2hhbmdlR3JvdXBWaWV3LmNzc1wiO1xuXG57XG4gIGxldCBnZXRHcm91cFRyZWVTb3VyY2U7XG4gIGxldCBjaGVja2VkR3JvdXBzO1xuXG4gIGNvbnN0IGdldEdyb3VwcyA9ICgpID0+IHtcbiAgICByZXR1cm4gZmV0Y2goXCIvYXBpL3YyL2FkbWluL2FjY291bnQvZ3JvdXBzL1wiLCB7XG4gICAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiXG4gICAgfSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH0pXG4gICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5ncm91cHM7XG4gICAgICB9KTtcbiAgfTtcblxuICBjb25zdCBpbml0VHJlZUdyb3VwID0gZ3JvdXBzID0+ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IGtlbmRvLmRhdGEuSGllcmFyY2hpY2FsRGF0YVNvdXJjZSh7XG4gICAgICBmaWx0ZXI6IHt9LFxuICAgICAgdHJhbnNwb3J0OiB7XG4gICAgICAgIHJlYWQ6IG9wdGlvbnMgPT4ge1xuICAgICAgICAgIGdyb3Vwc1xuICAgICAgICAgICAgLnRoZW4oZ3JvdXBzID0+IHtcbiAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhncm91cHMpLmZvckVhY2goY3VycmVudERhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRhLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0YS5pdGVtcyA9IGN1cnJlbnREYXRhLml0ZW1zIHx8IFtdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRhLnBhcmVudHMuZm9yRWFjaChwYXJlbnREYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwc1twYXJlbnREYXRhXS5pdGVtcyA9IGdyb3Vwc1twYXJlbnREYXRhXS5pdGVtcyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzW3BhcmVudERhdGFdLml0ZW1zLnB1c2goY3VycmVudERhdGEpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvL25vIG5lZWQgdG8gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgLy9TdXBwcmVzcyBmaXJzdCBsZXZlbCBlbGVtZW50c1xuICAgICAgICAgICAgICBPYmplY3QudmFsdWVzKGdyb3VwcykuZm9yRWFjaChjdXJyZW50RGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnREYXRhLnBhcmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIGdyb3Vwc1tjdXJyZW50RGF0YS5hY2NvdW50SWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvL1N1cHByZXNzIHJlZnMgZWxlbWVudHMgYW5kIGtlZXAgb25seSB2YWx1ZXNcbiAgICAgICAgICAgICAgICBncm91cHMgPSBPYmplY3QudmFsdWVzKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZ3JvdXBzKSkpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzID0gW107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgYWRkVW5pcUlkID0gKGN1cnJlbnRFbGVtZW50LCBpZCA9IFwiXCIpID0+IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudC5oaWVyYXJjaGljYWxJZCA9IGlkXG4gICAgICAgICAgICAgICAgICA/IGlkICsgXCIvXCIgKyBjdXJyZW50RWxlbWVudC5kb2N1bWVudElkXG4gICAgICAgICAgICAgICAgICA6IGN1cnJlbnRFbGVtZW50LmRvY3VtZW50SWQ7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50Lml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudC5pdGVtcy5mb3JFYWNoKGNoaWxkcmVuRWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFVuaXFJZChjaGlsZHJlbkVsZW1lbnQsIGN1cnJlbnRFbGVtZW50LmhpZXJhcmNoaWNhbElkKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZ3JvdXBzLmZvckVhY2goY3VycmVudEdyb3VwID0+IHtcbiAgICAgICAgICAgICAgICBhZGRVbmlxSWQoY3VycmVudEdyb3VwKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3RvcmVDaGVja2VkVHJlZSA9IGNoZWNrZWQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBhbmFseXplQ2hlY2tlZChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICBkYXRhLmZvckVhY2goY3VycmVudERhdGEgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGF0YS5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVja2VkW2N1cnJlbnREYXRhLmFjY291bnRJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGF0YS5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudERhdGEuaXRlbXMgJiYgY3VycmVudERhdGEuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYW5hbHl6ZUNoZWNrZWQoY3VycmVudERhdGEuaXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoY2hlY2tlZEdyb3Vwcykge1xuICAgICAgICAgICAgICAgIHJlc3RvcmVDaGVja2VkVHJlZShjaGVja2VkR3JvdXBzKShncm91cHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGhhc0NoaWxkQ2hlY2tlZCA9IGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLnJlZHVjZSgoYWNjdW11bGF0b3IsIGN1cnJlbnREYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudERhdGEuaXRlbXMgJiYgY3VycmVudERhdGEuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNDaGlsZENoZWNrZWQoY3VycmVudERhdGEuaXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudERhdGEuaGFzQ2hpbGRDaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yIHx8IGN1cnJlbnREYXRhLmNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBoYXNDaGlsZENoZWNrZWQoZ3JvdXBzKTtcblxuICAgICAgICAgICAgICBvcHRpb25zLnN1Y2Nlc3MoZ3JvdXBzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGdldCBncm91cFwiLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNjaGVtYToge1xuICAgICAgICBtb2RlbDoge1xuICAgICAgICAgIGlkOiBcImhpZXJhcmNoaWNhbElkXCIsXG4gICAgICAgICAgY2hpbGRyZW46IFwiaXRlbXNcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgd2luZG93LmRjcC5kb2N1bWVudC5kb2N1bWVudENvbnRyb2xsZXIoXG4gICAgXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgXCJiZWZvcmVSZW5kZXJcIixcbiAgICB7XG4gICAgICBuYW1lOiBcImNoYW5nZUdyb3VwQmVmb3JlUmVuZGVyLmNoYW5nZUdyb3VwXCIsXG4gICAgICBkb2N1bWVudENoZWNrOiBkb2N1bWVudE9iamVjdCA9PiB7XG4gICAgICAgIGNvbnN0IHNlcnZlckRhdGEgPSB3aW5kb3cuZGNwLmRvY3VtZW50LmRvY3VtZW50Q29udHJvbGxlcihcbiAgICAgICAgICBcImdldEN1c3RvbVNlcnZlckRhdGFcIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIGRvY3VtZW50T2JqZWN0LnJlbmRlck1vZGUgPT09IFwiZWRpdFwiICYmIHNlcnZlckRhdGFbXCJHUk9VUF9BTkFMWVpFXCJdXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICAoKSA9PiB7XG4gICAgICBpZiAoIWdldEdyb3VwVHJlZVNvdXJjZSkge1xuICAgICAgICBnZXRHcm91cFRyZWVTb3VyY2UgPSBpbml0VHJlZUdyb3VwKGdldEdyb3VwcygpKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG5cbiAgd2luZG93LmRjcC5kb2N1bWVudC5kb2N1bWVudENvbnRyb2xsZXIoXG4gICAgXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgXCJyZWFkeVwiLFxuICAgIHtcbiAgICAgIG5hbWU6IFwiY2hhbmdlR3JvdXBSZWFkeS5jaGFuZ2VHcm91cFwiLFxuICAgICAgZG9jdW1lbnRDaGVjazogZG9jdW1lbnRPYmplY3QgPT4ge1xuICAgICAgICBjb25zdCBzZXJ2ZXJEYXRhID0gd2luZG93LmRjcC5kb2N1bWVudC5kb2N1bWVudENvbnRyb2xsZXIoXG4gICAgICAgICAgXCJnZXRDdXN0b21TZXJ2ZXJEYXRhXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBkb2N1bWVudE9iamVjdC5yZW5kZXJNb2RlID09PSBcImVkaXRcIiAmJiBzZXJ2ZXJEYXRhW1wiR1JPVVBfQU5BTFlaRVwiXVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gICAgKCkgPT4ge1xuICAgICAgY29uc3Qgc2VydmVyRGF0YSA9IHdpbmRvdy5kY3AuZG9jdW1lbnQuZG9jdW1lbnRDb250cm9sbGVyKFxuICAgICAgICBcImdldEN1c3RvbVNlcnZlckRhdGFcIlxuICAgICAgKTtcbiAgICAgIGNoZWNrZWRHcm91cHMgPSBzZXJ2ZXJEYXRhLmdyb3VwcztcbiAgICAgIGxldCBmaWx0ZXJUaXRsZSA9IG51bGw7XG5cbiAgICAgIGNvbnN0IHVwZGF0ZVRyZWVTb3VyY2UgPSBrZW5kb1RyZWUgPT4ge1xuICAgICAgICByZXR1cm4gKGZvcmNlID0gZmFsc2UpID0+IHtcbiAgICAgICAgICBsZXQgZ3JvdXBUcmVlU291cmNlID0ga2VuZG9UcmVlLmRhdGFTb3VyY2U7XG4gICAgICAgICAgY29uc3QgZmlsdGVyID0gZmlsdGVyVGl0bGVcbiAgICAgICAgICAgID8geyBmaWVsZDogXCJ0aXRsZVwiLCBvcGVyYXRvcjogXCJjb250YWluc1wiLCB2YWx1ZTogZmlsdGVyVGl0bGUgfVxuICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgICBpZiAoZm9yY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RyZWVTb3VyY2UgPSBnZXRHcm91cFRyZWVTb3VyY2UoKTtcbiAgICAgICAgICAgIG5ld1RyZWVTb3VyY2UucmVhZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICBrZW5kb1RyZWUuc2V0RGF0YVNvdXJjZShuZXdUcmVlU291cmNlKTtcbiAgICAgICAgICAgICAgbmV3VHJlZVNvdXJjZS5maWx0ZXIoZmlsdGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncm91cFRyZWVTb3VyY2UuZmlsdGVyKGZpbHRlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgY29uc3QgZ2V0Q2hlY2tlZCA9IGNoZWNrZWQgPT4gY3VycmVudEV2ZW50Tm9kZSA9PiB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhbmFseXplQ2hlY2tlZChkYXRhU291cmNlKSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9XG4gICAgICAgICAgICBkYXRhU291cmNlIGluc3RhbmNlb2Yga2VuZG8uZGF0YS5IaWVyYXJjaGljYWxEYXRhU291cmNlICYmXG4gICAgICAgICAgICBkYXRhU291cmNlLmRhdGEoKTtcbiAgICAgICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YS5mb3JFYWNoKGN1cnJlbnROb2RlID0+IHtcbiAgICAgICAgICAgIGxldCBpc0NoZWNrZWQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRFdmVudE5vZGUuYWNjb3VudElkID09PSBjdXJyZW50Tm9kZS5hY2NvdW50SWQpIHtcbiAgICAgICAgICAgICAgaXNDaGVja2VkID0gY3VycmVudEV2ZW50Tm9kZS5jaGVja2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBpc0NoZWNrZWQgPT09IG51bGwgJiZcbiAgICAgICAgICAgICAgY3VycmVudE5vZGUuYWNjb3VudElkICYmXG4gICAgICAgICAgICAgIGN1cnJlbnROb2RlLmNoZWNrZWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpc0NoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQ2hlY2tlZCkge1xuICAgICAgICAgICAgICBjaGVja2VkW2N1cnJlbnROb2RlLmFjY291bnRJZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgIGFuYWx5emVDaGVja2VkKGN1cnJlbnROb2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGxldCB1cGRhdGVMaXN0T2ZHcm91cDtcblxuICAgICAgJChcIiNsaXN0T2ZHcm91cHNcIikua2VuZG9UcmVlVmlldyh7XG4gICAgICAgIGNoZWNrYm94ZXM6IHRydWUsXG4gICAgICAgIGRhdGFTb3VyY2U6IGdldEdyb3VwVHJlZVNvdXJjZSgpLFxuICAgICAgICBzZWxlY3Q6IGV2ZW50ID0+IHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9LFxuICAgICAgICB0ZW1wbGF0ZTpcbiAgICAgICAgICBcIjxzcGFuICMgaWYoaXRlbS5oYXNDaGlsZENoZWNrZWQpIHsjIGNsYXNzPSdoYXNDaGlsZENoZWNrZWQnICN9IyBkYXRhLWFjY291bnRJZD0nIz0gaXRlbS5hY2NvdW50SWQgIycgZGF0YS1zZS1pZD0nIz0gaXRlbS5kb2N1bWVudElkICMnPiM9IGl0ZW0udGl0bGUgIyAoIz0gaXRlbS5uYlVzZXIgIykgPC9zcGFuPlwiLFxuICAgICAgICBjaGVjazogZnVuY3Rpb24gb25UcmVlQ2hlY2soZXZlbnQpIHtcbiAgICAgICAgICBjb25zdCBldmVudE5vZGUgPSB0aGlzLmRhdGFJdGVtKGV2ZW50Lm5vZGUpO1xuICAgICAgICAgIGNvbnN0IGNoZWNrZWQgPSB7fTtcbiAgICAgICAgICBnZXRDaGVja2VkKGNoZWNrZWQpKGV2ZW50Tm9kZSkoZXZlbnQuc2VuZGVyLmRhdGFTb3VyY2UpO1xuICAgICAgICAgIGNoZWNrZWRHcm91cHMgPSBjaGVja2VkO1xuICAgICAgICAgIHdpbmRvdy5kY3AuZG9jdW1lbnQuZG9jdW1lbnRDb250cm9sbGVyKFwiYWRkQ3VzdG9tQ2xpZW50RGF0YVwiLCB7XG4gICAgICAgICAgICBwYXJlbnRHcm91cHM6IGNoZWNrZWRHcm91cHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB1cGRhdGVMaXN0T2ZHcm91cCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgICQoXCIjZm9ybUZpbHRlclwiKS5vbihcInN1Ym1pdFwiLCBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGZpbHRlclRpdGxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmaWx0ZXJUcmVlXCIpLnZhbHVlXG4gICAgICAgICAgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZpbHRlclRyZWVcIikudmFsdWUudG9Mb3dlckNhc2UoKVxuICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgdXBkYXRlTGlzdE9mR3JvdXAoKTtcbiAgICAgIH0pO1xuXG4gICAgICB1cGRhdGVMaXN0T2ZHcm91cCA9IHVwZGF0ZVRyZWVTb3VyY2UoXG4gICAgICAgICQoXCIjbGlzdE9mR3JvdXBzXCIpLmRhdGEoXCJrZW5kb1RyZWVWaWV3XCIpXG4gICAgICApO1xuICAgIH1cbiAgKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///ed7ea6f7dc20380e2940\n");

/***/ }),

/***/ "f1f6d1b513a156927c9d":
/*!**************************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.data.xml.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1051);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 1004:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.core */ \"46d3985e259824d97676\");\n\n/***/ }),\n\n/***/ 1051:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1004) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\tvar __meta__ = { // jshint ignore:line\r\n\t    id: \"data.xml\",\r\n\t    name: \"XML\",\r\n\t    category: \"framework\",\r\n\t    depends: [ \"core\" ],\r\n\t    hidden: true\r\n\t};\r\n\r\n\t/*jshint  eqnull: true, boss: true */\r\n\t(function($, undefined) {\r\n\t    var kendo = window.kendo,\r\n\t        isArray = $.isArray,\r\n\t        isPlainObject = $.isPlainObject,\r\n\t        map = $.map,\r\n\t        each = $.each,\r\n\t        extend = $.extend,\r\n\t        getter = kendo.getter,\r\n\t        Class = kendo.Class;\r\n\r\n\t    var XmlDataReader = Class.extend({\r\n\t        init: function(options) {\r\n\t            var that = this,\r\n\t                total = options.total,\r\n\t                model = options.model,\r\n\t                parse = options.parse,\r\n\t                errors = options.errors,\r\n\t                serialize = options.serialize,\r\n\t                data = options.data;\r\n\r\n\t            if (model) {\r\n\t                if (isPlainObject(model)) {\r\n\t                    var base = options.modelBase || kendo.data.Model;\r\n\r\n\t                    if (model.fields) {\r\n\t                        each(model.fields, function(field, value) {\r\n\t                            if (isPlainObject(value) && value.field) {\r\n\t                                if (!$.isFunction(value.field)) {\r\n\t                                    value = extend(value, { field: that.getter(value.field) });\r\n\t                                }\r\n\t                            } else {\r\n\t                                value = { field: that.getter(value) };\r\n\t                            }\r\n\t                            model.fields[field] = value;\r\n\t                        });\r\n\t                    }\r\n\r\n\t                    var id = model.id;\r\n\t                    if (id) {\r\n\t                        var idField = {};\r\n\r\n\t                        idField[that.xpathToMember(id, true)] = { field : that.getter(id) };\r\n\t                        model.fields = extend(idField, model.fields);\r\n\t                        model.id = that.xpathToMember(id);\r\n\t                    }\r\n\t                    model = base.define(model);\r\n\t                }\r\n\r\n\t                that.model = model;\r\n\t            }\r\n\r\n\t            if (total) {\r\n\t                if (typeof total == \"string\") {\r\n\t                    total = that.getter(total);\r\n\t                    that.total = function(data) {\r\n\t                        return parseInt(total(data), 10);\r\n\t                    };\r\n\t                } else if (typeof total == \"function\"){\r\n\t                    that.total = total;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (errors) {\r\n\t                if (typeof errors == \"string\") {\r\n\t                    errors = that.getter(errors);\r\n\t                    that.errors = function(data) {\r\n\t                        return errors(data) || null;\r\n\t                    };\r\n\t                } else if (typeof errors == \"function\"){\r\n\t                    that.errors = errors;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (data) {\r\n\t                if (typeof data == \"string\") {\r\n\t                    data = that.xpathToMember(data);\r\n\t                    that.data = function(value) {\r\n\t                        var result = that.evaluate(value, data),\r\n\t                            modelInstance;\r\n\r\n\t                        result = isArray(result) ? result : [result];\r\n\r\n\t                        if (that.model && model.fields) {\r\n\t                            modelInstance = new that.model();\r\n\r\n\t                            return map(result, function(value) {\r\n\t                                if (value) {\r\n\t                                    var record = {}, field;\r\n\r\n\t                                    for (field in model.fields) {\r\n\t                                        record[field] = modelInstance._parse(field, model.fields[field].field(value));\r\n\t                                    }\r\n\r\n\t                                    return record;\r\n\t                                }\r\n\t                            });\r\n\t                        }\r\n\r\n\t                        return result;\r\n\t                    };\r\n\t                } else if (typeof data == \"function\") {\r\n\t                    that.data = data;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (typeof parse == \"function\") {\r\n\t                var xmlParse = that.parse;\r\n\r\n\t                that.parse = function(data) {\r\n\t                    var xml = parse.call(that, data);\r\n\t                    return xmlParse.call(that, xml);\r\n\t                };\r\n\t            }\r\n\r\n\t            if (typeof serialize == \"function\") {\r\n\t                that.serialize = serialize;\r\n\t            }\r\n\t        },\r\n\t        total: function(result) {\r\n\t            return this.data(result).length;\r\n\t        },\r\n\t        errors: function(data) {\r\n\t            return data ? data.errors : null;\r\n\t        },\r\n\t        serialize: function(data) {\r\n\t            return data;\r\n\t        },\r\n\t        parseDOM: function(element) {\r\n\t            var result = {},\r\n\t                parsedNode,\r\n\t                node,\r\n\t                nodeType,\r\n\t                nodeName,\r\n\t                member,\r\n\t                attribute,\r\n\t                attributes = element.attributes,\r\n\t                attributeCount = attributes.length,\r\n\t                idx;\r\n\r\n\t            for (idx = 0; idx < attributeCount; idx++) {\r\n\t                attribute = attributes[idx];\r\n\t                result[\"@\" + attribute.nodeName] = attribute.nodeValue;\r\n\t            }\r\n\r\n\t            for (node = element.firstChild; node; node = node.nextSibling) {\r\n\t                nodeType = node.nodeType;\r\n\r\n\t                if (nodeType === 3 || nodeType === 4) {\r\n\t                    // text nodes or CDATA are stored as #text field\r\n\t                    result[\"#text\"] = node.nodeValue;\r\n\t                } else if (nodeType === 1) {\r\n\t                    // elements are stored as fields\r\n\t                    parsedNode = this.parseDOM(node);\r\n\r\n\t                    nodeName = node.nodeName;\r\n\r\n\t                    member = result[nodeName];\r\n\r\n\t                    if (isArray(member)) {\r\n\t                        // elements of same nodeName are stored as array\r\n\t                        member.push(parsedNode);\r\n\t                    } else if (member !== undefined) {\r\n\t                        member = [member, parsedNode];\r\n\t                    } else {\r\n\t                        member = parsedNode;\r\n\t                    }\r\n\r\n\t                    result[nodeName] = member;\r\n\t                }\r\n\t            }\r\n\t            return result;\r\n\t        },\r\n\r\n\t        evaluate: function(value, expression) {\r\n\t            var members = expression.split(\".\"),\r\n\t                member,\r\n\t                result,\r\n\t                length,\r\n\t                intermediateResult,\r\n\t                idx;\r\n\r\n\t            while (member = members.shift()) {\r\n\t                value = value[member];\r\n\r\n\t                if (isArray(value)) {\r\n\t                    result = [];\r\n\t                    expression = members.join(\".\");\r\n\r\n\t                    for (idx = 0, length = value.length; idx < length; idx++) {\r\n\t                        intermediateResult = this.evaluate(value[idx], expression);\r\n\r\n\t                        intermediateResult = isArray(intermediateResult) ? intermediateResult : [intermediateResult];\r\n\r\n\t                        result.push.apply(result, intermediateResult);\r\n\t                    }\r\n\r\n\t                    return result;\r\n\t                }\r\n\t            }\r\n\r\n\t            return value;\r\n\t        },\r\n\r\n\t        parse: function(xml) {\r\n\t            var documentElement,\r\n\t                tree,\r\n\t                result = {};\r\n\r\n\t            documentElement = xml.documentElement || $.parseXML(xml).documentElement;\r\n\r\n\t            tree = this.parseDOM(documentElement);\r\n\r\n\t            result[documentElement.nodeName] = tree;\r\n\r\n\t            return result;\r\n\t        },\r\n\r\n\t        xpathToMember: function(member, raw) {\r\n\t            if (!member) {\r\n\t                return \"\";\r\n\t            }\r\n\r\n\t            member = member.replace(/^\\//, \"\") // remove the first \"/\"\r\n\t                           .replace(/\\//g, \".\"); // replace all \"/\" with \".\"\r\n\r\n\t            if (member.indexOf(\"@\") >= 0) {\r\n\t                // replace @attribute with '[\"@attribute\"]'\r\n\t                return member.replace(/\\.?(@.*)/, raw? '$1':'[\"$1\"]');\r\n\t            }\r\n\r\n\t            if (member.indexOf(\"text()\") >= 0) {\r\n\t                // replace \".text()\" with '[\"#text\"]'\r\n\t                return member.replace(/(\\.?text\\(\\))/, raw? '#text':'[\"#text\"]');\r\n\t            }\r\n\r\n\t            return member;\r\n\t        },\r\n\t        getter: function(member) {\r\n\t            return getter(this.xpathToMember(member), true);\r\n\t        }\r\n\t    });\r\n\r\n\t    $.extend(true, kendo.data, {\r\n\t        XmlDataReader: XmlDataReader,\r\n\t        readers: {\r\n\t            xml: XmlDataReader\r\n\t        }\r\n\t    });\r\n\t})(window.kendo.jQuery);\r\n\r\n\treturn window.kendo;\r\n\r\n\t}, __webpack_require__(3));\r\n\n\n/***/ })\n\n/******/ });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZjFmNmQxYjUxM2ExNTY5MjdjOWQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb2dyZXNzL2tlbmRvLXVpL2pzL2tlbmRvLmRhdGEueG1sLmpzPzBlMzMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPVxuLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gMDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTA1MSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFwiZGVmaW5lIGNhbm5vdCBiZSB1c2VkIGluZGlyZWN0XCIpOyB9O1xyXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDEwMDQ6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9rZW5kby5jb3JlXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMTA1MTpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHR2YXIgX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsoZnVuY3Rpb24oZiwgZGVmaW5lKXtcclxuXHQgICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gWyBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMDQpIF0sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/IChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xyXG5cdH0pKGZ1bmN0aW9uKCl7XHJcblxyXG5cdHZhciBfX21ldGFfXyA9IHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXHJcblx0ICAgIGlkOiBcImRhdGEueG1sXCIsXHJcblx0ICAgIG5hbWU6IFwiWE1MXCIsXHJcblx0ICAgIGNhdGVnb3J5OiBcImZyYW1ld29ya1wiLFxyXG5cdCAgICBkZXBlbmRzOiBbIFwiY29yZVwiIF0sXHJcblx0ICAgIGhpZGRlbjogdHJ1ZVxyXG5cdH07XHJcblxyXG5cdC8qanNoaW50ICBlcW51bGw6IHRydWUsIGJvc3M6IHRydWUgKi9cclxuXHQoZnVuY3Rpb24oJCwgdW5kZWZpbmVkKSB7XHJcblx0ICAgIHZhciBrZW5kbyA9IHdpbmRvdy5rZW5kbyxcclxuXHQgICAgICAgIGlzQXJyYXkgPSAkLmlzQXJyYXksXHJcblx0ICAgICAgICBpc1BsYWluT2JqZWN0ID0gJC5pc1BsYWluT2JqZWN0LFxyXG5cdCAgICAgICAgbWFwID0gJC5tYXAsXHJcblx0ICAgICAgICBlYWNoID0gJC5lYWNoLFxyXG5cdCAgICAgICAgZXh0ZW5kID0gJC5leHRlbmQsXHJcblx0ICAgICAgICBnZXR0ZXIgPSBrZW5kby5nZXR0ZXIsXHJcblx0ICAgICAgICBDbGFzcyA9IGtlbmRvLkNsYXNzO1xyXG5cclxuXHQgICAgdmFyIFhtbERhdGFSZWFkZXIgPSBDbGFzcy5leHRlbmQoe1xyXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcclxuXHQgICAgICAgICAgICAgICAgdG90YWwgPSBvcHRpb25zLnRvdGFsLFxyXG5cdCAgICAgICAgICAgICAgICBtb2RlbCA9IG9wdGlvbnMubW9kZWwsXHJcblx0ICAgICAgICAgICAgICAgIHBhcnNlID0gb3B0aW9ucy5wYXJzZSxcclxuXHQgICAgICAgICAgICAgICAgZXJyb3JzID0gb3B0aW9ucy5lcnJvcnMsXHJcblx0ICAgICAgICAgICAgICAgIHNlcmlhbGl6ZSA9IG9wdGlvbnMuc2VyaWFsaXplLFxyXG5cdCAgICAgICAgICAgICAgICBkYXRhID0gb3B0aW9ucy5kYXRhO1xyXG5cclxuXHQgICAgICAgICAgICBpZiAobW9kZWwpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QobW9kZWwpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgYmFzZSA9IG9wdGlvbnMubW9kZWxCYXNlIHx8IGtlbmRvLmRhdGEuTW9kZWw7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmZpZWxkcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVhY2gobW9kZWwuZmllbGRzLCBmdW5jdGlvbihmaWVsZCwgdmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpICYmIHZhbHVlLmZpZWxkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISQuaXNGdW5jdGlvbih2YWx1ZS5maWVsZCkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGV4dGVuZCh2YWx1ZSwgeyBmaWVsZDogdGhhdC5nZXR0ZXIodmFsdWUuZmllbGQpIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB7IGZpZWxkOiB0aGF0LmdldHRlcih2YWx1ZSkgfTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5maWVsZHNbZmllbGRdID0gdmFsdWU7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gbW9kZWwuaWQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaWQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWRGaWVsZCA9IHt9O1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZEZpZWxkW3RoYXQueHBhdGhUb01lbWJlcihpZCwgdHJ1ZSldID0geyBmaWVsZCA6IHRoYXQuZ2V0dGVyKGlkKSB9O1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmZpZWxkcyA9IGV4dGVuZChpZEZpZWxkLCBtb2RlbC5maWVsZHMpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmlkID0gdGhhdC54cGF0aFRvTWVtYmVyKGlkKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgICAgIG1vZGVsID0gYmFzZS5kZWZpbmUobW9kZWwpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICB0aGF0Lm1vZGVsID0gbW9kZWw7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICBpZiAodG90YWwpIHtcclxuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3RhbCA9PSBcInN0cmluZ1wiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0b3RhbCA9IHRoYXQuZ2V0dGVyKHRvdGFsKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQudG90YWwgPSBmdW5jdGlvbihkYXRhKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRvdGFsKGRhdGEpLCAxMCk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0b3RhbCA9PSBcImZ1bmN0aW9uXCIpe1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC50b3RhbCA9IHRvdGFsO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICBpZiAoZXJyb3JzKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXJyb3JzID09IFwic3RyaW5nXCIpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IHRoYXQuZ2V0dGVyKGVycm9ycyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LmVycm9ycyA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3JzKGRhdGEpIHx8IG51bGw7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlcnJvcnMgPT0gXCJmdW5jdGlvblwiKXtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuZXJyb3JzID0gZXJyb3JzO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICBpZiAoZGF0YSkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gXCJzdHJpbmdcIikge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRoYXQueHBhdGhUb01lbWJlcihkYXRhKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuZGF0YSA9IGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoYXQuZXZhbHVhdGUodmFsdWUsIGRhdGEpLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbEluc3RhbmNlO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBpc0FycmF5KHJlc3VsdCkgPyByZXN1bHQgOiBbcmVzdWx0XTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQubW9kZWwgJiYgbW9kZWwuZmllbGRzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsSW5zdGFuY2UgPSBuZXcgdGhhdC5tb2RlbCgpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcChyZXN1bHQsIGZ1bmN0aW9uKHZhbHVlKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjb3JkID0ge30sIGZpZWxkO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGZpZWxkIGluIG1vZGVsLmZpZWxkcykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRbZmllbGRdID0gbW9kZWxJbnN0YW5jZS5fcGFyc2UoZmllbGQsIG1vZGVsLmZpZWxkc1tmaWVsZF0uZmllbGQodmFsdWUpKTtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH07XHJcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT0gXCJmdW5jdGlvblwiKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LmRhdGEgPSBkYXRhO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgeG1sUGFyc2UgPSB0aGF0LnBhcnNlO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgdGhhdC5wYXJzZSA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciB4bWwgPSBwYXJzZS5jYWxsKHRoYXQsIGRhdGEpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhtbFBhcnNlLmNhbGwodGhhdCwgeG1sKTtcclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VyaWFsaXplID09IFwiZnVuY3Rpb25cIikge1xyXG5cdCAgICAgICAgICAgICAgICB0aGF0LnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdG90YWw6IGZ1bmN0aW9uKHJlc3VsdCkge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEocmVzdWx0KS5sZW5ndGg7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgZXJyb3JzOiBmdW5jdGlvbihkYXRhKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhLmVycm9ycyA6IG51bGw7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc2VyaWFsaXplOiBmdW5jdGlvbihkYXRhKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgcGFyc2VET006IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge30sXHJcblx0ICAgICAgICAgICAgICAgIHBhcnNlZE5vZGUsXHJcblx0ICAgICAgICAgICAgICAgIG5vZGUsXHJcblx0ICAgICAgICAgICAgICAgIG5vZGVUeXBlLFxyXG5cdCAgICAgICAgICAgICAgICBub2RlTmFtZSxcclxuXHQgICAgICAgICAgICAgICAgbWVtYmVyLFxyXG5cdCAgICAgICAgICAgICAgICBhdHRyaWJ1dGUsXHJcblx0ICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBlbGVtZW50LmF0dHJpYnV0ZXMsXHJcblx0ICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUNvdW50ID0gYXR0cmlidXRlcy5sZW5ndGgsXHJcblx0ICAgICAgICAgICAgICAgIGlkeDtcclxuXHJcblx0ICAgICAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBhdHRyaWJ1dGVDb3VudDsgaWR4KyspIHtcclxuXHQgICAgICAgICAgICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpZHhdO1xyXG5cdCAgICAgICAgICAgICAgICByZXN1bHRbXCJAXCIgKyBhdHRyaWJ1dGUubm9kZU5hbWVdID0gYXR0cmlidXRlLm5vZGVWYWx1ZTtcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIGZvciAobm9kZSA9IGVsZW1lbnQuZmlyc3RDaGlsZDsgbm9kZTsgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpIHtcclxuXHQgICAgICAgICAgICAgICAgbm9kZVR5cGUgPSBub2RlLm5vZGVUeXBlO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAvLyB0ZXh0IG5vZGVzIG9yIENEQVRBIGFyZSBzdG9yZWQgYXMgI3RleHQgZmllbGRcclxuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtcIiN0ZXh0XCJdID0gbm9kZS5ub2RlVmFsdWU7XHJcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZVR5cGUgPT09IDEpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGVsZW1lbnRzIGFyZSBzdG9yZWQgYXMgZmllbGRzXHJcblx0ICAgICAgICAgICAgICAgICAgICBwYXJzZWROb2RlID0gdGhpcy5wYXJzZURPTShub2RlKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWU7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgbWVtYmVyID0gcmVzdWx0W25vZGVOYW1lXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShtZW1iZXIpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxlbWVudHMgb2Ygc2FtZSBub2RlTmFtZSBhcmUgc3RvcmVkIGFzIGFycmF5XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyLnB1c2gocGFyc2VkTm9kZSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1lbWJlciAhPT0gdW5kZWZpbmVkKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWVtYmVyID0gW21lbWJlciwgcGFyc2VkTm9kZV07XHJcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1lbWJlciA9IHBhcnNlZE5vZGU7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0W25vZGVOYW1lXSA9IG1lbWJlcjtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBldmFsdWF0ZTogZnVuY3Rpb24odmFsdWUsIGV4cHJlc3Npb24pIHtcclxuXHQgICAgICAgICAgICB2YXIgbWVtYmVycyA9IGV4cHJlc3Npb24uc3BsaXQoXCIuXCIpLFxyXG5cdCAgICAgICAgICAgICAgICBtZW1iZXIsXHJcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCxcclxuXHQgICAgICAgICAgICAgICAgbGVuZ3RoLFxyXG5cdCAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVSZXN1bHQsXHJcblx0ICAgICAgICAgICAgICAgIGlkeDtcclxuXHJcblx0ICAgICAgICAgICAgd2hpbGUgKG1lbWJlciA9IG1lbWJlcnMuc2hpZnQoKSkge1xyXG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlW21lbWJlcl07XHJcblxyXG5cdCAgICAgICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbiA9IG1lbWJlcnMuam9pbihcIi5cIik7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVSZXN1bHQgPSB0aGlzLmV2YWx1YXRlKHZhbHVlW2lkeF0sIGV4cHJlc3Npb24pO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGVSZXN1bHQgPSBpc0FycmF5KGludGVybWVkaWF0ZVJlc3VsdCkgPyBpbnRlcm1lZGlhdGVSZXN1bHQgOiBbaW50ZXJtZWRpYXRlUmVzdWx0XTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBpbnRlcm1lZGlhdGVSZXN1bHQpO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKHhtbCkge1xyXG5cdCAgICAgICAgICAgIHZhciBkb2N1bWVudEVsZW1lbnQsXHJcblx0ICAgICAgICAgICAgICAgIHRyZWUsXHJcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xyXG5cclxuXHQgICAgICAgICAgICBkb2N1bWVudEVsZW1lbnQgPSB4bWwuZG9jdW1lbnRFbGVtZW50IHx8ICQucGFyc2VYTUwoeG1sKS5kb2N1bWVudEVsZW1lbnQ7XHJcblxyXG5cdCAgICAgICAgICAgIHRyZWUgPSB0aGlzLnBhcnNlRE9NKGRvY3VtZW50RWxlbWVudCk7XHJcblxyXG5cdCAgICAgICAgICAgIHJlc3VsdFtkb2N1bWVudEVsZW1lbnQubm9kZU5hbWVdID0gdHJlZTtcclxuXHJcblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgeHBhdGhUb01lbWJlcjogZnVuY3Rpb24obWVtYmVyLCByYXcpIHtcclxuXHQgICAgICAgICAgICBpZiAoIW1lbWJlcikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIG1lbWJlciA9IG1lbWJlci5yZXBsYWNlKC9eXFwvLywgXCJcIikgLy8gcmVtb3ZlIHRoZSBmaXJzdCBcIi9cIlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXC8vZywgXCIuXCIpOyAvLyByZXBsYWNlIGFsbCBcIi9cIiB3aXRoIFwiLlwiXHJcblxyXG5cdCAgICAgICAgICAgIGlmIChtZW1iZXIuaW5kZXhPZihcIkBcIikgPj0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyByZXBsYWNlIEBhdHRyaWJ1dGUgd2l0aCAnW1wiQGF0dHJpYnV0ZVwiXSdcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1lbWJlci5yZXBsYWNlKC9cXC4/KEAuKikvLCByYXc/ICckMSc6J1tcIiQxXCJdJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICBpZiAobWVtYmVyLmluZGV4T2YoXCJ0ZXh0KClcIikgPj0gMCkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyByZXBsYWNlIFwiLnRleHQoKVwiIHdpdGggJ1tcIiN0ZXh0XCJdJ1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbWVtYmVyLnJlcGxhY2UoLyhcXC4/dGV4dFxcKFxcKSkvLCByYXc/ICcjdGV4dCc6J1tcIiN0ZXh0XCJdJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICByZXR1cm4gbWVtYmVyO1xyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIGdldHRlcjogZnVuY3Rpb24obWVtYmVyKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGdldHRlcih0aGlzLnhwYXRoVG9NZW1iZXIobWVtYmVyKSwgdHJ1ZSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0pO1xyXG5cclxuXHQgICAgJC5leHRlbmQodHJ1ZSwga2VuZG8uZGF0YSwge1xyXG5cdCAgICAgICAgWG1sRGF0YVJlYWRlcjogWG1sRGF0YVJlYWRlcixcclxuXHQgICAgICAgIHJlYWRlcnM6IHtcclxuXHQgICAgICAgICAgICB4bWw6IFhtbERhdGFSZWFkZXJcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSk7XHJcblx0fSkod2luZG93LmtlbmRvLmpRdWVyeSk7XHJcblxyXG5cdHJldHVybiB3aW5kb3cua2VuZG87XHJcblxyXG5cdH0sIF9fd2VicGFja19yZXF1aXJlX18oMykpO1xyXG5cblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///f1f6d1b513a156927c9d\n");

/***/ }),

/***/ "f78db54954381e284430":
/*!**********************************************************!*\
  !*** ./node_modules/@progress/kendo-ui/js/kendo.data.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1046);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 1004:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.core */ \"46d3985e259824d97676\");\n\n/***/ }),\n\n/***/ 1046:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1004), __webpack_require__(1047), __webpack_require__(1048) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\tvar __meta__ = { // jshint ignore:line\n\t    id: \"data\",\n\t    name: \"Data source\",\n\t    category: \"framework\",\n\t    description: \"Powerful component for using local and remote data.Fully supports CRUD, Sorting, Paging, Filtering, Grouping, and Aggregates.\",\n\t    depends: [ \"core\" ],\n\t    features: [ {\n\t        id: \"data-odata\",\n\t        name: \"OData\",\n\t        description: \"Support for accessing Open Data Protocol (OData) services.\",\n\t        depends: [ \"data.odata\" ]\n\t    }, {\n\t        id: \"data-signalr\",\n\t        name: \"SignalR\",\n\t        description: \"Support for binding to SignalR hubs.\",\n\t        depends: [ \"data.signalr\" ]\n\t    }, {\n\t        id: \"data-XML\",\n\t        name: \"XML\",\n\t        description: \"Support for binding to XML.\",\n\t        depends: [ \"data.xml\" ]\n\t    }]\n\t};\n\n\t/*jshint eqnull: true, loopfunc: true, evil: true */\n\t(function($, undefined) {\n\t    var extend = $.extend,\n\t        proxy = $.proxy,\n\t        isPlainObject = $.isPlainObject,\n\t        isEmptyObject = $.isEmptyObject,\n\t        isArray = $.isArray,\n\t        grep = $.grep,\n\t        ajax = $.ajax,\n\t        map,\n\t        each = $.each,\n\t        noop = $.noop,\n\t        kendo = window.kendo,\n\t        isFunction = kendo.isFunction,\n\t        Observable = kendo.Observable,\n\t        Class = kendo.Class,\n\t        STRING = \"string\",\n\t        FUNCTION = \"function\",\n\t        CREATE = \"create\",\n\t        READ = \"read\",\n\t        UPDATE = \"update\",\n\t        DESTROY = \"destroy\",\n\t        CHANGE = \"change\",\n\t        SYNC = \"sync\",\n\t        GET = \"get\",\n\t        ERROR = \"error\",\n\t        REQUESTSTART = \"requestStart\",\n\t        PROGRESS = \"progress\",\n\t        REQUESTEND = \"requestEnd\",\n\t        crud = [CREATE, READ, UPDATE, DESTROY],\n\t        identity = function(o) { return o; },\n\t        getter = kendo.getter,\n\t        stringify = kendo.stringify,\n\t        math = Math,\n\t        push = [].push,\n\t        join = [].join,\n\t        pop = [].pop,\n\t        splice = [].splice,\n\t        shift = [].shift,\n\t        slice = [].slice,\n\t        unshift = [].unshift,\n\t        toString = {}.toString,\n\t        stableSort = kendo.support.stableSort,\n\t        dateRegExp = /^\\/Date\\((.*?)\\)\\/$/;\n\n\t    var ObservableArray = Observable.extend({\n\t        init: function(array, type) {\n\t            var that = this;\n\n\t            that.type = type || ObservableObject;\n\n\t            Observable.fn.init.call(that);\n\n\t            that.length = array.length;\n\n\t            that.wrapAll(array, that);\n\t        },\n\n\t        at: function(index) {\n\t            return this[index];\n\t        },\n\n\t        toJSON: function() {\n\t            var idx, length = this.length, value, json = new Array(length);\n\n\t            for (idx = 0; idx < length; idx++){\n\t                value = this[idx];\n\n\t                if (value instanceof ObservableObject) {\n\t                    value = value.toJSON();\n\t                }\n\n\t                json[idx] = value;\n\t            }\n\n\t            return json;\n\t        },\n\n\t        parent: noop,\n\n\t        wrapAll: function(source, target) {\n\t            var that = this,\n\t                idx,\n\t                length,\n\t                parent = function() {\n\t                    return that;\n\t                };\n\n\t            target = target || [];\n\n\t            for (idx = 0, length = source.length; idx < length; idx++) {\n\t                target[idx] = that.wrap(source[idx], parent);\n\t            }\n\n\t            return target;\n\t        },\n\n\t        wrap: function(object, parent) {\n\t            var that = this,\n\t                observable;\n\n\t            if (object !== null && toString.call(object) === \"[object Object]\") {\n\t                observable = object instanceof that.type || object instanceof Model;\n\n\t                if (!observable) {\n\t                    object = object instanceof ObservableObject ? object.toJSON() : object;\n\t                    object = new that.type(object);\n\t                }\n\n\t                object.parent = parent;\n\n\t                object.bind(CHANGE, function(e) {\n\t                    that.trigger(CHANGE, {\n\t                        field: e.field,\n\t                        node: e.node,\n\t                        index: e.index,\n\t                        items: e.items || [this],\n\t                        action: e.node ? (e.action || \"itemloaded\") : \"itemchange\"\n\t                    });\n\t                });\n\t            }\n\n\t            return object;\n\t        },\n\n\t        push: function() {\n\t            var index = this.length,\n\t                items = this.wrapAll(arguments),\n\t                result;\n\n\t            result = push.apply(this, items);\n\n\t            this.trigger(CHANGE, {\n\t                action: \"add\",\n\t                index: index,\n\t                items: items\n\t            });\n\n\t            return result;\n\t        },\n\n\t        slice: slice,\n\n\t        sort: [].sort,\n\n\t        join: join,\n\n\t        pop: function() {\n\t            var length = this.length, result = pop.apply(this);\n\n\t            if (length) {\n\t                this.trigger(CHANGE, {\n\t                    action: \"remove\",\n\t                    index: length - 1,\n\t                    items:[result]\n\t                });\n\t            }\n\n\t            return result;\n\t        },\n\n\t        splice: function(index, howMany, item) {\n\t            var items = this.wrapAll(slice.call(arguments, 2)),\n\t                result, i, len;\n\n\t            result = splice.apply(this, [index, howMany].concat(items));\n\n\t            if (result.length) {\n\t                this.trigger(CHANGE, {\n\t                    action: \"remove\",\n\t                    index: index,\n\t                    items: result\n\t                });\n\n\t                for (i = 0, len = result.length; i < len; i++) {\n\t                    if (result[i] && result[i].children) {\n\t                        result[i].unbind(CHANGE);\n\t                    }\n\t                }\n\t            }\n\n\t            if (item) {\n\t                this.trigger(CHANGE, {\n\t                    action: \"add\",\n\t                    index: index,\n\t                    items: items\n\t                });\n\t            }\n\t            return result;\n\t        },\n\n\t        shift: function() {\n\t            var length = this.length, result = shift.apply(this);\n\n\t            if (length) {\n\t                this.trigger(CHANGE, {\n\t                    action: \"remove\",\n\t                    index: 0,\n\t                    items:[result]\n\t                });\n\t            }\n\n\t            return result;\n\t        },\n\n\t        unshift: function() {\n\t            var items = this.wrapAll(arguments),\n\t                result;\n\n\t            result = unshift.apply(this, items);\n\n\t            this.trigger(CHANGE, {\n\t                action: \"add\",\n\t                index: 0,\n\t                items: items\n\t            });\n\n\t            return result;\n\t        },\n\n\t        indexOf: function(item) {\n\t            var that = this,\n\t                idx,\n\t                length;\n\n\t            for (idx = 0, length = that.length; idx < length; idx++) {\n\t                if (that[idx] === item) {\n\t                    return idx;\n\t                }\n\t            }\n\t            return -1;\n\t        },\n\n\t        forEach: function(callback, thisArg) {\n\t            var idx = 0;\n\t            var length = this.length;\n\t            var context = thisArg || window;\n\n\t            for (; idx < length; idx++) {\n\t                callback.call(context, this[idx], idx, this);\n\t            }\n\t        },\n\n\t        map: function(callback, thisArg) {\n\t            var idx = 0;\n\t            var result = [];\n\t            var length = this.length;\n\t            var context = thisArg || window;\n\n\t            for (; idx < length; idx++) {\n\t                result[idx] = callback.call(context, this[idx], idx, this);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        reduce: function(callback) {\n\t            var idx = 0,\n\t                result,\n\t                length = this.length;\n\n\t            if (arguments.length == 2) {\n\t                result = arguments[1];\n\t            } else if (idx < length) {\n\t                result = this[idx++];\n\t            }\n\n\t            for (; idx < length; idx++) {\n\t                result = callback(result, this[idx], idx, this);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        reduceRight: function(callback) {\n\t            var idx = this.length - 1,\n\t                result;\n\n\t            if (arguments.length == 2) {\n\t                result = arguments[1];\n\t            } else if (idx > 0) {\n\t                result = this[idx--];\n\t            }\n\n\t            for (; idx >= 0; idx--) {\n\t                result = callback(result, this[idx], idx, this);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        filter: function(callback, thisArg) {\n\t            var idx = 0;\n\t            var result = [];\n\t            var item;\n\t            var length = this.length;\n\t            var context = thisArg || window;\n\n\t            for (; idx < length; idx++) {\n\t                item = this[idx];\n\t                if (callback.call(context, item, idx, this)) {\n\t                    result[result.length] = item;\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        find: function(callback, thisArg) {\n\t            var idx = 0;\n\t            var item;\n\t            var length = this.length;\n\t            var context = thisArg || window;\n\n\t            for (; idx < length; idx++) {\n\t                item = this[idx];\n\t                if (callback.call(context, item, idx, this)) {\n\t                    return item;\n\t                }\n\t            }\n\t        },\n\n\t        every: function(callback, thisArg) {\n\t            var idx = 0;\n\t            var item;\n\t            var length = this.length;\n\t            var context = thisArg || window;\n\n\t            for (; idx < length; idx++) {\n\t                item = this[idx];\n\t                if (!callback.call(context, item, idx, this)) {\n\t                    return false;\n\t                }\n\t            }\n\n\t            return true;\n\t        },\n\n\t        some: function(callback, thisArg) {\n\t            var idx = 0;\n\t            var item;\n\t            var length = this.length;\n\t            var context = thisArg || window;\n\n\t            for (; idx < length; idx++) {\n\t                item = this[idx];\n\t                if (callback.call(context, item, idx, this)) {\n\t                    return true;\n\t                }\n\t            }\n\n\t            return false;\n\t        },\n\n\t        // non-standard collection methods\n\t        remove: function(item) {\n\t            var idx = this.indexOf(item);\n\n\t            if (idx !== -1) {\n\t                this.splice(idx, 1);\n\t            }\n\t        },\n\n\t        empty: function() {\n\t            this.splice(0, this.length);\n\t        }\n\t    });\n\n\t    // Polyfill for Symbol.iterator\n\t    if (typeof Symbol !== \"undefined\" && Symbol.iterator && !ObservableArray.prototype[Symbol.iterator]) {\n\t        ObservableArray.prototype[Symbol.iterator] = [][Symbol.iterator];\n\t    }\n\n\t    var LazyObservableArray = ObservableArray.extend({\n\t        init: function (data, type, events) {\n\t            Observable.fn.init.call(this);\n\n\t            this.type = type || ObservableObject;\n\n\t            if (events) {\n\t                this._events = events;\n\t            }\n\n\t            for (var idx = 0; idx < data.length; idx++) {\n\t                this[idx] = data[idx];\n\t            }\n\n\t            this.length = idx;\n\t            this._parent = proxy(function() { return this; }, this);\n\t        },\n\t        at: function(index) {\n\t            var item = this[index];\n\n\t            if (!(item instanceof this.type)) {\n\t                item = this[index] = this.wrap(item, this._parent);\n\t            } else {\n\t                item.parent = this._parent;\n\t            }\n\n\t            return item;\n\t        }\n\t    });\n\n\t    function eventHandler(context, type, field, prefix) {\n\t        return function(e) {\n\t            var event = {}, key;\n\n\t            for (key in e) {\n\t                event[key] = e[key];\n\t            }\n\n\t            if (prefix) {\n\t                event.field = field + \".\" + e.field;\n\t            } else {\n\t                event.field = field;\n\t            }\n\n\t            if (type == CHANGE && context._notifyChange) {\n\t                context._notifyChange(event);\n\t            }\n\n\t            context.trigger(type, event);\n\t        };\n\t    }\n\n\t    var ObservableObject = Observable.extend({\n\t        init: function(value) {\n\t            var that = this,\n\t                member,\n\t                field,\n\t                parent = function() {\n\t                    return that;\n\t                };\n\n\t            Observable.fn.init.call(this);\n\n\t            this._handlers = {};\n\n\t            for (field in value) {\n\t                member = value[field];\n\n\t                if (typeof member === \"object\" && member && !member.getTime && field.charAt(0) != \"_\") {\n\t                    member = that.wrap(member, field, parent);\n\t                }\n\n\t                that[field] = member;\n\t            }\n\n\t            that.uid = kendo.guid();\n\t        },\n\n\t        shouldSerialize: function(field) {\n\t            return this.hasOwnProperty(field) && field !== \"_handlers\" && field !== \"_events\" && typeof this[field] !== FUNCTION && field !== \"uid\";\n\t        },\n\n\t        forEach: function(f) {\n\t            for (var i in this) {\n\t                if (this.shouldSerialize(i)) {\n\t                    f(this[i], i);\n\t                }\n\t            }\n\t        },\n\n\t        toJSON: function() {\n\t            var result = {}, value, field;\n\n\t            for (field in this) {\n\t                if (this.shouldSerialize(field)) {\n\t                    value = this[field];\n\n\t                    if (value instanceof ObservableObject || value instanceof ObservableArray) {\n\t                        value = value.toJSON();\n\t                    }\n\n\t                    result[field] = value;\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        get: function(field) {\n\t            var that = this, result;\n\n\t            that.trigger(GET, { field: field });\n\n\t            if (field === \"this\") {\n\t                result = that;\n\t            } else {\n\t                result = kendo.getter(field, true)(that);\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _set: function(field, value) {\n\t            var that = this;\n\t            var composite = field.indexOf(\".\") >= 0;\n\n\t            if (composite) {\n\t                var paths = field.split(\".\"),\n\t                    path = \"\";\n\n\t                while (paths.length > 1) {\n\t                    path += paths.shift();\n\t                    var obj = kendo.getter(path, true)(that);\n\t                    if (obj instanceof ObservableObject) {\n\t                        obj.set(paths.join(\".\"), value);\n\t                        return composite;\n\t                    }\n\t                    path += \".\";\n\t                }\n\t            }\n\n\t            kendo.setter(field)(that, value);\n\n\t            return composite;\n\t        },\n\n\t        set: function(field, value) {\n\t            var that = this,\n\t                isSetPrevented = false,\n\t                composite = field.indexOf(\".\") >= 0,\n\t                current = kendo.getter(field, true)(that);\n\n\t            if (current !== value) {\n\t                if (current instanceof Observable && this._handlers[field]) {\n\t                    if (this._handlers[field].get) {\n\t                       current.unbind(GET, this._handlers[field].get);\n\t                    }\n\t                    current.unbind(CHANGE, this._handlers[field].change);\n\t                }\n\n\t                isSetPrevented = that.trigger(\"set\", { field: field, value: value });\n\n\t                if (!isSetPrevented) {\n\t                    if (!composite) {\n\t                        value = that.wrap(value, field, function() { return that; });\n\t                    }\n\t                    if (!that._set(field, value) || field.indexOf(\"(\") >= 0 || field.indexOf(\"[\") >= 0) {\n\t                        that.trigger(CHANGE, { field: field });\n\t                    }\n\t                }\n\t            }\n\n\t            return isSetPrevented;\n\t        },\n\n\t        parent: noop,\n\n\t        wrap: function(object, field, parent) {\n\t            var that = this;\n\t            var get;\n\t            var change;\n\t            var type = toString.call(object);\n\n\t            if (object != null && (type === \"[object Object]\" || type === \"[object Array]\")) {\n\t                var isObservableArray = object instanceof ObservableArray;\n\t                var isDataSource = object instanceof DataSource;\n\n\t                if (type === \"[object Object]\" && !isDataSource && !isObservableArray) {\n\t                    if (!(object instanceof ObservableObject)) {\n\t                        object = new ObservableObject(object);\n\t                    }\n\n\t                    get = eventHandler(that, GET, field, true);\n\t                    object.bind(GET, get);\n\t                    change = eventHandler(that, CHANGE, field, true);\n\t                    object.bind(CHANGE, change);\n\n\t                    that._handlers[field] = { get: get, change: change };\n\t                } else if (type === \"[object Array]\" || isObservableArray || isDataSource) {\n\t                    if (!isObservableArray && !isDataSource) {\n\t                        object = new ObservableArray(object);\n\t                    }\n\n\t                    change = eventHandler(that, CHANGE, field, false);\n\n\t                    object.bind(CHANGE, change);\n\n\t                    that._handlers[field] = { change: change };\n\t                }\n\n\t                object.parent = parent;\n\t            }\n\n\t            return object;\n\t        }\n\t    });\n\n\t    function equal(x, y) {\n\t        if (x === y) {\n\t            return true;\n\t        }\n\n\t        var xtype = $.type(x), ytype = $.type(y), field;\n\n\t        if (xtype !== ytype) {\n\t            return false;\n\t        }\n\n\t        if (xtype === \"date\") {\n\t            return x.getTime() === y.getTime();\n\t        }\n\n\t        if (xtype !== \"object\" && xtype !== \"array\") {\n\t            return false;\n\t        }\n\n\t        for (field in x) {\n\t            if (!equal(x[field], y[field])) {\n\t                return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    }\n\n\t    var parsers = {\n\t        \"number\": function(value) {\n\t            if (typeof value === STRING && value.toLowerCase() === \"null\") {\n\t                return null;\n\t            }\n\t            return kendo.parseFloat(value);\n\t        },\n\n\t        \"date\": function(value) {\n\t            if (typeof value === STRING && value.toLowerCase() === \"null\") {\n\t                return null;\n\t            }\n\t            return kendo.parseDate(value);\n\t        },\n\n\t        \"boolean\": function(value) {\n\t            if (typeof value === STRING) {\n\t                if (value.toLowerCase() === \"null\") {\n\t                    return null;\n\t                } else {\n\t                    return value.toLowerCase() === \"true\";\n\t                }\n\t            }\n\t            return value != null ? !!value : value;\n\t        },\n\n\t        \"string\": function(value) {\n\t            if (typeof value === STRING && value.toLowerCase() === \"null\") {\n\t                return null;\n\t            }\n\t            return value != null ? (value + \"\") : value;\n\t        },\n\n\t        \"default\": function(value) {\n\t            return value;\n\t        }\n\t    };\n\n\t    var defaultValues = {\n\t        \"string\": \"\",\n\t        \"number\": 0,\n\t        \"date\": new Date(),\n\t        \"boolean\": false,\n\t        \"default\": \"\"\n\t    };\n\n\t    function getFieldByName(obj, name) {\n\t        var field,\n\t            fieldName;\n\n\t        for (fieldName in obj) {\n\t            field = obj[fieldName];\n\t            if (isPlainObject(field) && field.field && field.field === name) {\n\t                return field;\n\t            } else if (field === name) {\n\t                return field;\n\t            }\n\t        }\n\t        return null;\n\t    }\n\n\t    var Model = ObservableObject.extend({\n\t        init: function(data) {\n\t            var that = this;\n\n\t            if (!data || $.isEmptyObject(data)) {\n\t                data = $.extend({}, that.defaults, data);\n\n\t                if (that._initializers) {\n\t                    for (var idx = 0; idx < that._initializers.length; idx++) {\n\t                         var name = that._initializers[idx];\n\t                         data[name] = that.defaults[name]();\n\t                    }\n\t                }\n\t            }\n\n\t            ObservableObject.fn.init.call(that, data);\n\n\t            that.dirty = false;\n\t            that.dirtyFields = {};\n\n\t            if (that.idField) {\n\t                that.id = that.get(that.idField);\n\n\t                if (that.id === undefined) {\n\t                    that.id = that._defaultId;\n\t                }\n\t            }\n\t        },\n\n\t        shouldSerialize: function(field) {\n\t            return ObservableObject.fn.shouldSerialize.call(this, field) &&\n\t                field !== \"uid\" && !(this.idField !== \"id\" && field === \"id\") &&\n\t                field !== \"dirty\" &&  field !== \"dirtyFields\" && field !== \"_accessors\";\n\t        },\n\n\t        _parse: function(field, value) {\n\t            var that = this,\n\t                fieldName = field,\n\t                fields = (that.fields || {}),\n\t                parse;\n\n\t            field = fields[field];\n\t            if (!field) {\n\t                field = getFieldByName(fields, fieldName);\n\t            }\n\t            if (field) {\n\t                parse = field.parse;\n\t                if (!parse && field.type) {\n\t                    parse = parsers[field.type.toLowerCase()];\n\t                }\n\t            }\n\n\t            return parse ? parse(value) : value;\n\t        },\n\n\t        _notifyChange: function(e) {\n\t            var action = e.action;\n\n\t            if (action == \"add\" || action == \"remove\") {\n\t                this.dirty = true;\n\t                this.dirtyFields[e.field] = true;\n\t            }\n\t        },\n\n\t        editable: function(field) {\n\t            field = (this.fields || {})[field];\n\t            return field ? field.editable !== false : true;\n\t        },\n\n\t        set: function(field, value, initiator) {\n\t            var that = this;\n\t            var dirty = that.dirty;\n\n\t            if (that.editable(field)) {\n\t                value = that._parse(field, value);\n\n\t                if (!equal(value, that.get(field))) {\n\t                    that.dirty = true;\n\t                    that.dirtyFields[field] = true;\n\n\t                    if (ObservableObject.fn.set.call(that, field, value, initiator) && !dirty) {\n\t                        that.dirty = dirty;\n\n\t                        if (!that.dirty) {\n\t                            that.dirtyFields[field] = false;\n\t                        }\n\t                    }\n\t                } else {\n\t                    that.trigger(\"equalSet\", { field: field, value: value });\n\t                }\n\t            }\n\t        },\n\n\t        accept: function(data) {\n\t            var that = this,\n\t                parent = function() { return that; },\n\t                field;\n\n\t            for (field in data) {\n\t                var value = data[field];\n\n\t                if (field.charAt(0) != \"_\") {\n\t                    value = that.wrap(data[field], field, parent);\n\t                }\n\n\t                that._set(field, value);\n\t            }\n\n\t            if (that.idField) {\n\t                that.id = that.get(that.idField);\n\t            }\n\n\t            that.dirty = false;\n\t            that.dirtyFields = {};\n\t        },\n\n\t        isNew: function() {\n\t            return this.id === this._defaultId;\n\t        }\n\t    });\n\n\t    Model.define = function(base, options) {\n\t        if (options === undefined) {\n\t            options = base;\n\t            base = Model;\n\t        }\n\n\t        var model,\n\t            proto = extend({ defaults: {} }, options),\n\t            name,\n\t            field,\n\t            type,\n\t            value,\n\t            idx,\n\t            length,\n\t            fields = {},\n\t            originalName,\n\t            id = proto.id,\n\t            functionFields = [];\n\n\t        if (id) {\n\t            proto.idField = id;\n\t        }\n\n\t        if (proto.id) {\n\t            delete proto.id;\n\t        }\n\n\t        if (id) {\n\t            proto.defaults[id] = proto._defaultId = \"\";\n\t        }\n\n\t        if (toString.call(proto.fields) === \"[object Array]\") {\n\t            for (idx = 0, length = proto.fields.length; idx < length; idx++) {\n\t                field = proto.fields[idx];\n\t                if (typeof field === STRING) {\n\t                    fields[field] = {};\n\t                } else if (field.field) {\n\t                    fields[field.field] = field;\n\t                }\n\t            }\n\t            proto.fields = fields;\n\t        }\n\n\t        for (name in proto.fields) {\n\t            field = proto.fields[name];\n\t            type = field.type || \"default\";\n\t            value = null;\n\t            originalName = name;\n\n\t            name = typeof (field.field) === STRING ? field.field : name;\n\n\t            if (!field.nullable) {\n\t                value = proto.defaults[originalName !== name ? originalName : name] = field.defaultValue !== undefined ? field.defaultValue : defaultValues[type.toLowerCase()];\n\n\t                if (typeof value === \"function\") {\n\t                    functionFields.push(name);\n\t                }\n\t            }\n\n\t            if (options.id === name) {\n\t                proto._defaultId = value;\n\t            }\n\n\t            proto.defaults[originalName !== name ? originalName : name] = value;\n\n\t            field.parse = field.parse || parsers[type];\n\t        }\n\n\t        if (functionFields.length > 0) {\n\t            proto._initializers = functionFields;\n\t        }\n\n\t        model = base.extend(proto);\n\t        model.define = function(options) {\n\t            return Model.define(model, options);\n\t        };\n\n\t        if (proto.fields) {\n\t            model.fields = proto.fields;\n\t            model.idField = proto.idField;\n\t        }\n\n\t        return model;\n\t    };\n\n\t    var Comparer = {\n\t        selector: function(field) {\n\t            return isFunction(field) ? field : getter(field);\n\t        },\n\n\t        compare: function(field) {\n\t            var selector = this.selector(field);\n\t            return function (a, b) {\n\t                a = selector(a);\n\t                b = selector(b);\n\n\t                if (a == null && b == null) {\n\t                    return 0;\n\t                }\n\n\t                if (a == null) {\n\t                    return -1;\n\t                }\n\n\t                if (b == null) {\n\t                    return 1;\n\t                }\n\n\t                if (a.localeCompare) {\n\t                    return a.localeCompare(b);\n\t                }\n\n\t                return a > b ? 1 : (a < b ? -1 : 0);\n\t            };\n\t        },\n\n\t        create: function(sort) {\n\t            var compare = sort.compare || this.compare(sort.field);\n\n\t            if (sort.dir == \"desc\") {\n\t                return function(a, b) {\n\t                    return compare(b, a, true);\n\t                };\n\t            }\n\n\t            return compare;\n\t        },\n\n\t        combine: function(comparers) {\n\t            return function(a, b) {\n\t                var result = comparers[0](a, b),\n\t                    idx,\n\t                    length;\n\n\t                for (idx = 1, length = comparers.length; idx < length; idx ++) {\n\t                    result = result || comparers[idx](a, b);\n\t                }\n\n\t                return result;\n\t            };\n\t        }\n\t    };\n\n\t    var StableComparer = extend({}, Comparer, {\n\t        asc: function(field) {\n\t            var selector = this.selector(field);\n\t            return function (a, b) {\n\t                var valueA = selector(a);\n\t                var valueB = selector(b);\n\n\t                if (valueA && valueA.getTime && valueB && valueB.getTime) {\n\t                    valueA = valueA.getTime();\n\t                    valueB = valueB.getTime();\n\t                }\n\n\t                if (valueA === valueB) {\n\t                    return a.__position - b.__position;\n\t                }\n\n\t                if (valueA == null) {\n\t                    return -1;\n\t                }\n\n\t                if (valueB == null) {\n\t                    return 1;\n\t                }\n\n\t                if (valueA.localeCompare) {\n\t                    return valueA.localeCompare(valueB);\n\t                }\n\n\t                return valueA > valueB ? 1 : -1;\n\t            };\n\t        },\n\n\t        desc: function(field) {\n\t            var selector = this.selector(field);\n\t            return function (a, b) {\n\t                var valueA = selector(a);\n\t                var valueB = selector(b);\n\n\t                if (valueA && valueA.getTime && valueB && valueB.getTime) {\n\t                    valueA = valueA.getTime();\n\t                    valueB = valueB.getTime();\n\t                }\n\n\t                if (valueA === valueB) {\n\t                    return a.__position - b.__position;\n\t                }\n\n\t                if (valueA == null) {\n\t                    return 1;\n\t                }\n\n\t                if (valueB == null) {\n\t                    return -1;\n\t                }\n\n\t                if (valueB.localeCompare) {\n\t                    return valueB.localeCompare(valueA);\n\t                }\n\n\t                return valueA < valueB ? 1 : -1;\n\t            };\n\t        },\n\t        create: function(sort) {\n\t           return this[sort.dir](sort.field);\n\t        }\n\t    });\n\n\t    map = function (array, callback) {\n\t        var idx, length = array.length, result = new Array(length);\n\n\t        for (idx = 0; idx < length; idx++) {\n\t            result[idx] = callback(array[idx], idx, array);\n\t        }\n\n\t        return result;\n\t    };\n\n\t    var operators = (function(){\n\n\t        function quote(str) {\n\t            if (typeof str == \"string\") {\n\t                str = str.replace(/[\\r\\n]+/g, \"\");\n\t            }\n\t            return JSON.stringify(str);\n\t        }\n\n\t        function textOp(impl) {\n\t            return function(a, b, ignore) {\n\t                b += \"\";\n\t                if (ignore) {\n\t                    a = \"(\" + a + \" || '').toString().toLowerCase()\";\n\t                    b = b.toLowerCase();\n\t                }\n\t                return impl(a, quote(b), ignore);\n\t            };\n\t        }\n\n\t        function operator(op, a, b, ignore) {\n\t            if (b != null) {\n\t                if (typeof b === STRING) {\n\t                    var date = dateRegExp.exec(b);\n\t                    if (date) {\n\t                        b = new Date(+date[1]);\n\t                    } else if (ignore) {\n\t                        b = quote(b.toLowerCase());\n\t                        a = \"((\" + a + \" || '')+'').toLowerCase()\";\n\t                    } else {\n\t                        b = quote(b);\n\t                    }\n\t                }\n\n\t                if (b.getTime) {\n\t                    //b looks like a Date\n\t                    a = \"(\" + a + \"&&\" + a + \".getTime?\" + a + \".getTime():\" + a + \")\";\n\t                    b = b.getTime();\n\t                }\n\t            }\n\n\t            return a + \" \" + op + \" \" + b;\n\t        }\n\n\t        function getMatchRegexp(pattern) {\n\t            // take a pattern, as supported by Excel match filter, and\n\t            // convert it to the equivalent JS regular expression.\n\t            // Excel patterns support:\n\t            //\n\t            //   * - match any sequence of characters\n\t            //   ? - match a single character\n\t            //\n\t            // to match a literal * or ?, they must be prefixed by a tilde (~)\n\t            for (var rx = \"/^\", esc = false, i = 0; i < pattern.length; ++i) {\n\t                var ch = pattern.charAt(i);\n\t                if (esc) {\n\t                    rx += \"\\\\\" + ch;\n\t                } else if (ch == \"~\") {\n\t                    esc = true;\n\t                    continue;\n\t                } else if (ch == \"*\") {\n\t                    rx += \".*\";\n\t                } else if (ch == \"?\") {\n\t                    rx += \".\";\n\t                } else if (\".+^$()[]{}|\\\\/\\n\\r\\u2028\\u2029\\xA0\".indexOf(ch) >= 0) {\n\t                    rx += \"\\\\\" + ch;\n\t                } else {\n\t                    rx += ch;\n\t                }\n\t                esc = false;\n\t            }\n\t            return rx + \"$/\";\n\t        }\n\n\t        return {\n\t            quote: function(value) {\n\t                if (value && value.getTime) {\n\t                    return \"new Date(\" + value.getTime() + \")\";\n\t                }\n\t                return quote(value);\n\t            },\n\t            eq: function(a, b, ignore) {\n\t                return operator(\"==\", a, b, ignore);\n\t            },\n\t            neq: function(a, b, ignore) {\n\t                return operator(\"!=\", a, b, ignore);\n\t            },\n\t            gt: function(a, b, ignore) {\n\t                return operator(\">\", a, b, ignore);\n\t            },\n\t            gte: function(a, b, ignore) {\n\t                return operator(\">=\", a, b, ignore);\n\t            },\n\t            lt: function(a, b, ignore) {\n\t                return operator(\"<\", a, b, ignore);\n\t            },\n\t            lte: function(a, b, ignore) {\n\t                return operator(\"<=\", a, b, ignore);\n\t            },\n\t            startswith: textOp(function(a, b) {\n\t                return a + \".lastIndexOf(\" + b + \", 0) == 0\";\n\t            }),\n\t            doesnotstartwith: textOp(function(a, b) {\n\t                return a + \".lastIndexOf(\" + b + \", 0) == -1\";\n\t            }),\n\t            endswith: textOp(function(a, b) {\n\t                var n = b ? b.length - 2 : 0;\n\t                return a + \".indexOf(\" + b + \", \" + a + \".length - \" + n + \") >= 0\";\n\t            }),\n\t            doesnotendwith: textOp(function(a, b) {\n\t                var n = b ? b.length - 2 : 0;\n\t                return a + \".indexOf(\" + b + \", \" + a + \".length - \" + n + \") < 0\";\n\t            }),\n\t            contains: textOp(function(a, b) {\n\t                return a + \".indexOf(\" + b + \") >= 0\";\n\t            }),\n\t            doesnotcontain: textOp(function(a, b) {\n\t                return a + \".indexOf(\" + b + \") == -1\";\n\t            }),\n\t            matches: textOp(function(a, b){\n\t                b = b.substring(1, b.length - 1);\n\t                return getMatchRegexp(b) + \".test(\" + a + \")\";\n\t            }),\n\t            doesnotmatch: textOp(function(a, b){\n\t                b = b.substring(1, b.length - 1);\n\t                return \"!\" + getMatchRegexp(b) + \".test(\" + a + \")\";\n\t            }),\n\t            isempty: function(a) {\n\t                return a + \" === ''\";\n\t            },\n\t            isnotempty: function(a) {\n\t                return a + \" !== ''\";\n\t            },\n\t            isnull: function(a) {\n\t                return \"(\" + a + \" == null)\";\n\t            },\n\t            isnotnull: function(a) {\n\t                return \"(\" + a + \" != null)\";\n\t            },\n\t            isnullorempty: function(a) {\n\t                return \"(\" + a + \" === null) || (\" + a + \" === '')\";\n\t            },\n\t            isnotnullorempty: function(a) {\n\t                return \"(\" + a + \" !== null) && (\" + a + \" !== '')\";\n\t            }\n\t        };\n\t    })();\n\n\t    function Query(data) {\n\t        this.data = data || [];\n\t    }\n\n\t    Query.filterExpr = function(expression) {\n\t        var expressions = [],\n\t            logic = { and: \" && \", or: \" || \" },\n\t            idx,\n\t            length,\n\t            filter,\n\t            expr,\n\t            fieldFunctions = [],\n\t            operatorFunctions = [],\n\t            field,\n\t            operator,\n\t            filters = expression.filters;\n\n\t        for (idx = 0, length = filters.length; idx < length; idx++) {\n\t            filter = filters[idx];\n\t            field = filter.field;\n\t            operator = filter.operator;\n\n\t            if (filter.filters) {\n\t                expr = Query.filterExpr(filter);\n\t                //Nested function fields or operators - update their index e.g. __o[0] -> __o[1]\n\t                filter = expr.expression\n\t                .replace(/__o\\[(\\d+)\\]/g, function(match, index) {\n\t                    index = +index;\n\t                    return \"__o[\" + (operatorFunctions.length + index) + \"]\";\n\t                })\n\t                .replace(/__f\\[(\\d+)\\]/g, function(match, index) {\n\t                    index = +index;\n\t                    return \"__f[\" + (fieldFunctions.length + index) + \"]\";\n\t                });\n\n\t                operatorFunctions.push.apply(operatorFunctions, expr.operators);\n\t                fieldFunctions.push.apply(fieldFunctions, expr.fields);\n\t            } else {\n\t                if (typeof field === FUNCTION) {\n\t                    expr = \"__f[\" + fieldFunctions.length +\"](d)\";\n\t                    fieldFunctions.push(field);\n\t                } else {\n\t                    expr = kendo.expr(field);\n\t                }\n\n\t                if (typeof operator === FUNCTION) {\n\t                    filter = \"__o[\" + operatorFunctions.length + \"](\" + expr + \", \" + operators.quote(filter.value) + \")\";\n\t                    operatorFunctions.push(operator);\n\t                } else {\n\t                    filter = operators[(operator || \"eq\").toLowerCase()](expr, filter.value, filter.ignoreCase !== undefined? filter.ignoreCase : true);\n\t                }\n\t            }\n\n\t            expressions.push(filter);\n\t        }\n\n\t        return  { expression: \"(\" + expressions.join(logic[expression.logic]) + \")\", fields: fieldFunctions, operators: operatorFunctions };\n\t    };\n\n\t    function normalizeSort(field, dir) {\n\t        if (field) {\n\t            var descriptor = typeof field === STRING ? { field: field, dir: dir } : field,\n\t            descriptors = isArray(descriptor) ? descriptor : (descriptor !== undefined ? [descriptor] : []);\n\n\t            return grep(descriptors, function(d) { return !!d.dir; });\n\t        }\n\t    }\n\n\t    var operatorMap = {\n\t        \"==\": \"eq\",\n\t        equals: \"eq\",\n\t        isequalto: \"eq\",\n\t        equalto: \"eq\",\n\t        equal: \"eq\",\n\t        \"!=\": \"neq\",\n\t        ne: \"neq\",\n\t        notequals: \"neq\",\n\t        isnotequalto: \"neq\",\n\t        notequalto: \"neq\",\n\t        notequal: \"neq\",\n\t        \"<\": \"lt\",\n\t        islessthan: \"lt\",\n\t        lessthan: \"lt\",\n\t        less: \"lt\",\n\t        \"<=\": \"lte\",\n\t        le: \"lte\",\n\t        islessthanorequalto: \"lte\",\n\t        lessthanequal: \"lte\",\n\t        \">\": \"gt\",\n\t        isgreaterthan: \"gt\",\n\t        greaterthan: \"gt\",\n\t        greater: \"gt\",\n\t        \">=\": \"gte\",\n\t        isgreaterthanorequalto: \"gte\",\n\t        greaterthanequal: \"gte\",\n\t        ge: \"gte\",\n\t        notsubstringof: \"doesnotcontain\",\n\t        isnull: \"isnull\",\n\t        isempty: \"isempty\",\n\t        isnotempty: \"isnotempty\"\n\t    };\n\n\t    function normalizeOperator(expression) {\n\t        var idx,\n\t        length,\n\t        filter,\n\t        operator,\n\t        filters = expression.filters;\n\n\t        if (filters) {\n\t            for (idx = 0, length = filters.length; idx < length; idx++) {\n\t                filter = filters[idx];\n\t                operator = filter.operator;\n\n\t                if (operator && typeof operator === STRING) {\n\t                    filter.operator = operatorMap[operator.toLowerCase()] || operator;\n\t                }\n\n\t                normalizeOperator(filter);\n\t            }\n\t        }\n\t    }\n\n\t    function normalizeFilter(expression) {\n\t        if (expression && !isEmptyObject(expression)) {\n\t            if (isArray(expression) || !expression.filters) {\n\t                expression = {\n\t                    logic: \"and\",\n\t                    filters: isArray(expression) ? expression : [expression]\n\t                };\n\t            }\n\n\t            normalizeOperator(expression);\n\n\t            return expression;\n\t        }\n\t    }\n\n\t    Query.normalizeFilter = normalizeFilter;\n\n\t    function compareDescriptor(f1, f2) {\n\t        if (f1.logic || f2.logic) {\n\t            return false;\n\t        }\n\n\t        return f1.field === f2.field && f1.value === f2.value && f1.operator === f2.operator;\n\t    }\n\n\t    function normalizeDescriptor(filter) {\n\t        filter = filter || {};\n\n\t        if (isEmptyObject(filter)) {\n\t            return { logic: \"and\", filters: [] };\n\t        }\n\n\t        return normalizeFilter(filter);\n\t    }\n\n\t    function fieldComparer(a, b) {\n\t        if (b.logic || (a.field > b.field)) {\n\t            return 1;\n\t        } else if (a.field < b.field) {\n\t            return -1;\n\t        } else {\n\t            return 0;\n\t        }\n\t    }\n\n\t    function compareFilters(expr1, expr2) {\n\t        expr1 = normalizeDescriptor(expr1);\n\t        expr2 = normalizeDescriptor(expr2);\n\n\t        if (expr1.logic !== expr2.logic) {\n\t            return false;\n\t        }\n\n\t        var f1, f2;\n\t        var filters1 = (expr1.filters || []).slice();\n\t        var filters2 = (expr2.filters || []).slice();\n\n\t        if (filters1.length !== filters2.length) {\n\t            return false;\n\t        }\n\n\t        filters1 = filters1.sort(fieldComparer);\n\t        filters2 = filters2.sort(fieldComparer);\n\n\t        for (var idx = 0; idx < filters1.length; idx++) {\n\t            f1 = filters1[idx];\n\t            f2 = filters2[idx];\n\n\t            if (f1.logic && f2.logic) {\n\t                if (!compareFilters(f1, f2)) {\n\t                    return false;\n\t                }\n\t            } else if (!compareDescriptor(f1, f2)) {\n\t                return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    }\n\n\t    Query.compareFilters = compareFilters;\n\n\t    function normalizeAggregate(expressions) {\n\t        return isArray(expressions) ? expressions : [expressions];\n\t    }\n\n\t    function normalizeGroup(field, dir) {\n\t        var descriptor = typeof field === STRING ? { field: field, dir: dir } : field,\n\t        descriptors = isArray(descriptor) ? descriptor : (descriptor !== undefined ? [descriptor] : []);\n\n\t        return map(descriptors, function(d) { return { field: d.field, dir: d.dir || \"asc\", aggregates: d.aggregates }; });\n\t    }\n\n\t    Query.prototype = {\n\t        toArray: function () {\n\t            return this.data;\n\t        },\n\t        range: function(index, count) {\n\t            return new Query(this.data.slice(index, index + count));\n\t        },\n\t        skip: function (count) {\n\t            return new Query(this.data.slice(count));\n\t        },\n\t        take: function (count) {\n\t            return new Query(this.data.slice(0, count));\n\t        },\n\t        select: function (selector) {\n\t            return new Query(map(this.data, selector));\n\t        },\n\t        order: function(selector, dir, inPlace) {\n\t            var sort = { dir: dir };\n\n\t            if (selector) {\n\t                if (selector.compare) {\n\t                    sort.compare = selector.compare;\n\t                } else {\n\t                    sort.field = selector;\n\t                }\n\t            }\n\n\t            if (inPlace) {\n\t                return new Query(this.data.sort(Comparer.create(sort)));\n\t            }\n\t            return new Query(this.data.slice(0).sort(Comparer.create(sort)));\n\t        },\n\t        orderBy: function(selector, inPlace) {\n\t            return this.order(selector, \"asc\", inPlace);\n\t        },\n\t        orderByDescending: function(selector, inPlace) {\n\t            return this.order(selector, \"desc\", inPlace);\n\t        },\n\t        sort: function(field, dir, comparer, inPlace) {\n\t            var idx,\n\t            length,\n\t            descriptors = normalizeSort(field, dir),\n\t            comparers = [];\n\n\t            comparer = comparer || Comparer;\n\n\t            if (descriptors.length) {\n\t                for (idx = 0, length = descriptors.length; idx < length; idx++) {\n\t                    comparers.push(comparer.create(descriptors[idx]));\n\t                }\n\n\t                return this.orderBy({ compare: comparer.combine(comparers) }, inPlace);\n\t            }\n\n\t            return this;\n\t        },\n\n\t        filter: function(expressions) {\n\t            var idx,\n\t            current,\n\t            length,\n\t            compiled,\n\t            predicate,\n\t            data = this.data,\n\t            fields,\n\t            operators,\n\t            result = [],\n\t            filter;\n\n\t            expressions = normalizeFilter(expressions);\n\n\t            if (!expressions || expressions.filters.length === 0) {\n\t                return this;\n\t            }\n\n\t            compiled = Query.filterExpr(expressions);\n\t            fields = compiled.fields;\n\t            operators = compiled.operators;\n\n\t            predicate = filter = new Function(\"d, __f, __o\", \"return \" + compiled.expression);\n\n\t            if (fields.length || operators.length) {\n\t                filter = function(d) {\n\t                    return predicate(d, fields, operators);\n\t                };\n\t            }\n\n\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                current = data[idx];\n\n\t                if (filter(current)) {\n\t                    result.push(current);\n\t                }\n\t            }\n\n\t            return new Query(result);\n\t        },\n\n\t        group: function(descriptors, allData) {\n\t            descriptors =  normalizeGroup(descriptors || []);\n\t            allData = allData || this.data;\n\n\t            var that = this,\n\t            result = new Query(that.data),\n\t            descriptor;\n\n\t            if (descriptors.length > 0) {\n\t                descriptor = descriptors[0];\n\t                result = result.groupBy(descriptor).select(function(group) {\n\t                    var data = new Query(allData).filter([ { field: group.field, operator: \"eq\", value: group.value, ignoreCase: false } ]);\n\t                    return {\n\t                        field: group.field,\n\t                        value: group.value,\n\t                        items: descriptors.length > 1 ? new Query(group.items).group(descriptors.slice(1), data.toArray()).toArray() : group.items,\n\t                        hasSubgroups: descriptors.length > 1,\n\t                        aggregates: data.aggregate(descriptor.aggregates)\n\t                    };\n\t                });\n\t            }\n\t            return result;\n\t        },\n\n\t        groupBy: function(descriptor) {\n\t            if (isEmptyObject(descriptor) || !this.data.length) {\n\t                return new Query([]);\n\t            }\n\n\t            var field = descriptor.field,\n\t                sorted = this._sortForGrouping(field, descriptor.dir || \"asc\"),\n\t                accessor = kendo.accessor(field),\n\t                item,\n\t                groupValue = accessor.get(sorted[0], field),\n\t                group = {\n\t                    field: field,\n\t                    value: groupValue,\n\t                    items: []\n\t                },\n\t                currentValue,\n\t                idx,\n\t                len,\n\t                result = [group];\n\n\t            for(idx = 0, len = sorted.length; idx < len; idx++) {\n\t                item = sorted[idx];\n\t                currentValue = accessor.get(item, field);\n\t                if(!groupValueComparer(groupValue, currentValue)) {\n\t                    groupValue = currentValue;\n\t                    group = {\n\t                        field: field,\n\t                        value: groupValue,\n\t                        items: []\n\t                    };\n\t                    result.push(group);\n\t                }\n\t                group.items.push(item);\n\t            }\n\t            return new Query(result);\n\t        },\n\n\t        _sortForGrouping: function(field, dir) {\n\t            var idx, length,\n\t                data = this.data;\n\n\t            if (!stableSort) {\n\t                for (idx = 0, length = data.length; idx < length; idx++) {\n\t                    data[idx].__position = idx;\n\t                }\n\n\t                data = new Query(data).sort(field, dir, StableComparer).toArray();\n\n\t                for (idx = 0, length = data.length; idx < length; idx++) {\n\t                    delete data[idx].__position;\n\t                }\n\t                return data;\n\t            }\n\t            return this.sort(field, dir).toArray();\n\t        },\n\n\t        aggregate: function (aggregates) {\n\t            var idx,\n\t                len,\n\t                result = {},\n\t                state = {};\n\n\t            if (aggregates && aggregates.length) {\n\t                for(idx = 0, len = this.data.length; idx < len; idx++) {\n\t                    calculateAggregate(result, aggregates, this.data[idx], idx, len, state);\n\t                }\n\t            }\n\t            return result;\n\t        }\n\t    };\n\n\t    function groupValueComparer(a, b) {\n\t        if (a && a.getTime && b && b.getTime) {\n\t            return a.getTime() === b.getTime();\n\t        }\n\t        return a === b;\n\t    }\n\n\t    function calculateAggregate(accumulator, aggregates, item, index, length, state) {\n\t        aggregates = aggregates || [];\n\t        var idx,\n\t            aggr,\n\t            functionName,\n\t            len = aggregates.length;\n\n\t        for (idx = 0; idx < len; idx++) {\n\t            aggr = aggregates[idx];\n\t            functionName = aggr.aggregate;\n\t            var field = aggr.field;\n\t            accumulator[field] = accumulator[field] || {};\n\t            state[field] = state[field] || {};\n\t            state[field][functionName] = state[field][functionName] || {};\n\t            accumulator[field][functionName] = functions[functionName.toLowerCase()](accumulator[field][functionName], item, kendo.accessor(field), index, length, state[field][functionName]);\n\t        }\n\t    }\n\n\t    var functions = {\n\t        sum: function(accumulator, item, accessor) {\n\t            var value = accessor.get(item);\n\n\t            if (!isNumber(accumulator)) {\n\t                accumulator = value;\n\t            } else if (isNumber(value)) {\n\t                accumulator += value;\n\t            }\n\n\t            return accumulator;\n\t        },\n\t        count: function(accumulator) {\n\t            return (accumulator || 0) + 1;\n\t        },\n\t        average: function(accumulator, item, accessor, index, length, state) {\n\t            var value = accessor.get(item);\n\n\t            if (state.count === undefined) {\n\t                state.count = 0;\n\t            }\n\n\t            if (!isNumber(accumulator)) {\n\t                accumulator = value;\n\t            } else if (isNumber(value)) {\n\t                accumulator += value;\n\t            }\n\n\t            if (isNumber(value)) {\n\t                state.count++;\n\t            }\n\n\t            if(index == length - 1 && isNumber(accumulator)) {\n\t                accumulator = accumulator / state.count;\n\t            }\n\t            return accumulator;\n\t        },\n\t        max: function(accumulator, item, accessor) {\n\t            var value = accessor.get(item);\n\n\t            if (!isNumber(accumulator) && !isDate(accumulator)) {\n\t                accumulator = value;\n\t            }\n\n\t            if(accumulator < value && (isNumber(value) || isDate(value))) {\n\t                accumulator = value;\n\t            }\n\t            return accumulator;\n\t        },\n\t        min: function(accumulator, item, accessor) {\n\t            var value = accessor.get(item);\n\n\t            if (!isNumber(accumulator) && !isDate(accumulator)) {\n\t                accumulator = value;\n\t            }\n\n\t            if(accumulator > value && (isNumber(value) || isDate(value))) {\n\t                accumulator = value;\n\t            }\n\t            return accumulator;\n\t        }\n\t    };\n\n\t    function isNumber(val) {\n\t        return typeof val === \"number\" && !isNaN(val);\n\t    }\n\n\t    function isDate(val) {\n\t        return val && val.getTime;\n\t    }\n\n\t    function toJSON(array) {\n\t        var idx, length = array.length, result = new Array(length);\n\n\t        for (idx = 0; idx < length; idx++) {\n\t            result[idx] = array[idx].toJSON();\n\t        }\n\n\t        return result;\n\t    }\n\n\t    Query.normalizeGroup = normalizeGroup;\n\t    Query.normalizeSort = normalizeSort;\n\n\t    Query.process = function(data, options, inPlace) {\n\t        options = options || {};\n\n\t        var query = new Query(data),\n\t            group = options.group,\n\t            sort = normalizeGroup(group || []).concat(normalizeSort(options.sort || [])),\n\t            total,\n\t            filterCallback = options.filterCallback,\n\t            filter = options.filter,\n\t            skip = options.skip,\n\t            take = options.take;\n\n\t        if (sort && inPlace) {\n\t            query = query.sort(sort, undefined, undefined, inPlace);\n\t        }\n\n\t        if (filter) {\n\t            query = query.filter(filter);\n\n\t            if (filterCallback) {\n\t                query = filterCallback(query);\n\t            }\n\n\t            total = query.toArray().length;\n\t        }\n\n\t        if (sort && !inPlace) {\n\t            query = query.sort(sort);\n\n\t            if (group) {\n\t                data = query.toArray();\n\t            }\n\t        }\n\n\t        if (skip !== undefined && take !== undefined) {\n\t            query = query.range(skip, take);\n\t        }\n\n\t        if (group) {\n\t            query = query.group(group, data);\n\t        }\n\n\t        return {\n\t            total: total,\n\t            data: query.toArray()\n\t        };\n\t    };\n\n\t    var LocalTransport = Class.extend({\n\t        init: function(options) {\n\t            this.data = options.data;\n\t        },\n\n\t        read: function(options) {\n\t            options.success(this.data);\n\t        },\n\t        update: function(options) {\n\t            options.success(options.data);\n\t        },\n\t        create: function(options) {\n\t            options.success(options.data);\n\t        },\n\t        destroy: function(options) {\n\t            options.success(options.data);\n\t        }\n\t    });\n\n\t    var RemoteTransport = Class.extend( {\n\t        init: function(options) {\n\t            var that = this, parameterMap;\n\n\t            options = that.options = extend({}, that.options, options);\n\n\t            each(crud, function(index, type) {\n\t                if (typeof options[type] === STRING) {\n\t                    options[type] = {\n\t                        url: options[type]\n\t                    };\n\t                }\n\t            });\n\n\t            that.cache = options.cache? Cache.create(options.cache) : {\n\t                find: noop,\n\t                add: noop\n\t            };\n\n\t            parameterMap = options.parameterMap;\n\n\t            if (options.submit) {\n\t                that.submit = options.submit;\n\t            }\n\n\t            if (isFunction(options.push)) {\n\t                that.push = options.push;\n\t            }\n\n\t            if (!that.push) {\n\t                that.push = identity;\n\t            }\n\n\t            that.parameterMap = isFunction(parameterMap) ? parameterMap : function(options) {\n\t                var result = {};\n\n\t                each(options, function(option, value) {\n\t                    if (option in parameterMap) {\n\t                        option = parameterMap[option];\n\t                        if (isPlainObject(option)) {\n\t                            value = option.value(value);\n\t                            option = option.key;\n\t                        }\n\t                    }\n\n\t                    result[option] = value;\n\t                });\n\n\t                return result;\n\t            };\n\t        },\n\n\t        options: {\n\t            parameterMap: identity\n\t        },\n\n\t        create: function(options) {\n\t            return ajax(this.setup(options, CREATE));\n\t        },\n\n\t        read: function(options) {\n\t            var that = this,\n\t                success,\n\t                error,\n\t                result,\n\t                cache = that.cache;\n\n\t            options = that.setup(options, READ);\n\n\t            success = options.success || noop;\n\t            error = options.error || noop;\n\n\t            result = cache.find(options.data);\n\n\t            if(result !== undefined) {\n\t                success(result);\n\t            } else {\n\t                options.success = function(result) {\n\t                    cache.add(options.data, result);\n\n\t                    success(result);\n\t                };\n\n\t                $.ajax(options);\n\t            }\n\t        },\n\n\t        update: function(options) {\n\t            return ajax(this.setup(options, UPDATE));\n\t        },\n\n\t        destroy: function(options) {\n\t            return ajax(this.setup(options, DESTROY));\n\t        },\n\n\t        setup: function(options, type) {\n\t            options = options || {};\n\n\t            var that = this,\n\t                parameters,\n\t                operation = that.options[type],\n\t                data = isFunction(operation.data) ? operation.data(options.data) : operation.data;\n\n\t            options = extend(true, {}, operation, options);\n\t            parameters = extend(true, {}, data, options.data);\n\n\t            options.data = that.parameterMap(parameters, type);\n\n\t            if (isFunction(options.url)) {\n\t                options.url = options.url(parameters);\n\t            }\n\n\t            return options;\n\t        }\n\t    });\n\n\t    var Cache = Class.extend({\n\t        init: function() {\n\t            this._store = {};\n\t        },\n\t        add: function(key, data) {\n\t            if(key !== undefined) {\n\t                this._store[stringify(key)] = data;\n\t            }\n\t        },\n\t        find: function(key) {\n\t            return this._store[stringify(key)];\n\t        },\n\t        clear: function() {\n\t            this._store = {};\n\t        },\n\t        remove: function(key) {\n\t            delete this._store[stringify(key)];\n\t        }\n\t    });\n\n\t    Cache.create = function(options) {\n\t        var store = {\n\t            \"inmemory\": function() { return new Cache(); }\n\t        };\n\n\t        if (isPlainObject(options) && isFunction(options.find)) {\n\t            return options;\n\t        }\n\n\t        if (options === true) {\n\t            return new Cache();\n\t        }\n\n\t        return store[options]();\n\t    };\n\n\t    function serializeRecords(data, getters, modelInstance, originalFieldNames, fieldNames) {\n\t        var record,\n\t            getter,\n\t            originalName,\n\t            idx,\n\t            setters = {},\n\t            length;\n\n\t        for (idx = 0, length = data.length; idx < length; idx++) {\n\t            record = data[idx];\n\t            for (getter in getters) {\n\t                originalName = fieldNames[getter];\n\n\t                if (originalName && originalName !== getter) {\n\t                    if (!setters[originalName]) {\n\t                        setters[originalName] = kendo.setter(originalName);\n\t                    }\n\t                    setters[originalName](record, getters[getter](record));\n\t                    delete record[getter];\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    function convertRecords(data, getters, modelInstance, originalFieldNames, fieldNames) {\n\t        var record,\n\t            getter,\n\t            originalName,\n\t            idx,\n\t            length;\n\n\t        for (idx = 0, length = data.length; idx < length; idx++) {\n\t            record = data[idx];\n\t            for (getter in getters) {\n\t                record[getter] = modelInstance._parse(getter, getters[getter](record));\n\n\t                originalName = fieldNames[getter];\n\t                if (originalName && originalName !== getter) {\n\t                    delete record[originalName];\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    function convertGroup(data, getters, modelInstance, originalFieldNames, fieldNames) {\n\t        var record,\n\t            idx,\n\t            fieldName,\n\t            length;\n\n\t        for (idx = 0, length = data.length; idx < length; idx++) {\n\t            record = data[idx];\n\n\t            fieldName = originalFieldNames[record.field];\n\t            if (fieldName && fieldName != record.field) {\n\t                record.field = fieldName;\n\t            }\n\n\t            record.value = modelInstance._parse(record.field, record.value);\n\n\t            if (record.hasSubgroups) {\n\t                convertGroup(record.items, getters, modelInstance, originalFieldNames, fieldNames);\n\t            } else {\n\t                convertRecords(record.items, getters, modelInstance, originalFieldNames, fieldNames);\n\t            }\n\t        }\n\t    }\n\n\t    function wrapDataAccess(originalFunction, model, converter, getters, originalFieldNames, fieldNames) {\n\t        return function(data) {\n\t            data = originalFunction(data);\n\n\t            return wrapDataAccessBase(model, converter, getters, originalFieldNames, fieldNames)(data);\n\t        };\n\t    }\n\n\t    function wrapDataAccessBase(model, converter, getters, originalFieldNames, fieldNames) {\n\t        return function(data) {\n\n\t            if (data && !isEmptyObject(getters)) {\n\t                if (toString.call(data) !== \"[object Array]\" && !(data instanceof ObservableArray)) {\n\t                    data = [data];\n\t                }\n\n\t                converter(data, getters, new model(), originalFieldNames, fieldNames);\n\t            }\n\n\t            return data || [];\n\t        };\n\t    }\n\n\t    var DataReader = Class.extend({\n\t        init: function(schema) {\n\t            var that = this, member, get, model, base;\n\n\t            schema = schema || {};\n\n\t            for (member in schema) {\n\t                get = schema[member];\n\n\t                that[member] = typeof get === STRING ? getter(get) : get;\n\t            }\n\n\t            base = schema.modelBase || Model;\n\n\t            if (isPlainObject(that.model)) {\n\t                that.model = model = base.define(that.model);\n\t            }\n\n\t            var dataFunction = proxy(that.data, that);\n\n\t            that._dataAccessFunction = dataFunction;\n\n\t            if (that.model) {\n\t                var groupsFunction = proxy(that.groups, that),\n\t                    serializeFunction = proxy(that.serialize, that),\n\t                    originalFieldNames = {},\n\t                    getters = {},\n\t                    serializeGetters = {},\n\t                    fieldNames = {},\n\t                    shouldSerialize = false,\n\t                    fieldName,\n\t                    name;\n\n\t                model = that.model;\n\n\t                if (model.fields) {\n\t                    each(model.fields, function(field, value) {\n\t                        var fromName;\n\n\t                        fieldName = field;\n\n\t                        if (isPlainObject(value) && value.field) {\n\t                            fieldName = value.field;\n\t                        } else if (typeof value === STRING) {\n\t                            fieldName = value;\n\t                        }\n\n\t                        if (isPlainObject(value) && value.from) {\n\t                            fromName = value.from;\n\t                        }\n\n\t                        shouldSerialize = shouldSerialize || (fromName && fromName !== field) || fieldName !== field;\n\t                        name = fromName || fieldName;\n\t                        getters[field] = name.indexOf(\".\") !== -1 ? getter(name, true) : getter(name);\n\t                        serializeGetters[field] = getter(field);\n\t                        originalFieldNames[fromName || fieldName] = field;\n\t                        fieldNames[field] = fromName || fieldName;\n\t                    });\n\n\t                    if (!schema.serialize && shouldSerialize) {\n\t                        that.serialize = wrapDataAccess(serializeFunction, model, serializeRecords, serializeGetters, originalFieldNames, fieldNames);\n\t                    }\n\t                }\n\n\t                that._dataAccessFunction = dataFunction;\n\t                that._wrapDataAccessBase = wrapDataAccessBase(model, convertRecords, getters, originalFieldNames, fieldNames);\n\t                that.data = wrapDataAccess(dataFunction, model, convertRecords, getters, originalFieldNames, fieldNames);\n\t                that.groups = wrapDataAccess(groupsFunction, model, convertGroup, getters, originalFieldNames, fieldNames);\n\t            }\n\t        },\n\t        errors: function(data) {\n\t            return data ? data.errors : null;\n\t        },\n\t        parse: identity,\n\t        data: identity,\n\t        total: function(data) {\n\t            return data.length;\n\t        },\n\t        groups: identity,\n\t        aggregates: function() {\n\t            return {};\n\t        },\n\t        serialize: function(data) {\n\t            return data;\n\t        }\n\t    });\n\n\t    function fillLastGroup(originalGroup, newGroup) {\n\t        var currOriginal;\n\t        var currentNew;\n\n\t        if (newGroup.items && newGroup.items.length) {\n\t            for (var i = 0; i < newGroup.items.length; i++) {\n\t                currOriginal = originalGroup.items[i];\n\t                currentNew = newGroup.items[i];\n\t                if (currOriginal && currentNew) {\n\t                    if (currOriginal.hasSubgroups) {\n\t                        fillLastGroup(currOriginal, currentNew);\n\t                    } else if (currOriginal.field && currOriginal.value == currentNew.value) {\n\t                        currOriginal.items.push.apply(currOriginal.items, currentNew.items);\n\t                    } else {\n\t                        originalGroup.items.push.apply(originalGroup.items, [currentNew]);\n\t                    }\n\t                } else if (currentNew) {\n\t                    originalGroup.items.push.apply(originalGroup.items, [currentNew]);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    function mergeGroups(target, dest, skip, take) {\n\t        var group,\n\t            idx = 0,\n\t            items;\n\n\t        while (dest.length && take) {\n\t            group = dest[idx];\n\t            items = group.items;\n\n\t            var length = items.length;\n\n\t            if (target && target.field === group.field && target.value === group.value) {\n\t                if (target.hasSubgroups && target.items.length) {\n\t                    mergeGroups(target.items[target.items.length - 1], group.items, skip, take);\n\t                } else {\n\t                    items = items.slice(skip, skip + take);\n\t                    target.items = target.items.concat(items);\n\t                }\n\t                dest.splice(idx--, 1);\n\t            } else if (group.hasSubgroups && items.length) {\n\t                mergeGroups(group, items, skip, take);\n\t                if (!group.items.length) {\n\t                    dest.splice(idx--, 1);\n\t                }\n\t            } else {\n\t                items = items.slice(skip, skip + take);\n\t                group.items = items;\n\n\t                if (!group.items.length) {\n\t                    dest.splice(idx--, 1);\n\t                }\n\t            }\n\n\t            if (items.length === 0) {\n\t                skip -= length;\n\t            } else {\n\t                skip = 0;\n\t                take -= items.length;\n\t            }\n\n\t            if (++idx >= dest.length) {\n\t                break;\n\t            }\n\t        }\n\n\t        if (idx < dest.length) {\n\t            dest.splice(idx, dest.length - idx);\n\t        }\n\t    }\n\n\t    function flattenGroups(data) {\n\t        var idx,\n\t            result = [],\n\t            length,\n\t            items,\n\t            itemIndex;\n\n\t        for (idx = 0, length = data.length; idx < length; idx++) {\n\t            var group = data.at(idx);\n\t            if (group.hasSubgroups) {\n\t                result = result.concat(flattenGroups(group.items));\n\t            } else {\n\t                items = group.items;\n\t                for (itemIndex = 0; itemIndex < items.length; itemIndex++) {\n\t                    result.push(items.at(itemIndex));\n\t                }\n\t            }\n\t        }\n\t        return result;\n\t    }\n\n\t    function wrapGroupItems(data, model) {\n\t        var idx, length, group;\n\t        if (model) {\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                group = data.at(idx);\n\n\t                if (group.hasSubgroups) {\n\t                    wrapGroupItems(group.items, model);\n\t                } else {\n\t                    group.items = new LazyObservableArray(group.items, model, group.items._events);\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    function eachGroupItems(data, func) {\n\t        for (var idx = 0; idx < data.length; idx++) {\n\t            if (data[idx].hasSubgroups) {\n\t                if (eachGroupItems(data[idx].items, func)) {\n\t                    return true;\n\t                }\n\t            } else if (func(data[idx].items, data[idx])) {\n\t                return true;\n\t            }\n\t        }\n\t    }\n\n\t    function replaceInRanges(ranges, data, item, observable) {\n\t        for (var idx = 0; idx < ranges.length; idx++) {\n\t            if (ranges[idx].data === data) {\n\t                break;\n\t            }\n\t            if (replaceInRange(ranges[idx].data, item, observable)) {\n\t                break;\n\t            }\n\t        }\n\t    }\n\n\t    function replaceInRange(items, item, observable) {\n\t        for (var idx = 0, length = items.length; idx < length; idx++) {\n\t            if (items[idx] && items[idx].hasSubgroups) {\n\t                return replaceInRange(items[idx].items, item, observable);\n\t            } else if (items[idx] === item || items[idx] === observable) {\n\t               items[idx] = observable;\n\t               return true;\n\t            }\n\t        }\n\t    }\n\n\t    function replaceWithObservable(view, data, ranges, type, serverGrouping) {\n\t        for (var viewIndex = 0, length = view.length; viewIndex < length; viewIndex++) {\n\t            var item = view[viewIndex];\n\n\t            if (!item || item instanceof type) {\n\t                continue;\n\t            }\n\n\t            if (item.hasSubgroups !== undefined && !serverGrouping) {\n\t                replaceWithObservable(item.items, data, ranges, type, serverGrouping);\n\t            } else {\n\t                for (var idx = 0; idx < data.length; idx++) {\n\t                    if (data[idx] === item) {\n\t                        view[viewIndex] = data.at(idx);\n\t                        replaceInRanges(ranges, data, item, view[viewIndex]);\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    function removeModel(data, model) {\n\t        var length = data.length;\n\t        var dataItem;\n\t        var idx;\n\n\t        for (idx = 0; idx < length; idx++) {\n\t            dataItem = data[idx];\n\n\t            if (dataItem.uid && dataItem.uid == model.uid) {\n\t                data.splice(idx, 1);\n\t                return dataItem;\n\t            }\n\t        }\n\t    }\n\n\t    function indexOfPristineModel(data, model) {\n\t        if (model) {\n\t            return indexOf(data, function(item) {\n\t                return (item.uid && item.uid == model.uid) || (item[model.idField] === model.id && model.id !== model._defaultId);\n\t            });\n\t        }\n\t        return -1;\n\t    }\n\n\t    function indexOfModel(data, model) {\n\t        if (model) {\n\t            return indexOf(data, function(item) {\n\t                return item.uid == model.uid;\n\t            });\n\t        }\n\t        return -1;\n\t    }\n\n\t    function indexOf(data, comparer) {\n\t        var idx, length;\n\n\t        for (idx = 0, length = data.length; idx < length; idx++) {\n\t            if (comparer(data[idx])) {\n\t                return idx;\n\t            }\n\t        }\n\n\t        return -1;\n\t    }\n\n\t    function fieldNameFromModel(fields, name) {\n\t        if (fields && !isEmptyObject(fields)) {\n\t            var descriptor = fields[name];\n\t            var fieldName;\n\t            if (isPlainObject(descriptor)) {\n\t                fieldName = descriptor.from || descriptor.field || name;\n\t            } else {\n\t                fieldName = fields[name] || name;\n\t            }\n\n\t            if (isFunction(fieldName)) {\n\t                return name;\n\t            }\n\n\t            return fieldName;\n\t        }\n\t        return name;\n\t    }\n\n\t    function convertFilterDescriptorsField(descriptor, model) {\n\t        var idx,\n\t            length,\n\t            target = {};\n\n\t        for (var field in descriptor) {\n\t            if (field !== \"filters\") {\n\t                target[field] = descriptor[field];\n\t            }\n\t        }\n\n\t        if (descriptor.filters) {\n\t            target.filters = [];\n\t            for (idx = 0, length = descriptor.filters.length; idx < length; idx++) {\n\t                target.filters[idx] = convertFilterDescriptorsField(descriptor.filters[idx], model);\n\t            }\n\t        } else {\n\t            target.field = fieldNameFromModel(model.fields, target.field);\n\t        }\n\t        return target;\n\t    }\n\n\t    function convertDescriptorsField(descriptors, model) {\n\t        var idx,\n\t            length,\n\t            result = [],\n\t            target,\n\t            descriptor;\n\n\t        for (idx = 0, length = descriptors.length; idx < length; idx ++) {\n\t            target = {};\n\n\t            descriptor = descriptors[idx];\n\n\t            for (var field in descriptor) {\n\t                target[field] = descriptor[field];\n\t            }\n\n\t            target.field = fieldNameFromModel(model.fields, target.field);\n\n\t            if (target.aggregates && isArray(target.aggregates)) {\n\t                target.aggregates = convertDescriptorsField(target.aggregates, model);\n\t            }\n\t            result.push(target);\n\t        }\n\t        return result;\n\t    }\n\n\t    var DataSource = Observable.extend({\n\t        init: function(options) {\n\t            var that = this, model, data;\n\n\t            if (options) {\n\t                data = options.data;\n\t            }\n\n\t            options = that.options = extend({}, that.options, options);\n\n\t            that._map = {};\n\t            that._prefetch = {};\n\t            that._data = [];\n\t            that._pristineData = [];\n\t            that._ranges = [];\n\t            that._view = [];\n\t            that._pristineTotal = 0;\n\t            that._destroyed = [];\n\t            that._pageSize = options.pageSize;\n\t            that._page = options.page  || (options.pageSize ? 1 : undefined);\n\t            that._sort = normalizeSort(options.sort);\n\t            that._filter = normalizeFilter(options.filter);\n\t            that._group = normalizeGroup(options.group);\n\t            that._aggregate = options.aggregate;\n\t            that._total = options.total;\n\n\t            that._shouldDetachObservableParents = true;\n\n\t            Observable.fn.init.call(that);\n\n\t            that.transport = Transport.create(options, data, that);\n\n\t            if (isFunction(that.transport.push)) {\n\t                that.transport.push({\n\t                    pushCreate: proxy(that._pushCreate, that),\n\t                    pushUpdate: proxy(that._pushUpdate, that),\n\t                    pushDestroy: proxy(that._pushDestroy, that)\n\t                });\n\t            }\n\n\t            if (options.offlineStorage != null) {\n\t                if (typeof options.offlineStorage == \"string\") {\n\t                    var key = options.offlineStorage;\n\n\t                    that._storage = {\n\t                        getItem: function() {\n\t                            return JSON.parse(localStorage.getItem(key));\n\t                        },\n\t                        setItem: function(item) {\n\t                            localStorage.setItem(key, stringify(that.reader.serialize(item)));\n\t                        }\n\t                    };\n\t                } else {\n\t                    that._storage = options.offlineStorage;\n\t                }\n\t            }\n\n\t            that.reader = new kendo.data.readers[options.schema.type || \"json\" ](options.schema);\n\n\t            model = that.reader.model || {};\n\n\t            that._detachObservableParents();\n\n\t            that._data = that._observe(that._data);\n\t            that._online = true;\n\n\t            that.bind([\"push\", ERROR, CHANGE, REQUESTSTART, SYNC, REQUESTEND, PROGRESS], options);\n\t        },\n\n\t        options: {\n\t            data: null,\n\t            schema: {\n\t               modelBase: Model\n\t            },\n\t            offlineStorage: null,\n\t            serverSorting: false,\n\t            serverPaging: false,\n\t            serverFiltering: false,\n\t            serverGrouping: false,\n\t            serverAggregates: false,\n\t            batch: false,\n\t            inPlaceSort: false\n\t        },\n\n\t        clone: function() {\n\t            return this;\n\t        },\n\n\t        online: function(value) {\n\t            if (value !== undefined) {\n\t                if (this._online != value) {\n\t                    this._online = value;\n\n\t                    if (value) {\n\t                        return this.sync();\n\t                    }\n\t                }\n\n\t                return $.Deferred().resolve().promise();\n\t            } else {\n\t                return this._online;\n\t            }\n\t        },\n\n\t        offlineData: function(state) {\n\t            if (this.options.offlineStorage == null) {\n\t                return null;\n\t            }\n\n\t            if (state !== undefined) {\n\t                return this._storage.setItem(state);\n\t            }\n\n\t            return this._storage.getItem() || [];\n\t        },\n\n\t        _isServerGrouped: function() {\n\t            var group = this.group() || [];\n\n\t            return this.options.serverGrouping && group.length;\n\t        },\n\n\t        _pushCreate: function(result) {\n\t            this._push(result, \"pushCreate\");\n\t        },\n\n\t        _pushUpdate: function(result) {\n\t            this._push(result, \"pushUpdate\");\n\t        },\n\n\t        _pushDestroy: function(result) {\n\t            this._push(result, \"pushDestroy\");\n\t        },\n\n\t        _push: function(result, operation) {\n\t            var data = this._readData(result);\n\n\t            if (!data) {\n\t                data = result;\n\t            }\n\n\t            this[operation](data);\n\t        },\n\n\t        _flatData: function(data, skip) {\n\t            if (data) {\n\t                if (this._isServerGrouped()) {\n\t                    return flattenGroups(data);\n\t                }\n\n\t                if (!skip) {\n\t                    for (var idx = 0; idx < data.length; idx++) {\n\t                        data.at(idx);\n\t                    }\n\t                }\n\t            }\n\n\t            return data;\n\t        },\n\n\t        parent: noop,\n\n\t        get: function(id) {\n\t            var idx, length, data = this._flatData(this._data, this.options.useRanges);\n\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                if (data[idx].id == id) {\n\t                    return data[idx];\n\t                }\n\t            }\n\t        },\n\n\t        getByUid: function(id) {\n\t            return this._getByUid(id, this._data);\n\t        },\n\n\t        _getByUid: function(id, dataItems) {\n\t            var idx, length, data = this._flatData(dataItems, this.options.useRanges);\n\n\t            if (!data) {\n\t                return;\n\t            }\n\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                if (data[idx].uid == id) {\n\t                    return data[idx];\n\t                }\n\t            }\n\t        },\n\n\t        indexOf: function(model) {\n\t            return indexOfModel(this._data, model);\n\t        },\n\n\t        at: function(index) {\n\t            return this._data.at(index);\n\t        },\n\n\t        data: function(value) {\n\t            var that = this;\n\t            if (value !== undefined) {\n\t                that._detachObservableParents();\n\t                that._data = this._observe(value);\n\n\t                that._pristineData = value.slice(0);\n\n\t                that._storeData();\n\n\t                that._ranges = [];\n\t                that.trigger(\"reset\");\n\t                that._addRange(that._data);\n\n\t                that._total = that._data.length;\n\t                that._pristineTotal = that._total;\n\n\t                that._process(that._data);\n\t            } else {\n\t                if (that._data) {\n\t                    for (var idx = 0; idx < that._data.length; idx++) {\n\t                        that._data.at(idx);\n\t                    }\n\t                }\n\n\t                return that._data;\n\t            }\n\t        },\n\n\t        view: function(value) {\n\t            if (value === undefined) {\n\t                return this._view;\n\t            } else {\n\t                this._view = this._observeView(value);\n\t            }\n\t        },\n\n\t        _observeView: function(data) {\n\t            var that = this;\n\t            replaceWithObservable(data, that._data, that._ranges, that.reader.model || ObservableObject, that._isServerGrouped());\n\n\t            var view = new LazyObservableArray(data, that.reader.model);\n\t            view.parent = function() { return that.parent(); };\n\t            return view;\n\t        },\n\n\t        flatView: function() {\n\t            var groups = this.group() || [];\n\n\t            if (groups.length) {\n\t                return flattenGroups(this._view);\n\t            } else {\n\t                return this._view;\n\t            }\n\t        },\n\n\t        add: function(model) {\n\t            return this.insert(this._data.length, model);\n\t        },\n\n\t        _createNewModel: function(model) {\n\t            if (this.reader.model) {\n\t                return new this.reader.model(model);\n\t            }\n\n\t            if (model instanceof ObservableObject) {\n\t                return model;\n\t            }\n\n\t            return new ObservableObject(model);\n\t        },\n\n\t        insert: function(index, model) {\n\t            if (!model) {\n\t                model = index;\n\t                index = 0;\n\t            }\n\n\t            if (!(model instanceof Model)) {\n\t                model = this._createNewModel(model);\n\t            }\n\n\t            if (this._isServerGrouped()) {\n\t                this._data.splice(index, 0, this._wrapInEmptyGroup(model));\n\t            } else {\n\t                this._data.splice(index, 0, model);\n\t            }\n\n\t            this._insertModelInRange(index, model);\n\n\t            return model;\n\t        },\n\n\t        pushInsert: function(index, items) {\n\t            var that = this;\n\t            var rangeSpan = that._getCurrentRangeSpan();\n\n\t            if (!items) {\n\t                items = index;\n\t                index = 0;\n\t            }\n\n\t            if (!isArray(items)) {\n\t                items = [items];\n\t            }\n\n\t            var pushed = [];\n\t            var autoSync = this.options.autoSync;\n\t            this.options.autoSync = false;\n\n\t            try {\n\t                for (var idx = 0; idx < items.length; idx ++) {\n\t                    var item = items[idx];\n\n\t                    var result = this.insert(index, item);\n\n\t                    pushed.push(result);\n\n\t                    var pristine = result.toJSON();\n\n\t                    if (this._isServerGrouped()) {\n\t                        pristine = this._wrapInEmptyGroup(pristine);\n\t                    }\n\n\t                    this._pristineData.push(pristine);\n\n\t                    if (rangeSpan && rangeSpan.length) {\n\t                        $(rangeSpan).last()[0].pristineData.push(pristine);\n\t                    }\n\n\t                    index++;\n\t                }\n\t            } finally {\n\t                this.options.autoSync = autoSync;\n\t            }\n\n\t            if (pushed.length) {\n\t                this.trigger(\"push\", {\n\t                    type: \"create\",\n\t                    items: pushed\n\t                });\n\t            }\n\t        },\n\n\t        pushCreate: function(items) {\n\t            this.pushInsert(this._data.length, items);\n\t        },\n\n\t        pushUpdate: function(items) {\n\t            if (!isArray(items)) {\n\t                items = [items];\n\t            }\n\n\t            var pushed = [];\n\n\t            for (var idx = 0; idx < items.length; idx ++) {\n\t                var item = items[idx];\n\t                var model = this._createNewModel(item);\n\n\t                var target = this.get(model.id);\n\n\t                if (target) {\n\t                    pushed.push(target);\n\n\t                    target.accept(item);\n\n\t                    target.trigger(CHANGE);\n\n\t                    this._updatePristineForModel(target, item);\n\t                } else {\n\t                    this.pushCreate(item);\n\t                }\n\t            }\n\n\t            if (pushed.length) {\n\t                this.trigger(\"push\", {\n\t                    type: \"update\",\n\t                    items: pushed\n\t                });\n\t            }\n\t        },\n\n\t        pushDestroy: function(items) {\n\t            var pushed = this._removeItems(items);\n\n\t            if (pushed.length) {\n\t                this.trigger(\"push\", {\n\t                    type: \"destroy\",\n\t                    items: pushed\n\t                });\n\t            }\n\t        },\n\n\t        _removeItems: function(items, removePristine) {\n\t            if (!isArray(items)) {\n\t                items = [items];\n\t            }\n\n\t            var shouldRemovePristine = typeof removePristine !== \"undefined\" ? removePristine : true;\n\n\t            var destroyed = [];\n\t            var autoSync = this.options.autoSync;\n\t            this.options.autoSync = false;\n\t            try {\n\t                for (var idx = 0; idx < items.length; idx ++) {\n\t                    var item = items[idx];\n\t                    var model = this._createNewModel(item);\n\t                    var found = false;\n\n\t                    this._eachItem(this._data, function(items){\n\t                        for (var idx = 0; idx < items.length; idx++) {\n\t                            var item = items.at(idx);\n\t                            if (item.id === model.id) {\n\t                                destroyed.push(item);\n\t                                items.splice(idx, 1);\n\t                                found = true;\n\t                                break;\n\t                            }\n\t                        }\n\t                    });\n\n\t                    if (found && shouldRemovePristine) {\n\t                        this._removePristineForModel(model);\n\t                        this._destroyed.pop();\n\t                    }\n\t                }\n\t            } finally {\n\t                this.options.autoSync = autoSync;\n\t            }\n\n\t            return destroyed;\n\t        },\n\n\t        remove: function(model) {\n\t            var result,\n\t                that = this,\n\t                hasGroups = that._isServerGrouped();\n\n\t            this._eachItem(that._data, function(items) {\n\t                result = removeModel(items, model);\n\n\t                if (result && hasGroups) {\n\t                    if (!result.isNew || !result.isNew()) {\n\t                        that._destroyed.push(result);\n\t                    }\n\t                    return true;\n\t                }\n\t            });\n\n\t            this._removeModelFromRanges(model);\n\n\t            return model;\n\t        },\n\n\t        destroyed: function() {\n\t            return this._destroyed;\n\t        },\n\n\t        created: function() {\n\t            var idx,\n\t                length,\n\t                result = [],\n\t                data = this._flatData(this._data, this.options.useRanges);\n\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                if (data[idx].isNew && data[idx].isNew()) {\n\t                    result.push(data[idx]);\n\t                }\n\t            }\n\t            return result;\n\t        },\n\n\t        updated: function() {\n\t            var idx,\n\t                length,\n\t                result = [],\n\t                data = this._flatData(this._data, this.options.useRanges);\n\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                if ((data[idx].isNew && !data[idx].isNew()) && data[idx].dirty) {\n\t                    result.push(data[idx]);\n\t                }\n\t            }\n\t            return result;\n\t        },\n\n\t        sync: function() {\n\t            var that = this,\n\t                created = [],\n\t                updated = [],\n\t                destroyed = that._destroyed;\n\n\t            var promise = $.Deferred().resolve().promise();\n\n\t            if (that.online()) {\n\n\t                if (!that.reader.model) {\n\t                    return promise;\n\t                }\n\n\t                created = that.created();\n\t                updated = that.updated();\n\n\t                var promises = [];\n\n\t                if (that.options.batch && that.transport.submit) {\n\t                    promises = that._sendSubmit(created, updated, destroyed);\n\t                } else {\n\t                    promises.push.apply(promises, that._send(\"create\", created));\n\t                    promises.push.apply(promises, that._send(\"update\", updated));\n\t                    promises.push.apply(promises, that._send(\"destroy\", destroyed));\n\t                }\n\n\t                promise = $.when\n\t                 .apply(null, promises)\n\t                 .then(function() {\n\t                    var idx, length;\n\n\t                    for (idx = 0, length = arguments.length; idx < length; idx++){\n\t                        if (arguments[idx]) {\n\t                            that._accept(arguments[idx]);\n\t                        }\n\t                    }\n\n\t                    that._storeData(true);\n\n\t                    that._syncEnd();\n\n\t                    that._change({ action: \"sync\" });\n\n\t                    that.trigger(SYNC);\n\t                });\n\t            } else {\n\t                that._storeData(true);\n\n\t                that._syncEnd();\n\n\t                that._change({ action: \"sync\" });\n\t            }\n\n\t            return promise;\n\t        },\n\n\t        _syncEnd: noop,\n\n\t        cancelChanges: function(model) {\n\t            var that = this;\n\n\t            if (model instanceof kendo.data.Model) {\n\t                that._cancelModel(model);\n\t            } else {\n\t                that._destroyed = [];\n\t                that._detachObservableParents();\n\t                that._data = that._observe(that._pristineData);\n\t                if (that.options.serverPaging) {\n\t                    that._total = that._pristineTotal;\n\t                }\n\n\t                that._ranges = [];\n\t                that._addRange(that._data, 0);\n\n\t                that._changesCanceled();\n\n\t                that._change();\n\n\t                that._markOfflineUpdatesAsDirty();\n\t            }\n\t        },\n\n\t        _changesCanceled: noop,\n\n\t        _markOfflineUpdatesAsDirty: function() {\n\t            var that = this;\n\n\t            if (that.options.offlineStorage != null) {\n\t                that._eachItem(that._data, function(items) {\n\t                    for (var idx = 0; idx < items.length; idx++) {\n\t                        var item = items.at(idx);\n\t                        if (item.__state__ == \"update\" || item.__state__ == \"create\") {\n\t                            item.dirty = true;\n\t                        }\n\t                    }\n\t                });\n\t            }\n\t        },\n\n\t        hasChanges: function() {\n\t            var idx,\n\t                length,\n\t                data = this._flatData(this._data, this.options.useRanges);\n\n\t            if (this._destroyed.length) {\n\t                return true;\n\t            }\n\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                if ((data[idx].isNew && data[idx].isNew()) || data[idx].dirty) {\n\t                    return true;\n\t                }\n\t            }\n\n\t            return false;\n\t        },\n\n\t        _accept: function(result) {\n\t            var that = this,\n\t                models = result.models,\n\t                response = result.response,\n\t                idx = 0,\n\t                serverGroup = that._isServerGrouped(),\n\t                pristine = that._pristineData,\n\t                type = result.type,\n\t                length;\n\n\t            that.trigger(REQUESTEND, { response: response, type: type });\n\n\t            if (response && !isEmptyObject(response)) {\n\t                response = that.reader.parse(response);\n\n\t                if (that._handleCustomErrors(response)) {\n\t                    return;\n\t                }\n\n\t                response = that.reader.data(response);\n\n\t                if (!isArray(response)) {\n\t                    response = [response];\n\t                }\n\t            } else {\n\t                response = $.map(models, function(model) { return model.toJSON(); } );\n\t            }\n\n\t            if (type === \"destroy\") {\n\t                that._destroyed = [];\n\t            }\n\n\t            for (idx = 0, length = models.length; idx < length; idx++) {\n\t                if (type !== \"destroy\") {\n\t                    models[idx].accept(response[idx]);\n\n\t                    if (type === \"create\") {\n\t                        pristine.push(serverGroup ? that._wrapInEmptyGroup(models[idx].toJSON()) : response[idx]);\n\t                    } else if (type === \"update\") {\n\t                        that._updatePristineForModel(models[idx], response[idx]);\n\t                    }\n\t                } else {\n\t                    that._removePristineForModel(models[idx]);\n\t                }\n\t            }\n\t        },\n\n\t        _updatePristineForModel: function(model, values) {\n\t            this._executeOnPristineForModel(model, function(index, items) {\n\t                kendo.deepExtend(items[index], values);\n\t            });\n\t        },\n\n\t        _executeOnPristineForModel: function(model, callback) {\n\t            this._eachPristineItem(\n\t                function(items) {\n\t                    var index = indexOfPristineModel(items, model);\n\t                    if (index > -1) {\n\t                        callback(index, items);\n\t                        return true;\n\t                    }\n\t                });\n\t        },\n\n\t        _removePristineForModel: function(model) {\n\t            this._executeOnPristineForModel(model, function(index, items) {\n\t                items.splice(index, 1);\n\t            });\n\t        },\n\n\t        _readData: function(data) {\n\t            var read = !this._isServerGrouped() ? this.reader.data : this.reader.groups;\n\t            return read.call(this.reader, data);\n\t        },\n\n\t        _eachPristineItem: function(callback) {\n\t            var that = this;\n\t            var options = that.options;\n\t            var rangeSpan = that._getCurrentRangeSpan();\n\n\t            that._eachItem(that._pristineData, callback);\n\n\t            if (options.serverPaging && options.useRanges) {\n\t                each(rangeSpan, function(i, range) {\n\t                    that._eachItem(range.pristineData, callback);\n\t                });\n\t            }\n\t        },\n\n\t       _eachItem: function(data, callback) {\n\t            if (data && data.length) {\n\t                if (this._isServerGrouped()) {\n\t                    eachGroupItems(data, callback);\n\t                } else {\n\t                    callback(data);\n\t                }\n\t            }\n\t        },\n\n\t        _pristineForModel: function(model) {\n\t            var pristine,\n\t                idx,\n\t                callback = function(items) {\n\t                    idx = indexOfPristineModel(items, model);\n\t                    if (idx > -1) {\n\t                        pristine = items[idx];\n\t                        return true;\n\t                    }\n\t                };\n\n\t            this._eachPristineItem(callback);\n\n\t            return pristine;\n\t        },\n\n\t        _cancelModel: function(model) {\n\t            var that = this;\n\t            var pristine = this._pristineForModel(model);\n\n\t            this._eachItem(this._data, function(items) {\n\t                var idx = indexOfModel(items, model);\n\t                if (idx >= 0) {\n\t                    if (pristine && (!model.isNew() || pristine.__state__)) {\n\t                        items[idx].accept(pristine);\n\n\t                        if (pristine.__state__ == \"update\") {\n\t                            items[idx].dirty = true;\n\t                        }\n\n\t                    } else {\n\t                        that._modelCanceled(model);\n\n\t                        items.splice(idx, 1);\n\n\t                        that._removeModelFromRanges(model);\n\t                    }\n\t                }\n\t            });\n\t        },\n\n\t        _modelCanceled: noop,\n\n\t        _submit: function(promises, data) {\n\t            var that = this;\n\n\t            that.trigger(REQUESTSTART, { type: \"submit\" });\n\n\t            that.trigger(PROGRESS);\n\n\t            that.transport.submit(extend({\n\t                success: function(response, type) {\n\t                    var promise = $.grep(promises, function(x) {\n\t                        return x.type == type;\n\t                    })[0];\n\n\t                    if (promise) {\n\t                        promise.resolve({\n\t                            response: response,\n\t                            models: promise.models,\n\t                            type: type\n\t                        });\n\t                    }\n\t                },\n\t                error: function(response, status, error) {\n\t                    for (var idx = 0; idx < promises.length; idx++) {\n\t                        promises[idx].reject(response);\n\t                    }\n\n\t                    that.error(response, status, error);\n\t                }\n\t            }, data));\n\t        },\n\n\t        _sendSubmit: function(created, updated, destroyed) {\n\t            var that = this,\n\t                promises = [];\n\n\t            if (that.options.batch) {\n\t                if (created.length) {\n\t                    promises.push($.Deferred(function(deferred) {\n\t                        deferred.type = \"create\";\n\t                        deferred.models = created;\n\t                    }));\n\t                }\n\n\t                if (updated.length) {\n\t                    promises.push($.Deferred(function(deferred) {\n\t                        deferred.type = \"update\";\n\t                        deferred.models = updated;\n\t                    }));\n\t                }\n\n\t                if (destroyed.length) {\n\t                    promises.push($.Deferred(function(deferred) {\n\t                        deferred.type = \"destroy\";\n\t                        deferred.models = destroyed;\n\t                    }));\n\t                }\n\n\t                that._submit(promises, {\n\t                    data: {\n\t                        created: that.reader.serialize(toJSON(created)),\n\t                        updated: that.reader.serialize(toJSON(updated)),\n\t                        destroyed: that.reader.serialize(toJSON(destroyed))\n\t                    }\n\t                });\n\t            }\n\n\t            return promises;\n\t        },\n\n\t        _promise: function(data, models, type) {\n\t            var that = this;\n\n\t            return $.Deferred(function(deferred) {\n\t                that.trigger(REQUESTSTART, { type: type });\n\n\t                that.trigger(PROGRESS);\n\n\t                that.transport[type].call(that.transport, extend({\n\t                    success: function(response) {\n\t                        deferred.resolve({\n\t                            response: response,\n\t                            models: models,\n\t                            type: type\n\t                        });\n\t                    },\n\t                    error: function(response, status, error) {\n\t                        deferred.reject(response);\n\t                        that.error(response, status, error);\n\t                    }\n\t                }, data));\n\t            }).promise();\n\t        },\n\n\t        _send: function(method, data) {\n\t            var that = this,\n\t                idx,\n\t                length,\n\t                promises = [],\n\t                converted = that.reader.serialize(toJSON(data));\n\n\t            if (that.options.batch) {\n\t                if (data.length) {\n\t                    promises.push(that._promise( { data: { models: converted } }, data , method));\n\t                }\n\t            } else {\n\t                for (idx = 0, length = data.length; idx < length; idx++) {\n\t                    promises.push(that._promise( { data: converted[idx] }, [ data[idx] ], method));\n\t                }\n\t            }\n\n\t            return promises;\n\t        },\n\n\t        read: function(data) {\n\t            var that = this, params = that._params(data);\n\t            var deferred = $.Deferred();\n\n\t            that._queueRequest(params, function() {\n\t                var isPrevented = that.trigger(REQUESTSTART, { type: \"read\" });\n\t                if (!isPrevented) {\n\t                    that.trigger(PROGRESS);\n\n\t                    that._ranges = [];\n\t                    that.trigger(\"reset\");\n\t                    if (that.online()) {\n\t                        that.transport.read({\n\t                            data: params,\n\t                            success: function(data) {\n\t                                that._ranges = [];\n\t                                that.success(data, params);\n\n\t                                deferred.resolve();\n\t                            },\n\t                            error: function() {\n\t                                var args = slice.call(arguments);\n\n\t                                that.error.apply(that, args);\n\n\t                                deferred.reject.apply(deferred, args);\n\t                            }\n\t                        });\n\t                    } else if (that.options.offlineStorage != null){\n\t                        that.success(that.offlineData(), params);\n\n\t                        deferred.resolve();\n\t                    }\n\t                } else {\n\t                    that._dequeueRequest();\n\n\t                    deferred.resolve(isPrevented);\n\t                }\n\t            });\n\n\t            return deferred.promise();\n\t        },\n\n\t        _readAggregates: function(data) {\n\t            return this.reader.aggregates(data);\n\t        },\n\n\t        success: function(data) {\n\t            var that = this,\n\t                options = that.options,\n\t                items,\n\t                replaceSubset;\n\n\t            that.trigger(REQUESTEND, { response: data, type: \"read\" });\n\n\t            if (that.online()) {\n\t                data = that.reader.parse(data);\n\n\t                if (that._handleCustomErrors(data)) {\n\t                    that._dequeueRequest();\n\t                    return;\n\t                }\n\n\t                that._total = that.reader.total(data);\n\t                if (that._pageSize > that._total) {\n\t                    that._pageSize = that._total;\n\t                    if (that.options.pageSize && that.options.pageSize > that._pageSize) {\n\t                        that._pageSize = that.options.pageSize;\n\t                    }\n\t                }\n\n\t                if (that._aggregate && options.serverAggregates) {\n\t                    that._aggregateResult = that._readAggregates(data);\n\t                }\n\n\t                data = that._readData(data);\n\n\t                that._destroyed = [];\n\t            } else {\n\t                data = that._readData(data);\n\n\t                items = [];\n\t                var itemIds = {};\n\t                var model = that.reader.model;\n\t                var idField = model ? model.idField : \"id\";\n\t                var idx;\n\n\t                for (idx = 0; idx < this._destroyed.length; idx++) {\n\t                    var id = this._destroyed[idx][idField];\n\t                    itemIds[id] = id;\n\t                }\n\n\t                for (idx = 0; idx < data.length; idx++) {\n\t                    var item = data[idx];\n\t                    var state = item.__state__;\n\t                    if (state == \"destroy\") {\n\t                        if (!itemIds[item[idField]]) {\n\t                            this._destroyed.push(this._createNewModel(item));\n\t                        }\n\t                    } else {\n\t                        items.push(item);\n\t                    }\n\t                }\n\n\t                data = items;\n\n\t                that._total = data.length;\n\t            }\n\n\t            that._pristineTotal = that._total;\n\t            replaceSubset = that._skip && that._data.length && that._skip < that._data.length;\n\n\t            if (that.options.endless) {\n\t                if (replaceSubset) {\n\t                    that._pristineData.splice(that._skip, that._pristineData.length);\n\t                }\n\t                items = data.slice(0);\n\t                for (var j = 0; j < items.length; j++) {\n\t                    that._pristineData.push(items[j]);\n\t                }\n\t            } else {\n\t                that._pristineData = data.slice(0);\n\t            }\n\n\t            that._detachObservableParents();\n\n\t            if (that.options.endless) {\n\t                that._data.unbind(CHANGE, that._changeHandler);\n\n\t                if (that._isServerGrouped() && that._data[that._data.length - 1].value === data[0].value) {\n\t                    fillLastGroup(that._data[that._data.length - 1], data[0]);\n\t                    data.shift();\n\t                }\n\n\t                data = that._observe(data);\n\t                if (replaceSubset) {\n\t                    that._data.splice(that._skip, that._data.length);\n\t                }\n\t                for (var i = 0; i < data.length; i++) {\n\t                    that._data.push(data[i]);\n\t                }\n\t                that._data.bind(CHANGE, that._changeHandler);\n\t            } else {\n\t                that._data = that._observe(data);\n\t            }\n\n\t            that._markOfflineUpdatesAsDirty();\n\n\t            that._storeData();\n\n\t            that._addRange(that._data);\n\n\t            that._process(that._data);\n\n\t            that._dequeueRequest();\n\t        },\n\n\t        _detachObservableParents: function() {\n\t            if (this._data && this._shouldDetachObservableParents) {\n\t                for (var idx = 0; idx < this._data.length; idx++) {\n\t                    if (this._data[idx].parent) {\n\t                        this._data[idx].parent = noop;\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _storeData: function(updatePristine) {\n\t            var serverGrouping = this._isServerGrouped();\n\t            var model = this.reader.model;\n\n\t            function items(data) {\n\t                var state = [];\n\n\t                for (var idx = 0; idx < data.length; idx++) {\n\t                    var dataItem = data.at(idx);\n\t                    var item = dataItem.toJSON();\n\n\t                    if (serverGrouping && dataItem.items) {\n\t                        item.items = items(dataItem.items);\n\t                    } else {\n\t                        item.uid = dataItem.uid;\n\n\t                        if (model) {\n\t                            if (dataItem.isNew()) {\n\t                                item.__state__ = \"create\";\n\t                            } else if (dataItem.dirty) {\n\t                                item.__state__ = \"update\";\n\t                            }\n\t                        }\n\t                    }\n\t                    state.push(item);\n\t                }\n\n\t                return state;\n\t            }\n\n\t            if (this.options.offlineStorage != null) {\n\t                var state = items(this._data);\n\n\t                var destroyed = [];\n\n\t                for (var idx = 0; idx < this._destroyed.length; idx++) {\n\t                    var item = this._destroyed[idx].toJSON();\n\t                    item.__state__ = \"destroy\";\n\t                    destroyed.push(item);\n\t                }\n\n\t                this.offlineData(state.concat(destroyed));\n\n\t                if (updatePristine) {\n\t                    this._pristineData = this.reader.reader ? this.reader.reader._wrapDataAccessBase(state) : this.reader._wrapDataAccessBase(state);\n\t                }\n\t            }\n\t        },\n\n\t        _addRange: function(data, skip) {\n\t            var that = this,\n\t                start = typeof(skip) !== \"undefined\" ? skip : (that._skip || 0),\n\t                end = start + that._flatData(data, true).length;\n\n\t            that._ranges.push({\n\t                start: start,\n\t                end: end,\n\t                data: data,\n\t                pristineData: data.toJSON(),\n\t                timestamp: that._timeStamp()\n\t            });\n\n\t            that._sortRanges();\n\t        },\n\n\t        _sortRanges: function() {\n\t            this._ranges.sort(function(x, y) {\n\t                return x.start - y.start;\n\t            });\n\t        },\n\n\t        error: function(xhr, status, errorThrown) {\n\t            this._dequeueRequest();\n\t            this.trigger(REQUESTEND, { });\n\t            this.trigger(ERROR, { xhr: xhr, status: status, errorThrown: errorThrown });\n\t        },\n\n\t        _params: function(data) {\n\t            var that = this,\n\t                options =  extend({\n\t                    take: that.take(),\n\t                    skip: that.skip(),\n\t                    page: that.page(),\n\t                    pageSize: that.pageSize(),\n\t                    sort: that._sort,\n\t                    filter: that._filter,\n\t                    group: that._group,\n\t                    aggregate: that._aggregate\n\t                }, data);\n\n\t            if (!that.options.serverPaging) {\n\t                delete options.take;\n\t                delete options.skip;\n\t                delete options.page;\n\t                delete options.pageSize;\n\t            }\n\n\t            if (!that.options.serverGrouping) {\n\t                delete options.group;\n\t            } else if (that.reader.model && options.group) {\n\t                options.group = convertDescriptorsField(options.group, that.reader.model);\n\t            }\n\n\t            if (!that.options.serverFiltering) {\n\t                delete options.filter;\n\t            } else if (that.reader.model && options.filter) {\n\t               options.filter = convertFilterDescriptorsField(options.filter, that.reader.model);\n\t            }\n\n\t            if (!that.options.serverSorting) {\n\t                delete options.sort;\n\t            } else if (that.reader.model && options.sort) {\n\t                options.sort = convertDescriptorsField(options.sort, that.reader.model);\n\t            }\n\n\t            if (!that.options.serverAggregates) {\n\t                delete options.aggregate;\n\t            } else if (that.reader.model && options.aggregate) {\n\t                options.aggregate = convertDescriptorsField(options.aggregate, that.reader.model);\n\t            }\n\n\t            return options;\n\t        },\n\n\t        _queueRequest: function(options, callback) {\n\t            var that = this;\n\t            if (!that._requestInProgress) {\n\t                that._requestInProgress = true;\n\t                that._pending = undefined;\n\t                callback();\n\t            } else {\n\t                that._pending = { callback: proxy(callback, that), options: options };\n\t            }\n\t        },\n\n\t        _dequeueRequest: function() {\n\t            var that = this;\n\t            that._requestInProgress = false;\n\t            if (that._pending) {\n\t                that._queueRequest(that._pending.options, that._pending.callback);\n\t            }\n\t        },\n\n\t        _handleCustomErrors: function(response) {\n\t            if (this.reader.errors) {\n\t                var errors = this.reader.errors(response);\n\t                if (errors) {\n\t                    this.trigger(ERROR, { xhr: null, status: \"customerror\", errorThrown: \"custom error\", errors: errors });\n\t                    return true;\n\t                }\n\t            }\n\t            return false;\n\t        },\n\n\t        _shouldWrap: function(data) {\n\t            var model = this.reader.model;\n\n\t            if (model && data.length) {\n\t                return !(data[0] instanceof model);\n\t            }\n\n\t            return false;\n\t        },\n\n\t        _observe: function(data) {\n\t            var that = this,\n\t                model = that.reader.model;\n\n\t            that._shouldDetachObservableParents = true;\n\n\t            if (data instanceof ObservableArray) {\n\t                that._shouldDetachObservableParents = false;\n\t                if (that._shouldWrap(data)) {\n\t                    data.type = that.reader.model;\n\t                    data.wrapAll(data, data);\n\t                }\n\t            } else {\n\t                var arrayType = that.pageSize() && !that.options.serverPaging ? LazyObservableArray : ObservableArray;\n\t                data = new arrayType(data, that.reader.model);\n\t                data.parent = function() { return that.parent(); };\n\t            }\n\n\t            if (that._isServerGrouped()) {\n\t                wrapGroupItems(data, model);\n\t            }\n\n\t            if (that._changeHandler && that._data && that._data instanceof ObservableArray) {\n\t                that._data.unbind(CHANGE, that._changeHandler);\n\t            } else {\n\t                that._changeHandler = proxy(that._change, that);\n\t            }\n\n\t            return data.bind(CHANGE, that._changeHandler);\n\t        },\n\n\t        _updateTotalForAction: function(action, items) {\n\t            var that = this;\n\n\t            var total = parseInt(that._total, 10);\n\n\t            if (!isNumber(that._total)) {\n\t                total = parseInt(that._pristineTotal, 10);\n\t            }\n\t            if (action === \"add\") {\n\t                total += items.length;\n\t            } else if (action === \"remove\") {\n\t                total -= items.length;\n\t            } else if (action !== \"itemchange\" && action !== \"sync\" && !that.options.serverPaging) {\n\t                total = that._pristineTotal;\n\t            } else if (action === \"sync\") {\n\t                total = that._pristineTotal = parseInt(that._total, 10);\n\t            }\n\n\t            that._total = total;\n\t        },\n\n\t        _change: function(e) {\n\t            var that = this, idx, length, action = e ? e.action : \"\";\n\n\t            if (action === \"remove\") {\n\t                for (idx = 0, length = e.items.length; idx < length; idx++) {\n\t                    if (!e.items[idx].isNew || !e.items[idx].isNew()) {\n\t                        that._destroyed.push(e.items[idx]);\n\t                    }\n\t                }\n\t            }\n\n\t            if (that.options.autoSync && (action === \"add\" || action === \"remove\" || action === \"itemchange\")) {\n\n\t                var handler = function(args) {\n\t                    if (args.action === \"sync\") {\n\t                        that.unbind(\"change\", handler);\n\t                        that._updateTotalForAction(action, e.items);\n\t                    }\n\t                };\n\n\t                that.first(\"change\", handler);\n\n\t                that.sync();\n\n\t            } else {\n\t                that._updateTotalForAction(action, e ? e.items : []);\n\n\t                that._process(that._data, e);\n\t            }\n\t        },\n\n\t        _calculateAggregates: function (data, options) {\n\t            options = options || {};\n\n\t            var query = new Query(data),\n\t                aggregates = options.aggregate,\n\t                filter = options.filter;\n\n\t            if (filter) {\n\t                query = query.filter(filter);\n\t            }\n\n\t            return query.aggregate(aggregates);\n\t        },\n\n\t        _process: function (data, e) {\n\t            var that = this,\n\t                options = {},\n\t                result;\n\n\t            if (that.options.serverPaging !== true) {\n\t                options.skip = that._skip;\n\t                options.take = that._take || that._pageSize;\n\n\t                if(options.skip === undefined && that._page !== undefined && that._pageSize !== undefined) {\n\t                    options.skip = (that._page - 1) * that._pageSize;\n\t                }\n\n\t                if (that.options.useRanges) {\n\t                    options.skip = that.currentRangeStart();\n\t                }\n\t            }\n\n\t            if (that.options.serverSorting !== true) {\n\t                options.sort = that._sort;\n\t            }\n\n\t            if (that.options.serverFiltering !== true) {\n\t                options.filter = that._filter;\n\t            }\n\n\t            if (that.options.serverGrouping !== true) {\n\t                options.group = that._group;\n\t            }\n\n\t            if (that.options.serverAggregates !== true) {\n\t                options.aggregate = that._aggregate;\n\t            }\n\n\t            if (that.options.serverGrouping) {\n\t                that._clearEmptyGroups(data);\n\t            }\n\n\t            result = that._queryProcess(data, options);\n\n\t            if (that.options.serverAggregates !== true) {\n\t                // for performance reasons, calculate aggregates for part of the data only after query process\n\t                // this is necessary in the TreeList when paging\n\t                that._aggregateResult = that._calculateAggregates(result.dataToAggregate || data, options);\n\t            }\n\n\t            that.view(result.data);\n\n\t            that._setFilterTotal(result.total, false);\n\n\t            e = e || {};\n\n\t            e.items = e.items || that._view;\n\n\t            that.trigger(CHANGE, e);\n\t        },\n\n\t        _clearEmptyGroups: function(data) {\n\t            for (var idx = data.length - 1; idx >=0; idx--) {\n\t                var group = data[idx];\n\t                if (group.hasSubgroups) {\n\t                    this._clearEmptyGroups(group.items);\n\t                } else {\n\t                    if (group.items && !group.items.length) {\n\t                        splice.apply(group.parent(), [idx, 1]);\n\t                    }\n\t                }\n\t            }\n\t        },\n\n\t        _queryProcess: function(data, options) {\n\t            if (this.options.inPlaceSort) {\n\t                return Query.process(data, options, this.options.inPlaceSort);\n\t            }\n\t            else {\n\t                return Query.process(data, options);\n\t            }\n\t        },\n\n\t        _mergeState: function(options) {\n\t            var that = this;\n\n\t            if (options !== undefined) {\n\t                that._pageSize = options.pageSize;\n\t                that._page = options.page;\n\t                that._sort = options.sort;\n\t                that._filter = options.filter;\n\t                that._group = options.group;\n\t                that._aggregate = options.aggregate;\n\t                that._skip = that._currentRangeStart = options.skip;\n\t                that._take = options.take;\n\n\t                if(that._skip === undefined) {\n\t                    that._skip = that._currentRangeStart = that.skip();\n\t                    options.skip = that.skip();\n\t                }\n\n\t                if(that._take === undefined && that._pageSize !== undefined) {\n\t                    that._take = that._pageSize;\n\t                    options.take = that._take;\n\t                }\n\n\t                if (options.sort) {\n\t                    that._sort = options.sort = normalizeSort(options.sort);\n\t                }\n\n\t                if (options.filter) {\n\t                    that._filter = options.filter = normalizeFilter(options.filter);\n\t                }\n\n\t                if (options.group) {\n\t                    that._group = options.group = normalizeGroup(options.group);\n\t                }\n\t                if (options.aggregate) {\n\t                    that._aggregate = options.aggregate = normalizeAggregate(options.aggregate);\n\t                }\n\t            }\n\t            return options;\n\t        },\n\n\t        query: function(options) {\n\t            var result;\n\t            var remote = this.options.serverSorting || this.options.serverPaging || this.options.serverFiltering || this.options.serverGrouping || this.options.serverAggregates;\n\n\t            if (remote || ((this._data === undefined || this._data.length === 0) && !this._destroyed.length)) {\n\t                if (this.options.endless) {\n\t                    var moreItemsCount = options.pageSize - this.pageSize();\n\t                    if (moreItemsCount > 0) {\n\t                        moreItemsCount = this.pageSize();\n\t                        options.page = options.pageSize / moreItemsCount;\n\t                        options.pageSize = moreItemsCount;\n\t                    } else {\n\t                        options.page = 1;\n\t                        this.options.endless = false;\n\t                    }\n\t                }\n\t                return this.read(this._mergeState(options));\n\t            }\n\n\t            var isPrevented = this.trigger(REQUESTSTART, { type: \"read\" });\n\t            if (!isPrevented) {\n\t                this.trigger(PROGRESS);\n\n\t                result = this._queryProcess(this._data, this._mergeState(options));\n\n\t                this._setFilterTotal(result.total, true);\n\n\t                this._aggregateResult = this._calculateAggregates(result.dataToAggregate || this._data, options);\n\t                this.view(result.data);\n\t                this.trigger(REQUESTEND, { type: \"read\" });\n\t                this.trigger(CHANGE, { items: result.data });\n\t            }\n\n\t            return $.Deferred().resolve(isPrevented).promise();\n\t        },\n\n\t        _setFilterTotal: function(filterTotal, setDefaultValue) {\n\t            var that = this;\n\n\t            if (!that.options.serverFiltering) {\n\t                if (filterTotal !== undefined) {\n\t                    that._total = filterTotal;\n\t                } else if (setDefaultValue) {\n\t                    that._total = that._data.length;\n\t                }\n\t            }\n\t        },\n\n\t        fetch: function(callback) {\n\t            var that = this;\n\t            var fn = function(isPrevented) {\n\t                if (isPrevented !== true && isFunction(callback)) {\n\t                    callback.call(that);\n\t                }\n\t            };\n\n\t            return this._query().then(fn);\n\t        },\n\n\t        _query: function(options) {\n\t            var that = this;\n\n\t            return that.query(extend({}, {\n\t                page: that.page(),\n\t                pageSize: that.pageSize(),\n\t                sort: that.sort(),\n\t                filter: that.filter(),\n\t                group: that.group(),\n\t                aggregate: that.aggregate()\n\t            }, options));\n\t        },\n\n\t        next: function(options) {\n\t            var that = this,\n\t                page = that.page(),\n\t                total = that.total();\n\n\t            options = options || {};\n\n\t            if (!page || (total && page + 1 > that.totalPages())) {\n\t                return;\n\t            }\n\n\t            that._skip = that._currentRangeStart = page * that.take();\n\n\t            page += 1;\n\t            options.page = page;\n\n\t            that._query(options);\n\n\t            return page;\n\t        },\n\n\t        prev: function(options) {\n\t            var that = this,\n\t                page = that.page();\n\n\t            options = options || {};\n\n\t            if (!page || page === 1) {\n\t                return;\n\t            }\n\n\t            that._skip = that._currentRangeStart = that._skip - that.take();\n\n\t            page -= 1;\n\t            options.page = page;\n\n\t            that._query(options);\n\n\t            return page;\n\t        },\n\n\t        page: function(val) {\n\t            var that = this,\n\t            skip;\n\n\t            if(val !== undefined) {\n\t                val = math.max(math.min(math.max(val, 1), that.totalPages()), 1);\n\t                that._query(that._pageableQueryOptions({ page: val }));\n\t                return;\n\t            }\n\t            skip = that.skip();\n\n\t            return skip !== undefined ? math.round((skip || 0) / (that.take() || 1)) + 1 : undefined;\n\t        },\n\n\t        pageSize: function(val) {\n\t            var that = this;\n\n\t            if (val !== undefined) {\n\t                that._query(that._pageableQueryOptions({ pageSize: val, page: 1 }));\n\t                return;\n\t            }\n\n\t            return that.take();\n\t        },\n\n\t        sort: function(val) {\n\t            var that = this;\n\n\t            if(val !== undefined) {\n\t                that._query({ sort: val });\n\t                return;\n\t            }\n\n\t            return that._sort;\n\t        },\n\n\t        filter: function(val) {\n\t            var that = this;\n\n\t            if (val === undefined) {\n\t                return that._filter;\n\t            }\n\n\t            that.trigger(\"reset\");\n\t            that._query({ filter: val, page: 1 });\n\t        },\n\n\t        group: function(val) {\n\t            var that = this;\n\n\t            if(val !== undefined) {\n\t                that._query({ group: val });\n\t                return;\n\t            }\n\n\t            return that._group;\n\t        },\n\n\t        total: function() {\n\t            return parseInt(this._total || 0, 10);\n\t        },\n\n\t        aggregate: function(val) {\n\t            var that = this;\n\n\t            if(val !== undefined) {\n\t                that._query({ aggregate: val });\n\t                return;\n\t            }\n\n\t            return that._aggregate;\n\t        },\n\n\t        aggregates: function() {\n\t            var result = this._aggregateResult;\n\n\t            if (isEmptyObject(result)) {\n\t                result = this._emptyAggregates(this.aggregate());\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _emptyAggregates: function(aggregates) {\n\t            var result = {};\n\n\t            if (!isEmptyObject(aggregates)) {\n\t                var aggregate = {};\n\n\t                if (!isArray(aggregates)){\n\t                    aggregates = [aggregates];\n\t                }\n\n\t                for (var idx = 0; idx <aggregates.length; idx++) {\n\t                    aggregate[aggregates[idx].aggregate] = 0;\n\t                    result[aggregates[idx].field] = aggregate;\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        _pageableQueryOptions: function(options) {\n\t            return options;\n\t        },\n\n\t        _wrapInEmptyGroup: function(model) {\n\t            var groups = this.group(),\n\t                parent,\n\t                group,\n\t                idx,\n\t                length;\n\n\t            for (idx = groups.length-1, length = 0; idx >= length; idx--) {\n\t                group = groups[idx];\n\t                parent = {\n\t                    value: model.get ? model.get(group.field) : model[group.field],\n\t                    field: group.field,\n\t                    items: parent ? [parent] : [model],\n\t                    hasSubgroups: !!parent,\n\t                    aggregates: this._emptyAggregates(group.aggregates)\n\t                };\n\t            }\n\n\t            return parent;\n\t        },\n\n\t        totalPages: function() {\n\t            var that = this,\n\t            pageSize = that.pageSize() || that.total();\n\n\t            return math.ceil((that.total() || 0) / pageSize);\n\t        },\n\n\t        inRange: function(skip, take) {\n\t            var that = this,\n\t                end = math.min(skip + take, that.total());\n\n\t            if (!that.options.serverPaging && that._data.length > 0) {\n\t                return true;\n\t            }\n\n\t            return that._findRange(skip, end).length > 0;\n\t        },\n\n\t        lastRange: function() {\n\t            var ranges = this._ranges;\n\t            return ranges[ranges.length - 1] || { start: 0, end: 0, data: [] };\n\t        },\n\n\t        firstItemUid: function() {\n\t            var ranges = this._ranges;\n\t            return ranges.length && ranges[0].data.length && ranges[0].data[0].uid;\n\t        },\n\n\t        enableRequestsInProgress: function() {\n\t            this._skipRequestsInProgress = false;\n\t        },\n\n\t        _timeStamp: function() {\n\t            return new Date().getTime();\n\t        },\n\n\t        range: function(skip, take, callback) {\n\t            this._currentRequestTimeStamp = this._timeStamp();\n\t            this._skipRequestsInProgress = true;\n\n\t            skip = math.min(skip || 0, this.total());\n\t            callback = isFunction(callback) ? callback : noop;\n\n\t            var that = this,\n\t                pageSkip = math.max(math.floor(skip / take), 0) * take,\n\t                size = math.min(pageSkip + take, that.total()),\n\t                data;\n\n\t            data = that._findRange(skip, math.min(skip + take, that.total()));\n\n\t            if (data.length || that.total() === 0) {\n\t                that._processRangeData(data, skip, take, pageSkip, size);\n\t                callback();\n\t                return;\n\t            }\n\n\t            if (take !== undefined) {\n\t                if (!that._rangeExists(pageSkip, size)) {\n\t                    that.prefetch(pageSkip, take, function() {\n\t                        if (skip > pageSkip && size < that.total() && !that._rangeExists(size, math.min(size + take, that.total()))) {\n\t                            that.prefetch(size, take, function() {\n\t                                that.range(skip, take, callback );\n\t                            });\n\t                        } else {\n\t                            that.range(skip, take, callback);\n\t                        }\n\t                    });\n\t                } else if (pageSkip < skip) {\n\t                    that.prefetch(size, take, function() {\n\t                        that.range(skip, take, callback );\n\t                    });\n\t                }\n\t            }\n\t        },\n\n\t        _findRange: function(start, end) {\n\t            var that = this,\n\t                ranges = that._ranges,\n\t                range,\n\t                data = [],\n\t                skipIdx,\n\t                takeIdx,\n\t                startIndex,\n\t                endIndex,\n\t                rangeData,\n\t                rangeEnd,\n\t                processed,\n\t                options = that.options,\n\t                remote = options.serverSorting || options.serverPaging || options.serverFiltering || options.serverGrouping || options.serverAggregates,\n\t                flatData,\n\t                count,\n\t                length;\n\n\t            for (skipIdx = 0, length = ranges.length; skipIdx < length; skipIdx++) {\n\t                range = ranges[skipIdx];\n\t                if (start >= range.start && start <= range.end) {\n\t                    count = 0;\n\n\t                    for (takeIdx = skipIdx; takeIdx < length; takeIdx++) {\n\t                        range = ranges[takeIdx];\n\t                        flatData = that._flatData(range.data, true);\n\n\t                        if (flatData.length && start + count >= range.start) {\n\t                            rangeData = range.data;\n\t                            rangeEnd = range.end;\n\n\t                            if (!remote) {\n\t                                if (options.inPlaceSort) {\n\t                                    processed = that._queryProcess(range.data, { filter: that.filter() });\n\t                                } else {\n\t                                    var sort = normalizeGroup(that.group() || []).concat(normalizeSort(that.sort() || []));\n\t                                    processed = that._queryProcess(range.data, { sort: sort, filter: that.filter() });\n\t                                }\n\t                                flatData = rangeData = processed.data;\n\n\t                                if (processed.total !== undefined) {\n\t                                    rangeEnd = processed.total;\n\t                                }\n\t                            }\n\n\t                            startIndex = 0;\n\t                            if (start + count > range.start) {\n\t                                startIndex = (start + count) - range.start;\n\t                            }\n\t                            endIndex = flatData.length;\n\t                            if (rangeEnd > end) {\n\t                                endIndex = endIndex - (rangeEnd - end);\n\t                            }\n\t                            count += endIndex - startIndex;\n\t                            data = that._mergeGroups(data, rangeData, startIndex, endIndex);\n\n\t                            if (end <= range.end && count == end - start) {\n\t                                return data;\n\t                            }\n\t                        }\n\t                    }\n\t                    break;\n\t                }\n\t            }\n\t            return [];\n\t        },\n\n\t        _mergeGroups: function(data, range, skip, take) {\n\t            if (this._isServerGrouped()) {\n\t                var temp = range.toJSON(),\n\t                    prevGroup;\n\n\t                if (data.length) {\n\t                    prevGroup = data[data.length - 1];\n\t                }\n\n\t                mergeGroups(prevGroup, temp, skip, take);\n\n\t                return data.concat(temp);\n\t            }\n\t            return data.concat(range.slice(skip, take));\n\t        },\n\n\t        _processRangeData: function(data, skip, take, pageSkip, size) {\n\t            var that = this;\n\n\t            that._pending = undefined;\n\n\t            that._skip = skip > that.skip() ? math.min(size, (that.totalPages() - 1) * that.take()) : pageSkip;\n\n\t            that._currentRangeStart = skip;\n\n\t            that._take = take;\n\n\t            var paging = that.options.serverPaging;\n\t            var sorting = that.options.serverSorting;\n\t            var filtering = that.options.serverFiltering;\n\t            var aggregates = that.options.serverAggregates;\n\t            try {\n\t                that.options.serverPaging = true;\n\t                if (!that._isServerGrouped() && !(that.group() && that.group().length)) {\n\t                    that.options.serverSorting = true;\n\t                }\n\t                that.options.serverFiltering = true;\n\t                that.options.serverPaging = true;\n\t                that.options.serverAggregates = true;\n\n\t                if (paging) {\n\t                    that._detachObservableParents();\n\t                    that._data = data = that._observe(data);\n\t                }\n\t                that._process(data);\n\t            } finally {\n\t                that.options.serverPaging = paging;\n\t                that.options.serverSorting = sorting;\n\t                that.options.serverFiltering = filtering;\n\t                that.options.serverAggregates = aggregates;\n\t            }\n\t        },\n\n\t        skip: function() {\n\t            var that = this;\n\n\t            if (that._skip === undefined) {\n\t                return (that._page !== undefined ? (that._page  - 1) * (that.take() || 1) : undefined);\n\t            }\n\t            return that._skip;\n\t        },\n\n\t        currentRangeStart: function() {\n\t            return this._currentRangeStart || 0;\n\t        },\n\n\t        take: function() {\n\t            return this._take || this._pageSize;\n\t        },\n\n\t        _prefetchSuccessHandler: function (skip, size, callback, force) {\n\t            var that = this;\n\t            var timestamp = that._timeStamp();\n\n\t            return function(data) {\n\t                var found = false,\n\t                    range = { start: skip, end: size, data: [], timestamp: that._timeStamp() },\n\t                    idx,\n\t                    length,\n\t                    temp;\n\n\t                that._dequeueRequest();\n\n\t                that.trigger(REQUESTEND, { response: data, type: \"read\" });\n\n\t                data = that.reader.parse(data);\n\n\t                temp = that._readData(data);\n\n\t                if (temp.length) {\n\t                    for (idx = 0, length = that._ranges.length; idx < length; idx++) {\n\t                        if (that._ranges[idx].start === skip) {\n\t                            found = true;\n\t                            range = that._ranges[idx];\n\n\t                            range.pristineData = temp;\n\t                            range.data = that._observe(temp);\n\t                            range.end = range.start + that._flatData(range.data, true).length;\n\t                            that._sortRanges();\n\n\t                            break;\n\t                        }\n\t                    }\n\n\t                    if (!found) {\n\t                        that._addRange(that._observe(temp), skip);\n\t                    }\n\t                }\n\n\t                that._total = that.reader.total(data);\n\n\t                if (force || (timestamp >= that._currentRequestTimeStamp || !that._skipRequestsInProgress)) {\n\t                    if (callback && temp.length) {\n\t                        callback();\n\t                    } else {\n\t                        that.trigger(CHANGE, {});\n\t                    }\n\t                }\n\t            };\n\t        },\n\n\t        prefetch: function(skip, take, callback) {\n\t            var that = this,\n\t                size = math.min(skip + take, that.total()),\n\t                options = {\n\t                    take: take,\n\t                    skip: skip,\n\t                    page: skip / take + 1,\n\t                    pageSize: take,\n\t                    sort: that._sort,\n\t                    filter: that._filter,\n\t                    group: that._group,\n\t                    aggregate: that._aggregate\n\t                };\n\n\t            if (!that._rangeExists(skip, size)) {\n\t                clearTimeout(that._timeout);\n\n\t                that._timeout = setTimeout(function() {\n\t                    that._queueRequest(options, function() {\n\t                        if (!that.trigger(REQUESTSTART, { type: \"read\" })) {\n\t                            that.transport.read({\n\t                                data: that._params(options),\n\t                                success: that._prefetchSuccessHandler(skip, size, callback),\n\t                                error: function() {\n\t                                    var args = slice.call(arguments);\n\t                                    that.error.apply(that, args);\n\t                                }\n\t                            });\n\t                        } else {\n\t                            that._dequeueRequest();\n\t                        }\n\t                    });\n\t                }, 100);\n\t            } else if (callback) {\n\t                callback();\n\t            }\n\t        },\n\n\t        _multiplePrefetch: function(skip, take, callback) {\n\t            var that = this,\n\t                size = math.min(skip + take, that.total()),\n\t                options = {\n\t                    take: take,\n\t                    skip: skip,\n\t                    page: skip / take + 1,\n\t                    pageSize: take,\n\t                    sort: that._sort,\n\t                    filter: that._filter,\n\t                    group: that._group,\n\t                    aggregate: that._aggregate\n\t                };\n\n\t            if (!that._rangeExists(skip, size)) {\n\t                if (!that.trigger(REQUESTSTART, { type: \"read\" })) {\n\t                    that.transport.read({\n\t                        data: that._params(options),\n\t                        success: that._prefetchSuccessHandler(skip, size, callback, true)\n\t                    });\n\t                }\n\t            } else if (callback) {\n\t                callback();\n\t            }\n\t        },\n\n\t        _rangeExists: function(start, end) {\n\t            var that = this,\n\t                ranges = that._ranges,\n\t                idx,\n\t                length;\n\n\t            for (idx = 0, length = ranges.length; idx < length; idx++) {\n\t                if (ranges[idx].start <= start && ranges[idx].end >= end) {\n\t                    return true;\n\t                }\n\t            }\n\n\t            return false;\n\t        },\n\n\t        _getCurrentRangeSpan: function() {\n\t            var that = this;\n\t            var ranges = that._ranges;\n\t            var start = that.currentRangeStart();\n\t            var end = start + (that.take() || 0);\n\t            var rangeSpan = [];\n\t            var range;\n\t            var idx;\n\t            var length = ranges.length;\n\n\t            for (idx = 0; idx < length; idx++) {\n\t                range = ranges[idx];\n\n\t                if ((range.start <= start && range.end >= start) || (range.start >= start && range.start <= end)) {\n\t                    rangeSpan.push(range);\n\t                }\n\t            }\n\n\t            return rangeSpan;\n\t        },\n\n\t        _removeModelFromRanges: function(model) {\n\t            var that = this;\n\t            var result,\n\t                range;\n\n\t            for (var idx = 0, length = this._ranges.length; idx < length; idx++) {\n\t                range = this._ranges[idx];\n\n\t                this._eachItem(range.data, function(items) {\n\t                    result = removeModel(items, model);\n\t                });\n\n\t                if (result) {\n\t                    break;\n\t                }\n\t            }\n\n\t            that._updateRangesLength();\n\t        },\n\n\t        _insertModelInRange: function(index, model) {\n\t            var that = this;\n\t            var ranges = that._ranges || [];\n\t            var rangesLength = ranges.length;\n\t            var range;\n\t            var i;\n\n\t            for (i = 0; i < rangesLength; i++) {\n\t                range = ranges[i];\n\n\t                if (range.start <= index && range.end >= index) {\n\t                    if (!that._getByUid(model.uid, range.data)) {\n\t                        if (that._isServerGrouped()) {\n\t                            range.data.splice(index, 0, that._wrapInEmptyGroup(model));\n\t                        } else {\n\t                            range.data.splice(index, 0, model);\n\t                        }\n\t                    }\n\n\t                    break;\n\t                }\n\t            }\n\n\t            that._updateRangesLength();\n\t        },\n\n\t        _updateRangesLength: function() {\n\t            var that = this;\n\t            var ranges = that._ranges || [];\n\t            var rangesLength = ranges.length;\n\t            var mismatchFound = false;\n\t            var mismatchLength = 0;\n\t            var lengthDifference = 0;\n\t            var range;\n\t            var i;\n\n\t            for (i = 0; i < rangesLength; i++) {\n\t                range = ranges[i];\n\t                lengthDifference = that._flatData(range.data, true).length - math.abs(range.end - range.start);\n\n\t                if (!mismatchFound && lengthDifference !== 0) {\n\t                    mismatchFound = true;\n\t                    mismatchLength = lengthDifference;\n\t                    range.end += mismatchLength;\n\t                    continue;\n\t                }\n\n\t                if (mismatchFound) {\n\t                    range.start += mismatchLength;\n\t                    range.end += mismatchLength;\n\t                }\n\t            }\n\t        }\n\t    });\n\n\t    var Transport = {};\n\n\t    Transport.create = function(options, data, dataSource) {\n\t        var transport,\n\t            transportOptions = options.transport ? $.extend({}, options.transport) : null;\n\n\t        if (transportOptions) {\n\t            transportOptions.read = typeof transportOptions.read === STRING ? { url: transportOptions.read } : transportOptions.read;\n\n\t            if (options.type === \"jsdo\") {\n\t                transportOptions.dataSource = dataSource;\n\t            }\n\n\t            if (options.type) {\n\t                kendo.data.transports = kendo.data.transports || {};\n\t                kendo.data.schemas = kendo.data.schemas || {};\n\n\t                if (!kendo.data.transports[options.type]) {\n\t                    kendo.logToConsole(\"Unknown DataSource transport type '\" + options.type + \"'.\\nVerify that registration scripts for this type are included after Kendo UI on the page.\", \"warn\");\n\t                } else if (!isPlainObject(kendo.data.transports[options.type])) {\n\t                    transport = new kendo.data.transports[options.type](extend(transportOptions, { data: data }));\n\t                } else {\n\t                    transportOptions = extend(true, {}, kendo.data.transports[options.type], transportOptions);\n\t                }\n\n\t                options.schema = extend(true, {}, kendo.data.schemas[options.type], options.schema);\n\t            }\n\n\t            if (!transport) {\n\t                transport = isFunction(transportOptions.read) ? transportOptions : new RemoteTransport(transportOptions);\n\t            }\n\t        } else {\n\t            transport = new LocalTransport({ data: options.data || [] });\n\t        }\n\t        return transport;\n\t    };\n\n\t    DataSource.create = function(options) {\n\t        if (isArray(options) || options instanceof ObservableArray) {\n\t           options = { data: options };\n\t        }\n\n\t        var dataSource = options || {},\n\t            data = dataSource.data,\n\t            fields = dataSource.fields,\n\t            table = dataSource.table,\n\t            select = dataSource.select,\n\t            idx,\n\t            length,\n\t            model = {},\n\t            field;\n\n\t        if (!data && fields && !dataSource.transport) {\n\t            if (table) {\n\t                data = inferTable(table, fields);\n\t            } else if (select) {\n\t                data = inferSelect(select, fields);\n\n\t                if (dataSource.group === undefined && data[0] && data[0].optgroup !== undefined) {\n\t                    dataSource.group = \"optgroup\";\n\t                }\n\t            }\n\t        }\n\n\t        if (kendo.data.Model && fields && (!dataSource.schema || !dataSource.schema.model)) {\n\t            for (idx = 0, length = fields.length; idx < length; idx++) {\n\t                field = fields[idx];\n\t                if (field.type) {\n\t                    model[field.field] = field;\n\t                }\n\t            }\n\n\t            if (!isEmptyObject(model)) {\n\t                dataSource.schema = extend(true, dataSource.schema, { model:  { fields: model } });\n\t            }\n\t        }\n\n\t        dataSource.data = data;\n\n\t        select = null;\n\t        dataSource.select = null;\n\t        table = null;\n\t        dataSource.table = null;\n\n\t        return dataSource instanceof DataSource ? dataSource : new DataSource(dataSource);\n\t    };\n\n\t    function inferSelect(select, fields) {\n\t        select = $(select)[0];\n\t        var options = select.options;\n\t        var firstField = fields[0];\n\t        var secondField = fields[1];\n\n\t        var data = [];\n\t        var idx, length;\n\t        var optgroup;\n\t        var option;\n\t        var record;\n\t        var value;\n\n\t        for (idx = 0, length = options.length; idx < length; idx++) {\n\t            record = {};\n\t            option = options[idx];\n\t            optgroup = option.parentNode;\n\n\t            if (optgroup === select) {\n\t                optgroup = null;\n\t            }\n\n\t            if (option.disabled || (optgroup && optgroup.disabled)) {\n\t                continue;\n\t            }\n\n\t            if (optgroup) {\n\t                record.optgroup = optgroup.label;\n\t            }\n\n\t            record[firstField.field] = option.text;\n\n\t            value = option.attributes.value;\n\n\t            if (value && value.specified) {\n\t                value = option.value;\n\t            } else {\n\t                value = option.text;\n\t            }\n\n\t            record[secondField.field] = value;\n\n\t            data.push(record);\n\t        }\n\n\t        return data;\n\t    }\n\n\t    function inferTable(table, fields) {\n\t        var tbody = $(table)[0].tBodies[0],\n\t        rows = tbody ? tbody.rows : [],\n\t        idx,\n\t        length,\n\t        fieldIndex,\n\t        fieldCount = fields.length,\n\t        data = [],\n\t        cells,\n\t        record,\n\t        cell,\n\t        empty;\n\n\t        for (idx = 0, length = rows.length; idx < length; idx++) {\n\t            record = {};\n\t            empty = true;\n\t            cells = rows[idx].cells;\n\n\t            for (fieldIndex = 0; fieldIndex < fieldCount; fieldIndex++) {\n\t                cell = cells[fieldIndex];\n\t                if(cell.nodeName.toLowerCase() !== \"th\") {\n\t                    empty = false;\n\t                    record[fields[fieldIndex].field] = cell.innerHTML;\n\t                }\n\t            }\n\t            if(!empty) {\n\t                data.push(record);\n\t            }\n\t        }\n\n\t        return data;\n\t    }\n\n\t    var Node = Model.define({\n\t        idField: \"id\",\n\n\t        init: function(value) {\n\t            var that = this,\n\t                hasChildren = that.hasChildren || value && value.hasChildren,\n\t                childrenField = \"items\",\n\t                childrenOptions = {};\n\n\t            kendo.data.Model.fn.init.call(that, value);\n\n\t            if (typeof that.children === STRING) {\n\t                childrenField = that.children;\n\t            }\n\n\t            childrenOptions = {\n\t                schema: {\n\t                    data: childrenField,\n\t                    model: {\n\t                        hasChildren: hasChildren,\n\t                        id: that.idField,\n\t                        fields: that.fields\n\t                    }\n\t                }\n\t            };\n\n\t            if (typeof that.children !== STRING) {\n\t                extend(childrenOptions, that.children);\n\t            }\n\n\t            childrenOptions.data = value;\n\n\t            if (!hasChildren) {\n\t                hasChildren = childrenOptions.schema.data;\n\t            }\n\n\t            if (typeof hasChildren === STRING) {\n\t                hasChildren = kendo.getter(hasChildren);\n\t            }\n\n\t            if (isFunction(hasChildren)) {\n\t                var hasChildrenObject = hasChildren.call(that, that);\n\n\t                if(hasChildrenObject && hasChildrenObject.length === 0){\n\t                    that.hasChildren = false;\n\t                } else{\n\t                    that.hasChildren = !!hasChildrenObject;\n\t                }\n\t            }\n\n\t            that._childrenOptions = childrenOptions;\n\n\t            if (that.hasChildren) {\n\t                that._initChildren();\n\t            }\n\n\t            that._loaded = !!(value && value._loaded);\n\t        },\n\n\t        _initChildren: function() {\n\t            var that = this;\n\t            var children, transport, parameterMap;\n\n\t            if (!(that.children instanceof HierarchicalDataSource)) {\n\t                children = that.children = new HierarchicalDataSource(that._childrenOptions);\n\n\t                transport = children.transport;\n\t                parameterMap = transport.parameterMap;\n\n\t                transport.parameterMap = function(data, type) {\n\t                    data[that.idField || \"id\"] = that.id;\n\n\t                    if (parameterMap) {\n\t                        data = parameterMap(data, type);\n\t                    }\n\n\t                    return data;\n\t                };\n\n\t                children.parent = function(){\n\t                    return that;\n\t                };\n\n\t                children.bind(CHANGE, function(e){\n\t                    e.node = e.node || that;\n\t                    that.trigger(CHANGE, e);\n\t                });\n\n\t                children.bind(ERROR, function(e){\n\t                    var collection = that.parent();\n\n\t                    if (collection) {\n\t                        e.node = e.node || that;\n\t                        collection.trigger(ERROR, e);\n\t                    }\n\t                });\n\n\t                that._updateChildrenField();\n\t            }\n\t        },\n\n\t        append: function(model) {\n\t            this._initChildren();\n\t            this.loaded(true);\n\t            this.children.add(model);\n\t        },\n\n\t        hasChildren: false,\n\n\t        level: function() {\n\t            var parentNode = this.parentNode(),\n\t                level = 0;\n\n\t            while (parentNode && parentNode.parentNode) {\n\t                level++;\n\t                parentNode = parentNode.parentNode ? parentNode.parentNode() : null;\n\t            }\n\n\t            return level;\n\t        },\n\n\t        _updateChildrenField: function() {\n\t            var fieldName = this._childrenOptions.schema.data;\n\n\t            this[fieldName || \"items\"] = this.children.data();\n\t        },\n\n\t        _childrenLoaded: function() {\n\t            this._loaded = true;\n\n\t            this._updateChildrenField();\n\t        },\n\n\t        load: function() {\n\t            var options = {};\n\t            var method = \"_query\";\n\t            var children, promise;\n\n\t            if (this.hasChildren) {\n\t                this._initChildren();\n\n\t                children = this.children;\n\n\t                options[this.idField || \"id\"] = this.id;\n\n\t                if (!this._loaded) {\n\t                    children._data = undefined;\n\t                    method = \"read\";\n\t                }\n\n\t                children.one(CHANGE, proxy(this._childrenLoaded, this));\n\n\t                if(this._matchFilter){\n\t                    options.filter = { field: '_matchFilter', operator: 'eq', value: true };\n\t                }\n\n\t                promise = children[method](options);\n\t            } else {\n\t                this.loaded(true);\n\t            }\n\n\t            return promise || $.Deferred().resolve().promise();\n\t        },\n\n\t        parentNode: function() {\n\t            var array = this.parent();\n\n\t            return array.parent();\n\t        },\n\n\t        loaded: function(value) {\n\t            if (value !== undefined) {\n\t                this._loaded = value;\n\t            } else {\n\t                return this._loaded;\n\t            }\n\t        },\n\n\t        shouldSerialize: function(field) {\n\t            return Model.fn.shouldSerialize.call(this, field) &&\n\t                    field !== \"children\" &&\n\t                    field !== \"_loaded\" &&\n\t                    field !== \"hasChildren\" &&\n\t                    field !== \"_childrenOptions\";\n\t        }\n\t    });\n\n\t    function dataMethod(name) {\n\t        return function() {\n\t            var data = this._data,\n\t                result = DataSource.fn[name].apply(this, slice.call(arguments));\n\n\t            if (this._data != data) {\n\t                this._attachBubbleHandlers();\n\t            }\n\n\t            return result;\n\t        };\n\t    }\n\n\t    var HierarchicalDataSource = DataSource.extend({\n\t        init: function(options) {\n\t            var node = Node.define({\n\t                children: options\n\t            });\n\n\t            if(options.filter && !options.serverFiltering){\n\t                this._hierarchicalFilter = options.filter;\n\t                options.filter = null;\n\t            }\n\n\t            DataSource.fn.init.call(this, extend(true, {}, { schema: { modelBase: node, model: node } }, options));\n\n\t            this._attachBubbleHandlers();\n\t        },\n\n\t        _attachBubbleHandlers: function() {\n\t            var that = this;\n\n\t            that._data.bind(ERROR, function(e) {\n\t                that.trigger(ERROR, e);\n\t            });\n\t        },\n\n\t        read: function(data) {\n\t            var result = DataSource.fn.read.call(this, data);\n\n\t            if(this._hierarchicalFilter){\n\t                if(this._data && this._data.length > 0){\n\t                    this.filter(this._hierarchicalFilter);\n\t                }else{\n\t                    this.options.filter = this._hierarchicalFilter;\n\t                    this._filter = normalizeFilter(this.options.filter);\n\t                    this._hierarchicalFilter = null;\n\t                }\n\t            }\n\n\t            return result;\n\t        },\n\n\t        remove: function(node){\n\t            var parentNode = node.parentNode(),\n\t                dataSource = this,\n\t                result;\n\n\t            if (parentNode && parentNode._initChildren) {\n\t                dataSource = parentNode.children;\n\t            }\n\n\t            result = DataSource.fn.remove.call(dataSource, node);\n\n\t            if (parentNode && !dataSource.data().length) {\n\t                parentNode.hasChildren = false;\n\t            }\n\n\t            return result;\n\t        },\n\n\t        success: dataMethod(\"success\"),\n\n\t        data: dataMethod(\"data\"),\n\n\t        insert: function(index, model) {\n\t            var parentNode = this.parent();\n\n\t            if (parentNode && parentNode._initChildren) {\n\t                parentNode.hasChildren = true;\n\t                parentNode._initChildren();\n\t            }\n\n\t            return DataSource.fn.insert.call(this, index, model);\n\t        },\n\n\t        filter: function(val) {\n\t            if (val === undefined) {\n\t                 return this._filter;\n\t            }\n\n\t            if(!this.options.serverFiltering && this._markHierarchicalQuery(val)){\n\t                val = { logic: \"or\", filters: [val, {field:'_matchFilter', operator: 'equals', value: true }]};\n\t            }\n\n\t            this.trigger(\"reset\");\n\t            this._query({ filter: val, page: 1 });\n\t        },\n\n\t        _markHierarchicalQuery: function(expressions){\n\t            var compiled;\n\t            var predicate;\n\t            var fields;\n\t            var operators;\n\t            var filter;\n\n\t            expressions = normalizeFilter(expressions);\n\n\t            if (!expressions || expressions.filters.length === 0) {\n\t                this._updateHierarchicalFilter(function(){return true;});\n\t                return false;\n\t            }\n\n\t            compiled = Query.filterExpr(expressions);\n\t            fields = compiled.fields;\n\t            operators = compiled.operators;\n\n\t            predicate = filter = new Function(\"d, __f, __o\", \"return \" + compiled.expression);\n\n\t            if (fields.length || operators.length) {\n\t                filter = function(d) {\n\t                    return predicate(d, fields, operators);\n\t                };\n\t            }\n\n\t            this._updateHierarchicalFilter(filter);\n\t            return true;\n\t        },\n\n\t         _updateHierarchicalFilter: function(filter){\n\t            var current;\n\t            var data = this._data;\n\t            var result = false;\n\n\t            for (var idx = 0; idx < data.length; idx++) {\n\t                 current = data[idx];\n\n\t                 if(current.hasChildren){\n\t                     current._matchFilter = current.children._updateHierarchicalFilter(filter);\n\t                    if(!current._matchFilter){\n\t                        current._matchFilter = filter(current);\n\t                    }\n\t                }else{\n\t                    current._matchFilter = filter(current);\n\t                }\n\n\t                if(current._matchFilter){\n\t                    result = true;\n\t                }\n\t            }\n\t            return result;\n\t        },\n\n\t        _find: function(method, value) {\n\t            var idx, length, node, children;\n\t            var data = this._data;\n\n\t            if (!data) {\n\t                return;\n\t            }\n\n\t            node = DataSource.fn[method].call(this, value);\n\n\t            if (node) {\n\t                return node;\n\t            }\n\n\t            data = this._flatData(this._data);\n\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\n\t                children = data[idx].children;\n\n\t                if (!(children instanceof HierarchicalDataSource)) {\n\t                    continue;\n\t                }\n\n\t                node = children[method](value);\n\n\t                if (node) {\n\t                    return node;\n\t                }\n\t            }\n\t        },\n\n\t        get: function(id) {\n\t            return this._find(\"get\", id);\n\t        },\n\n\t        getByUid: function(uid) {\n\t            return this._find(\"getByUid\", uid);\n\t        }\n\t    });\n\n\t    function inferList(list, fields) {\n\t        var items = $(list).children(),\n\t            idx,\n\t            length,\n\t            data = [],\n\t            record,\n\t            textField = fields[0].field,\n\t            urlField = fields[1] && fields[1].field,\n\t            spriteCssClassField = fields[2] && fields[2].field,\n\t            imageUrlField = fields[3] && fields[3].field,\n\t            item,\n\t            id,\n\t            textChild,\n\t            className,\n\t            children;\n\n\t        function elements(collection, tagName) {\n\t            return collection.filter(tagName).add(collection.find(tagName));\n\t        }\n\n\t        for (idx = 0, length = items.length; idx < length; idx++) {\n\t            record = { _loaded: true };\n\t            item = items.eq(idx);\n\n\t            textChild = item[0].firstChild;\n\t            children = item.children();\n\t            list = children.filter(\"ul\");\n\t            children = children.filter(\":not(ul)\");\n\n\t            id = item.attr(\"data-id\");\n\n\t            if (id) {\n\t                record.id = id;\n\t            }\n\n\t            if (textChild) {\n\t                record[textField] = textChild.nodeType == 3 ? textChild.nodeValue : children.text();\n\t            }\n\n\t            if (urlField) {\n\t                record[urlField] = elements(children, \"a\").attr(\"href\");\n\t            }\n\n\t            if (imageUrlField) {\n\t                record[imageUrlField] = elements(children, \"img\").attr(\"src\");\n\t            }\n\n\t            if (spriteCssClassField) {\n\t                className = elements(children, \".k-sprite\").prop(\"className\");\n\t                record[spriteCssClassField] = className && $.trim(className.replace(\"k-sprite\", \"\"));\n\t            }\n\n\t            if (list.length) {\n\t                record.items = inferList(list.eq(0), fields);\n\t            }\n\n\t            if (item.attr(\"data-hasChildren\") == \"true\") {\n\t                record.hasChildren = true;\n\t            }\n\n\t            data.push(record);\n\t        }\n\n\t        return data;\n\t    }\n\n\t    HierarchicalDataSource.create = function(options) {\n\t        options = options && options.push ? { data: options } : options;\n\n\t        var dataSource = options || {},\n\t            data = dataSource.data,\n\t            fields = dataSource.fields,\n\t            list = dataSource.list;\n\n\t        if (data && data._dataSource) {\n\t            return data._dataSource;\n\t        }\n\n\t        if (!data && fields && !dataSource.transport) {\n\t            if (list) {\n\t                data = inferList(list, fields);\n\t            }\n\t        }\n\n\t        dataSource.data = data;\n\n\t        return dataSource instanceof HierarchicalDataSource ? dataSource : new HierarchicalDataSource(dataSource);\n\t    };\n\n\t    var Buffer = kendo.Observable.extend({\n\t        init: function(dataSource, viewSize, disablePrefetch) {\n\t            kendo.Observable.fn.init.call(this);\n\n\t            this._prefetching = false;\n\t            this.dataSource = dataSource;\n\t            this.prefetch = !disablePrefetch;\n\n\t            var buffer = this;\n\n\t            dataSource.bind(\"change\", function() {\n\t                buffer._change();\n\t            });\n\n\t            dataSource.bind(\"reset\", function() {\n\t                buffer._reset();\n\t            });\n\n\t            this._syncWithDataSource();\n\n\t            this.setViewSize(viewSize);\n\t        },\n\n\t        setViewSize: function(viewSize) {\n\t            this.viewSize = viewSize;\n\t            this._recalculate();\n\t        },\n\n\t        at: function(index)  {\n\t            var pageSize = this.pageSize,\n\t                itemPresent = true;\n\n\t            if (index >= this.total()) {\n\t                this.trigger(\"endreached\", {index: index });\n\t                return null;\n\t            }\n\n\t            if (!this.useRanges) {\n\t               return this.dataSource.view()[index];\n\t            }\n\t            if (this.useRanges) {\n\t                // out of range request\n\t                if (index < this.dataOffset || index >= this.skip + pageSize) {\n\t                    itemPresent = this.range(Math.floor(index / pageSize) * pageSize);\n\t                }\n\n\t                // prefetch\n\t                if (index === this.prefetchThreshold) {\n\t                    this._prefetch();\n\t                }\n\n\t                // mid-range jump - prefetchThreshold and nextPageThreshold may be equal, do not change to else if\n\t                if (index === this.midPageThreshold) {\n\t                    this.range(this.nextMidRange, true);\n\t                }\n\t                // next range jump\n\t                else if (index === this.nextPageThreshold) {\n\t                    this.range(this.nextFullRange);\n\t                }\n\t                // pull-back\n\t                else if (index === this.pullBackThreshold) {\n\t                    if (this.offset === this.skip) { // from full range to mid range\n\t                        this.range(this.previousMidRange);\n\t                    } else { // from mid range to full range\n\t                        this.range(this.previousFullRange);\n\t                    }\n\t                }\n\n\t                if (itemPresent) {\n\t                    return this.dataSource.at(index - this.dataOffset);\n\t                } else {\n\t                    this.trigger(\"endreached\", { index: index });\n\t                    return null;\n\t                }\n\t            }\n\t        },\n\n\t        indexOf: function(item) {\n\t            return this.dataSource.data().indexOf(item) + this.dataOffset;\n\t        },\n\n\t        total: function() {\n\t            return parseInt(this.dataSource.total(), 10);\n\t        },\n\n\t        next: function() {\n\t            var buffer = this,\n\t                pageSize = buffer.pageSize,\n\t                offset = buffer.skip - buffer.viewSize + pageSize,\n\t                pageSkip = math.max(math.floor(offset / pageSize), 0) * pageSize;\n\n\t            this.offset = offset;\n\t            this.dataSource.prefetch(pageSkip, pageSize, function() {\n\t                buffer._goToRange(offset, true);\n\t            });\n\t        },\n\n\t        range: function(offset, nextRange) {\n\t            if (this.offset === offset) {\n\t                return true;\n\t            }\n\n\t            var buffer = this,\n\t                pageSize = this.pageSize,\n\t                pageSkip = math.max(math.floor(offset / pageSize), 0) * pageSize,\n\t                dataSource = this.dataSource;\n\n\t            if (nextRange) {\n\t                pageSkip += pageSize;\n\t            }\n\n\t            if (dataSource.inRange(offset, pageSize)) {\n\t                this.offset = offset;\n\t                this._recalculate();\n\t                this._goToRange(offset);\n\t                return true;\n\t            } else if (this.prefetch) {\n\t                dataSource.prefetch(pageSkip, pageSize, function() {\n\t                    buffer.offset = offset;\n\t                    buffer._recalculate();\n\t                    buffer._goToRange(offset, true);\n\t                });\n\t                return false;\n\t            }\n\n\t            return true;\n\t        },\n\n\t        syncDataSource: function() {\n\t            var offset = this.offset;\n\t            this.offset = null;\n\t            this.range(offset);\n\t        },\n\n\t        destroy: function() {\n\t            this.unbind();\n\t        },\n\n\t        _prefetch: function() {\n\t            var buffer = this,\n\t                pageSize = this.pageSize,\n\t                prefetchOffset = this.skip + pageSize,\n\t                dataSource = this.dataSource;\n\n\t            if (!dataSource.inRange(prefetchOffset, pageSize) && !this._prefetching && this.prefetch) {\n\t                this._prefetching = true;\n\t                this.trigger(\"prefetching\", { skip: prefetchOffset, take: pageSize });\n\n\t                dataSource.prefetch(prefetchOffset, pageSize, function() {\n\t                    buffer._prefetching = false;\n\t                    buffer.trigger(\"prefetched\", { skip: prefetchOffset, take: pageSize });\n\t                });\n\t            }\n\t        },\n\n\t        _goToRange: function(offset, expanding) {\n\t            if (this.offset !== offset) {\n\t                return;\n\t            }\n\n\t            this.dataOffset = offset;\n\t            this._expanding = expanding;\n\t            this.dataSource.range(offset, this.pageSize);\n\t            this.dataSource.enableRequestsInProgress();\n\t        },\n\n\t        _reset: function() {\n\t            this._syncPending = true;\n\t        },\n\n\t        _change: function() {\n\t            var dataSource = this.dataSource;\n\n\t            this.length = this.useRanges ? dataSource.lastRange().end : dataSource.view().length;\n\n\t            if (this._syncPending) {\n\t                this._syncWithDataSource();\n\t                this._recalculate();\n\t                this._syncPending = false;\n\t                this.trigger(\"reset\", { offset: this.offset });\n\t            }\n\n\t            this.trigger(\"resize\");\n\n\t            if (this._expanding) {\n\t                this.trigger(\"expand\");\n\t            }\n\n\t            delete this._expanding;\n\t        },\n\n\t        _syncWithDataSource: function() {\n\t            var dataSource = this.dataSource;\n\n\t            this._firstItemUid = dataSource.firstItemUid();\n\t            this.dataOffset = this.offset = dataSource.skip() || 0;\n\t            this.pageSize = dataSource.pageSize();\n\t            this.useRanges = dataSource.options.serverPaging;\n\t        },\n\n\t        _recalculate: function() {\n\t            var pageSize = this.pageSize,\n\t                offset = this.offset,\n\t                viewSize = this.viewSize,\n\t                skip = Math.ceil(offset / pageSize) * pageSize;\n\n\t            this.skip = skip;\n\t            this.midPageThreshold = skip + pageSize - 1;\n\t            this.nextPageThreshold = skip + viewSize - 1;\n\t            this.prefetchThreshold = skip + Math.floor(pageSize / 3 * 2);\n\t            this.pullBackThreshold = this.offset - 1;\n\n\t            this.nextMidRange = skip + pageSize - viewSize;\n\t            this.nextFullRange = skip;\n\t            this.previousMidRange = offset - viewSize;\n\t            this.previousFullRange = skip - pageSize;\n\t        }\n\t    });\n\n\t    var BatchBuffer = kendo.Observable.extend({\n\t        init: function(dataSource, batchSize) {\n\t            var batchBuffer = this;\n\n\t            kendo.Observable.fn.init.call(batchBuffer);\n\n\t            this.dataSource = dataSource;\n\t            this.batchSize = batchSize;\n\t            this._total = 0;\n\n\t            this.buffer = new Buffer(dataSource, batchSize * 3);\n\n\t            this.buffer.bind({\n\t                \"endreached\": function (e) {\n\t                    batchBuffer.trigger(\"endreached\", { index: e.index });\n\t                },\n\t                \"prefetching\": function (e) {\n\t                    batchBuffer.trigger(\"prefetching\", { skip: e.skip, take: e.take });\n\t                },\n\t                \"prefetched\": function (e) {\n\t                    batchBuffer.trigger(\"prefetched\", { skip: e.skip, take: e.take });\n\t                },\n\t                \"reset\": function () {\n\t                    batchBuffer._total = 0;\n\t                    batchBuffer.trigger(\"reset\");\n\t                },\n\t                \"resize\": function () {\n\t                    batchBuffer._total = Math.ceil(this.length / batchBuffer.batchSize);\n\t                    batchBuffer.trigger(\"resize\", { total: batchBuffer.total(), offset: this.offset });\n\t                }\n\t            });\n\t        },\n\n\t        syncDataSource: function() {\n\t            this.buffer.syncDataSource();\n\t        },\n\n\t        at: function(index) {\n\t            var buffer = this.buffer,\n\t                skip = index * this.batchSize,\n\t                take = this.batchSize,\n\t                view = [],\n\t                item;\n\n\t            if (buffer.offset > skip) {\n\t                buffer.at(buffer.offset - 1);\n\t            }\n\n\t            for (var i = 0; i < take; i++) {\n\t                item = buffer.at(skip + i);\n\n\t                if (item === null) {\n\t                    break;\n\t                }\n\n\t                view.push(item);\n\t            }\n\n\t            return view;\n\t        },\n\n\t        total: function() {\n\t            return this._total;\n\t        },\n\n\t        destroy: function() {\n\t            this.buffer.destroy();\n\t            this.unbind();\n\t        }\n\t    });\n\n\t    extend(true, kendo.data, {\n\t        readers: {\n\t            json: DataReader\n\t        },\n\t        Query: Query,\n\t        DataSource: DataSource,\n\t        HierarchicalDataSource: HierarchicalDataSource,\n\t        Node: Node,\n\t        ObservableObject: ObservableObject,\n\t        ObservableArray: ObservableArray,\n\t        LazyObservableArray: LazyObservableArray,\n\t        LocalTransport: LocalTransport,\n\t        RemoteTransport: RemoteTransport,\n\t        Cache: Cache,\n\t        DataReader: DataReader,\n\t        Model: Model,\n\t        Buffer: Buffer,\n\t        BatchBuffer: BatchBuffer\n\t    });\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 1047:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.data.odata */ \"c4b523a40f8c9d1f237b\");\n\n/***/ }),\n\n/***/ 1048:\n/***/ (function(module, exports) {\n\n\tmodule.exports = __webpack_require__(/*! ./kendo.data.xml */ \"f1f6d1b513a156927c9d\");\n\n/***/ })\n\n/******/ });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZjc4ZGI1NDk1NDM4MWUyODQ0MzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb2dyZXNzL2tlbmRvLXVpL2pzL2tlbmRvLmRhdGEuanM/MWY0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuXG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoe1xuXG4vKioqLyAwOlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDQ2KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJkZWZpbmUgY2Fubm90IGJlIHVzZWQgaW5kaXJlY3RcIik7IH07XHJcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTAwNDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2tlbmRvLmNvcmVcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMDQ2OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdHZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fOyhmdW5jdGlvbihmLCBkZWZpbmUpe1xuXHQgICAgIShfX1dFQlBBQ0tfQU1EX0RFRklORV9BUlJBWV9fID0gWyBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMDQpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNDcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwNDgpIF0sIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9IChmKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSAodHlwZW9mIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyA9PT0gJ2Z1bmN0aW9uJyA/IChfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18uYXBwbHkoZXhwb3J0cywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXykpIDogX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fKSwgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gIT09IHVuZGVmaW5lZCAmJiAobW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXykpO1xuXHR9KShmdW5jdGlvbigpe1xuXG5cdHZhciBfX21ldGFfXyA9IHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cdCAgICBpZDogXCJkYXRhXCIsXG5cdCAgICBuYW1lOiBcIkRhdGEgc291cmNlXCIsXG5cdCAgICBjYXRlZ29yeTogXCJmcmFtZXdvcmtcIixcblx0ICAgIGRlc2NyaXB0aW9uOiBcIlBvd2VyZnVsIGNvbXBvbmVudCBmb3IgdXNpbmcgbG9jYWwgYW5kIHJlbW90ZSBkYXRhLkZ1bGx5IHN1cHBvcnRzIENSVUQsIFNvcnRpbmcsIFBhZ2luZywgRmlsdGVyaW5nLCBHcm91cGluZywgYW5kIEFnZ3JlZ2F0ZXMuXCIsXG5cdCAgICBkZXBlbmRzOiBbIFwiY29yZVwiIF0sXG5cdCAgICBmZWF0dXJlczogWyB7XG5cdCAgICAgICAgaWQ6IFwiZGF0YS1vZGF0YVwiLFxuXHQgICAgICAgIG5hbWU6IFwiT0RhdGFcIixcblx0ICAgICAgICBkZXNjcmlwdGlvbjogXCJTdXBwb3J0IGZvciBhY2Nlc3NpbmcgT3BlbiBEYXRhIFByb3RvY29sIChPRGF0YSkgc2VydmljZXMuXCIsXG5cdCAgICAgICAgZGVwZW5kczogWyBcImRhdGEub2RhdGFcIiBdXG5cdCAgICB9LCB7XG5cdCAgICAgICAgaWQ6IFwiZGF0YS1zaWduYWxyXCIsXG5cdCAgICAgICAgbmFtZTogXCJTaWduYWxSXCIsXG5cdCAgICAgICAgZGVzY3JpcHRpb246IFwiU3VwcG9ydCBmb3IgYmluZGluZyB0byBTaWduYWxSIGh1YnMuXCIsXG5cdCAgICAgICAgZGVwZW5kczogWyBcImRhdGEuc2lnbmFsclwiIF1cblx0ICAgIH0sIHtcblx0ICAgICAgICBpZDogXCJkYXRhLVhNTFwiLFxuXHQgICAgICAgIG5hbWU6IFwiWE1MXCIsXG5cdCAgICAgICAgZGVzY3JpcHRpb246IFwiU3VwcG9ydCBmb3IgYmluZGluZyB0byBYTUwuXCIsXG5cdCAgICAgICAgZGVwZW5kczogWyBcImRhdGEueG1sXCIgXVxuXHQgICAgfV1cblx0fTtcblxuXHQvKmpzaGludCBlcW51bGw6IHRydWUsIGxvb3BmdW5jOiB0cnVlLCBldmlsOiB0cnVlICovXG5cdChmdW5jdGlvbigkLCB1bmRlZmluZWQpIHtcblx0ICAgIHZhciBleHRlbmQgPSAkLmV4dGVuZCxcblx0ICAgICAgICBwcm94eSA9ICQucHJveHksXG5cdCAgICAgICAgaXNQbGFpbk9iamVjdCA9ICQuaXNQbGFpbk9iamVjdCxcblx0ICAgICAgICBpc0VtcHR5T2JqZWN0ID0gJC5pc0VtcHR5T2JqZWN0LFxuXHQgICAgICAgIGlzQXJyYXkgPSAkLmlzQXJyYXksXG5cdCAgICAgICAgZ3JlcCA9ICQuZ3JlcCxcblx0ICAgICAgICBhamF4ID0gJC5hamF4LFxuXHQgICAgICAgIG1hcCxcblx0ICAgICAgICBlYWNoID0gJC5lYWNoLFxuXHQgICAgICAgIG5vb3AgPSAkLm5vb3AsXG5cdCAgICAgICAga2VuZG8gPSB3aW5kb3cua2VuZG8sXG5cdCAgICAgICAgaXNGdW5jdGlvbiA9IGtlbmRvLmlzRnVuY3Rpb24sXG5cdCAgICAgICAgT2JzZXJ2YWJsZSA9IGtlbmRvLk9ic2VydmFibGUsXG5cdCAgICAgICAgQ2xhc3MgPSBrZW5kby5DbGFzcyxcblx0ICAgICAgICBTVFJJTkcgPSBcInN0cmluZ1wiLFxuXHQgICAgICAgIEZVTkNUSU9OID0gXCJmdW5jdGlvblwiLFxuXHQgICAgICAgIENSRUFURSA9IFwiY3JlYXRlXCIsXG5cdCAgICAgICAgUkVBRCA9IFwicmVhZFwiLFxuXHQgICAgICAgIFVQREFURSA9IFwidXBkYXRlXCIsXG5cdCAgICAgICAgREVTVFJPWSA9IFwiZGVzdHJveVwiLFxuXHQgICAgICAgIENIQU5HRSA9IFwiY2hhbmdlXCIsXG5cdCAgICAgICAgU1lOQyA9IFwic3luY1wiLFxuXHQgICAgICAgIEdFVCA9IFwiZ2V0XCIsXG5cdCAgICAgICAgRVJST1IgPSBcImVycm9yXCIsXG5cdCAgICAgICAgUkVRVUVTVFNUQVJUID0gXCJyZXF1ZXN0U3RhcnRcIixcblx0ICAgICAgICBQUk9HUkVTUyA9IFwicHJvZ3Jlc3NcIixcblx0ICAgICAgICBSRVFVRVNURU5EID0gXCJyZXF1ZXN0RW5kXCIsXG5cdCAgICAgICAgY3J1ZCA9IFtDUkVBVEUsIFJFQUQsIFVQREFURSwgREVTVFJPWV0sXG5cdCAgICAgICAgaWRlbnRpdHkgPSBmdW5jdGlvbihvKSB7IHJldHVybiBvOyB9LFxuXHQgICAgICAgIGdldHRlciA9IGtlbmRvLmdldHRlcixcblx0ICAgICAgICBzdHJpbmdpZnkgPSBrZW5kby5zdHJpbmdpZnksXG5cdCAgICAgICAgbWF0aCA9IE1hdGgsXG5cdCAgICAgICAgcHVzaCA9IFtdLnB1c2gsXG5cdCAgICAgICAgam9pbiA9IFtdLmpvaW4sXG5cdCAgICAgICAgcG9wID0gW10ucG9wLFxuXHQgICAgICAgIHNwbGljZSA9IFtdLnNwbGljZSxcblx0ICAgICAgICBzaGlmdCA9IFtdLnNoaWZ0LFxuXHQgICAgICAgIHNsaWNlID0gW10uc2xpY2UsXG5cdCAgICAgICAgdW5zaGlmdCA9IFtdLnVuc2hpZnQsXG5cdCAgICAgICAgdG9TdHJpbmcgPSB7fS50b1N0cmluZyxcblx0ICAgICAgICBzdGFibGVTb3J0ID0ga2VuZG8uc3VwcG9ydC5zdGFibGVTb3J0LFxuXHQgICAgICAgIGRhdGVSZWdFeHAgPSAvXlxcL0RhdGVcXCgoLio/KVxcKVxcLyQvO1xuXG5cdCAgICB2YXIgT2JzZXJ2YWJsZUFycmF5ID0gT2JzZXJ2YWJsZS5leHRlbmQoe1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGFycmF5LCB0eXBlKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuXHQgICAgICAgICAgICB0aGF0LnR5cGUgPSB0eXBlIHx8IE9ic2VydmFibGVPYmplY3Q7XG5cblx0ICAgICAgICAgICAgT2JzZXJ2YWJsZS5mbi5pbml0LmNhbGwodGhhdCk7XG5cblx0ICAgICAgICAgICAgdGhhdC5sZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgdGhhdC53cmFwQWxsKGFycmF5LCB0aGF0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYXQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzW2luZGV4XTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgdG9KU09OOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIGlkeCwgbGVuZ3RoID0gdGhpcy5sZW5ndGgsIHZhbHVlLCBqc29uID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cblx0ICAgICAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKXtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpc1tpZHhdO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYnNlcnZhYmxlT2JqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAganNvbltpZHhdID0gdmFsdWU7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4ganNvbjtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgcGFyZW50OiBub29wLFxuXG5cdCAgICAgICAgd3JhcEFsbDogZnVuY3Rpb24oc291cmNlLCB0YXJnZXQpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgaWR4LFxuXHQgICAgICAgICAgICAgICAgbGVuZ3RoLFxuXHQgICAgICAgICAgICAgICAgcGFyZW50ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQ7XG5cdCAgICAgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCBbXTtcblxuXHQgICAgICAgICAgICBmb3IgKGlkeCA9IDAsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgICAgIHRhcmdldFtpZHhdID0gdGhhdC53cmFwKHNvdXJjZVtpZHhdLCBwYXJlbnQpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgd3JhcDogZnVuY3Rpb24ob2JqZWN0LCBwYXJlbnQpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgb2JzZXJ2YWJsZTtcblxuXHQgICAgICAgICAgICBpZiAob2JqZWN0ICE9PSBudWxsICYmIHRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuXHQgICAgICAgICAgICAgICAgb2JzZXJ2YWJsZSA9IG9iamVjdCBpbnN0YW5jZW9mIHRoYXQudHlwZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBNb2RlbDtcblxuXHQgICAgICAgICAgICAgICAgaWYgKCFvYnNlcnZhYmxlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZU9iamVjdCA/IG9iamVjdC50b0pTT04oKSA6IG9iamVjdDtcblx0ICAgICAgICAgICAgICAgICAgICBvYmplY3QgPSBuZXcgdGhhdC50eXBlKG9iamVjdCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIG9iamVjdC5wYXJlbnQgPSBwYXJlbnQ7XG5cblx0ICAgICAgICAgICAgICAgIG9iamVjdC5iaW5kKENIQU5HRSwgZnVuY3Rpb24oZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQudHJpZ2dlcihDSEFOR0UsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGUuZmllbGQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IGUubm9kZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGUuaW5kZXgsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBlLml0ZW1zIHx8IFt0aGlzXSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBlLm5vZGUgPyAoZS5hY3Rpb24gfHwgXCJpdGVtbG9hZGVkXCIpIDogXCJpdGVtY2hhbmdlXCJcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgcHVzaDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMubGVuZ3RoLFxuXHQgICAgICAgICAgICAgICAgaXRlbXMgPSB0aGlzLndyYXBBbGwoYXJndW1lbnRzKSxcblx0ICAgICAgICAgICAgICAgIHJlc3VsdDtcblxuXHQgICAgICAgICAgICByZXN1bHQgPSBwdXNoLmFwcGx5KHRoaXMsIGl0ZW1zKTtcblxuXHQgICAgICAgICAgICB0aGlzLnRyaWdnZXIoQ0hBTkdFLCB7XG5cdCAgICAgICAgICAgICAgICBhY3Rpb246IFwiYWRkXCIsXG5cdCAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG5cdCAgICAgICAgICAgICAgICBpdGVtczogaXRlbXNcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgc2xpY2U6IHNsaWNlLFxuXG5cdCAgICAgICAgc29ydDogW10uc29ydCxcblxuXHQgICAgICAgIGpvaW46IGpvaW4sXG5cblx0ICAgICAgICBwb3A6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgsIHJlc3VsdCA9IHBvcC5hcHBseSh0aGlzKTtcblxuXHQgICAgICAgICAgICBpZiAobGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoQ0hBTkdFLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlbW92ZVwiLFxuXHQgICAgICAgICAgICAgICAgICAgIGluZGV4OiBsZW5ndGggLSAxLFxuXHQgICAgICAgICAgICAgICAgICAgIGl0ZW1zOltyZXN1bHRdXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHNwbGljZTogZnVuY3Rpb24oaW5kZXgsIGhvd01hbnksIGl0ZW0pIHtcblx0ICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy53cmFwQWxsKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSksXG5cdCAgICAgICAgICAgICAgICByZXN1bHQsIGksIGxlbjtcblxuXHQgICAgICAgICAgICByZXN1bHQgPSBzcGxpY2UuYXBwbHkodGhpcywgW2luZGV4LCBob3dNYW55XS5jb25jYXQoaXRlbXMpKTtcblxuXHQgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKENIQU5HRSwge1xuXHQgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZW1vdmVcIixcblx0ICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG5cdCAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHJlc3VsdFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbaV0gJiYgcmVzdWx0W2ldLmNoaWxkcmVuKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXS51bmJpbmQoQ0hBTkdFKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoaXRlbSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKENIQU5HRSwge1xuXHQgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJhZGRcIixcblx0ICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG5cdCAgICAgICAgICAgICAgICAgICAgaXRlbXM6IGl0ZW1zXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBzaGlmdDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCwgcmVzdWx0ID0gc2hpZnQuYXBwbHkodGhpcyk7XG5cblx0ICAgICAgICAgICAgaWYgKGxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKENIQU5HRSwge1xuXHQgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZW1vdmVcIixcblx0ICAgICAgICAgICAgICAgICAgICBpbmRleDogMCxcblx0ICAgICAgICAgICAgICAgICAgICBpdGVtczpbcmVzdWx0XVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICB1bnNoaWZ0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy53cmFwQWxsKGFyZ3VtZW50cyksXG5cdCAgICAgICAgICAgICAgICByZXN1bHQ7XG5cblx0ICAgICAgICAgICAgcmVzdWx0ID0gdW5zaGlmdC5hcHBseSh0aGlzLCBpdGVtcyk7XG5cblx0ICAgICAgICAgICAgdGhpcy50cmlnZ2VyKENIQU5HRSwge1xuXHQgICAgICAgICAgICAgICAgYWN0aW9uOiBcImFkZFwiLFxuXHQgICAgICAgICAgICAgICAgaW5kZXg6IDAsXG5cdCAgICAgICAgICAgICAgICBpdGVtczogaXRlbXNcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgaW5kZXhPZjogZnVuY3Rpb24oaXRlbSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBpZHgsXG5cdCAgICAgICAgICAgICAgICBsZW5ndGg7XG5cblx0ICAgICAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSB0aGF0Lmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoYXRbaWR4XSA9PT0gaXRlbSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBpZHg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBmb3JFYWNoOiBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuXHQgICAgICAgICAgICB2YXIgaWR4ID0gMDtcblx0ICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXHQgICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXNBcmcgfHwgd2luZG93O1xuXG5cdCAgICAgICAgICAgIGZvciAoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIHRoaXNbaWR4XSwgaWR4LCB0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBtYXA6IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG5cdCAgICAgICAgICAgIHZhciBpZHggPSAwO1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcblx0ICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzQXJnIHx8IHdpbmRvdztcblxuXHQgICAgICAgICAgICBmb3IgKDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0W2lkeF0gPSBjYWxsYmFjay5jYWxsKGNvbnRleHQsIHRoaXNbaWR4XSwgaWR4LCB0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHJlZHVjZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgdmFyIGlkeCA9IDAsXG5cdCAgICAgICAgICAgICAgICByZXN1bHQsXG5cdCAgICAgICAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcblxuXHQgICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbMV07XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoaWR4IDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzW2lkeCsrXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGZvciAoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjayhyZXN1bHQsIHRoaXNbaWR4XSwgaWR4LCB0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHJlZHVjZVJpZ2h0OiBmdW5jdGlvbihjYWxsYmFjaykge1xuXHQgICAgICAgICAgICB2YXIgaWR4ID0gdGhpcy5sZW5ndGggLSAxLFxuXHQgICAgICAgICAgICAgICAgcmVzdWx0O1xuXG5cdCAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IGFyZ3VtZW50c1sxXTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChpZHggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzW2lkeC0tXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGZvciAoOyBpZHggPj0gMDsgaWR4LS0pIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKHJlc3VsdCwgdGhpc1tpZHhdLCBpZHgsIHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZmlsdGVyOiBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuXHQgICAgICAgICAgICB2YXIgaWR4ID0gMDtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgICAgICB2YXIgaXRlbTtcblx0ICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuXHQgICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXNBcmcgfHwgd2luZG93O1xuXG5cdCAgICAgICAgICAgIGZvciAoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICBpdGVtID0gdGhpc1tpZHhdO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwoY29udGV4dCwgaXRlbSwgaWR4LCB0aGlzKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IGl0ZW07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBmaW5kOiBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuXHQgICAgICAgICAgICB2YXIgaWR4ID0gMDtcblx0ICAgICAgICAgICAgdmFyIGl0ZW07XG5cdCAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcblx0ICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzQXJnIHx8IHdpbmRvdztcblxuXHQgICAgICAgICAgICBmb3IgKDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgaXRlbSA9IHRoaXNbaWR4XTtcblx0ICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKGNvbnRleHQsIGl0ZW0sIGlkeCwgdGhpcykpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBldmVyeTogZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcblx0ICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG5cdCAgICAgICAgICAgIHZhciBpdGVtO1xuXHQgICAgICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG5cdCAgICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpc0FyZyB8fCB3aW5kb3c7XG5cblx0ICAgICAgICAgICAgZm9yICg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgICAgIGl0ZW0gPSB0aGlzW2lkeF07XG5cdCAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrLmNhbGwoY29udGV4dCwgaXRlbSwgaWR4LCB0aGlzKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBzb21lOiBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuXHQgICAgICAgICAgICB2YXIgaWR4ID0gMDtcblx0ICAgICAgICAgICAgdmFyIGl0ZW07XG5cdCAgICAgICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcblx0ICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzQXJnIHx8IHdpbmRvdztcblxuXHQgICAgICAgICAgICBmb3IgKDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgaXRlbSA9IHRoaXNbaWR4XTtcblx0ICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKGNvbnRleHQsIGl0ZW0sIGlkeCwgdGhpcykpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLy8gbm9uLXN0YW5kYXJkIGNvbGxlY3Rpb24gbWV0aG9kc1xuXHQgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oaXRlbSkge1xuXHQgICAgICAgICAgICB2YXIgaWR4ID0gdGhpcy5pbmRleE9mKGl0ZW0pO1xuXG5cdCAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNwbGljZShpZHgsIDEpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGVtcHR5OiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdGhpcy5zcGxpY2UoMCwgdGhpcy5sZW5ndGgpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvLyBQb2x5ZmlsbCBmb3IgU3ltYm9sLml0ZXJhdG9yXG5cdCAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgJiYgIU9ic2VydmFibGVBcnJheS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSkge1xuXHQgICAgICAgIE9ic2VydmFibGVBcnJheS5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IFtdW1N5bWJvbC5pdGVyYXRvcl07XG5cdCAgICB9XG5cblx0ICAgIHZhciBMYXp5T2JzZXJ2YWJsZUFycmF5ID0gT2JzZXJ2YWJsZUFycmF5LmV4dGVuZCh7XG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGRhdGEsIHR5cGUsIGV2ZW50cykge1xuXHQgICAgICAgICAgICBPYnNlcnZhYmxlLmZuLmluaXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IE9ic2VydmFibGVPYmplY3Q7XG5cblx0ICAgICAgICAgICAgaWYgKGV2ZW50cykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gZXZlbnRzO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgZGF0YS5sZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzW2lkeF0gPSBkYXRhW2lkeF07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGlkeDtcblx0ICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcHJveHkoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9LCB0aGlzKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGF0OiBmdW5jdGlvbihpbmRleCkge1xuXHQgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXNbaW5kZXhdO1xuXG5cdCAgICAgICAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiB0aGlzLnR5cGUpKSB7XG5cdCAgICAgICAgICAgICAgICBpdGVtID0gdGhpc1tpbmRleF0gPSB0aGlzLndyYXAoaXRlbSwgdGhpcy5fcGFyZW50KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGl0ZW0ucGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIGZ1bmN0aW9uIGV2ZW50SGFuZGxlcihjb250ZXh0LCB0eXBlLCBmaWVsZCwgcHJlZml4KSB7XG5cdCAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcblx0ICAgICAgICAgICAgdmFyIGV2ZW50ID0ge30sIGtleTtcblxuXHQgICAgICAgICAgICBmb3IgKGtleSBpbiBlKSB7XG5cdCAgICAgICAgICAgICAgICBldmVudFtrZXldID0gZVtrZXldO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHByZWZpeCkge1xuXHQgICAgICAgICAgICAgICAgZXZlbnQuZmllbGQgPSBmaWVsZCArIFwiLlwiICsgZS5maWVsZDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGV2ZW50LmZpZWxkID0gZmllbGQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAodHlwZSA9PSBDSEFOR0UgJiYgY29udGV4dC5fbm90aWZ5Q2hhbmdlKSB7XG5cdCAgICAgICAgICAgICAgICBjb250ZXh0Ll9ub3RpZnlDaGFuZ2UoZXZlbnQpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgY29udGV4dC50cmlnZ2VyKHR5cGUsIGV2ZW50KTtcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgT2JzZXJ2YWJsZU9iamVjdCA9IE9ic2VydmFibGUuZXh0ZW5kKHtcblx0ICAgICAgICBpbml0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBtZW1iZXIsXG5cdCAgICAgICAgICAgICAgICBmaWVsZCxcblx0ICAgICAgICAgICAgICAgIHBhcmVudCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0O1xuXHQgICAgICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICBPYnNlcnZhYmxlLmZuLmluaXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuXG5cdCAgICAgICAgICAgIGZvciAoZmllbGQgaW4gdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIG1lbWJlciA9IHZhbHVlW2ZpZWxkXTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1iZXIgPT09IFwib2JqZWN0XCIgJiYgbWVtYmVyICYmICFtZW1iZXIuZ2V0VGltZSAmJiBmaWVsZC5jaGFyQXQoMCkgIT0gXCJfXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBtZW1iZXIgPSB0aGF0LndyYXAobWVtYmVyLCBmaWVsZCwgcGFyZW50KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdGhhdFtmaWVsZF0gPSBtZW1iZXI7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGF0LnVpZCA9IGtlbmRvLmd1aWQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgc2hvdWxkU2VyaWFsaXplOiBmdW5jdGlvbihmaWVsZCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNPd25Qcm9wZXJ0eShmaWVsZCkgJiYgZmllbGQgIT09IFwiX2hhbmRsZXJzXCIgJiYgZmllbGQgIT09IFwiX2V2ZW50c1wiICYmIHR5cGVvZiB0aGlzW2ZpZWxkXSAhPT0gRlVOQ1RJT04gJiYgZmllbGQgIT09IFwidWlkXCI7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGZvckVhY2g6IGZ1bmN0aW9uKGYpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRTZXJpYWxpemUoaSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmKHRoaXNbaV0sIGkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fSwgdmFsdWUsIGZpZWxkO1xuXG5cdCAgICAgICAgICAgIGZvciAoZmllbGQgaW4gdGhpcykge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkU2VyaWFsaXplKGZpZWxkKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpc1tmaWVsZF07XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYnNlcnZhYmxlT2JqZWN0IHx8IHZhbHVlIGluc3RhbmNlb2YgT2JzZXJ2YWJsZUFycmF5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ZpZWxkXSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbihmaWVsZCkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIHJlc3VsdDtcblxuXHQgICAgICAgICAgICB0aGF0LnRyaWdnZXIoR0VULCB7IGZpZWxkOiBmaWVsZCB9KTtcblxuXHQgICAgICAgICAgICBpZiAoZmllbGQgPT09IFwidGhpc1wiKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGF0O1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0ga2VuZG8uZ2V0dGVyKGZpZWxkLCB0cnVlKSh0aGF0KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9zZXQ6IGZ1bmN0aW9uKGZpZWxkLCB2YWx1ZSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciBjb21wb3NpdGUgPSBmaWVsZC5pbmRleE9mKFwiLlwiKSA+PSAwO1xuXG5cdCAgICAgICAgICAgIGlmIChjb21wb3NpdGUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwYXRocyA9IGZpZWxkLnNwbGl0KFwiLlwiKSxcblx0ICAgICAgICAgICAgICAgICAgICBwYXRoID0gXCJcIjtcblxuXHQgICAgICAgICAgICAgICAgd2hpbGUgKHBhdGhzLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwYXRoICs9IHBhdGhzLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IGtlbmRvLmdldHRlcihwYXRoLCB0cnVlKSh0aGF0KTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgT2JzZXJ2YWJsZU9iamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvYmouc2V0KHBhdGhzLmpvaW4oXCIuXCIpLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wb3NpdGU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHBhdGggKz0gXCIuXCI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBrZW5kby5zZXR0ZXIoZmllbGQpKHRoYXQsIHZhbHVlKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY29tcG9zaXRlO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uKGZpZWxkLCB2YWx1ZSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBpc1NldFByZXZlbnRlZCA9IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgY29tcG9zaXRlID0gZmllbGQuaW5kZXhPZihcIi5cIikgPj0gMCxcblx0ICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBrZW5kby5nZXR0ZXIoZmllbGQsIHRydWUpKHRoYXQpO1xuXG5cdCAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSB2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBPYnNlcnZhYmxlICYmIHRoaXMuX2hhbmRsZXJzW2ZpZWxkXSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1tmaWVsZF0uZ2V0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudC51bmJpbmQoR0VULCB0aGlzLl9oYW5kbGVyc1tmaWVsZF0uZ2V0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgY3VycmVudC51bmJpbmQoQ0hBTkdFLCB0aGlzLl9oYW5kbGVyc1tmaWVsZF0uY2hhbmdlKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaXNTZXRQcmV2ZW50ZWQgPSB0aGF0LnRyaWdnZXIoXCJzZXRcIiwgeyBmaWVsZDogZmllbGQsIHZhbHVlOiB2YWx1ZSB9KTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKCFpc1NldFByZXZlbnRlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghY29tcG9zaXRlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhhdC53cmFwKHZhbHVlLCBmaWVsZCwgZnVuY3Rpb24oKSB7IHJldHVybiB0aGF0OyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGF0Ll9zZXQoZmllbGQsIHZhbHVlKSB8fCBmaWVsZC5pbmRleE9mKFwiKFwiKSA+PSAwIHx8IGZpZWxkLmluZGV4T2YoXCJbXCIpID49IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC50cmlnZ2VyKENIQU5HRSwgeyBmaWVsZDogZmllbGQgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGlzU2V0UHJldmVudGVkO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBwYXJlbnQ6IG5vb3AsXG5cblx0ICAgICAgICB3cmFwOiBmdW5jdGlvbihvYmplY3QsIGZpZWxkLCBwYXJlbnQpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgZ2V0O1xuXHQgICAgICAgICAgICB2YXIgY2hhbmdlO1xuXHQgICAgICAgICAgICB2YXIgdHlwZSA9IHRvU3RyaW5nLmNhbGwob2JqZWN0KTtcblxuXHQgICAgICAgICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgKHR5cGUgPT09IFwiW29iamVjdCBPYmplY3RdXCIgfHwgdHlwZSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGlzT2JzZXJ2YWJsZUFycmF5ID0gb2JqZWN0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZUFycmF5O1xuXHQgICAgICAgICAgICAgICAgdmFyIGlzRGF0YVNvdXJjZSA9IG9iamVjdCBpbnN0YW5jZW9mIERhdGFTb3VyY2U7XG5cblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcIltvYmplY3QgT2JqZWN0XVwiICYmICFpc0RhdGFTb3VyY2UgJiYgIWlzT2JzZXJ2YWJsZUFycmF5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEob2JqZWN0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZU9iamVjdCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0ID0gbmV3IE9ic2VydmFibGVPYmplY3Qob2JqZWN0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBnZXQgPSBldmVudEhhbmRsZXIodGhhdCwgR0VULCBmaWVsZCwgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmJpbmQoR0VULCBnZXQpO1xuXHQgICAgICAgICAgICAgICAgICAgIGNoYW5nZSA9IGV2ZW50SGFuZGxlcih0aGF0LCBDSEFOR0UsIGZpZWxkLCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICBvYmplY3QuYmluZChDSEFOR0UsIGNoYW5nZSk7XG5cblx0ICAgICAgICAgICAgICAgICAgICB0aGF0Ll9oYW5kbGVyc1tmaWVsZF0gPSB7IGdldDogZ2V0LCBjaGFuZ2U6IGNoYW5nZSB9O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIltvYmplY3QgQXJyYXldXCIgfHwgaXNPYnNlcnZhYmxlQXJyYXkgfHwgaXNEYXRhU291cmNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFpc09ic2VydmFibGVBcnJheSAmJiAhaXNEYXRhU291cmNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG5ldyBPYnNlcnZhYmxlQXJyYXkob2JqZWN0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgPSBldmVudEhhbmRsZXIodGhhdCwgQ0hBTkdFLCBmaWVsZCwgZmFsc2UpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmJpbmQoQ0hBTkdFLCBjaGFuZ2UpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC5faGFuZGxlcnNbZmllbGRdID0geyBjaGFuZ2U6IGNoYW5nZSB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBvYmplY3QucGFyZW50ID0gcGFyZW50O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gZXF1YWwoeCwgeSkge1xuXHQgICAgICAgIGlmICh4ID09PSB5KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciB4dHlwZSA9ICQudHlwZSh4KSwgeXR5cGUgPSAkLnR5cGUoeSksIGZpZWxkO1xuXG5cdCAgICAgICAgaWYgKHh0eXBlICE9PSB5dHlwZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHh0eXBlID09PSBcImRhdGVcIikge1xuXHQgICAgICAgICAgICByZXR1cm4geC5nZXRUaW1lKCkgPT09IHkuZ2V0VGltZSgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh4dHlwZSAhPT0gXCJvYmplY3RcIiAmJiB4dHlwZSAhPT0gXCJhcnJheVwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmb3IgKGZpZWxkIGluIHgpIHtcblx0ICAgICAgICAgICAgaWYgKCFlcXVhbCh4W2ZpZWxkXSwgeVtmaWVsZF0pKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHBhcnNlcnMgPSB7XG5cdCAgICAgICAgXCJudW1iZXJcIjogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gU1RSSU5HICYmIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwibnVsbFwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4ga2VuZG8ucGFyc2VGbG9hdCh2YWx1ZSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIFwiZGF0ZVwiOiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBTVFJJTkcgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gXCJudWxsXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBrZW5kby5wYXJzZURhdGUodmFsdWUpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBcImJvb2xlYW5cIjogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gU1RSSU5HKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gXCJudWxsXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IFwidHJ1ZVwiO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gISF2YWx1ZSA6IHZhbHVlO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBcInN0cmluZ1wiOiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBTVFJJTkcgJiYgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gXCJudWxsXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gKHZhbHVlICsgXCJcIikgOiB2YWx1ZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICB2YXIgZGVmYXVsdFZhbHVlcyA9IHtcblx0ICAgICAgICBcInN0cmluZ1wiOiBcIlwiLFxuXHQgICAgICAgIFwibnVtYmVyXCI6IDAsXG5cdCAgICAgICAgXCJkYXRlXCI6IG5ldyBEYXRlKCksXG5cdCAgICAgICAgXCJib29sZWFuXCI6IGZhbHNlLFxuXHQgICAgICAgIFwiZGVmYXVsdFwiOiBcIlwiXG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBnZXRGaWVsZEJ5TmFtZShvYmosIG5hbWUpIHtcblx0ICAgICAgICB2YXIgZmllbGQsXG5cdCAgICAgICAgICAgIGZpZWxkTmFtZTtcblxuXHQgICAgICAgIGZvciAoZmllbGROYW1lIGluIG9iaikge1xuXHQgICAgICAgICAgICBmaWVsZCA9IG9ialtmaWVsZE5hbWVdO1xuXHQgICAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChmaWVsZCkgJiYgZmllbGQuZmllbGQgJiYgZmllbGQuZmllbGQgPT09IG5hbWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZDtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZCA9PT0gbmFtZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZpZWxkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgTW9kZWwgPSBPYnNlcnZhYmxlT2JqZWN0LmV4dGVuZCh7XG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICQuaXNFbXB0eU9iamVjdChkYXRhKSkge1xuXHQgICAgICAgICAgICAgICAgZGF0YSA9ICQuZXh0ZW5kKHt9LCB0aGF0LmRlZmF1bHRzLCBkYXRhKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHRoYXQuX2luaXRpYWxpemVycykge1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHRoYXQuX2luaXRpYWxpemVycy5sZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHRoYXQuX2luaXRpYWxpemVyc1tpZHhdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtuYW1lXSA9IHRoYXQuZGVmYXVsdHNbbmFtZV0oKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBPYnNlcnZhYmxlT2JqZWN0LmZuLmluaXQuY2FsbCh0aGF0LCBkYXRhKTtcblxuXHQgICAgICAgICAgICB0aGF0LmRpcnR5ID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHRoYXQuZGlydHlGaWVsZHMgPSB7fTtcblxuXHQgICAgICAgICAgICBpZiAodGhhdC5pZEZpZWxkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGF0LmlkID0gdGhhdC5nZXQodGhhdC5pZEZpZWxkKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHRoYXQuaWQgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuaWQgPSB0aGF0Ll9kZWZhdWx0SWQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgc2hvdWxkU2VyaWFsaXplOiBmdW5jdGlvbihmaWVsZCkge1xuXHQgICAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZU9iamVjdC5mbi5zaG91bGRTZXJpYWxpemUuY2FsbCh0aGlzLCBmaWVsZCkgJiZcblx0ICAgICAgICAgICAgICAgIGZpZWxkICE9PSBcInVpZFwiICYmICEodGhpcy5pZEZpZWxkICE9PSBcImlkXCIgJiYgZmllbGQgPT09IFwiaWRcIikgJiZcblx0ICAgICAgICAgICAgICAgIGZpZWxkICE9PSBcImRpcnR5XCIgJiYgIGZpZWxkICE9PSBcImRpcnR5RmllbGRzXCIgJiYgZmllbGQgIT09IFwiX2FjY2Vzc29yc1wiO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfcGFyc2U6IGZ1bmN0aW9uKGZpZWxkLCB2YWx1ZSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBmaWVsZE5hbWUgPSBmaWVsZCxcblx0ICAgICAgICAgICAgICAgIGZpZWxkcyA9ICh0aGF0LmZpZWxkcyB8fCB7fSksXG5cdCAgICAgICAgICAgICAgICBwYXJzZTtcblxuXHQgICAgICAgICAgICBmaWVsZCA9IGZpZWxkc1tmaWVsZF07XG5cdCAgICAgICAgICAgIGlmICghZmllbGQpIHtcblx0ICAgICAgICAgICAgICAgIGZpZWxkID0gZ2V0RmllbGRCeU5hbWUoZmllbGRzLCBmaWVsZE5hbWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChmaWVsZCkge1xuXHQgICAgICAgICAgICAgICAgcGFyc2UgPSBmaWVsZC5wYXJzZTtcblx0ICAgICAgICAgICAgICAgIGlmICghcGFyc2UgJiYgZmllbGQudHlwZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHBhcnNlID0gcGFyc2Vyc1tmaWVsZC50eXBlLnRvTG93ZXJDYXNlKCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHBhcnNlID8gcGFyc2UodmFsdWUpIDogdmFsdWU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9ub3RpZnlDaGFuZ2U6IGZ1bmN0aW9uKGUpIHtcblx0ICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGUuYWN0aW9uO1xuXG5cdCAgICAgICAgICAgIGlmIChhY3Rpb24gPT0gXCJhZGRcIiB8fCBhY3Rpb24gPT0gXCJyZW1vdmVcIikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpcnR5RmllbGRzW2UuZmllbGRdID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBlZGl0YWJsZTogZnVuY3Rpb24oZmllbGQpIHtcblx0ICAgICAgICAgICAgZmllbGQgPSAodGhpcy5maWVsZHMgfHwge30pW2ZpZWxkXTtcblx0ICAgICAgICAgICAgcmV0dXJuIGZpZWxkID8gZmllbGQuZWRpdGFibGUgIT09IGZhbHNlIDogdHJ1ZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbihmaWVsZCwgdmFsdWUsIGluaXRpYXRvcikge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciBkaXJ0eSA9IHRoYXQuZGlydHk7XG5cblx0ICAgICAgICAgICAgaWYgKHRoYXQuZWRpdGFibGUoZmllbGQpKSB7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoYXQuX3BhcnNlKGZpZWxkLCB2YWx1ZSk7XG5cblx0ICAgICAgICAgICAgICAgIGlmICghZXF1YWwodmFsdWUsIHRoYXQuZ2V0KGZpZWxkKSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LmRpcnR5ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LmRpcnR5RmllbGRzW2ZpZWxkXSA9IHRydWU7XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoT2JzZXJ2YWJsZU9iamVjdC5mbi5zZXQuY2FsbCh0aGF0LCBmaWVsZCwgdmFsdWUsIGluaXRpYXRvcikgJiYgIWRpcnR5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZGlydHkgPSBkaXJ0eTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoYXQuZGlydHkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZGlydHlGaWVsZHNbZmllbGRdID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQudHJpZ2dlcihcImVxdWFsU2V0XCIsIHsgZmllbGQ6IGZpZWxkLCB2YWx1ZTogdmFsdWUgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYWNjZXB0OiBmdW5jdGlvbihkYXRhKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcblx0ICAgICAgICAgICAgICAgIHBhcmVudCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhhdDsgfSxcblx0ICAgICAgICAgICAgICAgIGZpZWxkO1xuXG5cdCAgICAgICAgICAgIGZvciAoZmllbGQgaW4gZGF0YSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0YVtmaWVsZF07XG5cblx0ICAgICAgICAgICAgICAgIGlmIChmaWVsZC5jaGFyQXQoMCkgIT0gXCJfXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoYXQud3JhcChkYXRhW2ZpZWxkXSwgZmllbGQsIHBhcmVudCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHRoYXQuX3NldChmaWVsZCwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHRoYXQuaWRGaWVsZCkge1xuXHQgICAgICAgICAgICAgICAgdGhhdC5pZCA9IHRoYXQuZ2V0KHRoYXQuaWRGaWVsZCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGF0LmRpcnR5ID0gZmFsc2U7XG5cdCAgICAgICAgICAgIHRoYXQuZGlydHlGaWVsZHMgPSB7fTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgaXNOZXc6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5pZCA9PT0gdGhpcy5fZGVmYXVsdElkO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBNb2RlbC5kZWZpbmUgPSBmdW5jdGlvbihiYXNlLCBvcHRpb25zKSB7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICBvcHRpb25zID0gYmFzZTtcblx0ICAgICAgICAgICAgYmFzZSA9IE1vZGVsO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBtb2RlbCxcblx0ICAgICAgICAgICAgcHJvdG8gPSBleHRlbmQoeyBkZWZhdWx0czoge30gfSwgb3B0aW9ucyksXG5cdCAgICAgICAgICAgIG5hbWUsXG5cdCAgICAgICAgICAgIGZpZWxkLFxuXHQgICAgICAgICAgICB0eXBlLFxuXHQgICAgICAgICAgICB2YWx1ZSxcblx0ICAgICAgICAgICAgaWR4LFxuXHQgICAgICAgICAgICBsZW5ndGgsXG5cdCAgICAgICAgICAgIGZpZWxkcyA9IHt9LFxuXHQgICAgICAgICAgICBvcmlnaW5hbE5hbWUsXG5cdCAgICAgICAgICAgIGlkID0gcHJvdG8uaWQsXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uRmllbGRzID0gW107XG5cblx0ICAgICAgICBpZiAoaWQpIHtcblx0ICAgICAgICAgICAgcHJvdG8uaWRGaWVsZCA9IGlkO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChwcm90by5pZCkge1xuXHQgICAgICAgICAgICBkZWxldGUgcHJvdG8uaWQ7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGlkKSB7XG5cdCAgICAgICAgICAgIHByb3RvLmRlZmF1bHRzW2lkXSA9IHByb3RvLl9kZWZhdWx0SWQgPSBcIlwiO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmICh0b1N0cmluZy5jYWxsKHByb3RvLmZpZWxkcykgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuXHQgICAgICAgICAgICBmb3IgKGlkeCA9IDAsIGxlbmd0aCA9IHByb3RvLmZpZWxkcy5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgICAgIGZpZWxkID0gcHJvdG8uZmllbGRzW2lkeF07XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpZWxkID09PSBTVFJJTkcpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmaWVsZHNbZmllbGRdID0ge307XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLmZpZWxkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZmllbGRzW2ZpZWxkLmZpZWxkXSA9IGZpZWxkO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHByb3RvLmZpZWxkcyA9IGZpZWxkcztcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmb3IgKG5hbWUgaW4gcHJvdG8uZmllbGRzKSB7XG5cdCAgICAgICAgICAgIGZpZWxkID0gcHJvdG8uZmllbGRzW25hbWVdO1xuXHQgICAgICAgICAgICB0eXBlID0gZmllbGQudHlwZSB8fCBcImRlZmF1bHRcIjtcblx0ICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuXHQgICAgICAgICAgICBvcmlnaW5hbE5hbWUgPSBuYW1lO1xuXG5cdCAgICAgICAgICAgIG5hbWUgPSB0eXBlb2YgKGZpZWxkLmZpZWxkKSA9PT0gU1RSSU5HID8gZmllbGQuZmllbGQgOiBuYW1lO1xuXG5cdCAgICAgICAgICAgIGlmICghZmllbGQubnVsbGFibGUpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gcHJvdG8uZGVmYXVsdHNbb3JpZ2luYWxOYW1lICE9PSBuYW1lID8gb3JpZ2luYWxOYW1lIDogbmFtZV0gPSBmaWVsZC5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCA/IGZpZWxkLmRlZmF1bHRWYWx1ZSA6IGRlZmF1bHRWYWx1ZXNbdHlwZS50b0xvd2VyQ2FzZSgpXTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25GaWVsZHMucHVzaChuYW1lKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmIChvcHRpb25zLmlkID09PSBuYW1lKSB7XG5cdCAgICAgICAgICAgICAgICBwcm90by5fZGVmYXVsdElkID0gdmFsdWU7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBwcm90by5kZWZhdWx0c1tvcmlnaW5hbE5hbWUgIT09IG5hbWUgPyBvcmlnaW5hbE5hbWUgOiBuYW1lXSA9IHZhbHVlO1xuXG5cdCAgICAgICAgICAgIGZpZWxkLnBhcnNlID0gZmllbGQucGFyc2UgfHwgcGFyc2Vyc1t0eXBlXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoZnVuY3Rpb25GaWVsZHMubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICBwcm90by5faW5pdGlhbGl6ZXJzID0gZnVuY3Rpb25GaWVsZHM7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgbW9kZWwgPSBiYXNlLmV4dGVuZChwcm90byk7XG5cdCAgICAgICAgbW9kZWwuZGVmaW5lID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgICAgICAgICAgICByZXR1cm4gTW9kZWwuZGVmaW5lKG1vZGVsLCBvcHRpb25zKTtcblx0ICAgICAgICB9O1xuXG5cdCAgICAgICAgaWYgKHByb3RvLmZpZWxkcykge1xuXHQgICAgICAgICAgICBtb2RlbC5maWVsZHMgPSBwcm90by5maWVsZHM7XG5cdCAgICAgICAgICAgIG1vZGVsLmlkRmllbGQgPSBwcm90by5pZEZpZWxkO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBtb2RlbDtcblx0ICAgIH07XG5cblx0ICAgIHZhciBDb21wYXJlciA9IHtcblx0ICAgICAgICBzZWxlY3RvcjogZnVuY3Rpb24oZmllbGQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZmllbGQpID8gZmllbGQgOiBnZXR0ZXIoZmllbGQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjb21wYXJlOiBmdW5jdGlvbihmaWVsZCkge1xuXHQgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yKGZpZWxkKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG5cdCAgICAgICAgICAgICAgICBhID0gc2VsZWN0b3IoYSk7XG5cdCAgICAgICAgICAgICAgICBiID0gc2VsZWN0b3IoYik7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChhID09IG51bGwgJiYgYiA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChhID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChiID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKGEubG9jYWxlQ29tcGFyZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmxvY2FsZUNvbXBhcmUoYik7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBhID4gYiA/IDEgOiAoYSA8IGIgPyAtMSA6IDApO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uKHNvcnQpIHtcblx0ICAgICAgICAgICAgdmFyIGNvbXBhcmUgPSBzb3J0LmNvbXBhcmUgfHwgdGhpcy5jb21wYXJlKHNvcnQuZmllbGQpO1xuXG5cdCAgICAgICAgICAgIGlmIChzb3J0LmRpciA9PSBcImRlc2NcIikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZShiLCBhLCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gY29tcGFyZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY29tYmluZTogZnVuY3Rpb24oY29tcGFyZXJzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZXJzWzBdKGEsIGIpLFxuXHQgICAgICAgICAgICAgICAgICAgIGlkeCxcblx0ICAgICAgICAgICAgICAgICAgICBsZW5ndGg7XG5cblx0ICAgICAgICAgICAgICAgIGZvciAoaWR4ID0gMSwgbGVuZ3RoID0gY29tcGFyZXJzLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHggKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgfHwgY29tcGFyZXJzW2lkeF0oYSwgYik7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgdmFyIFN0YWJsZUNvbXBhcmVyID0gZXh0ZW5kKHt9LCBDb21wYXJlciwge1xuXHQgICAgICAgIGFzYzogZnVuY3Rpb24oZmllbGQpIHtcblx0ICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcihmaWVsZCk7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlQSA9IHNlbGVjdG9yKGEpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlQiA9IHNlbGVjdG9yKGIpO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWVBICYmIHZhbHVlQS5nZXRUaW1lICYmIHZhbHVlQiAmJiB2YWx1ZUIuZ2V0VGltZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlQSA9IHZhbHVlQS5nZXRUaW1lKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWVCID0gdmFsdWVCLmdldFRpbWUoKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlQSA9PT0gdmFsdWVCKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuX19wb3NpdGlvbiAtIGIuX19wb3NpdGlvbjtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlQSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWVCID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlQS5sb2NhbGVDb21wYXJlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlQS5sb2NhbGVDb21wYXJlKHZhbHVlQik7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZUEgPiB2YWx1ZUIgPyAxIDogLTE7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRlc2M6IGZ1bmN0aW9uKGZpZWxkKSB7XG5cdCAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IoZmllbGQpO1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZUEgPSBzZWxlY3RvcihhKTtcblx0ICAgICAgICAgICAgICAgIHZhciB2YWx1ZUIgPSBzZWxlY3RvcihiKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlQSAmJiB2YWx1ZUEuZ2V0VGltZSAmJiB2YWx1ZUIgJiYgdmFsdWVCLmdldFRpbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZUEgPSB2YWx1ZUEuZ2V0VGltZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlQiA9IHZhbHVlQi5nZXRUaW1lKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZUEgPT09IHZhbHVlQikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLl9fcG9zaXRpb24gLSBiLl9fcG9zaXRpb247XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZUEgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAodmFsdWVCID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZUIubG9jYWxlQ29tcGFyZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZUIubG9jYWxlQ29tcGFyZSh2YWx1ZUEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVBIDwgdmFsdWVCID8gMSA6IC0xO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgY3JlYXRlOiBmdW5jdGlvbihzb3J0KSB7XG5cdCAgICAgICAgICAgcmV0dXJuIHRoaXNbc29ydC5kaXJdKHNvcnQuZmllbGQpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBtYXAgPSBmdW5jdGlvbiAoYXJyYXksIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgdmFyIGlkeCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLCByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblxuXHQgICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICByZXN1bHRbaWR4XSA9IGNhbGxiYWNrKGFycmF5W2lkeF0sIGlkeCwgYXJyYXkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXG5cdCAgICB2YXIgb3BlcmF0b3JzID0gKGZ1bmN0aW9uKCl7XG5cblx0ICAgICAgICBmdW5jdGlvbiBxdW90ZShzdHIpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHIgPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL1tcXHJcXG5dKy9nLCBcIlwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RyKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmdW5jdGlvbiB0ZXh0T3AoaW1wbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYSwgYiwgaWdub3JlKSB7XG5cdCAgICAgICAgICAgICAgICBiICs9IFwiXCI7XG5cdCAgICAgICAgICAgICAgICBpZiAoaWdub3JlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYSA9IFwiKFwiICsgYSArIFwiIHx8ICcnKS50b1N0cmluZygpLnRvTG93ZXJDYXNlKClcIjtcblx0ICAgICAgICAgICAgICAgICAgICBiID0gYi50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGltcGwoYSwgcXVvdGUoYiksIGlnbm9yZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gb3BlcmF0b3Iob3AsIGEsIGIsIGlnbm9yZSkge1xuXHQgICAgICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGIgPT09IFNUUklORykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkYXRlID0gZGF0ZVJlZ0V4cC5leGVjKGIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBuZXcgRGF0ZSgrZGF0ZVsxXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpZ25vcmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHF1b3RlKGIudG9Mb3dlckNhc2UoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBcIigoXCIgKyBhICsgXCIgfHwgJycpKycnKS50b0xvd2VyQ2FzZSgpXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHF1b3RlKGIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKGIuZ2V0VGltZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vYiBsb29rcyBsaWtlIGEgRGF0ZVxuXHQgICAgICAgICAgICAgICAgICAgIGEgPSBcIihcIiArIGEgKyBcIiYmXCIgKyBhICsgXCIuZ2V0VGltZT9cIiArIGEgKyBcIi5nZXRUaW1lKCk6XCIgKyBhICsgXCIpXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgYiA9IGIuZ2V0VGltZSgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGEgKyBcIiBcIiArIG9wICsgXCIgXCIgKyBiO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIGdldE1hdGNoUmVnZXhwKHBhdHRlcm4pIHtcblx0ICAgICAgICAgICAgLy8gdGFrZSBhIHBhdHRlcm4sIGFzIHN1cHBvcnRlZCBieSBFeGNlbCBtYXRjaCBmaWx0ZXIsIGFuZFxuXHQgICAgICAgICAgICAvLyBjb252ZXJ0IGl0IHRvIHRoZSBlcXVpdmFsZW50IEpTIHJlZ3VsYXIgZXhwcmVzc2lvbi5cblx0ICAgICAgICAgICAgLy8gRXhjZWwgcGF0dGVybnMgc3VwcG9ydDpcblx0ICAgICAgICAgICAgLy9cblx0ICAgICAgICAgICAgLy8gICAqIC0gbWF0Y2ggYW55IHNlcXVlbmNlIG9mIGNoYXJhY3RlcnNcblx0ICAgICAgICAgICAgLy8gICA/IC0gbWF0Y2ggYSBzaW5nbGUgY2hhcmFjdGVyXG5cdCAgICAgICAgICAgIC8vXG5cdCAgICAgICAgICAgIC8vIHRvIG1hdGNoIGEgbGl0ZXJhbCAqIG9yID8sIHRoZXkgbXVzdCBiZSBwcmVmaXhlZCBieSBhIHRpbGRlICh+KVxuXHQgICAgICAgICAgICBmb3IgKHZhciByeCA9IFwiL15cIiwgZXNjID0gZmFsc2UsIGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7ICsraSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGNoID0gcGF0dGVybi5jaGFyQXQoaSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXNjKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcnggKz0gXCJcXFxcXCIgKyBjaDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCJ+XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBlc2MgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PSBcIipcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJ4ICs9IFwiLipcIjtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT0gXCI/XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByeCArPSBcIi5cIjtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIuK14kKClbXXt9fFxcXFwvXFxuXFxyXFx1MjAyOFxcdTIwMjlcXHhBMFwiLmluZGV4T2YoY2gpID49IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICByeCArPSBcIlxcXFxcIiArIGNoO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByeCArPSBjaDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVzYyA9IGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByeCArIFwiJC9cIjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBxdW90ZTogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5nZXRUaW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibmV3IERhdGUoXCIgKyB2YWx1ZS5nZXRUaW1lKCkgKyBcIilcIjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGVxOiBmdW5jdGlvbihhLCBiLCBpZ25vcmUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBvcGVyYXRvcihcIj09XCIsIGEsIGIsIGlnbm9yZSk7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIG5lcTogZnVuY3Rpb24oYSwgYiwgaWdub3JlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IoXCIhPVwiLCBhLCBiLCBpZ25vcmUpO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBndDogZnVuY3Rpb24oYSwgYiwgaWdub3JlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IoXCI+XCIsIGEsIGIsIGlnbm9yZSk7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGd0ZTogZnVuY3Rpb24oYSwgYiwgaWdub3JlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IoXCI+PVwiLCBhLCBiLCBpZ25vcmUpO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBsdDogZnVuY3Rpb24oYSwgYiwgaWdub3JlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IoXCI8XCIsIGEsIGIsIGlnbm9yZSk7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGx0ZTogZnVuY3Rpb24oYSwgYiwgaWdub3JlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IoXCI8PVwiLCBhLCBiLCBpZ25vcmUpO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBzdGFydHN3aXRoOiB0ZXh0T3AoZnVuY3Rpb24oYSwgYikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGEgKyBcIi5sYXN0SW5kZXhPZihcIiArIGIgKyBcIiwgMCkgPT0gMFwiO1xuXHQgICAgICAgICAgICB9KSxcblx0ICAgICAgICAgICAgZG9lc25vdHN0YXJ0d2l0aDogdGV4dE9wKGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhICsgXCIubGFzdEluZGV4T2YoXCIgKyBiICsgXCIsIDApID09IC0xXCI7XG5cdCAgICAgICAgICAgIH0pLFxuXHQgICAgICAgICAgICBlbmRzd2l0aDogdGV4dE9wKGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBuID0gYiA/IGIubGVuZ3RoIC0gMiA6IDA7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYSArIFwiLmluZGV4T2YoXCIgKyBiICsgXCIsIFwiICsgYSArIFwiLmxlbmd0aCAtIFwiICsgbiArIFwiKSA+PSAwXCI7XG5cdCAgICAgICAgICAgIH0pLFxuXHQgICAgICAgICAgICBkb2Vzbm90ZW5kd2l0aDogdGV4dE9wKGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBuID0gYiA/IGIubGVuZ3RoIC0gMiA6IDA7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYSArIFwiLmluZGV4T2YoXCIgKyBiICsgXCIsIFwiICsgYSArIFwiLmxlbmd0aCAtIFwiICsgbiArIFwiKSA8IDBcIjtcblx0ICAgICAgICAgICAgfSksXG5cdCAgICAgICAgICAgIGNvbnRhaW5zOiB0ZXh0T3AoZnVuY3Rpb24oYSwgYikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGEgKyBcIi5pbmRleE9mKFwiICsgYiArIFwiKSA+PSAwXCI7XG5cdCAgICAgICAgICAgIH0pLFxuXHQgICAgICAgICAgICBkb2Vzbm90Y29udGFpbjogdGV4dE9wKGZ1bmN0aW9uKGEsIGIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBhICsgXCIuaW5kZXhPZihcIiArIGIgKyBcIikgPT0gLTFcIjtcblx0ICAgICAgICAgICAgfSksXG5cdCAgICAgICAgICAgIG1hdGNoZXM6IHRleHRPcChmdW5jdGlvbihhLCBiKXtcblx0ICAgICAgICAgICAgICAgIGIgPSBiLnN1YnN0cmluZygxLCBiLmxlbmd0aCAtIDEpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGdldE1hdGNoUmVnZXhwKGIpICsgXCIudGVzdChcIiArIGEgKyBcIilcIjtcblx0ICAgICAgICAgICAgfSksXG5cdCAgICAgICAgICAgIGRvZXNub3RtYXRjaDogdGV4dE9wKGZ1bmN0aW9uKGEsIGIpe1xuXHQgICAgICAgICAgICAgICAgYiA9IGIuc3Vic3RyaW5nKDEsIGIubGVuZ3RoIC0gMSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gXCIhXCIgKyBnZXRNYXRjaFJlZ2V4cChiKSArIFwiLnRlc3QoXCIgKyBhICsgXCIpXCI7XG5cdCAgICAgICAgICAgIH0pLFxuXHQgICAgICAgICAgICBpc2VtcHR5OiBmdW5jdGlvbihhKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYSArIFwiID09PSAnJ1wiO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBpc25vdGVtcHR5OiBmdW5jdGlvbihhKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gYSArIFwiICE9PSAnJ1wiO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBpc251bGw6IGZ1bmN0aW9uKGEpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBcIihcIiArIGEgKyBcIiA9PSBudWxsKVwiO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBpc25vdG51bGw6IGZ1bmN0aW9uKGEpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBcIihcIiArIGEgKyBcIiAhPSBudWxsKVwiO1xuXHQgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICBpc251bGxvcmVtcHR5OiBmdW5jdGlvbihhKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gXCIoXCIgKyBhICsgXCIgPT09IG51bGwpIHx8IChcIiArIGEgKyBcIiA9PT0gJycpXCI7XG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIGlzbm90bnVsbG9yZW1wdHk6IGZ1bmN0aW9uKGEpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBcIihcIiArIGEgKyBcIiAhPT0gbnVsbCkgJiYgKFwiICsgYSArIFwiICE9PSAnJylcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9KSgpO1xuXG5cdCAgICBmdW5jdGlvbiBRdWVyeShkYXRhKSB7XG5cdCAgICAgICAgdGhpcy5kYXRhID0gZGF0YSB8fCBbXTtcblx0ICAgIH1cblxuXHQgICAgUXVlcnkuZmlsdGVyRXhwciA9IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcblx0ICAgICAgICB2YXIgZXhwcmVzc2lvbnMgPSBbXSxcblx0ICAgICAgICAgICAgbG9naWMgPSB7IGFuZDogXCIgJiYgXCIsIG9yOiBcIiB8fCBcIiB9LFxuXHQgICAgICAgICAgICBpZHgsXG5cdCAgICAgICAgICAgIGxlbmd0aCxcblx0ICAgICAgICAgICAgZmlsdGVyLFxuXHQgICAgICAgICAgICBleHByLFxuXHQgICAgICAgICAgICBmaWVsZEZ1bmN0aW9ucyA9IFtdLFxuXHQgICAgICAgICAgICBvcGVyYXRvckZ1bmN0aW9ucyA9IFtdLFxuXHQgICAgICAgICAgICBmaWVsZCxcblx0ICAgICAgICAgICAgb3BlcmF0b3IsXG5cdCAgICAgICAgICAgIGZpbHRlcnMgPSBleHByZXNzaW9uLmZpbHRlcnM7XG5cblx0ICAgICAgICBmb3IgKGlkeCA9IDAsIGxlbmd0aCA9IGZpbHRlcnMubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgIGZpbHRlciA9IGZpbHRlcnNbaWR4XTtcblx0ICAgICAgICAgICAgZmllbGQgPSBmaWx0ZXIuZmllbGQ7XG5cdCAgICAgICAgICAgIG9wZXJhdG9yID0gZmlsdGVyLm9wZXJhdG9yO1xuXG5cdCAgICAgICAgICAgIGlmIChmaWx0ZXIuZmlsdGVycykge1xuXHQgICAgICAgICAgICAgICAgZXhwciA9IFF1ZXJ5LmZpbHRlckV4cHIoZmlsdGVyKTtcblx0ICAgICAgICAgICAgICAgIC8vTmVzdGVkIGZ1bmN0aW9uIGZpZWxkcyBvciBvcGVyYXRvcnMgLSB1cGRhdGUgdGhlaXIgaW5kZXggZS5nLiBfX29bMF0gLT4gX19vWzFdXG5cdCAgICAgICAgICAgICAgICBmaWx0ZXIgPSBleHByLmV4cHJlc3Npb25cblx0ICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9fX29cXFsoXFxkKylcXF0vZywgZnVuY3Rpb24obWF0Y2gsIGluZGV4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAraW5kZXg7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiX19vW1wiICsgKG9wZXJhdG9yRnVuY3Rpb25zLmxlbmd0aCArIGluZGV4KSArIFwiXVwiO1xuXHQgICAgICAgICAgICAgICAgfSlcblx0ICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9fX2ZcXFsoXFxkKylcXF0vZywgZnVuY3Rpb24obWF0Y2gsIGluZGV4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5kZXggPSAraW5kZXg7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiX19mW1wiICsgKGZpZWxkRnVuY3Rpb25zLmxlbmd0aCArIGluZGV4KSArIFwiXVwiO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgICAgIG9wZXJhdG9yRnVuY3Rpb25zLnB1c2guYXBwbHkob3BlcmF0b3JGdW5jdGlvbnMsIGV4cHIub3BlcmF0b3JzKTtcblx0ICAgICAgICAgICAgICAgIGZpZWxkRnVuY3Rpb25zLnB1c2guYXBwbHkoZmllbGRGdW5jdGlvbnMsIGV4cHIuZmllbGRzKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGQgPT09IEZVTkNUSU9OKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IFwiX19mW1wiICsgZmllbGRGdW5jdGlvbnMubGVuZ3RoICtcIl0oZClcIjtcblx0ICAgICAgICAgICAgICAgICAgICBmaWVsZEZ1bmN0aW9ucy5wdXNoKGZpZWxkKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZXhwciA9IGtlbmRvLmV4cHIoZmllbGQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wZXJhdG9yID09PSBGVU5DVElPTikge1xuXHQgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IFwiX19vW1wiICsgb3BlcmF0b3JGdW5jdGlvbnMubGVuZ3RoICsgXCJdKFwiICsgZXhwciArIFwiLCBcIiArIG9wZXJhdG9ycy5xdW90ZShmaWx0ZXIudmFsdWUpICsgXCIpXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3JGdW5jdGlvbnMucHVzaChvcGVyYXRvcik7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IG9wZXJhdG9yc1sob3BlcmF0b3IgfHwgXCJlcVwiKS50b0xvd2VyQ2FzZSgpXShleHByLCBmaWx0ZXIudmFsdWUsIGZpbHRlci5pZ25vcmVDYXNlICE9PSB1bmRlZmluZWQ/IGZpbHRlci5pZ25vcmVDYXNlIDogdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBleHByZXNzaW9ucy5wdXNoKGZpbHRlcik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuICB7IGV4cHJlc3Npb246IFwiKFwiICsgZXhwcmVzc2lvbnMuam9pbihsb2dpY1tleHByZXNzaW9uLmxvZ2ljXSkgKyBcIilcIiwgZmllbGRzOiBmaWVsZEZ1bmN0aW9ucywgb3BlcmF0b3JzOiBvcGVyYXRvckZ1bmN0aW9ucyB9O1xuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gbm9ybWFsaXplU29ydChmaWVsZCwgZGlyKSB7XG5cdCAgICAgICAgaWYgKGZpZWxkKSB7XG5cdCAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yID0gdHlwZW9mIGZpZWxkID09PSBTVFJJTkcgPyB7IGZpZWxkOiBmaWVsZCwgZGlyOiBkaXIgfSA6IGZpZWxkLFxuXHQgICAgICAgICAgICBkZXNjcmlwdG9ycyA9IGlzQXJyYXkoZGVzY3JpcHRvcikgPyBkZXNjcmlwdG9yIDogKGRlc2NyaXB0b3IgIT09IHVuZGVmaW5lZCA/IFtkZXNjcmlwdG9yXSA6IFtdKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gZ3JlcChkZXNjcmlwdG9ycywgZnVuY3Rpb24oZCkgeyByZXR1cm4gISFkLmRpcjsgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgb3BlcmF0b3JNYXAgPSB7XG5cdCAgICAgICAgXCI9PVwiOiBcImVxXCIsXG5cdCAgICAgICAgZXF1YWxzOiBcImVxXCIsXG5cdCAgICAgICAgaXNlcXVhbHRvOiBcImVxXCIsXG5cdCAgICAgICAgZXF1YWx0bzogXCJlcVwiLFxuXHQgICAgICAgIGVxdWFsOiBcImVxXCIsXG5cdCAgICAgICAgXCIhPVwiOiBcIm5lcVwiLFxuXHQgICAgICAgIG5lOiBcIm5lcVwiLFxuXHQgICAgICAgIG5vdGVxdWFsczogXCJuZXFcIixcblx0ICAgICAgICBpc25vdGVxdWFsdG86IFwibmVxXCIsXG5cdCAgICAgICAgbm90ZXF1YWx0bzogXCJuZXFcIixcblx0ICAgICAgICBub3RlcXVhbDogXCJuZXFcIixcblx0ICAgICAgICBcIjxcIjogXCJsdFwiLFxuXHQgICAgICAgIGlzbGVzc3RoYW46IFwibHRcIixcblx0ICAgICAgICBsZXNzdGhhbjogXCJsdFwiLFxuXHQgICAgICAgIGxlc3M6IFwibHRcIixcblx0ICAgICAgICBcIjw9XCI6IFwibHRlXCIsXG5cdCAgICAgICAgbGU6IFwibHRlXCIsXG5cdCAgICAgICAgaXNsZXNzdGhhbm9yZXF1YWx0bzogXCJsdGVcIixcblx0ICAgICAgICBsZXNzdGhhbmVxdWFsOiBcImx0ZVwiLFxuXHQgICAgICAgIFwiPlwiOiBcImd0XCIsXG5cdCAgICAgICAgaXNncmVhdGVydGhhbjogXCJndFwiLFxuXHQgICAgICAgIGdyZWF0ZXJ0aGFuOiBcImd0XCIsXG5cdCAgICAgICAgZ3JlYXRlcjogXCJndFwiLFxuXHQgICAgICAgIFwiPj1cIjogXCJndGVcIixcblx0ICAgICAgICBpc2dyZWF0ZXJ0aGFub3JlcXVhbHRvOiBcImd0ZVwiLFxuXHQgICAgICAgIGdyZWF0ZXJ0aGFuZXF1YWw6IFwiZ3RlXCIsXG5cdCAgICAgICAgZ2U6IFwiZ3RlXCIsXG5cdCAgICAgICAgbm90c3Vic3RyaW5nb2Y6IFwiZG9lc25vdGNvbnRhaW5cIixcblx0ICAgICAgICBpc251bGw6IFwiaXNudWxsXCIsXG5cdCAgICAgICAgaXNlbXB0eTogXCJpc2VtcHR5XCIsXG5cdCAgICAgICAgaXNub3RlbXB0eTogXCJpc25vdGVtcHR5XCJcblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9wZXJhdG9yKGV4cHJlc3Npb24pIHtcblx0ICAgICAgICB2YXIgaWR4LFxuXHQgICAgICAgIGxlbmd0aCxcblx0ICAgICAgICBmaWx0ZXIsXG5cdCAgICAgICAgb3BlcmF0b3IsXG5cdCAgICAgICAgZmlsdGVycyA9IGV4cHJlc3Npb24uZmlsdGVycztcblxuXHQgICAgICAgIGlmIChmaWx0ZXJzKSB7XG5cdCAgICAgICAgICAgIGZvciAoaWR4ID0gMCwgbGVuZ3RoID0gZmlsdGVycy5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgICAgIGZpbHRlciA9IGZpbHRlcnNbaWR4XTtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gZmlsdGVyLm9wZXJhdG9yO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAob3BlcmF0b3IgJiYgdHlwZW9mIG9wZXJhdG9yID09PSBTVFJJTkcpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmaWx0ZXIub3BlcmF0b3IgPSBvcGVyYXRvck1hcFtvcGVyYXRvci50b0xvd2VyQ2FzZSgpXSB8fCBvcGVyYXRvcjtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgbm9ybWFsaXplT3BlcmF0b3IoZmlsdGVyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gbm9ybWFsaXplRmlsdGVyKGV4cHJlc3Npb24pIHtcblx0ICAgICAgICBpZiAoZXhwcmVzc2lvbiAmJiAhaXNFbXB0eU9iamVjdChleHByZXNzaW9uKSkge1xuXHQgICAgICAgICAgICBpZiAoaXNBcnJheShleHByZXNzaW9uKSB8fCAhZXhwcmVzc2lvbi5maWx0ZXJzKSB7XG5cdCAgICAgICAgICAgICAgICBleHByZXNzaW9uID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2ljOiBcImFuZFwiLFxuXHQgICAgICAgICAgICAgICAgICAgIGZpbHRlcnM6IGlzQXJyYXkoZXhwcmVzc2lvbikgPyBleHByZXNzaW9uIDogW2V4cHJlc3Npb25dXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgbm9ybWFsaXplT3BlcmF0b3IoZXhwcmVzc2lvbik7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBRdWVyeS5ub3JtYWxpemVGaWx0ZXIgPSBub3JtYWxpemVGaWx0ZXI7XG5cblx0ICAgIGZ1bmN0aW9uIGNvbXBhcmVEZXNjcmlwdG9yKGYxLCBmMikge1xuXHQgICAgICAgIGlmIChmMS5sb2dpYyB8fCBmMi5sb2dpYykge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGYxLmZpZWxkID09PSBmMi5maWVsZCAmJiBmMS52YWx1ZSA9PT0gZjIudmFsdWUgJiYgZjEub3BlcmF0b3IgPT09IGYyLm9wZXJhdG9yO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBub3JtYWxpemVEZXNjcmlwdG9yKGZpbHRlcikge1xuXHQgICAgICAgIGZpbHRlciA9IGZpbHRlciB8fCB7fTtcblxuXHQgICAgICAgIGlmIChpc0VtcHR5T2JqZWN0KGZpbHRlcikpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHsgbG9naWM6IFwiYW5kXCIsIGZpbHRlcnM6IFtdIH07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZUZpbHRlcihmaWx0ZXIpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBmaWVsZENvbXBhcmVyKGEsIGIpIHtcblx0ICAgICAgICBpZiAoYi5sb2dpYyB8fCAoYS5maWVsZCA+IGIuZmllbGQpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAxO1xuXHQgICAgICAgIH0gZWxzZSBpZiAoYS5maWVsZCA8IGIuZmllbGQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiAwO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY29tcGFyZUZpbHRlcnMoZXhwcjEsIGV4cHIyKSB7XG5cdCAgICAgICAgZXhwcjEgPSBub3JtYWxpemVEZXNjcmlwdG9yKGV4cHIxKTtcblx0ICAgICAgICBleHByMiA9IG5vcm1hbGl6ZURlc2NyaXB0b3IoZXhwcjIpO1xuXG5cdCAgICAgICAgaWYgKGV4cHIxLmxvZ2ljICE9PSBleHByMi5sb2dpYykge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGYxLCBmMjtcblx0ICAgICAgICB2YXIgZmlsdGVyczEgPSAoZXhwcjEuZmlsdGVycyB8fCBbXSkuc2xpY2UoKTtcblx0ICAgICAgICB2YXIgZmlsdGVyczIgPSAoZXhwcjIuZmlsdGVycyB8fCBbXSkuc2xpY2UoKTtcblxuXHQgICAgICAgIGlmIChmaWx0ZXJzMS5sZW5ndGggIT09IGZpbHRlcnMyLmxlbmd0aCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZmlsdGVyczEgPSBmaWx0ZXJzMS5zb3J0KGZpZWxkQ29tcGFyZXIpO1xuXHQgICAgICAgIGZpbHRlcnMyID0gZmlsdGVyczIuc29ydChmaWVsZENvbXBhcmVyKTtcblxuXHQgICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGZpbHRlcnMxLmxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgZjEgPSBmaWx0ZXJzMVtpZHhdO1xuXHQgICAgICAgICAgICBmMiA9IGZpbHRlcnMyW2lkeF07XG5cblx0ICAgICAgICAgICAgaWYgKGYxLmxvZ2ljICYmIGYyLmxvZ2ljKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWNvbXBhcmVGaWx0ZXJzKGYxLCBmMikpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNvbXBhcmVEZXNjcmlwdG9yKGYxLCBmMikpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBRdWVyeS5jb21wYXJlRmlsdGVycyA9IGNvbXBhcmVGaWx0ZXJzO1xuXG5cdCAgICBmdW5jdGlvbiBub3JtYWxpemVBZ2dyZWdhdGUoZXhwcmVzc2lvbnMpIHtcblx0ICAgICAgICByZXR1cm4gaXNBcnJheShleHByZXNzaW9ucykgPyBleHByZXNzaW9ucyA6IFtleHByZXNzaW9uc107XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUdyb3VwKGZpZWxkLCBkaXIpIHtcblx0ICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHR5cGVvZiBmaWVsZCA9PT0gU1RSSU5HID8geyBmaWVsZDogZmllbGQsIGRpcjogZGlyIH0gOiBmaWVsZCxcblx0ICAgICAgICBkZXNjcmlwdG9ycyA9IGlzQXJyYXkoZGVzY3JpcHRvcikgPyBkZXNjcmlwdG9yIDogKGRlc2NyaXB0b3IgIT09IHVuZGVmaW5lZCA/IFtkZXNjcmlwdG9yXSA6IFtdKTtcblxuXHQgICAgICAgIHJldHVybiBtYXAoZGVzY3JpcHRvcnMsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHsgZmllbGQ6IGQuZmllbGQsIGRpcjogZC5kaXIgfHwgXCJhc2NcIiwgYWdncmVnYXRlczogZC5hZ2dyZWdhdGVzIH07IH0pO1xuXHQgICAgfVxuXG5cdCAgICBRdWVyeS5wcm90b3R5cGUgPSB7XG5cdCAgICAgICAgdG9BcnJheTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgcmFuZ2U6IGZ1bmN0aW9uKGluZGV4LCBjb3VudCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMuZGF0YS5zbGljZShpbmRleCwgaW5kZXggKyBjb3VudCkpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2tpcDogZnVuY3Rpb24gKGNvdW50KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgUXVlcnkodGhpcy5kYXRhLnNsaWNlKGNvdW50KSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB0YWtlOiBmdW5jdGlvbiAoY291bnQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLmRhdGEuc2xpY2UoMCwgY291bnQpKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNlbGVjdDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgUXVlcnkobWFwKHRoaXMuZGF0YSwgc2VsZWN0b3IpKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIG9yZGVyOiBmdW5jdGlvbihzZWxlY3RvciwgZGlyLCBpblBsYWNlKSB7XG5cdCAgICAgICAgICAgIHZhciBzb3J0ID0geyBkaXI6IGRpciB9O1xuXG5cdCAgICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xuXHQgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yLmNvbXBhcmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzb3J0LmNvbXBhcmUgPSBzZWxlY3Rvci5jb21wYXJlO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBzb3J0LmZpZWxkID0gc2VsZWN0b3I7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoaW5QbGFjZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWVyeSh0aGlzLmRhdGEuc29ydChDb21wYXJlci5jcmVhdGUoc29ydCkpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KHRoaXMuZGF0YS5zbGljZSgwKS5zb3J0KENvbXBhcmVyLmNyZWF0ZShzb3J0KSkpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgb3JkZXJCeTogZnVuY3Rpb24oc2VsZWN0b3IsIGluUGxhY2UpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JkZXIoc2VsZWN0b3IsIFwiYXNjXCIsIGluUGxhY2UpO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgb3JkZXJCeURlc2NlbmRpbmc6IGZ1bmN0aW9uKHNlbGVjdG9yLCBpblBsYWNlKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLm9yZGVyKHNlbGVjdG9yLCBcImRlc2NcIiwgaW5QbGFjZSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzb3J0OiBmdW5jdGlvbihmaWVsZCwgZGlyLCBjb21wYXJlciwgaW5QbGFjZSkge1xuXHQgICAgICAgICAgICB2YXIgaWR4LFxuXHQgICAgICAgICAgICBsZW5ndGgsXG5cdCAgICAgICAgICAgIGRlc2NyaXB0b3JzID0gbm9ybWFsaXplU29ydChmaWVsZCwgZGlyKSxcblx0ICAgICAgICAgICAgY29tcGFyZXJzID0gW107XG5cblx0ICAgICAgICAgICAgY29tcGFyZXIgPSBjb21wYXJlciB8fCBDb21wYXJlcjtcblxuXHQgICAgICAgICAgICBpZiAoZGVzY3JpcHRvcnMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKGlkeCA9IDAsIGxlbmd0aCA9IGRlc2NyaXB0b3JzLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbXBhcmVycy5wdXNoKGNvbXBhcmVyLmNyZWF0ZShkZXNjcmlwdG9yc1tpZHhdKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9yZGVyQnkoeyBjb21wYXJlOiBjb21wYXJlci5jb21iaW5lKGNvbXBhcmVycykgfSwgaW5QbGFjZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZmlsdGVyOiBmdW5jdGlvbihleHByZXNzaW9ucykge1xuXHQgICAgICAgICAgICB2YXIgaWR4LFxuXHQgICAgICAgICAgICBjdXJyZW50LFxuXHQgICAgICAgICAgICBsZW5ndGgsXG5cdCAgICAgICAgICAgIGNvbXBpbGVkLFxuXHQgICAgICAgICAgICBwcmVkaWNhdGUsXG5cdCAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEsXG5cdCAgICAgICAgICAgIGZpZWxkcyxcblx0ICAgICAgICAgICAgb3BlcmF0b3JzLFxuXHQgICAgICAgICAgICByZXN1bHQgPSBbXSxcblx0ICAgICAgICAgICAgZmlsdGVyO1xuXG5cdCAgICAgICAgICAgIGV4cHJlc3Npb25zID0gbm9ybWFsaXplRmlsdGVyKGV4cHJlc3Npb25zKTtcblxuXHQgICAgICAgICAgICBpZiAoIWV4cHJlc3Npb25zIHx8IGV4cHJlc3Npb25zLmZpbHRlcnMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGNvbXBpbGVkID0gUXVlcnkuZmlsdGVyRXhwcihleHByZXNzaW9ucyk7XG5cdCAgICAgICAgICAgIGZpZWxkcyA9IGNvbXBpbGVkLmZpZWxkcztcblx0ICAgICAgICAgICAgb3BlcmF0b3JzID0gY29tcGlsZWQub3BlcmF0b3JzO1xuXG5cdCAgICAgICAgICAgIHByZWRpY2F0ZSA9IGZpbHRlciA9IG5ldyBGdW5jdGlvbihcImQsIF9fZiwgX19vXCIsIFwicmV0dXJuIFwiICsgY29tcGlsZWQuZXhwcmVzc2lvbik7XG5cblx0ICAgICAgICAgICAgaWYgKGZpZWxkcy5sZW5ndGggfHwgb3BlcmF0b3JzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgZmlsdGVyID0gZnVuY3Rpb24oZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGUoZCwgZmllbGRzLCBvcGVyYXRvcnMpO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfVxuXG5cblx0ICAgICAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgY3VycmVudCA9IGRhdGFbaWR4XTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKGZpbHRlcihjdXJyZW50KSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShyZXN1bHQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBncm91cDogZnVuY3Rpb24oZGVzY3JpcHRvcnMsIGFsbERhdGEpIHtcblx0ICAgICAgICAgICAgZGVzY3JpcHRvcnMgPSAgbm9ybWFsaXplR3JvdXAoZGVzY3JpcHRvcnMgfHwgW10pO1xuXHQgICAgICAgICAgICBhbGxEYXRhID0gYWxsRGF0YSB8fCB0aGlzLmRhdGE7XG5cblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICByZXN1bHQgPSBuZXcgUXVlcnkodGhhdC5kYXRhKSxcblx0ICAgICAgICAgICAgZGVzY3JpcHRvcjtcblxuXHQgICAgICAgICAgICBpZiAoZGVzY3JpcHRvcnMubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IGRlc2NyaXB0b3JzWzBdO1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lmdyb3VwQnkoZGVzY3JpcHRvcikuc2VsZWN0KGZ1bmN0aW9uKGdyb3VwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBuZXcgUXVlcnkoYWxsRGF0YSkuZmlsdGVyKFsgeyBmaWVsZDogZ3JvdXAuZmllbGQsIG9wZXJhdG9yOiBcImVxXCIsIHZhbHVlOiBncm91cC52YWx1ZSwgaWdub3JlQ2FzZTogZmFsc2UgfSBdKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogZ3JvdXAuZmllbGQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBncm91cC52YWx1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IGRlc2NyaXB0b3JzLmxlbmd0aCA+IDEgPyBuZXcgUXVlcnkoZ3JvdXAuaXRlbXMpLmdyb3VwKGRlc2NyaXB0b3JzLnNsaWNlKDEpLCBkYXRhLnRvQXJyYXkoKSkudG9BcnJheSgpIDogZ3JvdXAuaXRlbXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhhc1N1Ymdyb3VwczogZGVzY3JpcHRvcnMubGVuZ3RoID4gMSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlczogZGF0YS5hZ2dyZWdhdGUoZGVzY3JpcHRvci5hZ2dyZWdhdGVzKVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBncm91cEJ5OiBmdW5jdGlvbihkZXNjcmlwdG9yKSB7XG5cdCAgICAgICAgICAgIGlmIChpc0VtcHR5T2JqZWN0KGRlc2NyaXB0b3IpIHx8ICF0aGlzLmRhdGEubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFF1ZXJ5KFtdKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHZhciBmaWVsZCA9IGRlc2NyaXB0b3IuZmllbGQsXG5cdCAgICAgICAgICAgICAgICBzb3J0ZWQgPSB0aGlzLl9zb3J0Rm9yR3JvdXBpbmcoZmllbGQsIGRlc2NyaXB0b3IuZGlyIHx8IFwiYXNjXCIpLFxuXHQgICAgICAgICAgICAgICAgYWNjZXNzb3IgPSBrZW5kby5hY2Nlc3NvcihmaWVsZCksXG5cdCAgICAgICAgICAgICAgICBpdGVtLFxuXHQgICAgICAgICAgICAgICAgZ3JvdXBWYWx1ZSA9IGFjY2Vzc29yLmdldChzb3J0ZWRbMF0sIGZpZWxkKSxcblx0ICAgICAgICAgICAgICAgIGdyb3VwID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXBWYWx1ZSxcblx0ICAgICAgICAgICAgICAgICAgICBpdGVtczogW11cblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUsXG5cdCAgICAgICAgICAgICAgICBpZHgsXG5cdCAgICAgICAgICAgICAgICBsZW4sXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSBbZ3JvdXBdO1xuXG5cdCAgICAgICAgICAgIGZvcihpZHggPSAwLCBsZW4gPSBzb3J0ZWQubGVuZ3RoOyBpZHggPCBsZW47IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICBpdGVtID0gc29ydGVkW2lkeF07XG5cdCAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBhY2Nlc3Nvci5nZXQoaXRlbSwgZmllbGQpO1xuXHQgICAgICAgICAgICAgICAgaWYoIWdyb3VwVmFsdWVDb21wYXJlcihncm91cFZhbHVlLCBjdXJyZW50VmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZ3JvdXBWYWx1ZSA9IGN1cnJlbnRWYWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBncm91cCA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ3JvdXBWYWx1ZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFtdXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChncm91cCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBncm91cC5pdGVtcy5wdXNoKGl0ZW0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgUXVlcnkocmVzdWx0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3NvcnRGb3JHcm91cGluZzogZnVuY3Rpb24oZmllbGQsIGRpcikge1xuXHQgICAgICAgICAgICB2YXIgaWR4LCBsZW5ndGgsXG5cdCAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5kYXRhO1xuXG5cdCAgICAgICAgICAgIGlmICghc3RhYmxlU29ydCkge1xuXHQgICAgICAgICAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGRhdGFbaWR4XS5fX3Bvc2l0aW9uID0gaWR4O1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBkYXRhID0gbmV3IFF1ZXJ5KGRhdGEpLnNvcnQoZmllbGQsIGRpciwgU3RhYmxlQ29tcGFyZXIpLnRvQXJyYXkoKTtcblxuXHQgICAgICAgICAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhW2lkeF0uX19wb3NpdGlvbjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnNvcnQoZmllbGQsIGRpcikudG9BcnJheSgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBhZ2dyZWdhdGU6IGZ1bmN0aW9uIChhZ2dyZWdhdGVzKSB7XG5cdCAgICAgICAgICAgIHZhciBpZHgsXG5cdCAgICAgICAgICAgICAgICBsZW4sXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSB7fSxcblx0ICAgICAgICAgICAgICAgIHN0YXRlID0ge307XG5cblx0ICAgICAgICAgICAgaWYgKGFnZ3JlZ2F0ZXMgJiYgYWdncmVnYXRlcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIGZvcihpZHggPSAwLCBsZW4gPSB0aGlzLmRhdGEubGVuZ3RoOyBpZHggPCBsZW47IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlQWdncmVnYXRlKHJlc3VsdCwgYWdncmVnYXRlcywgdGhpcy5kYXRhW2lkeF0sIGlkeCwgbGVuLCBzdGF0ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBmdW5jdGlvbiBncm91cFZhbHVlQ29tcGFyZXIoYSwgYikge1xuXHQgICAgICAgIGlmIChhICYmIGEuZ2V0VGltZSAmJiBiICYmIGIuZ2V0VGltZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYSA9PT0gYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY2FsY3VsYXRlQWdncmVnYXRlKGFjY3VtdWxhdG9yLCBhZ2dyZWdhdGVzLCBpdGVtLCBpbmRleCwgbGVuZ3RoLCBzdGF0ZSkge1xuXHQgICAgICAgIGFnZ3JlZ2F0ZXMgPSBhZ2dyZWdhdGVzIHx8IFtdO1xuXHQgICAgICAgIHZhciBpZHgsXG5cdCAgICAgICAgICAgIGFnZ3IsXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uTmFtZSxcblx0ICAgICAgICAgICAgbGVuID0gYWdncmVnYXRlcy5sZW5ndGg7XG5cblx0ICAgICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGxlbjsgaWR4KyspIHtcblx0ICAgICAgICAgICAgYWdnciA9IGFnZ3JlZ2F0ZXNbaWR4XTtcblx0ICAgICAgICAgICAgZnVuY3Rpb25OYW1lID0gYWdnci5hZ2dyZWdhdGU7XG5cdCAgICAgICAgICAgIHZhciBmaWVsZCA9IGFnZ3IuZmllbGQ7XG5cdCAgICAgICAgICAgIGFjY3VtdWxhdG9yW2ZpZWxkXSA9IGFjY3VtdWxhdG9yW2ZpZWxkXSB8fCB7fTtcblx0ICAgICAgICAgICAgc3RhdGVbZmllbGRdID0gc3RhdGVbZmllbGRdIHx8IHt9O1xuXHQgICAgICAgICAgICBzdGF0ZVtmaWVsZF1bZnVuY3Rpb25OYW1lXSA9IHN0YXRlW2ZpZWxkXVtmdW5jdGlvbk5hbWVdIHx8IHt9O1xuXHQgICAgICAgICAgICBhY2N1bXVsYXRvcltmaWVsZF1bZnVuY3Rpb25OYW1lXSA9IGZ1bmN0aW9uc1tmdW5jdGlvbk5hbWUudG9Mb3dlckNhc2UoKV0oYWNjdW11bGF0b3JbZmllbGRdW2Z1bmN0aW9uTmFtZV0sIGl0ZW0sIGtlbmRvLmFjY2Vzc29yKGZpZWxkKSwgaW5kZXgsIGxlbmd0aCwgc3RhdGVbZmllbGRdW2Z1bmN0aW9uTmFtZV0pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgdmFyIGZ1bmN0aW9ucyA9IHtcblx0ICAgICAgICBzdW06IGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCBpdGVtLCBhY2Nlc3Nvcikge1xuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSBhY2Nlc3Nvci5nZXQoaXRlbSk7XG5cblx0ICAgICAgICAgICAgaWYgKCFpc051bWJlcihhY2N1bXVsYXRvcikpIHtcblx0ICAgICAgICAgICAgICAgIGFjY3VtdWxhdG9yID0gdmFsdWU7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIodmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICBhY2N1bXVsYXRvciArPSB2YWx1ZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGNvdW50OiBmdW5jdGlvbihhY2N1bXVsYXRvcikge1xuXHQgICAgICAgICAgICByZXR1cm4gKGFjY3VtdWxhdG9yIHx8IDApICsgMTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGF2ZXJhZ2U6IGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCBpdGVtLCBhY2Nlc3NvciwgaW5kZXgsIGxlbmd0aCwgc3RhdGUpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gYWNjZXNzb3IuZ2V0KGl0ZW0pO1xuXG5cdCAgICAgICAgICAgIGlmIChzdGF0ZS5jb3VudCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICBzdGF0ZS5jb3VudCA9IDA7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKGFjY3VtdWxhdG9yKSkge1xuXHQgICAgICAgICAgICAgICAgYWNjdW11bGF0b3IgPSB2YWx1ZTtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcih2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgICAgIGFjY3VtdWxhdG9yICs9IHZhbHVlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgc3RhdGUuY291bnQrKztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmKGluZGV4ID09IGxlbmd0aCAtIDEgJiYgaXNOdW1iZXIoYWNjdW11bGF0b3IpKSB7XG5cdCAgICAgICAgICAgICAgICBhY2N1bXVsYXRvciA9IGFjY3VtdWxhdG9yIC8gc3RhdGUuY291bnQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgbWF4OiBmdW5jdGlvbihhY2N1bXVsYXRvciwgaXRlbSwgYWNjZXNzb3IpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gYWNjZXNzb3IuZ2V0KGl0ZW0pO1xuXG5cdCAgICAgICAgICAgIGlmICghaXNOdW1iZXIoYWNjdW11bGF0b3IpICYmICFpc0RhdGUoYWNjdW11bGF0b3IpKSB7XG5cdCAgICAgICAgICAgICAgICBhY2N1bXVsYXRvciA9IHZhbHVlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYoYWNjdW11bGF0b3IgPCB2YWx1ZSAmJiAoaXNOdW1iZXIodmFsdWUpIHx8IGlzRGF0ZSh2YWx1ZSkpKSB7XG5cdCAgICAgICAgICAgICAgICBhY2N1bXVsYXRvciA9IHZhbHVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIG1pbjogZnVuY3Rpb24oYWNjdW11bGF0b3IsIGl0ZW0sIGFjY2Vzc29yKSB7XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFjY2Vzc29yLmdldChpdGVtKTtcblxuXHQgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKGFjY3VtdWxhdG9yKSAmJiAhaXNEYXRlKGFjY3VtdWxhdG9yKSkge1xuXHQgICAgICAgICAgICAgICAgYWNjdW11bGF0b3IgPSB2YWx1ZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmKGFjY3VtdWxhdG9yID4gdmFsdWUgJiYgKGlzTnVtYmVyKHZhbHVlKSB8fCBpc0RhdGUodmFsdWUpKSkge1xuXHQgICAgICAgICAgICAgICAgYWNjdW11bGF0b3IgPSB2YWx1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG5cdCAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgJiYgIWlzTmFOKHZhbCk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcblx0ICAgICAgICByZXR1cm4gdmFsICYmIHZhbC5nZXRUaW1lO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiB0b0pTT04oYXJyYXkpIHtcblx0ICAgICAgICB2YXIgaWR4LCBsZW5ndGggPSBhcnJheS5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xuXG5cdCAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdFtpZHhdID0gYXJyYXlbaWR4XS50b0pTT04oKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXG5cdCAgICBRdWVyeS5ub3JtYWxpemVHcm91cCA9IG5vcm1hbGl6ZUdyb3VwO1xuXHQgICAgUXVlcnkubm9ybWFsaXplU29ydCA9IG5vcm1hbGl6ZVNvcnQ7XG5cblx0ICAgIFF1ZXJ5LnByb2Nlc3MgPSBmdW5jdGlvbihkYXRhLCBvcHRpb25zLCBpblBsYWNlKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0ICAgICAgICB2YXIgcXVlcnkgPSBuZXcgUXVlcnkoZGF0YSksXG5cdCAgICAgICAgICAgIGdyb3VwID0gb3B0aW9ucy5ncm91cCxcblx0ICAgICAgICAgICAgc29ydCA9IG5vcm1hbGl6ZUdyb3VwKGdyb3VwIHx8IFtdKS5jb25jYXQobm9ybWFsaXplU29ydChvcHRpb25zLnNvcnQgfHwgW10pKSxcblx0ICAgICAgICAgICAgdG90YWwsXG5cdCAgICAgICAgICAgIGZpbHRlckNhbGxiYWNrID0gb3B0aW9ucy5maWx0ZXJDYWxsYmFjayxcblx0ICAgICAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXIsXG5cdCAgICAgICAgICAgIHNraXAgPSBvcHRpb25zLnNraXAsXG5cdCAgICAgICAgICAgIHRha2UgPSBvcHRpb25zLnRha2U7XG5cblx0ICAgICAgICBpZiAoc29ydCAmJiBpblBsYWNlKSB7XG5cdCAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuc29ydChzb3J0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaW5QbGFjZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGZpbHRlcikge1xuXHQgICAgICAgICAgICBxdWVyeSA9IHF1ZXJ5LmZpbHRlcihmaWx0ZXIpO1xuXG5cdCAgICAgICAgICAgIGlmIChmaWx0ZXJDYWxsYmFjaykge1xuXHQgICAgICAgICAgICAgICAgcXVlcnkgPSBmaWx0ZXJDYWxsYmFjayhxdWVyeSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0b3RhbCA9IHF1ZXJ5LnRvQXJyYXkoKS5sZW5ndGg7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKHNvcnQgJiYgIWluUGxhY2UpIHtcblx0ICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5zb3J0KHNvcnQpO1xuXG5cdCAgICAgICAgICAgIGlmIChncm91cCkge1xuXHQgICAgICAgICAgICAgICAgZGF0YSA9IHF1ZXJ5LnRvQXJyYXkoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChza2lwICE9PSB1bmRlZmluZWQgJiYgdGFrZSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkucmFuZ2Uoc2tpcCwgdGFrZSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKGdyb3VwKSB7XG5cdCAgICAgICAgICAgIHF1ZXJ5ID0gcXVlcnkuZ3JvdXAoZ3JvdXAsIGRhdGEpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHRvdGFsOiB0b3RhbCxcblx0ICAgICAgICAgICAgZGF0YTogcXVlcnkudG9BcnJheSgpXG5cdCAgICAgICAgfTtcblx0ICAgIH07XG5cblx0ICAgIHZhciBMb2NhbFRyYW5zcG9ydCA9IENsYXNzLmV4dGVuZCh7XG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgICAgICAgICAgICB0aGlzLmRhdGEgPSBvcHRpb25zLmRhdGE7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHJlYWQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzKHRoaXMuZGF0YSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzKG9wdGlvbnMuZGF0YSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzKG9wdGlvbnMuZGF0YSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBkZXN0cm95OiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIG9wdGlvbnMuc3VjY2VzcyhvcHRpb25zLmRhdGEpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICB2YXIgUmVtb3RlVHJhbnNwb3J0ID0gQ2xhc3MuZXh0ZW5kKCB7XG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIHBhcmFtZXRlck1hcDtcblxuXHQgICAgICAgICAgICBvcHRpb25zID0gdGhhdC5vcHRpb25zID0gZXh0ZW5kKHt9LCB0aGF0Lm9wdGlvbnMsIG9wdGlvbnMpO1xuXG5cdCAgICAgICAgICAgIGVhY2goY3J1ZCwgZnVuY3Rpb24oaW5kZXgsIHR5cGUpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc1t0eXBlXSA9PT0gU1RSSU5HKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1t0eXBlXSA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBvcHRpb25zW3R5cGVdXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgdGhhdC5jYWNoZSA9IG9wdGlvbnMuY2FjaGU/IENhY2hlLmNyZWF0ZShvcHRpb25zLmNhY2hlKSA6IHtcblx0ICAgICAgICAgICAgICAgIGZpbmQ6IG5vb3AsXG5cdCAgICAgICAgICAgICAgICBhZGQ6IG5vb3Bcblx0ICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICBwYXJhbWV0ZXJNYXAgPSBvcHRpb25zLnBhcmFtZXRlck1hcDtcblxuXHQgICAgICAgICAgICBpZiAob3B0aW9ucy5zdWJtaXQpIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQuc3VibWl0ID0gb3B0aW9ucy5zdWJtaXQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnB1c2gpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGF0LnB1c2ggPSBvcHRpb25zLnB1c2g7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoIXRoYXQucHVzaCkge1xuXHQgICAgICAgICAgICAgICAgdGhhdC5wdXNoID0gaWRlbnRpdHk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGF0LnBhcmFtZXRlck1hcCA9IGlzRnVuY3Rpb24ocGFyYW1ldGVyTWFwKSA/IHBhcmFtZXRlck1hcCA6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuXHQgICAgICAgICAgICAgICAgZWFjaChvcHRpb25zLCBmdW5jdGlvbihvcHRpb24sIHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbiBpbiBwYXJhbWV0ZXJNYXApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gcGFyYW1ldGVyTWFwW29wdGlvbl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KG9wdGlvbikpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb3B0aW9uLnZhbHVlKHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbi5rZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRbb3B0aW9uXSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIG9wdGlvbnM6IHtcblx0ICAgICAgICAgICAgcGFyYW1ldGVyTWFwOiBpZGVudGl0eVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGFqYXgodGhpcy5zZXR1cChvcHRpb25zLCBDUkVBVEUpKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgcmVhZDogZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBzdWNjZXNzLFxuXHQgICAgICAgICAgICAgICAgZXJyb3IsXG5cdCAgICAgICAgICAgICAgICByZXN1bHQsXG5cdCAgICAgICAgICAgICAgICBjYWNoZSA9IHRoYXQuY2FjaGU7XG5cblx0ICAgICAgICAgICAgb3B0aW9ucyA9IHRoYXQuc2V0dXAob3B0aW9ucywgUkVBRCk7XG5cblx0ICAgICAgICAgICAgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcyB8fCBub29wO1xuXHQgICAgICAgICAgICBlcnJvciA9IG9wdGlvbnMuZXJyb3IgfHwgbm9vcDtcblxuXHQgICAgICAgICAgICByZXN1bHQgPSBjYWNoZS5maW5kKG9wdGlvbnMuZGF0YSk7XG5cblx0ICAgICAgICAgICAgaWYocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHN1Y2Nlc3MocmVzdWx0KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhY2hlLmFkZChvcHRpb25zLmRhdGEsIHJlc3VsdCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICBzdWNjZXNzKHJlc3VsdCk7XG5cdCAgICAgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgICAgICAkLmFqYXgob3B0aW9ucyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgdXBkYXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBhamF4KHRoaXMuc2V0dXAob3B0aW9ucywgVVBEQVRFKSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGFqYXgodGhpcy5zZXR1cChvcHRpb25zLCBERVNUUk9ZKSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHNldHVwOiBmdW5jdGlvbihvcHRpb25zLCB0eXBlKSB7XG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcblx0ICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMsXG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb24gPSB0aGF0Lm9wdGlvbnNbdHlwZV0sXG5cdCAgICAgICAgICAgICAgICBkYXRhID0gaXNGdW5jdGlvbihvcGVyYXRpb24uZGF0YSkgPyBvcGVyYXRpb24uZGF0YShvcHRpb25zLmRhdGEpIDogb3BlcmF0aW9uLmRhdGE7XG5cblx0ICAgICAgICAgICAgb3B0aW9ucyA9IGV4dGVuZCh0cnVlLCB7fSwgb3BlcmF0aW9uLCBvcHRpb25zKTtcblx0ICAgICAgICAgICAgcGFyYW1ldGVycyA9IGV4dGVuZCh0cnVlLCB7fSwgZGF0YSwgb3B0aW9ucy5kYXRhKTtcblxuXHQgICAgICAgICAgICBvcHRpb25zLmRhdGEgPSB0aGF0LnBhcmFtZXRlck1hcChwYXJhbWV0ZXJzLCB0eXBlKTtcblxuXHQgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zLnVybCkpIHtcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMudXJsID0gb3B0aW9ucy51cmwocGFyYW1ldGVycyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgdmFyIENhY2hlID0gQ2xhc3MuZXh0ZW5kKHtcblx0ICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc3RvcmUgPSB7fTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGFkZDogZnVuY3Rpb24oa2V5LCBkYXRhKSB7XG5cdCAgICAgICAgICAgIGlmKGtleSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zdG9yZVtzdHJpbmdpZnkoa2V5KV0gPSBkYXRhO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBmaW5kOiBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlW3N0cmluZ2lmeShrZXkpXTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc3RvcmUgPSB7fTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdG9yZVtzdHJpbmdpZnkoa2V5KV07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIENhY2hlLmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICAgICAgICB2YXIgc3RvcmUgPSB7XG5cdCAgICAgICAgICAgIFwiaW5tZW1vcnlcIjogZnVuY3Rpb24oKSB7IHJldHVybiBuZXcgQ2FjaGUoKTsgfVxuXHQgICAgICAgIH07XG5cblx0ICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChvcHRpb25zKSAmJiBpc0Z1bmN0aW9uKG9wdGlvbnMuZmluZCkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBDYWNoZSgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBzdG9yZVtvcHRpb25zXSgpO1xuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gc2VyaWFsaXplUmVjb3JkcyhkYXRhLCBnZXR0ZXJzLCBtb2RlbEluc3RhbmNlLCBvcmlnaW5hbEZpZWxkTmFtZXMsIGZpZWxkTmFtZXMpIHtcblx0ICAgICAgICB2YXIgcmVjb3JkLFxuXHQgICAgICAgICAgICBnZXR0ZXIsXG5cdCAgICAgICAgICAgIG9yaWdpbmFsTmFtZSxcblx0ICAgICAgICAgICAgaWR4LFxuXHQgICAgICAgICAgICBzZXR0ZXJzID0ge30sXG5cdCAgICAgICAgICAgIGxlbmd0aDtcblxuXHQgICAgICAgIGZvciAoaWR4ID0gMCwgbGVuZ3RoID0gZGF0YS5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgcmVjb3JkID0gZGF0YVtpZHhdO1xuXHQgICAgICAgICAgICBmb3IgKGdldHRlciBpbiBnZXR0ZXJzKSB7XG5cdCAgICAgICAgICAgICAgICBvcmlnaW5hbE5hbWUgPSBmaWVsZE5hbWVzW2dldHRlcl07XG5cblx0ICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbE5hbWUgJiYgb3JpZ2luYWxOYW1lICE9PSBnZXR0ZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRlcnNbb3JpZ2luYWxOYW1lXSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXJzW29yaWdpbmFsTmFtZV0gPSBrZW5kby5zZXR0ZXIob3JpZ2luYWxOYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgc2V0dGVyc1tvcmlnaW5hbE5hbWVdKHJlY29yZCwgZ2V0dGVyc1tnZXR0ZXJdKHJlY29yZCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZWNvcmRbZ2V0dGVyXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY29udmVydFJlY29yZHMoZGF0YSwgZ2V0dGVycywgbW9kZWxJbnN0YW5jZSwgb3JpZ2luYWxGaWVsZE5hbWVzLCBmaWVsZE5hbWVzKSB7XG5cdCAgICAgICAgdmFyIHJlY29yZCxcblx0ICAgICAgICAgICAgZ2V0dGVyLFxuXHQgICAgICAgICAgICBvcmlnaW5hbE5hbWUsXG5cdCAgICAgICAgICAgIGlkeCxcblx0ICAgICAgICAgICAgbGVuZ3RoO1xuXG5cdCAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICByZWNvcmQgPSBkYXRhW2lkeF07XG5cdCAgICAgICAgICAgIGZvciAoZ2V0dGVyIGluIGdldHRlcnMpIHtcblx0ICAgICAgICAgICAgICAgIHJlY29yZFtnZXR0ZXJdID0gbW9kZWxJbnN0YW5jZS5fcGFyc2UoZ2V0dGVyLCBnZXR0ZXJzW2dldHRlcl0ocmVjb3JkKSk7XG5cblx0ICAgICAgICAgICAgICAgIG9yaWdpbmFsTmFtZSA9IGZpZWxkTmFtZXNbZ2V0dGVyXTtcblx0ICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbE5hbWUgJiYgb3JpZ2luYWxOYW1lICE9PSBnZXR0ZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVjb3JkW29yaWdpbmFsTmFtZV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNvbnZlcnRHcm91cChkYXRhLCBnZXR0ZXJzLCBtb2RlbEluc3RhbmNlLCBvcmlnaW5hbEZpZWxkTmFtZXMsIGZpZWxkTmFtZXMpIHtcblx0ICAgICAgICB2YXIgcmVjb3JkLFxuXHQgICAgICAgICAgICBpZHgsXG5cdCAgICAgICAgICAgIGZpZWxkTmFtZSxcblx0ICAgICAgICAgICAgbGVuZ3RoO1xuXG5cdCAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICByZWNvcmQgPSBkYXRhW2lkeF07XG5cblx0ICAgICAgICAgICAgZmllbGROYW1lID0gb3JpZ2luYWxGaWVsZE5hbWVzW3JlY29yZC5maWVsZF07XG5cdCAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgJiYgZmllbGROYW1lICE9IHJlY29yZC5maWVsZCkge1xuXHQgICAgICAgICAgICAgICAgcmVjb3JkLmZpZWxkID0gZmllbGROYW1lO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmVjb3JkLnZhbHVlID0gbW9kZWxJbnN0YW5jZS5fcGFyc2UocmVjb3JkLmZpZWxkLCByZWNvcmQudmFsdWUpO1xuXG5cdCAgICAgICAgICAgIGlmIChyZWNvcmQuaGFzU3ViZ3JvdXBzKSB7XG5cdCAgICAgICAgICAgICAgICBjb252ZXJ0R3JvdXAocmVjb3JkLml0ZW1zLCBnZXR0ZXJzLCBtb2RlbEluc3RhbmNlLCBvcmlnaW5hbEZpZWxkTmFtZXMsIGZpZWxkTmFtZXMpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgY29udmVydFJlY29yZHMocmVjb3JkLml0ZW1zLCBnZXR0ZXJzLCBtb2RlbEluc3RhbmNlLCBvcmlnaW5hbEZpZWxkTmFtZXMsIGZpZWxkTmFtZXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiB3cmFwRGF0YUFjY2VzcyhvcmlnaW5hbEZ1bmN0aW9uLCBtb2RlbCwgY29udmVydGVyLCBnZXR0ZXJzLCBvcmlnaW5hbEZpZWxkTmFtZXMsIGZpZWxkTmFtZXMpIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgICAgICAgICBkYXRhID0gb3JpZ2luYWxGdW5jdGlvbihkYXRhKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gd3JhcERhdGFBY2Nlc3NCYXNlKG1vZGVsLCBjb252ZXJ0ZXIsIGdldHRlcnMsIG9yaWdpbmFsRmllbGROYW1lcywgZmllbGROYW1lcykoZGF0YSk7XG5cdCAgICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gd3JhcERhdGFBY2Nlc3NCYXNlKG1vZGVsLCBjb252ZXJ0ZXIsIGdldHRlcnMsIG9yaWdpbmFsRmllbGROYW1lcywgZmllbGROYW1lcykge1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG5cblx0ICAgICAgICAgICAgaWYgKGRhdGEgJiYgIWlzRW1wdHlPYmplY3QoZ2V0dGVycykpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0b1N0cmluZy5jYWxsKGRhdGEpICE9PSBcIltvYmplY3QgQXJyYXldXCIgJiYgIShkYXRhIGluc3RhbmNlb2YgT2JzZXJ2YWJsZUFycmF5KSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGNvbnZlcnRlcihkYXRhLCBnZXR0ZXJzLCBuZXcgbW9kZWwoKSwgb3JpZ2luYWxGaWVsZE5hbWVzLCBmaWVsZE5hbWVzKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBkYXRhIHx8IFtdO1xuXHQgICAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIHZhciBEYXRhUmVhZGVyID0gQ2xhc3MuZXh0ZW5kKHtcblx0ICAgICAgICBpbml0OiBmdW5jdGlvbihzY2hlbWEpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLCBtZW1iZXIsIGdldCwgbW9kZWwsIGJhc2U7XG5cblx0ICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1hIHx8IHt9O1xuXG5cdCAgICAgICAgICAgIGZvciAobWVtYmVyIGluIHNjaGVtYSkge1xuXHQgICAgICAgICAgICAgICAgZ2V0ID0gc2NoZW1hW21lbWJlcl07XG5cblx0ICAgICAgICAgICAgICAgIHRoYXRbbWVtYmVyXSA9IHR5cGVvZiBnZXQgPT09IFNUUklORyA/IGdldHRlcihnZXQpIDogZ2V0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgYmFzZSA9IHNjaGVtYS5tb2RlbEJhc2UgfHwgTW9kZWw7XG5cblx0ICAgICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QodGhhdC5tb2RlbCkpIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQubW9kZWwgPSBtb2RlbCA9IGJhc2UuZGVmaW5lKHRoYXQubW9kZWwpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdmFyIGRhdGFGdW5jdGlvbiA9IHByb3h5KHRoYXQuZGF0YSwgdGhhdCk7XG5cblx0ICAgICAgICAgICAgdGhhdC5fZGF0YUFjY2Vzc0Z1bmN0aW9uID0gZGF0YUZ1bmN0aW9uO1xuXG5cdCAgICAgICAgICAgIGlmICh0aGF0Lm1vZGVsKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZ3JvdXBzRnVuY3Rpb24gPSBwcm94eSh0aGF0Lmdyb3VwcywgdGhhdCksXG5cdCAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplRnVuY3Rpb24gPSBwcm94eSh0aGF0LnNlcmlhbGl6ZSwgdGhhdCksXG5cdCAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxGaWVsZE5hbWVzID0ge30sXG5cdCAgICAgICAgICAgICAgICAgICAgZ2V0dGVycyA9IHt9LFxuXHQgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUdldHRlcnMgPSB7fSxcblx0ICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWVzID0ge30sXG5cdCAgICAgICAgICAgICAgICAgICAgc2hvdWxkU2VyaWFsaXplID0gZmFsc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgIG5hbWU7XG5cblx0ICAgICAgICAgICAgICAgIG1vZGVsID0gdGhhdC5tb2RlbDtcblxuXHQgICAgICAgICAgICAgICAgaWYgKG1vZGVsLmZpZWxkcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGVhY2gobW9kZWwuZmllbGRzLCBmdW5jdGlvbihmaWVsZCwgdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyb21OYW1lO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IGZpZWxkO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiB2YWx1ZS5maWVsZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGROYW1lID0gdmFsdWUuZmllbGQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBTVFJJTkcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpICYmIHZhbHVlLmZyb20pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21OYW1lID0gdmFsdWUuZnJvbTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFNlcmlhbGl6ZSA9IHNob3VsZFNlcmlhbGl6ZSB8fCAoZnJvbU5hbWUgJiYgZnJvbU5hbWUgIT09IGZpZWxkKSB8fCBmaWVsZE5hbWUgIT09IGZpZWxkO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gZnJvbU5hbWUgfHwgZmllbGROYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBnZXR0ZXJzW2ZpZWxkXSA9IG5hbWUuaW5kZXhPZihcIi5cIikgIT09IC0xID8gZ2V0dGVyKG5hbWUsIHRydWUpIDogZ2V0dGVyKG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVHZXR0ZXJzW2ZpZWxkXSA9IGdldHRlcihmaWVsZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRmllbGROYW1lc1tmcm9tTmFtZSB8fCBmaWVsZE5hbWVdID0gZmllbGQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZXNbZmllbGRdID0gZnJvbU5hbWUgfHwgZmllbGROYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFzY2hlbWEuc2VyaWFsaXplICYmIHNob3VsZFNlcmlhbGl6ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNlcmlhbGl6ZSA9IHdyYXBEYXRhQWNjZXNzKHNlcmlhbGl6ZUZ1bmN0aW9uLCBtb2RlbCwgc2VyaWFsaXplUmVjb3Jkcywgc2VyaWFsaXplR2V0dGVycywgb3JpZ2luYWxGaWVsZE5hbWVzLCBmaWVsZE5hbWVzKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHRoYXQuX2RhdGFBY2Nlc3NGdW5jdGlvbiA9IGRhdGFGdW5jdGlvbjtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX3dyYXBEYXRhQWNjZXNzQmFzZSA9IHdyYXBEYXRhQWNjZXNzQmFzZShtb2RlbCwgY29udmVydFJlY29yZHMsIGdldHRlcnMsIG9yaWdpbmFsRmllbGROYW1lcywgZmllbGROYW1lcyk7XG5cdCAgICAgICAgICAgICAgICB0aGF0LmRhdGEgPSB3cmFwRGF0YUFjY2VzcyhkYXRhRnVuY3Rpb24sIG1vZGVsLCBjb252ZXJ0UmVjb3JkcywgZ2V0dGVycywgb3JpZ2luYWxGaWVsZE5hbWVzLCBmaWVsZE5hbWVzKTtcblx0ICAgICAgICAgICAgICAgIHRoYXQuZ3JvdXBzID0gd3JhcERhdGFBY2Nlc3MoZ3JvdXBzRnVuY3Rpb24sIG1vZGVsLCBjb252ZXJ0R3JvdXAsIGdldHRlcnMsIG9yaWdpbmFsRmllbGROYW1lcywgZmllbGROYW1lcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVycm9yczogZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZGF0YSA/IGRhdGEuZXJyb3JzIDogbnVsbDtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHBhcnNlOiBpZGVudGl0eSxcblx0ICAgICAgICBkYXRhOiBpZGVudGl0eSxcblx0ICAgICAgICB0b3RhbDogZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBncm91cHM6IGlkZW50aXR5LFxuXHQgICAgICAgIGFnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4ge307XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXJpYWxpemU6IGZ1bmN0aW9uKGRhdGEpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIGZ1bmN0aW9uIGZpbGxMYXN0R3JvdXAob3JpZ2luYWxHcm91cCwgbmV3R3JvdXApIHtcblx0ICAgICAgICB2YXIgY3Vyck9yaWdpbmFsO1xuXHQgICAgICAgIHZhciBjdXJyZW50TmV3O1xuXG5cdCAgICAgICAgaWYgKG5ld0dyb3VwLml0ZW1zICYmIG5ld0dyb3VwLml0ZW1zLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0dyb3VwLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBjdXJyT3JpZ2luYWwgPSBvcmlnaW5hbEdyb3VwLml0ZW1zW2ldO1xuXHQgICAgICAgICAgICAgICAgY3VycmVudE5ldyA9IG5ld0dyb3VwLml0ZW1zW2ldO1xuXHQgICAgICAgICAgICAgICAgaWYgKGN1cnJPcmlnaW5hbCAmJiBjdXJyZW50TmV3KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJPcmlnaW5hbC5oYXNTdWJncm91cHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmlsbExhc3RHcm91cChjdXJyT3JpZ2luYWwsIGN1cnJlbnROZXcpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3Vyck9yaWdpbmFsLmZpZWxkICYmIGN1cnJPcmlnaW5hbC52YWx1ZSA9PSBjdXJyZW50TmV3LnZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJPcmlnaW5hbC5pdGVtcy5wdXNoLmFwcGx5KGN1cnJPcmlnaW5hbC5pdGVtcywgY3VycmVudE5ldy5pdGVtcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxHcm91cC5pdGVtcy5wdXNoLmFwcGx5KG9yaWdpbmFsR3JvdXAuaXRlbXMsIFtjdXJyZW50TmV3XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50TmV3KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxHcm91cC5pdGVtcy5wdXNoLmFwcGx5KG9yaWdpbmFsR3JvdXAuaXRlbXMsIFtjdXJyZW50TmV3XSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBtZXJnZUdyb3Vwcyh0YXJnZXQsIGRlc3QsIHNraXAsIHRha2UpIHtcblx0ICAgICAgICB2YXIgZ3JvdXAsXG5cdCAgICAgICAgICAgIGlkeCA9IDAsXG5cdCAgICAgICAgICAgIGl0ZW1zO1xuXG5cdCAgICAgICAgd2hpbGUgKGRlc3QubGVuZ3RoICYmIHRha2UpIHtcblx0ICAgICAgICAgICAgZ3JvdXAgPSBkZXN0W2lkeF07XG5cdCAgICAgICAgICAgIGl0ZW1zID0gZ3JvdXAuaXRlbXM7XG5cblx0ICAgICAgICAgICAgdmFyIGxlbmd0aCA9IGl0ZW1zLmxlbmd0aDtcblxuXHQgICAgICAgICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5maWVsZCA9PT0gZ3JvdXAuZmllbGQgJiYgdGFyZ2V0LnZhbHVlID09PSBncm91cC52YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5oYXNTdWJncm91cHMgJiYgdGFyZ2V0Lml0ZW1zLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgIG1lcmdlR3JvdXBzKHRhcmdldC5pdGVtc1t0YXJnZXQuaXRlbXMubGVuZ3RoIC0gMV0sIGdyb3VwLml0ZW1zLCBza2lwLCB0YWtlKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSBpdGVtcy5zbGljZShza2lwLCBza2lwICsgdGFrZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Lml0ZW1zID0gdGFyZ2V0Lml0ZW1zLmNvbmNhdChpdGVtcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBkZXN0LnNwbGljZShpZHgtLSwgMSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoZ3JvdXAuaGFzU3ViZ3JvdXBzICYmIGl0ZW1zLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgbWVyZ2VHcm91cHMoZ3JvdXAsIGl0ZW1zLCBza2lwLCB0YWtlKTtcblx0ICAgICAgICAgICAgICAgIGlmICghZ3JvdXAuaXRlbXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVzdC5zcGxpY2UoaWR4LS0sIDEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgaXRlbXMgPSBpdGVtcy5zbGljZShza2lwLCBza2lwICsgdGFrZSk7XG5cdCAgICAgICAgICAgICAgICBncm91cC5pdGVtcyA9IGl0ZW1zO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoIWdyb3VwLml0ZW1zLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlc3Quc3BsaWNlKGlkeC0tLCAxKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIHNraXAgLT0gbGVuZ3RoO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgc2tpcCA9IDA7XG5cdCAgICAgICAgICAgICAgICB0YWtlIC09IGl0ZW1zLmxlbmd0aDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICgrK2lkeCA+PSBkZXN0Lmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoaWR4IDwgZGVzdC5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgZGVzdC5zcGxpY2UoaWR4LCBkZXN0Lmxlbmd0aCAtIGlkeCk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBmbGF0dGVuR3JvdXBzKGRhdGEpIHtcblx0ICAgICAgICB2YXIgaWR4LFxuXHQgICAgICAgICAgICByZXN1bHQgPSBbXSxcblx0ICAgICAgICAgICAgbGVuZ3RoLFxuXHQgICAgICAgICAgICBpdGVtcyxcblx0ICAgICAgICAgICAgaXRlbUluZGV4O1xuXG5cdCAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICB2YXIgZ3JvdXAgPSBkYXRhLmF0KGlkeCk7XG5cdCAgICAgICAgICAgIGlmIChncm91cC5oYXNTdWJncm91cHMpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoZmxhdHRlbkdyb3Vwcyhncm91cC5pdGVtcykpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgaXRlbXMgPSBncm91cC5pdGVtcztcblx0ICAgICAgICAgICAgICAgIGZvciAoaXRlbUluZGV4ID0gMDsgaXRlbUluZGV4IDwgaXRlbXMubGVuZ3RoOyBpdGVtSW5kZXgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW1zLmF0KGl0ZW1JbmRleCkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHdyYXBHcm91cEl0ZW1zKGRhdGEsIG1vZGVsKSB7XG5cdCAgICAgICAgdmFyIGlkeCwgbGVuZ3RoLCBncm91cDtcblx0ICAgICAgICBpZiAobW9kZWwpIHtcblx0ICAgICAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgZ3JvdXAgPSBkYXRhLmF0KGlkeCk7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChncm91cC5oYXNTdWJncm91cHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB3cmFwR3JvdXBJdGVtcyhncm91cC5pdGVtcywgbW9kZWwpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBncm91cC5pdGVtcyA9IG5ldyBMYXp5T2JzZXJ2YWJsZUFycmF5KGdyb3VwLml0ZW1zLCBtb2RlbCwgZ3JvdXAuaXRlbXMuX2V2ZW50cyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGVhY2hHcm91cEl0ZW1zKGRhdGEsIGZ1bmMpIHtcblx0ICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBkYXRhLmxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgaWYgKGRhdGFbaWR4XS5oYXNTdWJncm91cHMpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlYWNoR3JvdXBJdGVtcyhkYXRhW2lkeF0uaXRlbXMsIGZ1bmMpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoZnVuYyhkYXRhW2lkeF0uaXRlbXMsIGRhdGFbaWR4XSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiByZXBsYWNlSW5SYW5nZXMocmFuZ2VzLCBkYXRhLCBpdGVtLCBvYnNlcnZhYmxlKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgcmFuZ2VzLmxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgaWYgKHJhbmdlc1tpZHhdLmRhdGEgPT09IGRhdGEpIHtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChyZXBsYWNlSW5SYW5nZShyYW5nZXNbaWR4XS5kYXRhLCBpdGVtLCBvYnNlcnZhYmxlKSkge1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIHJlcGxhY2VJblJhbmdlKGl0ZW1zLCBpdGVtLCBvYnNlcnZhYmxlKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaWR4ID0gMCwgbGVuZ3RoID0gaXRlbXMubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgIGlmIChpdGVtc1tpZHhdICYmIGl0ZW1zW2lkeF0uaGFzU3ViZ3JvdXBzKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZUluUmFuZ2UoaXRlbXNbaWR4XS5pdGVtcywgaXRlbSwgb2JzZXJ2YWJsZSk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbXNbaWR4XSA9PT0gaXRlbSB8fCBpdGVtc1tpZHhdID09PSBvYnNlcnZhYmxlKSB7XG5cdCAgICAgICAgICAgICAgIGl0ZW1zW2lkeF0gPSBvYnNlcnZhYmxlO1xuXHQgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gcmVwbGFjZVdpdGhPYnNlcnZhYmxlKHZpZXcsIGRhdGEsIHJhbmdlcywgdHlwZSwgc2VydmVyR3JvdXBpbmcpIHtcblx0ICAgICAgICBmb3IgKHZhciB2aWV3SW5kZXggPSAwLCBsZW5ndGggPSB2aWV3Lmxlbmd0aDsgdmlld0luZGV4IDwgbGVuZ3RoOyB2aWV3SW5kZXgrKykge1xuXHQgICAgICAgICAgICB2YXIgaXRlbSA9IHZpZXdbdmlld0luZGV4XTtcblxuXHQgICAgICAgICAgICBpZiAoIWl0ZW0gfHwgaXRlbSBpbnN0YW5jZW9mIHR5cGUpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGl0ZW0uaGFzU3ViZ3JvdXBzICE9PSB1bmRlZmluZWQgJiYgIXNlcnZlckdyb3VwaW5nKSB7XG5cdCAgICAgICAgICAgICAgICByZXBsYWNlV2l0aE9ic2VydmFibGUoaXRlbS5pdGVtcywgZGF0YSwgcmFuZ2VzLCB0eXBlLCBzZXJ2ZXJHcm91cGluZyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBkYXRhLmxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpZHhdID09PSBpdGVtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdbdmlld0luZGV4XSA9IGRhdGEuYXQoaWR4KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZUluUmFuZ2VzKHJhbmdlcywgZGF0YSwgaXRlbSwgdmlld1t2aWV3SW5kZXhdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiByZW1vdmVNb2RlbChkYXRhLCBtb2RlbCkge1xuXHQgICAgICAgIHZhciBsZW5ndGggPSBkYXRhLmxlbmd0aDtcblx0ICAgICAgICB2YXIgZGF0YUl0ZW07XG5cdCAgICAgICAgdmFyIGlkeDtcblxuXHQgICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICBkYXRhSXRlbSA9IGRhdGFbaWR4XTtcblxuXHQgICAgICAgICAgICBpZiAoZGF0YUl0ZW0udWlkICYmIGRhdGFJdGVtLnVpZCA9PSBtb2RlbC51aWQpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGEuc3BsaWNlKGlkeCwgMSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZGF0YUl0ZW07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGluZGV4T2ZQcmlzdGluZU1vZGVsKGRhdGEsIG1vZGVsKSB7XG5cdCAgICAgICAgaWYgKG1vZGVsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBpbmRleE9mKGRhdGEsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiAoaXRlbS51aWQgJiYgaXRlbS51aWQgPT0gbW9kZWwudWlkKSB8fCAoaXRlbVttb2RlbC5pZEZpZWxkXSA9PT0gbW9kZWwuaWQgJiYgbW9kZWwuaWQgIT09IG1vZGVsLl9kZWZhdWx0SWQpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBpbmRleE9mTW9kZWwoZGF0YSwgbW9kZWwpIHtcblx0ICAgICAgICBpZiAobW9kZWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGluZGV4T2YoZGF0YSwgZnVuY3Rpb24oaXRlbSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0udWlkID09IG1vZGVsLnVpZDtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiAtMTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaW5kZXhPZihkYXRhLCBjb21wYXJlcikge1xuXHQgICAgICAgIHZhciBpZHgsIGxlbmd0aDtcblxuXHQgICAgICAgIGZvciAoaWR4ID0gMCwgbGVuZ3RoID0gZGF0YS5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgaWYgKGNvbXBhcmVyKGRhdGFbaWR4XSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBpZHg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gLTE7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGZpZWxkTmFtZUZyb21Nb2RlbChmaWVsZHMsIG5hbWUpIHtcblx0ICAgICAgICBpZiAoZmllbGRzICYmICFpc0VtcHR5T2JqZWN0KGZpZWxkcykpIHtcblx0ICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBmaWVsZHNbbmFtZV07XG5cdCAgICAgICAgICAgIHZhciBmaWVsZE5hbWU7XG5cdCAgICAgICAgICAgIGlmIChpc1BsYWluT2JqZWN0KGRlc2NyaXB0b3IpKSB7XG5cdCAgICAgICAgICAgICAgICBmaWVsZE5hbWUgPSBkZXNjcmlwdG9yLmZyb20gfHwgZGVzY3JpcHRvci5maWVsZCB8fCBuYW1lO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZmllbGROYW1lID0gZmllbGRzW25hbWVdIHx8IG5hbWU7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihmaWVsZE5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmFtZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBmaWVsZE5hbWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuYW1lO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBjb252ZXJ0RmlsdGVyRGVzY3JpcHRvcnNGaWVsZChkZXNjcmlwdG9yLCBtb2RlbCkge1xuXHQgICAgICAgIHZhciBpZHgsXG5cdCAgICAgICAgICAgIGxlbmd0aCxcblx0ICAgICAgICAgICAgdGFyZ2V0ID0ge307XG5cblx0ICAgICAgICBmb3IgKHZhciBmaWVsZCBpbiBkZXNjcmlwdG9yKSB7XG5cdCAgICAgICAgICAgIGlmIChmaWVsZCAhPT0gXCJmaWx0ZXJzXCIpIHtcblx0ICAgICAgICAgICAgICAgIHRhcmdldFtmaWVsZF0gPSBkZXNjcmlwdG9yW2ZpZWxkXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChkZXNjcmlwdG9yLmZpbHRlcnMpIHtcblx0ICAgICAgICAgICAgdGFyZ2V0LmZpbHRlcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSBkZXNjcmlwdG9yLmZpbHRlcnMubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICB0YXJnZXQuZmlsdGVyc1tpZHhdID0gY29udmVydEZpbHRlckRlc2NyaXB0b3JzRmllbGQoZGVzY3JpcHRvci5maWx0ZXJzW2lkeF0sIG1vZGVsKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgIHRhcmdldC5maWVsZCA9IGZpZWxkTmFtZUZyb21Nb2RlbChtb2RlbC5maWVsZHMsIHRhcmdldC5maWVsZCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0YXJnZXQ7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNvbnZlcnREZXNjcmlwdG9yc0ZpZWxkKGRlc2NyaXB0b3JzLCBtb2RlbCkge1xuXHQgICAgICAgIHZhciBpZHgsXG5cdCAgICAgICAgICAgIGxlbmd0aCxcblx0ICAgICAgICAgICAgcmVzdWx0ID0gW10sXG5cdCAgICAgICAgICAgIHRhcmdldCxcblx0ICAgICAgICAgICAgZGVzY3JpcHRvcjtcblxuXHQgICAgICAgIGZvciAoaWR4ID0gMCwgbGVuZ3RoID0gZGVzY3JpcHRvcnMubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCArKykge1xuXHQgICAgICAgICAgICB0YXJnZXQgPSB7fTtcblxuXHQgICAgICAgICAgICBkZXNjcmlwdG9yID0gZGVzY3JpcHRvcnNbaWR4XTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBmaWVsZCBpbiBkZXNjcmlwdG9yKSB7XG5cdCAgICAgICAgICAgICAgICB0YXJnZXRbZmllbGRdID0gZGVzY3JpcHRvcltmaWVsZF07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0YXJnZXQuZmllbGQgPSBmaWVsZE5hbWVGcm9tTW9kZWwobW9kZWwuZmllbGRzLCB0YXJnZXQuZmllbGQpO1xuXG5cdCAgICAgICAgICAgIGlmICh0YXJnZXQuYWdncmVnYXRlcyAmJiBpc0FycmF5KHRhcmdldC5hZ2dyZWdhdGVzKSkge1xuXHQgICAgICAgICAgICAgICAgdGFyZ2V0LmFnZ3JlZ2F0ZXMgPSBjb252ZXJ0RGVzY3JpcHRvcnNGaWVsZCh0YXJnZXQuYWdncmVnYXRlcywgbW9kZWwpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRhcmdldCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9XG5cblx0ICAgIHZhciBEYXRhU291cmNlID0gT2JzZXJ2YWJsZS5leHRlbmQoe1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLCBtb2RlbCwgZGF0YTtcblxuXHQgICAgICAgICAgICBpZiAob3B0aW9ucykge1xuXHQgICAgICAgICAgICAgICAgZGF0YSA9IG9wdGlvbnMuZGF0YTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSB0aGF0Lm9wdGlvbnMgPSBleHRlbmQoe30sIHRoYXQub3B0aW9ucywgb3B0aW9ucyk7XG5cblx0ICAgICAgICAgICAgdGhhdC5fbWFwID0ge307XG5cdCAgICAgICAgICAgIHRoYXQuX3ByZWZldGNoID0ge307XG5cdCAgICAgICAgICAgIHRoYXQuX2RhdGEgPSBbXTtcblx0ICAgICAgICAgICAgdGhhdC5fcHJpc3RpbmVEYXRhID0gW107XG5cdCAgICAgICAgICAgIHRoYXQuX3JhbmdlcyA9IFtdO1xuXHQgICAgICAgICAgICB0aGF0Ll92aWV3ID0gW107XG5cdCAgICAgICAgICAgIHRoYXQuX3ByaXN0aW5lVG90YWwgPSAwO1xuXHQgICAgICAgICAgICB0aGF0Ll9kZXN0cm95ZWQgPSBbXTtcblx0ICAgICAgICAgICAgdGhhdC5fcGFnZVNpemUgPSBvcHRpb25zLnBhZ2VTaXplO1xuXHQgICAgICAgICAgICB0aGF0Ll9wYWdlID0gb3B0aW9ucy5wYWdlICB8fCAob3B0aW9ucy5wYWdlU2l6ZSA/IDEgOiB1bmRlZmluZWQpO1xuXHQgICAgICAgICAgICB0aGF0Ll9zb3J0ID0gbm9ybWFsaXplU29ydChvcHRpb25zLnNvcnQpO1xuXHQgICAgICAgICAgICB0aGF0Ll9maWx0ZXIgPSBub3JtYWxpemVGaWx0ZXIob3B0aW9ucy5maWx0ZXIpO1xuXHQgICAgICAgICAgICB0aGF0Ll9ncm91cCA9IG5vcm1hbGl6ZUdyb3VwKG9wdGlvbnMuZ3JvdXApO1xuXHQgICAgICAgICAgICB0aGF0Ll9hZ2dyZWdhdGUgPSBvcHRpb25zLmFnZ3JlZ2F0ZTtcblx0ICAgICAgICAgICAgdGhhdC5fdG90YWwgPSBvcHRpb25zLnRvdGFsO1xuXG5cdCAgICAgICAgICAgIHRoYXQuX3Nob3VsZERldGFjaE9ic2VydmFibGVQYXJlbnRzID0gdHJ1ZTtcblxuXHQgICAgICAgICAgICBPYnNlcnZhYmxlLmZuLmluaXQuY2FsbCh0aGF0KTtcblxuXHQgICAgICAgICAgICB0aGF0LnRyYW5zcG9ydCA9IFRyYW5zcG9ydC5jcmVhdGUob3B0aW9ucywgZGF0YSwgdGhhdCk7XG5cblx0ICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhhdC50cmFuc3BvcnQucHVzaCkpIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQudHJhbnNwb3J0LnB1c2goe1xuXHQgICAgICAgICAgICAgICAgICAgIHB1c2hDcmVhdGU6IHByb3h5KHRoYXQuX3B1c2hDcmVhdGUsIHRoYXQpLFxuXHQgICAgICAgICAgICAgICAgICAgIHB1c2hVcGRhdGU6IHByb3h5KHRoYXQuX3B1c2hVcGRhdGUsIHRoYXQpLFxuXHQgICAgICAgICAgICAgICAgICAgIHB1c2hEZXN0cm95OiBwcm94eSh0aGF0Ll9wdXNoRGVzdHJveSwgdGhhdClcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMub2ZmbGluZVN0b3JhZ2UgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLm9mZmxpbmVTdG9yYWdlID09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gb3B0aW9ucy5vZmZsaW5lU3RvcmFnZTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuX3N0b3JhZ2UgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGdldEl0ZW06IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldEl0ZW06IGZ1bmN0aW9uKGl0ZW0pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgc3RyaW5naWZ5KHRoYXQucmVhZGVyLnNlcmlhbGl6ZShpdGVtKSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC5fc3RvcmFnZSA9IG9wdGlvbnMub2ZmbGluZVN0b3JhZ2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGF0LnJlYWRlciA9IG5ldyBrZW5kby5kYXRhLnJlYWRlcnNbb3B0aW9ucy5zY2hlbWEudHlwZSB8fCBcImpzb25cIiBdKG9wdGlvbnMuc2NoZW1hKTtcblxuXHQgICAgICAgICAgICBtb2RlbCA9IHRoYXQucmVhZGVyLm1vZGVsIHx8IHt9O1xuXG5cdCAgICAgICAgICAgIHRoYXQuX2RldGFjaE9ic2VydmFibGVQYXJlbnRzKCk7XG5cblx0ICAgICAgICAgICAgdGhhdC5fZGF0YSA9IHRoYXQuX29ic2VydmUodGhhdC5fZGF0YSk7XG5cdCAgICAgICAgICAgIHRoYXQuX29ubGluZSA9IHRydWU7XG5cblx0ICAgICAgICAgICAgdGhhdC5iaW5kKFtcInB1c2hcIiwgRVJST1IsIENIQU5HRSwgUkVRVUVTVFNUQVJULCBTWU5DLCBSRVFVRVNURU5ELCBQUk9HUkVTU10sIG9wdGlvbnMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBvcHRpb25zOiB7XG5cdCAgICAgICAgICAgIGRhdGE6IG51bGwsXG5cdCAgICAgICAgICAgIHNjaGVtYToge1xuXHQgICAgICAgICAgICAgICBtb2RlbEJhc2U6IE1vZGVsXG5cdCAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgIG9mZmxpbmVTdG9yYWdlOiBudWxsLFxuXHQgICAgICAgICAgICBzZXJ2ZXJTb3J0aW5nOiBmYWxzZSxcblx0ICAgICAgICAgICAgc2VydmVyUGFnaW5nOiBmYWxzZSxcblx0ICAgICAgICAgICAgc2VydmVyRmlsdGVyaW5nOiBmYWxzZSxcblx0ICAgICAgICAgICAgc2VydmVyR3JvdXBpbmc6IGZhbHNlLFxuXHQgICAgICAgICAgICBzZXJ2ZXJBZ2dyZWdhdGVzOiBmYWxzZSxcblx0ICAgICAgICAgICAgYmF0Y2g6IGZhbHNlLFxuXHQgICAgICAgICAgICBpblBsYWNlU29ydDogZmFsc2Vcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgb25saW5lOiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuX29ubGluZSAhPSB2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX29ubGluZSA9IHZhbHVlO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bmMoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiAkLkRlZmVycmVkKCkucmVzb2x2ZSgpLnByb21pc2UoKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmxpbmU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgb2ZmbGluZURhdGE6IGZ1bmN0aW9uKHN0YXRlKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMub2ZmbGluZVN0b3JhZ2UgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoc3RhdGUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2Uuc2V0SXRlbShzdGF0ZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcmFnZS5nZXRJdGVtKCkgfHwgW107XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9pc1NlcnZlckdyb3VwZWQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgZ3JvdXAgPSB0aGlzLmdyb3VwKCkgfHwgW107XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zZXJ2ZXJHcm91cGluZyAmJiBncm91cC5sZW5ndGg7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9wdXNoQ3JlYXRlOiBmdW5jdGlvbihyZXN1bHQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fcHVzaChyZXN1bHQsIFwicHVzaENyZWF0ZVwiKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3B1c2hVcGRhdGU6IGZ1bmN0aW9uKHJlc3VsdCkge1xuXHQgICAgICAgICAgICB0aGlzLl9wdXNoKHJlc3VsdCwgXCJwdXNoVXBkYXRlXCIpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfcHVzaERlc3Ryb3k6IGZ1bmN0aW9uKHJlc3VsdCkge1xuXHQgICAgICAgICAgICB0aGlzLl9wdXNoKHJlc3VsdCwgXCJwdXNoRGVzdHJveVwiKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3B1c2g6IGZ1bmN0aW9uKHJlc3VsdCwgb3BlcmF0aW9uKSB7XG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fcmVhZERhdGEocmVzdWx0KTtcblxuXHQgICAgICAgICAgICBpZiAoIWRhdGEpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGEgPSByZXN1bHQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGlzW29wZXJhdGlvbl0oZGF0YSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9mbGF0RGF0YTogZnVuY3Rpb24oZGF0YSwgc2tpcCkge1xuXHQgICAgICAgICAgICBpZiAoZGF0YSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2VydmVyR3JvdXBlZCgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5Hcm91cHMoZGF0YSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmICghc2tpcCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGRhdGEubGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmF0KGlkeCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHBhcmVudDogbm9vcCxcblxuXHQgICAgICAgIGdldDogZnVuY3Rpb24oaWQpIHtcblx0ICAgICAgICAgICAgdmFyIGlkeCwgbGVuZ3RoLCBkYXRhID0gdGhpcy5fZmxhdERhdGEodGhpcy5fZGF0YSwgdGhpcy5vcHRpb25zLnVzZVJhbmdlcyk7XG5cblx0ICAgICAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGRhdGFbaWR4XS5pZCA9PSBpZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2lkeF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZ2V0QnlVaWQ6IGZ1bmN0aW9uKGlkKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRCeVVpZChpZCwgdGhpcy5fZGF0YSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9nZXRCeVVpZDogZnVuY3Rpb24oaWQsIGRhdGFJdGVtcykge1xuXHQgICAgICAgICAgICB2YXIgaWR4LCBsZW5ndGgsIGRhdGEgPSB0aGlzLl9mbGF0RGF0YShkYXRhSXRlbXMsIHRoaXMub3B0aW9ucy51c2VSYW5nZXMpO1xuXG5cdCAgICAgICAgICAgIGlmICghZGF0YSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGRhdGFbaWR4XS51aWQgPT0gaWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtpZHhdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGluZGV4T2Y6IGZ1bmN0aW9uKG1vZGVsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBpbmRleE9mTW9kZWwodGhpcy5fZGF0YSwgbW9kZWwpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBhdDogZnVuY3Rpb24oaW5kZXgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuYXQoaW5kZXgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBkYXRhOiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9kZXRhY2hPYnNlcnZhYmxlUGFyZW50cygpO1xuXHQgICAgICAgICAgICAgICAgdGhhdC5fZGF0YSA9IHRoaXMuX29ic2VydmUodmFsdWUpO1xuXG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9wcmlzdGluZURhdGEgPSB2YWx1ZS5zbGljZSgwKTtcblxuXHQgICAgICAgICAgICAgICAgdGhhdC5fc3RvcmVEYXRhKCk7XG5cblx0ICAgICAgICAgICAgICAgIHRoYXQuX3JhbmdlcyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgdGhhdC50cmlnZ2VyKFwicmVzZXRcIik7XG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9hZGRSYW5nZSh0aGF0Ll9kYXRhKTtcblxuXHQgICAgICAgICAgICAgICAgdGhhdC5fdG90YWwgPSB0aGF0Ll9kYXRhLmxlbmd0aDtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX3ByaXN0aW5lVG90YWwgPSB0aGF0Ll90b3RhbDtcblxuXHQgICAgICAgICAgICAgICAgdGhhdC5fcHJvY2Vzcyh0aGF0Ll9kYXRhKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9kYXRhKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdGhhdC5fZGF0YS5sZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX2RhdGEuYXQoaWR4KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGF0Ll9kYXRhO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHZpZXc6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlldztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXcgPSB0aGlzLl9vYnNlcnZlVmlldyh2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX29ic2VydmVWaWV3OiBmdW5jdGlvbihkYXRhKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblx0ICAgICAgICAgICAgcmVwbGFjZVdpdGhPYnNlcnZhYmxlKGRhdGEsIHRoYXQuX2RhdGEsIHRoYXQuX3JhbmdlcywgdGhhdC5yZWFkZXIubW9kZWwgfHwgT2JzZXJ2YWJsZU9iamVjdCwgdGhhdC5faXNTZXJ2ZXJHcm91cGVkKCkpO1xuXG5cdCAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IExhenlPYnNlcnZhYmxlQXJyYXkoZGF0YSwgdGhhdC5yZWFkZXIubW9kZWwpO1xuXHQgICAgICAgICAgICB2aWV3LnBhcmVudCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhhdC5wYXJlbnQoKTsgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIHZpZXc7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGZsYXRWaWV3OiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXAoKSB8fCBbXTtcblxuXHQgICAgICAgICAgICBpZiAoZ3JvdXBzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5Hcm91cHModGhpcy5fdmlldyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlldztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBhZGQ6IGZ1bmN0aW9uKG1vZGVsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmluc2VydCh0aGlzLl9kYXRhLmxlbmd0aCwgbW9kZWwpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfY3JlYXRlTmV3TW9kZWw6IGZ1bmN0aW9uKG1vZGVsKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLnJlYWRlci5tb2RlbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzLnJlYWRlci5tb2RlbChtb2RlbCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAobW9kZWwgaW5zdGFuY2VvZiBPYnNlcnZhYmxlT2JqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWw7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGVPYmplY3QobW9kZWwpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBpbnNlcnQ6IGZ1bmN0aW9uKGluZGV4LCBtb2RlbCkge1xuXHQgICAgICAgICAgICBpZiAoIW1vZGVsKSB7XG5cdCAgICAgICAgICAgICAgICBtb2RlbCA9IGluZGV4O1xuXHQgICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKCEobW9kZWwgaW5zdGFuY2VvZiBNb2RlbCkpIHtcblx0ICAgICAgICAgICAgICAgIG1vZGVsID0gdGhpcy5fY3JlYXRlTmV3TW9kZWwobW9kZWwpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2VydmVyR3JvdXBlZCgpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9kYXRhLnNwbGljZShpbmRleCwgMCwgdGhpcy5fd3JhcEluRW1wdHlHcm91cChtb2RlbCkpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fZGF0YS5zcGxpY2UoaW5kZXgsIDAsIG1vZGVsKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoaXMuX2luc2VydE1vZGVsSW5SYW5nZShpbmRleCwgbW9kZWwpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBtb2RlbDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgcHVzaEluc2VydDogZnVuY3Rpb24oaW5kZXgsIGl0ZW1zKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblx0ICAgICAgICAgICAgdmFyIHJhbmdlU3BhbiA9IHRoYXQuX2dldEN1cnJlbnRSYW5nZVNwYW4oKTtcblxuXHQgICAgICAgICAgICBpZiAoIWl0ZW1zKSB7XG5cdCAgICAgICAgICAgICAgICBpdGVtcyA9IGluZGV4O1xuXHQgICAgICAgICAgICAgICAgaW5kZXggPSAwO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKCFpc0FycmF5KGl0ZW1zKSkge1xuXHQgICAgICAgICAgICAgICAgaXRlbXMgPSBbaXRlbXNdO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdmFyIHB1c2hlZCA9IFtdO1xuXHQgICAgICAgICAgICB2YXIgYXV0b1N5bmMgPSB0aGlzLm9wdGlvbnMuYXV0b1N5bmM7XG5cdCAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hdXRvU3luYyA9IGZhbHNlO1xuXG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBpdGVtcy5sZW5ndGg7IGlkeCArKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbaWR4XTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmluc2VydChpbmRleCwgaXRlbSk7XG5cblx0ICAgICAgICAgICAgICAgICAgICBwdXNoZWQucHVzaChyZXN1bHQpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByaXN0aW5lID0gcmVzdWx0LnRvSlNPTigpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2VydmVyR3JvdXBlZCgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHByaXN0aW5lID0gdGhpcy5fd3JhcEluRW1wdHlHcm91cChwcmlzdGluZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpc3RpbmVEYXRhLnB1c2gocHJpc3RpbmUpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlU3BhbiAmJiByYW5nZVNwYW4ubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICQocmFuZ2VTcGFuKS5sYXN0KClbMF0ucHJpc3RpbmVEYXRhLnB1c2gocHJpc3RpbmUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZmluYWxseSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuYXV0b1N5bmMgPSBhdXRvU3luYztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmIChwdXNoZWQubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJwdXNoXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNyZWF0ZVwiLFxuXHQgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBwdXNoZWRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHB1c2hDcmVhdGU6IGZ1bmN0aW9uKGl0ZW1zKSB7XG5cdCAgICAgICAgICAgIHRoaXMucHVzaEluc2VydCh0aGlzLl9kYXRhLmxlbmd0aCwgaXRlbXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBwdXNoVXBkYXRlOiBmdW5jdGlvbihpdGVtcykge1xuXHQgICAgICAgICAgICBpZiAoIWlzQXJyYXkoaXRlbXMpKSB7XG5cdCAgICAgICAgICAgICAgICBpdGVtcyA9IFtpdGVtc107XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB2YXIgcHVzaGVkID0gW107XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgaXRlbXMubGVuZ3RoOyBpZHggKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbaWR4XTtcblx0ICAgICAgICAgICAgICAgIHZhciBtb2RlbCA9IHRoaXMuX2NyZWF0ZU5ld01vZGVsKGl0ZW0pO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5nZXQobW9kZWwuaWQpO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcHVzaGVkLnB1c2godGFyZ2V0KTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHRhcmdldC5hY2NlcHQoaXRlbSk7XG5cblx0ICAgICAgICAgICAgICAgICAgICB0YXJnZXQudHJpZ2dlcihDSEFOR0UpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUHJpc3RpbmVGb3JNb2RlbCh0YXJnZXQsIGl0ZW0pO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hDcmVhdGUoaXRlbSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAocHVzaGVkLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwicHVzaFwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcblx0ICAgICAgICAgICAgICAgICAgICBpdGVtczogcHVzaGVkXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBwdXNoRGVzdHJveTogZnVuY3Rpb24oaXRlbXMpIHtcblx0ICAgICAgICAgICAgdmFyIHB1c2hlZCA9IHRoaXMuX3JlbW92ZUl0ZW1zKGl0ZW1zKTtcblxuXHQgICAgICAgICAgICBpZiAocHVzaGVkLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwicHVzaFwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkZXN0cm95XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgaXRlbXM6IHB1c2hlZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3JlbW92ZUl0ZW1zOiBmdW5jdGlvbihpdGVtcywgcmVtb3ZlUHJpc3RpbmUpIHtcblx0ICAgICAgICAgICAgaWYgKCFpc0FycmF5KGl0ZW1zKSkge1xuXHQgICAgICAgICAgICAgICAgaXRlbXMgPSBbaXRlbXNdO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdmFyIHNob3VsZFJlbW92ZVByaXN0aW5lID0gdHlwZW9mIHJlbW92ZVByaXN0aW5lICE9PSBcInVuZGVmaW5lZFwiID8gcmVtb3ZlUHJpc3RpbmUgOiB0cnVlO1xuXG5cdCAgICAgICAgICAgIHZhciBkZXN0cm95ZWQgPSBbXTtcblx0ICAgICAgICAgICAgdmFyIGF1dG9TeW5jID0gdGhpcy5vcHRpb25zLmF1dG9TeW5jO1xuXHQgICAgICAgICAgICB0aGlzLm9wdGlvbnMuYXV0b1N5bmMgPSBmYWxzZTtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGl0ZW1zLmxlbmd0aDsgaWR4ICsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpZHhdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtb2RlbCA9IHRoaXMuX2NyZWF0ZU5ld01vZGVsKGl0ZW0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWFjaEl0ZW0odGhpcy5fZGF0YSwgZnVuY3Rpb24oaXRlbXMpe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBpdGVtcy5sZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zLmF0KGlkeCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5pZCA9PT0gbW9kZWwuaWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0cm95ZWQucHVzaChpdGVtKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtcy5zcGxpY2UoaWR4LCAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZCAmJiBzaG91bGRSZW1vdmVQcmlzdGluZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVQcmlzdGluZUZvck1vZGVsKG1vZGVsKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVzdHJveWVkLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hdXRvU3luYyA9IGF1dG9TeW5jO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3llZDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihtb2RlbCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0LFxuXHQgICAgICAgICAgICAgICAgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBoYXNHcm91cHMgPSB0aGF0Ll9pc1NlcnZlckdyb3VwZWQoKTtcblxuXHQgICAgICAgICAgICB0aGlzLl9lYWNoSXRlbSh0aGF0Ll9kYXRhLCBmdW5jdGlvbihpdGVtcykge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVtb3ZlTW9kZWwoaXRlbXMsIG1vZGVsKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAmJiBoYXNHcm91cHMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5pc05ldyB8fCAhcmVzdWx0LmlzTmV3KCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fZGVzdHJveWVkLnB1c2gocmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXG5cdCAgICAgICAgICAgIHRoaXMuX3JlbW92ZU1vZGVsRnJvbVJhbmdlcyhtb2RlbCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG1vZGVsO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBkZXN0cm95ZWQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVzdHJveWVkO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIGlkeCxcblx0ICAgICAgICAgICAgICAgIGxlbmd0aCxcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IFtdLFxuXHQgICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2ZsYXREYXRhKHRoaXMuX2RhdGEsIHRoaXMub3B0aW9ucy51c2VSYW5nZXMpO1xuXG5cdCAgICAgICAgICAgIGZvciAoaWR4ID0gMCwgbGVuZ3RoID0gZGF0YS5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChkYXRhW2lkeF0uaXNOZXcgJiYgZGF0YVtpZHhdLmlzTmV3KCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChkYXRhW2lkeF0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHVwZGF0ZWQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgaWR4LFxuXHQgICAgICAgICAgICAgICAgbGVuZ3RoLFxuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gW10sXG5cdCAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5fZmxhdERhdGEodGhpcy5fZGF0YSwgdGhpcy5vcHRpb25zLnVzZVJhbmdlcyk7XG5cblx0ICAgICAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKChkYXRhW2lkeF0uaXNOZXcgJiYgIWRhdGFbaWR4XS5pc05ldygpKSAmJiBkYXRhW2lkeF0uZGlydHkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChkYXRhW2lkeF0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHN5bmM6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBjcmVhdGVkID0gW10sXG5cdCAgICAgICAgICAgICAgICB1cGRhdGVkID0gW10sXG5cdCAgICAgICAgICAgICAgICBkZXN0cm95ZWQgPSB0aGF0Ll9kZXN0cm95ZWQ7XG5cblx0ICAgICAgICAgICAgdmFyIHByb21pc2UgPSAkLkRlZmVycmVkKCkucmVzb2x2ZSgpLnByb21pc2UoKTtcblxuXHQgICAgICAgICAgICBpZiAodGhhdC5vbmxpbmUoKSkge1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoYXQucmVhZGVyLm1vZGVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGNyZWF0ZWQgPSB0aGF0LmNyZWF0ZWQoKTtcblx0ICAgICAgICAgICAgICAgIHVwZGF0ZWQgPSB0aGF0LnVwZGF0ZWQoKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHByb21pc2VzID0gW107XG5cblx0ICAgICAgICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMuYmF0Y2ggJiYgdGhhdC50cmFuc3BvcnQuc3VibWl0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMgPSB0aGF0Ll9zZW5kU3VibWl0KGNyZWF0ZWQsIHVwZGF0ZWQsIGRlc3Ryb3llZCk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2guYXBwbHkocHJvbWlzZXMsIHRoYXQuX3NlbmQoXCJjcmVhdGVcIiwgY3JlYXRlZCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2guYXBwbHkocHJvbWlzZXMsIHRoYXQuX3NlbmQoXCJ1cGRhdGVcIiwgdXBkYXRlZCkpO1xuXHQgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2guYXBwbHkocHJvbWlzZXMsIHRoYXQuX3NlbmQoXCJkZXN0cm95XCIsIGRlc3Ryb3llZCkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBwcm9taXNlID0gJC53aGVuXG5cdCAgICAgICAgICAgICAgICAgLmFwcGx5KG51bGwsIHByb21pc2VzKVxuXHQgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpZHgsIGxlbmd0aDtcblxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoaWR4ID0gMCwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKyl7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaWR4XSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fYWNjZXB0KGFyZ3VtZW50c1tpZHhdKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuX3N0b3JlRGF0YSh0cnVlKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuX3N5bmNFbmQoKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuX2NoYW5nZSh7IGFjdGlvbjogXCJzeW5jXCIgfSk7XG5cblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXIoU1lOQyk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX3N0b3JlRGF0YSh0cnVlKTtcblxuXHQgICAgICAgICAgICAgICAgdGhhdC5fc3luY0VuZCgpO1xuXG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9jaGFuZ2UoeyBhY3Rpb246IFwic3luY1wiIH0pO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9zeW5jRW5kOiBub29wLFxuXG5cdCAgICAgICAgY2FuY2VsQ2hhbmdlczogZnVuY3Rpb24obW9kZWwpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG5cdCAgICAgICAgICAgIGlmIChtb2RlbCBpbnN0YW5jZW9mIGtlbmRvLmRhdGEuTW9kZWwpIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX2NhbmNlbE1vZGVsKG1vZGVsKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX2Rlc3Ryb3llZCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgdGhhdC5fZGV0YWNoT2JzZXJ2YWJsZVBhcmVudHMoKTtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX2RhdGEgPSB0aGF0Ll9vYnNlcnZlKHRoYXQuX3ByaXN0aW5lRGF0YSk7XG5cdCAgICAgICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnNlcnZlclBhZ2luZykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuX3RvdGFsID0gdGhhdC5fcHJpc3RpbmVUb3RhbDtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdGhhdC5fcmFuZ2VzID0gW107XG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9hZGRSYW5nZSh0aGF0Ll9kYXRhLCAwKTtcblxuXHQgICAgICAgICAgICAgICAgdGhhdC5fY2hhbmdlc0NhbmNlbGVkKCk7XG5cblx0ICAgICAgICAgICAgICAgIHRoYXQuX2NoYW5nZSgpO1xuXG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9tYXJrT2ZmbGluZVVwZGF0ZXNBc0RpcnR5KCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2NoYW5nZXNDYW5jZWxlZDogbm9vcCxcblxuXHQgICAgICAgIF9tYXJrT2ZmbGluZVVwZGF0ZXNBc0RpcnR5OiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG5cdCAgICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMub2ZmbGluZVN0b3JhZ2UgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgdGhhdC5fZWFjaEl0ZW0odGhhdC5fZGF0YSwgZnVuY3Rpb24oaXRlbXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBpdGVtcy5sZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gaXRlbXMuYXQoaWR4KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uX19zdGF0ZV9fID09IFwidXBkYXRlXCIgfHwgaXRlbS5fX3N0YXRlX18gPT0gXCJjcmVhdGVcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5kaXJ0eSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBoYXNDaGFuZ2VzOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIGlkeCxcblx0ICAgICAgICAgICAgICAgIGxlbmd0aCxcblx0ICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9mbGF0RGF0YSh0aGlzLl9kYXRhLCB0aGlzLm9wdGlvbnMudXNlUmFuZ2VzKTtcblxuXHQgICAgICAgICAgICBpZiAodGhpcy5fZGVzdHJveWVkLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBmb3IgKGlkeCA9IDAsIGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoKGRhdGFbaWR4XS5pc05ldyAmJiBkYXRhW2lkeF0uaXNOZXcoKSkgfHwgZGF0YVtpZHhdLmRpcnR5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9hY2NlcHQ6IGZ1bmN0aW9uKHJlc3VsdCkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBtb2RlbHMgPSByZXN1bHQubW9kZWxzLFxuXHQgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXN1bHQucmVzcG9uc2UsXG5cdCAgICAgICAgICAgICAgICBpZHggPSAwLFxuXHQgICAgICAgICAgICAgICAgc2VydmVyR3JvdXAgPSB0aGF0Ll9pc1NlcnZlckdyb3VwZWQoKSxcblx0ICAgICAgICAgICAgICAgIHByaXN0aW5lID0gdGhhdC5fcHJpc3RpbmVEYXRhLFxuXHQgICAgICAgICAgICAgICAgdHlwZSA9IHJlc3VsdC50eXBlLFxuXHQgICAgICAgICAgICAgICAgbGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIHRoYXQudHJpZ2dlcihSRVFVRVNURU5ELCB7IHJlc3BvbnNlOiByZXNwb25zZSwgdHlwZTogdHlwZSB9KTtcblxuXHQgICAgICAgICAgICBpZiAocmVzcG9uc2UgJiYgIWlzRW1wdHlPYmplY3QocmVzcG9uc2UpKSB7XG5cdCAgICAgICAgICAgICAgICByZXNwb25zZSA9IHRoYXQucmVhZGVyLnBhcnNlKHJlc3BvbnNlKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHRoYXQuX2hhbmRsZUN1c3RvbUVycm9ycyhyZXNwb25zZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gdGhhdC5yZWFkZXIuZGF0YShyZXNwb25zZSk7XG5cblx0ICAgICAgICAgICAgICAgIGlmICghaXNBcnJheShyZXNwb25zZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IFtyZXNwb25zZV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXNwb25zZSA9ICQubWFwKG1vZGVscywgZnVuY3Rpb24obW9kZWwpIHsgcmV0dXJuIG1vZGVsLnRvSlNPTigpOyB9ICk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJkZXN0cm95XCIpIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX2Rlc3Ryb3llZCA9IFtdO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSBtb2RlbHMubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gXCJkZXN0cm95XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBtb2RlbHNbaWR4XS5hY2NlcHQocmVzcG9uc2VbaWR4XSk7XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJjcmVhdGVcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcmlzdGluZS5wdXNoKHNlcnZlckdyb3VwID8gdGhhdC5fd3JhcEluRW1wdHlHcm91cChtb2RlbHNbaWR4XS50b0pTT04oKSkgOiByZXNwb25zZVtpZHhdKTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidXBkYXRlXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fdXBkYXRlUHJpc3RpbmVGb3JNb2RlbChtb2RlbHNbaWR4XSwgcmVzcG9uc2VbaWR4XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0Ll9yZW1vdmVQcmlzdGluZUZvck1vZGVsKG1vZGVsc1tpZHhdKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfdXBkYXRlUHJpc3RpbmVGb3JNb2RlbDogZnVuY3Rpb24obW9kZWwsIHZhbHVlcykge1xuXHQgICAgICAgICAgICB0aGlzLl9leGVjdXRlT25QcmlzdGluZUZvck1vZGVsKG1vZGVsLCBmdW5jdGlvbihpbmRleCwgaXRlbXMpIHtcblx0ICAgICAgICAgICAgICAgIGtlbmRvLmRlZXBFeHRlbmQoaXRlbXNbaW5kZXhdLCB2YWx1ZXMpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2V4ZWN1dGVPblByaXN0aW5lRm9yTW9kZWw6IGZ1bmN0aW9uKG1vZGVsLCBjYWxsYmFjaykge1xuXHQgICAgICAgICAgICB0aGlzLl9lYWNoUHJpc3RpbmVJdGVtKFxuXHQgICAgICAgICAgICAgICAgZnVuY3Rpb24oaXRlbXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBpbmRleE9mUHJpc3RpbmVNb2RlbChpdGVtcywgbW9kZWwpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGluZGV4LCBpdGVtcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfcmVtb3ZlUHJpc3RpbmVGb3JNb2RlbDogZnVuY3Rpb24obW9kZWwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZXhlY3V0ZU9uUHJpc3RpbmVGb3JNb2RlbChtb2RlbCwgZnVuY3Rpb24oaW5kZXgsIGl0ZW1zKSB7XG5cdCAgICAgICAgICAgICAgICBpdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3JlYWREYXRhOiBmdW5jdGlvbihkYXRhKSB7XG5cdCAgICAgICAgICAgIHZhciByZWFkID0gIXRoaXMuX2lzU2VydmVyR3JvdXBlZCgpID8gdGhpcy5yZWFkZXIuZGF0YSA6IHRoaXMucmVhZGVyLmdyb3Vwcztcblx0ICAgICAgICAgICAgcmV0dXJuIHJlYWQuY2FsbCh0aGlzLnJlYWRlciwgZGF0YSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9lYWNoUHJpc3RpbmVJdGVtOiBmdW5jdGlvbihjYWxsYmFjaykge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciBvcHRpb25zID0gdGhhdC5vcHRpb25zO1xuXHQgICAgICAgICAgICB2YXIgcmFuZ2VTcGFuID0gdGhhdC5fZ2V0Q3VycmVudFJhbmdlU3BhbigpO1xuXG5cdCAgICAgICAgICAgIHRoYXQuX2VhY2hJdGVtKHRoYXQuX3ByaXN0aW5lRGF0YSwgY2FsbGJhY2spO1xuXG5cdCAgICAgICAgICAgIGlmIChvcHRpb25zLnNlcnZlclBhZ2luZyAmJiBvcHRpb25zLnVzZVJhbmdlcykge1xuXHQgICAgICAgICAgICAgICAgZWFjaChyYW5nZVNwYW4sIGZ1bmN0aW9uKGksIHJhbmdlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC5fZWFjaEl0ZW0ocmFuZ2UucHJpc3RpbmVEYXRhLCBjYWxsYmFjayk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgIF9lYWNoSXRlbTogZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1NlcnZlckdyb3VwZWQoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGVhY2hHcm91cEl0ZW1zKGRhdGEsIGNhbGxiYWNrKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3ByaXN0aW5lRm9yTW9kZWw6IGZ1bmN0aW9uKG1vZGVsKSB7XG5cdCAgICAgICAgICAgIHZhciBwcmlzdGluZSxcblx0ICAgICAgICAgICAgICAgIGlkeCxcblx0ICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oaXRlbXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZHggPSBpbmRleE9mUHJpc3RpbmVNb2RlbChpdGVtcywgbW9kZWwpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpZHggPiAtMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcmlzdGluZSA9IGl0ZW1zW2lkeF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgdGhpcy5fZWFjaFByaXN0aW5lSXRlbShjYWxsYmFjayk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHByaXN0aW5lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfY2FuY2VsTW9kZWw6IGZ1bmN0aW9uKG1vZGVsKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblx0ICAgICAgICAgICAgdmFyIHByaXN0aW5lID0gdGhpcy5fcHJpc3RpbmVGb3JNb2RlbChtb2RlbCk7XG5cblx0ICAgICAgICAgICAgdGhpcy5fZWFjaEl0ZW0odGhpcy5fZGF0YSwgZnVuY3Rpb24oaXRlbXMpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpZHggPSBpbmRleE9mTW9kZWwoaXRlbXMsIG1vZGVsKTtcblx0ICAgICAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcmlzdGluZSAmJiAoIW1vZGVsLmlzTmV3KCkgfHwgcHJpc3RpbmUuX19zdGF0ZV9fKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpZHhdLmFjY2VwdChwcmlzdGluZSk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByaXN0aW5lLl9fc3RhdGVfXyA9PSBcInVwZGF0ZVwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtc1tpZHhdLmRpcnR5ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fbW9kZWxDYW5jZWxlZChtb2RlbCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMuc3BsaWNlKGlkeCwgMSk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fcmVtb3ZlTW9kZWxGcm9tUmFuZ2VzKG1vZGVsKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbW9kZWxDYW5jZWxlZDogbm9vcCxcblxuXHQgICAgICAgIF9zdWJtaXQ6IGZ1bmN0aW9uKHByb21pc2VzLCBkYXRhKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuXHQgICAgICAgICAgICB0aGF0LnRyaWdnZXIoUkVRVUVTVFNUQVJULCB7IHR5cGU6IFwic3VibWl0XCIgfSk7XG5cblx0ICAgICAgICAgICAgdGhhdC50cmlnZ2VyKFBST0dSRVNTKTtcblxuXHQgICAgICAgICAgICB0aGF0LnRyYW5zcG9ydC5zdWJtaXQoZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHJlc3BvbnNlLCB0eXBlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSAkLmdyZXAocHJvbWlzZXMsIGZ1bmN0aW9uKHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHgudHlwZSA9PSB0eXBlO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pWzBdO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsczogcHJvbWlzZS5tb2RlbHMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24ocmVzcG9uc2UsIHN0YXR1cywgZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBwcm9taXNlcy5sZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzW2lkeF0ucmVqZWN0KHJlc3BvbnNlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LmVycm9yKHJlc3BvbnNlLCBzdGF0dXMsIGVycm9yKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSwgZGF0YSkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfc2VuZFN1Ym1pdDogZnVuY3Rpb24oY3JlYXRlZCwgdXBkYXRlZCwgZGVzdHJveWVkKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcblx0ICAgICAgICAgICAgICAgIHByb21pc2VzID0gW107XG5cblx0ICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5iYXRjaCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGNyZWF0ZWQubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkLkRlZmVycmVkKGZ1bmN0aW9uKGRlZmVycmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnR5cGUgPSBcImNyZWF0ZVwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5tb2RlbHMgPSBjcmVhdGVkO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWQubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCgkLkRlZmVycmVkKGZ1bmN0aW9uKGRlZmVycmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnR5cGUgPSBcInVwZGF0ZVwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5tb2RlbHMgPSB1cGRhdGVkO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKGRlc3Ryb3llZC5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKCQuRGVmZXJyZWQoZnVuY3Rpb24oZGVmZXJyZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQudHlwZSA9IFwiZGVzdHJveVwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5tb2RlbHMgPSBkZXN0cm95ZWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9zdWJtaXQocHJvbWlzZXMsIHtcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZWQ6IHRoYXQucmVhZGVyLnNlcmlhbGl6ZSh0b0pTT04oY3JlYXRlZCkpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkOiB0aGF0LnJlYWRlci5zZXJpYWxpemUodG9KU09OKHVwZGF0ZWQpKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJveWVkOiB0aGF0LnJlYWRlci5zZXJpYWxpemUodG9KU09OKGRlc3Ryb3llZCkpXG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9wcm9taXNlOiBmdW5jdGlvbihkYXRhLCBtb2RlbHMsIHR5cGUpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG5cdCAgICAgICAgICAgIHJldHVybiAkLkRlZmVycmVkKGZ1bmN0aW9uKGRlZmVycmVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXIoUkVRVUVTVFNUQVJULCB7IHR5cGU6IHR5cGUgfSk7XG5cblx0ICAgICAgICAgICAgICAgIHRoYXQudHJpZ2dlcihQUk9HUkVTUyk7XG5cblx0ICAgICAgICAgICAgICAgIHRoYXQudHJhbnNwb3J0W3R5cGVdLmNhbGwodGhhdC50cmFuc3BvcnQsIGV4dGVuZCh7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24ocmVzcG9uc2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbHM6IG1vZGVscyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24ocmVzcG9uc2UsIHN0YXR1cywgZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KHJlc3BvbnNlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5lcnJvcihyZXNwb25zZSwgc3RhdHVzLCBlcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSwgZGF0YSkpO1xuXHQgICAgICAgICAgICB9KS5wcm9taXNlKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9zZW5kOiBmdW5jdGlvbihtZXRob2QsIGRhdGEpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgaWR4LFxuXHQgICAgICAgICAgICAgICAgbGVuZ3RoLFxuXHQgICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXSxcblx0ICAgICAgICAgICAgICAgIGNvbnZlcnRlZCA9IHRoYXQucmVhZGVyLnNlcmlhbGl6ZSh0b0pTT04oZGF0YSkpO1xuXG5cdCAgICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMuYmF0Y2gpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhhdC5fcHJvbWlzZSggeyBkYXRhOiB7IG1vZGVsczogY29udmVydGVkIH0gfSwgZGF0YSAsIG1ldGhvZCkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSBkYXRhLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhhdC5fcHJvbWlzZSggeyBkYXRhOiBjb252ZXJ0ZWRbaWR4XSB9LCBbIGRhdGFbaWR4XSBdLCBtZXRob2QpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgcmVhZDogZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIHBhcmFtcyA9IHRoYXQuX3BhcmFtcyhkYXRhKTtcblx0ICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpO1xuXG5cdCAgICAgICAgICAgIHRoYXQuX3F1ZXVlUmVxdWVzdChwYXJhbXMsIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGlzUHJldmVudGVkID0gdGhhdC50cmlnZ2VyKFJFUVVFU1RTVEFSVCwgeyB0eXBlOiBcInJlYWRcIiB9KTtcblx0ICAgICAgICAgICAgICAgIGlmICghaXNQcmV2ZW50ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LnRyaWdnZXIoUFJPR1JFU1MpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC5fcmFuZ2VzID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC50cmlnZ2VyKFwicmVzZXRcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQub25saW5lKCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC50cmFuc3BvcnQucmVhZCh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwYXJhbXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fcmFuZ2VzID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zdWNjZXNzKGRhdGEsIHBhcmFtcyk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5lcnJvci5hcHBseSh0aGF0LCBhcmdzKTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdC5hcHBseShkZWZlcnJlZCwgYXJncyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhhdC5vcHRpb25zLm9mZmxpbmVTdG9yYWdlICE9IG51bGwpe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnN1Y2Nlc3ModGhhdC5vZmZsaW5lRGF0YSgpLCBwYXJhbXMpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuX2RlcXVldWVSZXF1ZXN0KCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKGlzUHJldmVudGVkKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3JlYWRBZ2dyZWdhdGVzOiBmdW5jdGlvbihkYXRhKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRlci5hZ2dyZWdhdGVzKGRhdGEpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihkYXRhKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB0aGF0Lm9wdGlvbnMsXG5cdCAgICAgICAgICAgICAgICBpdGVtcyxcblx0ICAgICAgICAgICAgICAgIHJlcGxhY2VTdWJzZXQ7XG5cblx0ICAgICAgICAgICAgdGhhdC50cmlnZ2VyKFJFUVVFU1RFTkQsIHsgcmVzcG9uc2U6IGRhdGEsIHR5cGU6IFwicmVhZFwiIH0pO1xuXG5cdCAgICAgICAgICAgIGlmICh0aGF0Lm9ubGluZSgpKSB7XG5cdCAgICAgICAgICAgICAgICBkYXRhID0gdGhhdC5yZWFkZXIucGFyc2UoZGF0YSk7XG5cblx0ICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9oYW5kbGVDdXN0b21FcnJvcnMoZGF0YSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0Ll9kZXF1ZXVlUmVxdWVzdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdGhhdC5fdG90YWwgPSB0aGF0LnJlYWRlci50b3RhbChkYXRhKTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9wYWdlU2l6ZSA+IHRoYXQuX3RvdGFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC5fcGFnZVNpemUgPSB0aGF0Ll90b3RhbDtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnBhZ2VTaXplICYmIHRoYXQub3B0aW9ucy5wYWdlU2l6ZSA+IHRoYXQuX3BhZ2VTaXplKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX3BhZ2VTaXplID0gdGhhdC5vcHRpb25zLnBhZ2VTaXplO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKHRoYXQuX2FnZ3JlZ2F0ZSAmJiBvcHRpb25zLnNlcnZlckFnZ3JlZ2F0ZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0Ll9hZ2dyZWdhdGVSZXN1bHQgPSB0aGF0Ll9yZWFkQWdncmVnYXRlcyhkYXRhKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZGF0YSA9IHRoYXQuX3JlYWREYXRhKGRhdGEpO1xuXG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9kZXN0cm95ZWQgPSBbXTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGRhdGEgPSB0aGF0Ll9yZWFkRGF0YShkYXRhKTtcblxuXHQgICAgICAgICAgICAgICAgaXRlbXMgPSBbXTtcblx0ICAgICAgICAgICAgICAgIHZhciBpdGVtSWRzID0ge307XG5cdCAgICAgICAgICAgICAgICB2YXIgbW9kZWwgPSB0aGF0LnJlYWRlci5tb2RlbDtcblx0ICAgICAgICAgICAgICAgIHZhciBpZEZpZWxkID0gbW9kZWwgPyBtb2RlbC5pZEZpZWxkIDogXCJpZFwiO1xuXHQgICAgICAgICAgICAgICAgdmFyIGlkeDtcblxuXHQgICAgICAgICAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCB0aGlzLl9kZXN0cm95ZWQubGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpZCA9IHRoaXMuX2Rlc3Ryb3llZFtpZHhdW2lkRmllbGRdO1xuXHQgICAgICAgICAgICAgICAgICAgIGl0ZW1JZHNbaWRdID0gaWQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgZGF0YS5sZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBkYXRhW2lkeF07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gaXRlbS5fX3N0YXRlX187XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlID09IFwiZGVzdHJveVwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXRlbUlkc1tpdGVtW2lkRmllbGRdXSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVzdHJveWVkLnB1c2godGhpcy5fY3JlYXRlTmV3TW9kZWwoaXRlbSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGRhdGEgPSBpdGVtcztcblxuXHQgICAgICAgICAgICAgICAgdGhhdC5fdG90YWwgPSBkYXRhLmxlbmd0aDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoYXQuX3ByaXN0aW5lVG90YWwgPSB0aGF0Ll90b3RhbDtcblx0ICAgICAgICAgICAgcmVwbGFjZVN1YnNldCA9IHRoYXQuX3NraXAgJiYgdGhhdC5fZGF0YS5sZW5ndGggJiYgdGhhdC5fc2tpcCA8IHRoYXQuX2RhdGEubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMuZW5kbGVzcykge1xuXHQgICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VTdWJzZXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0Ll9wcmlzdGluZURhdGEuc3BsaWNlKHRoYXQuX3NraXAsIHRoYXQuX3ByaXN0aW5lRGF0YS5sZW5ndGgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaXRlbXMgPSBkYXRhLnNsaWNlKDApO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpdGVtcy5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuX3ByaXN0aW5lRGF0YS5wdXNoKGl0ZW1zW2pdKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX3ByaXN0aW5lRGF0YSA9IGRhdGEuc2xpY2UoMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGF0Ll9kZXRhY2hPYnNlcnZhYmxlUGFyZW50cygpO1xuXG5cdCAgICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMuZW5kbGVzcykge1xuXHQgICAgICAgICAgICAgICAgdGhhdC5fZGF0YS51bmJpbmQoQ0hBTkdFLCB0aGF0Ll9jaGFuZ2VIYW5kbGVyKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHRoYXQuX2lzU2VydmVyR3JvdXBlZCgpICYmIHRoYXQuX2RhdGFbdGhhdC5fZGF0YS5sZW5ndGggLSAxXS52YWx1ZSA9PT0gZGF0YVswXS52YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZpbGxMYXN0R3JvdXAodGhhdC5fZGF0YVt0aGF0Ll9kYXRhLmxlbmd0aCAtIDFdLCBkYXRhWzBdKTtcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhLnNoaWZ0KCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGRhdGEgPSB0aGF0Ll9vYnNlcnZlKGRhdGEpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VTdWJzZXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0Ll9kYXRhLnNwbGljZSh0aGF0Ll9za2lwLCB0aGF0Ll9kYXRhLmxlbmd0aCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0Ll9kYXRhLnB1c2goZGF0YVtpXSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9kYXRhLmJpbmQoQ0hBTkdFLCB0aGF0Ll9jaGFuZ2VIYW5kbGVyKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX2RhdGEgPSB0aGF0Ll9vYnNlcnZlKGRhdGEpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdGhhdC5fbWFya09mZmxpbmVVcGRhdGVzQXNEaXJ0eSgpO1xuXG5cdCAgICAgICAgICAgIHRoYXQuX3N0b3JlRGF0YSgpO1xuXG5cdCAgICAgICAgICAgIHRoYXQuX2FkZFJhbmdlKHRoYXQuX2RhdGEpO1xuXG5cdCAgICAgICAgICAgIHRoYXQuX3Byb2Nlc3ModGhhdC5fZGF0YSk7XG5cblx0ICAgICAgICAgICAgdGhhdC5fZGVxdWV1ZVJlcXVlc3QoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RldGFjaE9ic2VydmFibGVQYXJlbnRzOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2RhdGEgJiYgdGhpcy5fc2hvdWxkRGV0YWNoT2JzZXJ2YWJsZVBhcmVudHMpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHRoaXMuX2RhdGEubGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kYXRhW2lkeF0ucGFyZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFbaWR4XS5wYXJlbnQgPSBub29wO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfc3RvcmVEYXRhOiBmdW5jdGlvbih1cGRhdGVQcmlzdGluZSkge1xuXHQgICAgICAgICAgICB2YXIgc2VydmVyR3JvdXBpbmcgPSB0aGlzLl9pc1NlcnZlckdyb3VwZWQoKTtcblx0ICAgICAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5yZWFkZXIubW9kZWw7XG5cblx0ICAgICAgICAgICAgZnVuY3Rpb24gaXRlbXMoZGF0YSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gW107XG5cblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGRhdGEubGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhSXRlbSA9IGRhdGEuYXQoaWR4KTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGRhdGFJdGVtLnRvSlNPTigpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZlckdyb3VwaW5nICYmIGRhdGFJdGVtLml0ZW1zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uaXRlbXMgPSBpdGVtcyhkYXRhSXRlbS5pdGVtcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS51aWQgPSBkYXRhSXRlbS51aWQ7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUl0ZW0uaXNOZXcoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uX19zdGF0ZV9fID0gXCJjcmVhdGVcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YUl0ZW0uZGlydHkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLl9fc3RhdGVfXyA9IFwidXBkYXRlXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGUucHVzaChpdGVtKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vZmZsaW5lU3RvcmFnZSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3RhdGUgPSBpdGVtcyh0aGlzLl9kYXRhKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIGRlc3Ryb3llZCA9IFtdO1xuXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCB0aGlzLl9kZXN0cm95ZWQubGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5fZGVzdHJveWVkW2lkeF0udG9KU09OKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaXRlbS5fX3N0YXRlX18gPSBcImRlc3Ryb3lcIjtcblx0ICAgICAgICAgICAgICAgICAgICBkZXN0cm95ZWQucHVzaChpdGVtKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdGhpcy5vZmZsaW5lRGF0YShzdGF0ZS5jb25jYXQoZGVzdHJveWVkKSk7XG5cblx0ICAgICAgICAgICAgICAgIGlmICh1cGRhdGVQcmlzdGluZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaXN0aW5lRGF0YSA9IHRoaXMucmVhZGVyLnJlYWRlciA/IHRoaXMucmVhZGVyLnJlYWRlci5fd3JhcERhdGFBY2Nlc3NCYXNlKHN0YXRlKSA6IHRoaXMucmVhZGVyLl93cmFwRGF0YUFjY2Vzc0Jhc2Uoc3RhdGUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9hZGRSYW5nZTogZnVuY3Rpb24oZGF0YSwgc2tpcCkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBzdGFydCA9IHR5cGVvZihza2lwKSAhPT0gXCJ1bmRlZmluZWRcIiA/IHNraXAgOiAodGhhdC5fc2tpcCB8fCAwKSxcblx0ICAgICAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgdGhhdC5fZmxhdERhdGEoZGF0YSwgdHJ1ZSkubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIHRoYXQuX3Jhbmdlcy5wdXNoKHtcblx0ICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcblx0ICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuXHQgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcblx0ICAgICAgICAgICAgICAgIHByaXN0aW5lRGF0YTogZGF0YS50b0pTT04oKSxcblx0ICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogdGhhdC5fdGltZVN0YW1wKClcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgdGhhdC5fc29ydFJhbmdlcygpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfc29ydFJhbmdlczogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Jhbmdlcy5zb3J0KGZ1bmN0aW9uKHgsIHkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB4LnN0YXJ0IC0geS5zdGFydDtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGVycm9yOiBmdW5jdGlvbih4aHIsIHN0YXR1cywgZXJyb3JUaHJvd24pIHtcblx0ICAgICAgICAgICAgdGhpcy5fZGVxdWV1ZVJlcXVlc3QoKTtcblx0ICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFJFUVVFU1RFTkQsIHsgfSk7XG5cdCAgICAgICAgICAgIHRoaXMudHJpZ2dlcihFUlJPUiwgeyB4aHI6IHhociwgc3RhdHVzOiBzdGF0dXMsIGVycm9yVGhyb3duOiBlcnJvclRocm93biB9KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3BhcmFtczogZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zID0gIGV4dGVuZCh7XG5cdCAgICAgICAgICAgICAgICAgICAgdGFrZTogdGhhdC50YWtlKCksXG5cdCAgICAgICAgICAgICAgICAgICAgc2tpcDogdGhhdC5za2lwKCksXG5cdCAgICAgICAgICAgICAgICAgICAgcGFnZTogdGhhdC5wYWdlKCksXG5cdCAgICAgICAgICAgICAgICAgICAgcGFnZVNpemU6IHRoYXQucGFnZVNpemUoKSxcblx0ICAgICAgICAgICAgICAgICAgICBzb3J0OiB0aGF0Ll9zb3J0LFxuXHQgICAgICAgICAgICAgICAgICAgIGZpbHRlcjogdGhhdC5fZmlsdGVyLFxuXHQgICAgICAgICAgICAgICAgICAgIGdyb3VwOiB0aGF0Ll9ncm91cCxcblx0ICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGU6IHRoYXQuX2FnZ3JlZ2F0ZVxuXHQgICAgICAgICAgICAgICAgfSwgZGF0YSk7XG5cblx0ICAgICAgICAgICAgaWYgKCF0aGF0Lm9wdGlvbnMuc2VydmVyUGFnaW5nKSB7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy50YWtlO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuc2tpcDtcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLnBhZ2U7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5wYWdlU2l6ZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICghdGhhdC5vcHRpb25zLnNlcnZlckdyb3VwaW5nKSB7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5ncm91cDtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGF0LnJlYWRlci5tb2RlbCAmJiBvcHRpb25zLmdyb3VwKSB7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLmdyb3VwID0gY29udmVydERlc2NyaXB0b3JzRmllbGQob3B0aW9ucy5ncm91cCwgdGhhdC5yZWFkZXIubW9kZWwpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKCF0aGF0Lm9wdGlvbnMuc2VydmVyRmlsdGVyaW5nKSB7XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5maWx0ZXI7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAodGhhdC5yZWFkZXIubW9kZWwgJiYgb3B0aW9ucy5maWx0ZXIpIHtcblx0ICAgICAgICAgICAgICAgb3B0aW9ucy5maWx0ZXIgPSBjb252ZXJ0RmlsdGVyRGVzY3JpcHRvcnNGaWVsZChvcHRpb25zLmZpbHRlciwgdGhhdC5yZWFkZXIubW9kZWwpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKCF0aGF0Lm9wdGlvbnMuc2VydmVyU29ydGluZykge1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuc29ydDtcblx0ICAgICAgICAgICAgfSBlbHNlIGlmICh0aGF0LnJlYWRlci5tb2RlbCAmJiBvcHRpb25zLnNvcnQpIHtcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuc29ydCA9IGNvbnZlcnREZXNjcmlwdG9yc0ZpZWxkKG9wdGlvbnMuc29ydCwgdGhhdC5yZWFkZXIubW9kZWwpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKCF0aGF0Lm9wdGlvbnMuc2VydmVyQWdncmVnYXRlcykge1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuYWdncmVnYXRlO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoYXQucmVhZGVyLm1vZGVsICYmIG9wdGlvbnMuYWdncmVnYXRlKSB7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLmFnZ3JlZ2F0ZSA9IGNvbnZlcnREZXNjcmlwdG9yc0ZpZWxkKG9wdGlvbnMuYWdncmVnYXRlLCB0aGF0LnJlYWRlci5tb2RlbCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3F1ZXVlUmVxdWVzdDogZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXHQgICAgICAgICAgICBpZiAoIXRoYXQuX3JlcXVlc3RJblByb2dyZXNzKSB7XG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9yZXF1ZXN0SW5Qcm9ncmVzcyA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9wZW5kaW5nID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX3BlbmRpbmcgPSB7IGNhbGxiYWNrOiBwcm94eShjYWxsYmFjaywgdGhhdCksIG9wdGlvbnM6IG9wdGlvbnMgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZGVxdWV1ZVJlcXVlc3Q6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cdCAgICAgICAgICAgIHRoYXQuX3JlcXVlc3RJblByb2dyZXNzID0gZmFsc2U7XG5cdCAgICAgICAgICAgIGlmICh0aGF0Ll9wZW5kaW5nKSB7XG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9xdWV1ZVJlcXVlc3QodGhhdC5fcGVuZGluZy5vcHRpb25zLCB0aGF0Ll9wZW5kaW5nLmNhbGxiYWNrKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfaGFuZGxlQ3VzdG9tRXJyb3JzOiBmdW5jdGlvbihyZXNwb25zZSkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5yZWFkZXIuZXJyb3JzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZXJyb3JzID0gdGhpcy5yZWFkZXIuZXJyb3JzKHJlc3BvbnNlKTtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnJvcnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoRVJST1IsIHsgeGhyOiBudWxsLCBzdGF0dXM6IFwiY3VzdG9tZXJyb3JcIiwgZXJyb3JUaHJvd246IFwiY3VzdG9tIGVycm9yXCIsIGVycm9yczogZXJyb3JzIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3Nob3VsZFdyYXA6IGZ1bmN0aW9uKGRhdGEpIHtcblx0ICAgICAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5yZWFkZXIubW9kZWw7XG5cblx0ICAgICAgICAgICAgaWYgKG1vZGVsICYmIGRhdGEubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gIShkYXRhWzBdIGluc3RhbmNlb2YgbW9kZWwpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfb2JzZXJ2ZTogZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBtb2RlbCA9IHRoYXQucmVhZGVyLm1vZGVsO1xuXG5cdCAgICAgICAgICAgIHRoYXQuX3Nob3VsZERldGFjaE9ic2VydmFibGVQYXJlbnRzID0gdHJ1ZTtcblxuXHQgICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIE9ic2VydmFibGVBcnJheSkge1xuXHQgICAgICAgICAgICAgICAgdGhhdC5fc2hvdWxkRGV0YWNoT2JzZXJ2YWJsZVBhcmVudHMgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9zaG91bGRXcmFwKGRhdGEpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YS50eXBlID0gdGhhdC5yZWFkZXIubW9kZWw7XG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YS53cmFwQWxsKGRhdGEsIGRhdGEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFyIGFycmF5VHlwZSA9IHRoYXQucGFnZVNpemUoKSAmJiAhdGhhdC5vcHRpb25zLnNlcnZlclBhZ2luZyA/IExhenlPYnNlcnZhYmxlQXJyYXkgOiBPYnNlcnZhYmxlQXJyYXk7XG5cdCAgICAgICAgICAgICAgICBkYXRhID0gbmV3IGFycmF5VHlwZShkYXRhLCB0aGF0LnJlYWRlci5tb2RlbCk7XG5cdCAgICAgICAgICAgICAgICBkYXRhLnBhcmVudCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhhdC5wYXJlbnQoKTsgfTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICh0aGF0Ll9pc1NlcnZlckdyb3VwZWQoKSkge1xuXHQgICAgICAgICAgICAgICAgd3JhcEdyb3VwSXRlbXMoZGF0YSwgbW9kZWwpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHRoYXQuX2NoYW5nZUhhbmRsZXIgJiYgdGhhdC5fZGF0YSAmJiB0aGF0Ll9kYXRhIGluc3RhbmNlb2YgT2JzZXJ2YWJsZUFycmF5KSB7XG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9kYXRhLnVuYmluZChDSEFOR0UsIHRoYXQuX2NoYW5nZUhhbmRsZXIpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhhdC5fY2hhbmdlSGFuZGxlciA9IHByb3h5KHRoYXQuX2NoYW5nZSwgdGhhdCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZGF0YS5iaW5kKENIQU5HRSwgdGhhdC5fY2hhbmdlSGFuZGxlcik7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF91cGRhdGVUb3RhbEZvckFjdGlvbjogZnVuY3Rpb24oYWN0aW9uLCBpdGVtcykge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgdmFyIHRvdGFsID0gcGFyc2VJbnQodGhhdC5fdG90YWwsIDEwKTtcblxuXHQgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHRoYXQuX3RvdGFsKSkge1xuXHQgICAgICAgICAgICAgICAgdG90YWwgPSBwYXJzZUludCh0aGF0Ll9wcmlzdGluZVRvdGFsLCAxMCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gXCJhZGRcIikge1xuXHQgICAgICAgICAgICAgICAgdG90YWwgKz0gaXRlbXMubGVuZ3RoO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJyZW1vdmVcIikge1xuXHQgICAgICAgICAgICAgICAgdG90YWwgLT0gaXRlbXMubGVuZ3RoO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbiAhPT0gXCJpdGVtY2hhbmdlXCIgJiYgYWN0aW9uICE9PSBcInN5bmNcIiAmJiAhdGhhdC5vcHRpb25zLnNlcnZlclBhZ2luZykge1xuXHQgICAgICAgICAgICAgICAgdG90YWwgPSB0aGF0Ll9wcmlzdGluZVRvdGFsO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJzeW5jXCIpIHtcblx0ICAgICAgICAgICAgICAgIHRvdGFsID0gdGhhdC5fcHJpc3RpbmVUb3RhbCA9IHBhcnNlSW50KHRoYXQuX3RvdGFsLCAxMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGF0Ll90b3RhbCA9IHRvdGFsO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfY2hhbmdlOiBmdW5jdGlvbihlKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcywgaWR4LCBsZW5ndGgsIGFjdGlvbiA9IGUgPyBlLmFjdGlvbiA6IFwiXCI7XG5cblx0ICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gXCJyZW1vdmVcIikge1xuXHQgICAgICAgICAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSBlLml0ZW1zLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghZS5pdGVtc1tpZHhdLmlzTmV3IHx8ICFlLml0ZW1zW2lkeF0uaXNOZXcoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9kZXN0cm95ZWQucHVzaChlLml0ZW1zW2lkeF0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMuYXV0b1N5bmMgJiYgKGFjdGlvbiA9PT0gXCJhZGRcIiB8fCBhY3Rpb24gPT09IFwicmVtb3ZlXCIgfHwgYWN0aW9uID09PSBcIml0ZW1jaGFuZ2VcIikpIHtcblxuXHQgICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbihhcmdzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MuYWN0aW9uID09PSBcInN5bmNcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnVuYmluZChcImNoYW5nZVwiLCBoYW5kbGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fdXBkYXRlVG90YWxGb3JBY3Rpb24oYWN0aW9uLCBlLml0ZW1zKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgICAgICB0aGF0LmZpcnN0KFwiY2hhbmdlXCIsIGhhbmRsZXIpO1xuXG5cdCAgICAgICAgICAgICAgICB0aGF0LnN5bmMoKTtcblxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhhdC5fdXBkYXRlVG90YWxGb3JBY3Rpb24oYWN0aW9uLCBlID8gZS5pdGVtcyA6IFtdKTtcblxuXHQgICAgICAgICAgICAgICAgdGhhdC5fcHJvY2Vzcyh0aGF0Ll9kYXRhLCBlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfY2FsY3VsYXRlQWdncmVnYXRlczogZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0ICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gbmV3IFF1ZXJ5KGRhdGEpLFxuXHQgICAgICAgICAgICAgICAgYWdncmVnYXRlcyA9IG9wdGlvbnMuYWdncmVnYXRlLFxuXHQgICAgICAgICAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG5cblx0ICAgICAgICAgICAgaWYgKGZpbHRlcikge1xuXHQgICAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeS5maWx0ZXIoZmlsdGVyKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBxdWVyeS5hZ2dyZWdhdGUoYWdncmVnYXRlcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9wcm9jZXNzOiBmdW5jdGlvbiAoZGF0YSwgZSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zID0ge30sXG5cdCAgICAgICAgICAgICAgICByZXN1bHQ7XG5cblx0ICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5zZXJ2ZXJQYWdpbmcgIT09IHRydWUpIHtcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuc2tpcCA9IHRoYXQuX3NraXA7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLnRha2UgPSB0aGF0Ll90YWtlIHx8IHRoYXQuX3BhZ2VTaXplO1xuXG5cdCAgICAgICAgICAgICAgICBpZihvcHRpb25zLnNraXAgPT09IHVuZGVmaW5lZCAmJiB0aGF0Ll9wYWdlICE9PSB1bmRlZmluZWQgJiYgdGhhdC5fcGFnZVNpemUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2tpcCA9ICh0aGF0Ll9wYWdlIC0gMSkgKiB0aGF0Ll9wYWdlU2l6ZTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy51c2VSYW5nZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNraXAgPSB0aGF0LmN1cnJlbnRSYW5nZVN0YXJ0KCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnNlcnZlclNvcnRpbmcgIT09IHRydWUpIHtcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuc29ydCA9IHRoYXQuX3NvcnQ7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnNlcnZlckZpbHRlcmluZyAhPT0gdHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5maWx0ZXIgPSB0aGF0Ll9maWx0ZXI7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnNlcnZlckdyb3VwaW5nICE9PSB0cnVlKSB7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zLmdyb3VwID0gdGhhdC5fZ3JvdXA7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnNlcnZlckFnZ3JlZ2F0ZXMgIT09IHRydWUpIHtcblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuYWdncmVnYXRlID0gdGhhdC5fYWdncmVnYXRlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5zZXJ2ZXJHcm91cGluZykge1xuXHQgICAgICAgICAgICAgICAgdGhhdC5fY2xlYXJFbXB0eUdyb3VwcyhkYXRhKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJlc3VsdCA9IHRoYXQuX3F1ZXJ5UHJvY2VzcyhkYXRhLCBvcHRpb25zKTtcblxuXHQgICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnNlcnZlckFnZ3JlZ2F0ZXMgIT09IHRydWUpIHtcblx0ICAgICAgICAgICAgICAgIC8vIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBjYWxjdWxhdGUgYWdncmVnYXRlcyBmb3IgcGFydCBvZiB0aGUgZGF0YSBvbmx5IGFmdGVyIHF1ZXJ5IHByb2Nlc3Ncblx0ICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgbmVjZXNzYXJ5IGluIHRoZSBUcmVlTGlzdCB3aGVuIHBhZ2luZ1xuXHQgICAgICAgICAgICAgICAgdGhhdC5fYWdncmVnYXRlUmVzdWx0ID0gdGhhdC5fY2FsY3VsYXRlQWdncmVnYXRlcyhyZXN1bHQuZGF0YVRvQWdncmVnYXRlIHx8IGRhdGEsIG9wdGlvbnMpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdGhhdC52aWV3KHJlc3VsdC5kYXRhKTtcblxuXHQgICAgICAgICAgICB0aGF0Ll9zZXRGaWx0ZXJUb3RhbChyZXN1bHQudG90YWwsIGZhbHNlKTtcblxuXHQgICAgICAgICAgICBlID0gZSB8fCB7fTtcblxuXHQgICAgICAgICAgICBlLml0ZW1zID0gZS5pdGVtcyB8fCB0aGF0Ll92aWV3O1xuXG5cdCAgICAgICAgICAgIHRoYXQudHJpZ2dlcihDSEFOR0UsIGUpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfY2xlYXJFbXB0eUdyb3VwczogZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpZHggPSBkYXRhLmxlbmd0aCAtIDE7IGlkeCA+PTA7IGlkeC0tKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZ3JvdXAgPSBkYXRhW2lkeF07XG5cdCAgICAgICAgICAgICAgICBpZiAoZ3JvdXAuaGFzU3ViZ3JvdXBzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJFbXB0eUdyb3Vwcyhncm91cC5pdGVtcyk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChncm91cC5pdGVtcyAmJiAhZ3JvdXAuaXRlbXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNwbGljZS5hcHBseShncm91cC5wYXJlbnQoKSwgW2lkeCwgMV0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfcXVlcnlQcm9jZXNzOiBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5QbGFjZVNvcnQpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBRdWVyeS5wcm9jZXNzKGRhdGEsIG9wdGlvbnMsIHRoaXMub3B0aW9ucy5pblBsYWNlU29ydCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gUXVlcnkucHJvY2VzcyhkYXRhLCBvcHRpb25zKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbWVyZ2VTdGF0ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdGhhdC5fcGFnZVNpemUgPSBvcHRpb25zLnBhZ2VTaXplO1xuXHQgICAgICAgICAgICAgICAgdGhhdC5fcGFnZSA9IG9wdGlvbnMucGFnZTtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX3NvcnQgPSBvcHRpb25zLnNvcnQ7XG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9maWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX2dyb3VwID0gb3B0aW9ucy5ncm91cDtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX2FnZ3JlZ2F0ZSA9IG9wdGlvbnMuYWdncmVnYXRlO1xuXHQgICAgICAgICAgICAgICAgdGhhdC5fc2tpcCA9IHRoYXQuX2N1cnJlbnRSYW5nZVN0YXJ0ID0gb3B0aW9ucy5za2lwO1xuXHQgICAgICAgICAgICAgICAgdGhhdC5fdGFrZSA9IG9wdGlvbnMudGFrZTtcblxuXHQgICAgICAgICAgICAgICAgaWYodGhhdC5fc2tpcCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC5fc2tpcCA9IHRoYXQuX2N1cnJlbnRSYW5nZVN0YXJ0ID0gdGhhdC5za2lwKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5za2lwID0gdGhhdC5za2lwKCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmKHRoYXQuX3Rha2UgPT09IHVuZGVmaW5lZCAmJiB0aGF0Ll9wYWdlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC5fdGFrZSA9IHRoYXQuX3BhZ2VTaXplO1xuXHQgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMudGFrZSA9IHRoYXQuX3Rha2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNvcnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0Ll9zb3J0ID0gb3B0aW9ucy5zb3J0ID0gbm9ybWFsaXplU29ydChvcHRpb25zLnNvcnQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5maWx0ZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0Ll9maWx0ZXIgPSBvcHRpb25zLmZpbHRlciA9IG5vcm1hbGl6ZUZpbHRlcihvcHRpb25zLmZpbHRlcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmdyb3VwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC5fZ3JvdXAgPSBvcHRpb25zLmdyb3VwID0gbm9ybWFsaXplR3JvdXAob3B0aW9ucy5ncm91cCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hZ2dyZWdhdGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0Ll9hZ2dyZWdhdGUgPSBvcHRpb25zLmFnZ3JlZ2F0ZSA9IG5vcm1hbGl6ZUFnZ3JlZ2F0ZShvcHRpb25zLmFnZ3JlZ2F0ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHF1ZXJ5OiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQ7XG5cdCAgICAgICAgICAgIHZhciByZW1vdGUgPSB0aGlzLm9wdGlvbnMuc2VydmVyU29ydGluZyB8fCB0aGlzLm9wdGlvbnMuc2VydmVyUGFnaW5nIHx8IHRoaXMub3B0aW9ucy5zZXJ2ZXJGaWx0ZXJpbmcgfHwgdGhpcy5vcHRpb25zLnNlcnZlckdyb3VwaW5nIHx8IHRoaXMub3B0aW9ucy5zZXJ2ZXJBZ2dyZWdhdGVzO1xuXG5cdCAgICAgICAgICAgIGlmIChyZW1vdGUgfHwgKCh0aGlzLl9kYXRhID09PSB1bmRlZmluZWQgfHwgdGhpcy5fZGF0YS5sZW5ndGggPT09IDApICYmICF0aGlzLl9kZXN0cm95ZWQubGVuZ3RoKSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmRsZXNzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1vcmVJdGVtc0NvdW50ID0gb3B0aW9ucy5wYWdlU2l6ZSAtIHRoaXMucGFnZVNpemUoKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobW9yZUl0ZW1zQ291bnQgPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1vcmVJdGVtc0NvdW50ID0gdGhpcy5wYWdlU2l6ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhZ2UgPSBvcHRpb25zLnBhZ2VTaXplIC8gbW9yZUl0ZW1zQ291bnQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFnZVNpemUgPSBtb3JlSXRlbXNDb3VudDtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhZ2UgPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5kbGVzcyA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWQodGhpcy5fbWVyZ2VTdGF0ZShvcHRpb25zKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB2YXIgaXNQcmV2ZW50ZWQgPSB0aGlzLnRyaWdnZXIoUkVRVUVTVFNUQVJULCB7IHR5cGU6IFwicmVhZFwiIH0pO1xuXHQgICAgICAgICAgICBpZiAoIWlzUHJldmVudGVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoUFJPR1JFU1MpO1xuXG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9xdWVyeVByb2Nlc3ModGhpcy5fZGF0YSwgdGhpcy5fbWVyZ2VTdGF0ZShvcHRpb25zKSk7XG5cblx0ICAgICAgICAgICAgICAgIHRoaXMuX3NldEZpbHRlclRvdGFsKHJlc3VsdC50b3RhbCwgdHJ1ZSk7XG5cblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FnZ3JlZ2F0ZVJlc3VsdCA9IHRoaXMuX2NhbGN1bGF0ZUFnZ3JlZ2F0ZXMocmVzdWx0LmRhdGFUb0FnZ3JlZ2F0ZSB8fCB0aGlzLl9kYXRhLCBvcHRpb25zKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMudmlldyhyZXN1bHQuZGF0YSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoUkVRVUVTVEVORCwgeyB0eXBlOiBcInJlYWRcIiB9KTtcblx0ICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihDSEFOR0UsIHsgaXRlbXM6IHJlc3VsdC5kYXRhIH0pO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuICQuRGVmZXJyZWQoKS5yZXNvbHZlKGlzUHJldmVudGVkKS5wcm9taXNlKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9zZXRGaWx0ZXJUb3RhbDogZnVuY3Rpb24oZmlsdGVyVG90YWwsIHNldERlZmF1bHRWYWx1ZSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgaWYgKCF0aGF0Lm9wdGlvbnMuc2VydmVyRmlsdGVyaW5nKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZmlsdGVyVG90YWwgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuX3RvdGFsID0gZmlsdGVyVG90YWw7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNldERlZmF1bHRWYWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuX3RvdGFsID0gdGhhdC5fZGF0YS5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZmV0Y2g6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblx0ICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24oaXNQcmV2ZW50ZWQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpc1ByZXZlbnRlZCAhPT0gdHJ1ZSAmJiBpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhhdCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJ5KCkudGhlbihmbik7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9xdWVyeTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHRoYXQucXVlcnkoZXh0ZW5kKHt9LCB7XG5cdCAgICAgICAgICAgICAgICBwYWdlOiB0aGF0LnBhZ2UoKSxcblx0ICAgICAgICAgICAgICAgIHBhZ2VTaXplOiB0aGF0LnBhZ2VTaXplKCksXG5cdCAgICAgICAgICAgICAgICBzb3J0OiB0aGF0LnNvcnQoKSxcblx0ICAgICAgICAgICAgICAgIGZpbHRlcjogdGhhdC5maWx0ZXIoKSxcblx0ICAgICAgICAgICAgICAgIGdyb3VwOiB0aGF0Lmdyb3VwKCksXG5cdCAgICAgICAgICAgICAgICBhZ2dyZWdhdGU6IHRoYXQuYWdncmVnYXRlKClcblx0ICAgICAgICAgICAgfSwgb3B0aW9ucykpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBuZXh0OiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcblx0ICAgICAgICAgICAgICAgIHBhZ2UgPSB0aGF0LnBhZ2UoKSxcblx0ICAgICAgICAgICAgICAgIHRvdGFsID0gdGhhdC50b3RhbCgpO1xuXG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdCAgICAgICAgICAgIGlmICghcGFnZSB8fCAodG90YWwgJiYgcGFnZSArIDEgPiB0aGF0LnRvdGFsUGFnZXMoKSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoYXQuX3NraXAgPSB0aGF0Ll9jdXJyZW50UmFuZ2VTdGFydCA9IHBhZ2UgKiB0aGF0LnRha2UoKTtcblxuXHQgICAgICAgICAgICBwYWdlICs9IDE7XG5cdCAgICAgICAgICAgIG9wdGlvbnMucGFnZSA9IHBhZ2U7XG5cblx0ICAgICAgICAgICAgdGhhdC5fcXVlcnkob3B0aW9ucyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHBhZ2U7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHByZXY6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgcGFnZSA9IHRoYXQucGFnZSgpO1xuXG5cdCAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdCAgICAgICAgICAgIGlmICghcGFnZSB8fCBwYWdlID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGF0Ll9za2lwID0gdGhhdC5fY3VycmVudFJhbmdlU3RhcnQgPSB0aGF0Ll9za2lwIC0gdGhhdC50YWtlKCk7XG5cblx0ICAgICAgICAgICAgcGFnZSAtPSAxO1xuXHQgICAgICAgICAgICBvcHRpb25zLnBhZ2UgPSBwYWdlO1xuXG5cdCAgICAgICAgICAgIHRoYXQuX3F1ZXJ5KG9wdGlvbnMpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBwYWdlO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBwYWdlOiBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICBza2lwO1xuXG5cdCAgICAgICAgICAgIGlmKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB2YWwgPSBtYXRoLm1heChtYXRoLm1pbihtYXRoLm1heCh2YWwsIDEpLCB0aGF0LnRvdGFsUGFnZXMoKSksIDEpO1xuXHQgICAgICAgICAgICAgICAgdGhhdC5fcXVlcnkodGhhdC5fcGFnZWFibGVRdWVyeU9wdGlvbnMoeyBwYWdlOiB2YWwgfSkpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHNraXAgPSB0aGF0LnNraXAoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gc2tpcCAhPT0gdW5kZWZpbmVkID8gbWF0aC5yb3VuZCgoc2tpcCB8fCAwKSAvICh0aGF0LnRha2UoKSB8fCAxKSkgKyAxIDogdW5kZWZpbmVkO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBwYWdlU2l6ZTogZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuXHQgICAgICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX3F1ZXJ5KHRoYXQuX3BhZ2VhYmxlUXVlcnlPcHRpb25zKHsgcGFnZVNpemU6IHZhbCwgcGFnZTogMSB9KSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdGhhdC50YWtlKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHNvcnQ6IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgaWYodmFsICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX3F1ZXJ5KHsgc29ydDogdmFsIH0pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHRoYXQuX3NvcnQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGZpbHRlcjogZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuXHQgICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGF0Ll9maWx0ZXI7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGF0LnRyaWdnZXIoXCJyZXNldFwiKTtcblx0ICAgICAgICAgICAgdGhhdC5fcXVlcnkoeyBmaWx0ZXI6IHZhbCwgcGFnZTogMSB9KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZ3JvdXA6IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgaWYodmFsICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX3F1ZXJ5KHsgZ3JvdXA6IHZhbCB9KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB0aGF0Ll9ncm91cDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgdG90YWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5fdG90YWwgfHwgMCwgMTApO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBhZ2dyZWdhdGU6IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgaWYodmFsICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQuX3F1ZXJ5KHsgYWdncmVnYXRlOiB2YWwgfSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdGhhdC5fYWdncmVnYXRlO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBhZ2dyZWdhdGVzOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2FnZ3JlZ2F0ZVJlc3VsdDtcblxuXHQgICAgICAgICAgICBpZiAoaXNFbXB0eU9iamVjdChyZXN1bHQpKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9lbXB0eUFnZ3JlZ2F0ZXModGhpcy5hZ2dyZWdhdGUoKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZW1wdHlBZ2dyZWdhdGVzOiBmdW5jdGlvbihhZ2dyZWdhdGVzKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuXHQgICAgICAgICAgICBpZiAoIWlzRW1wdHlPYmplY3QoYWdncmVnYXRlcykpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBhZ2dyZWdhdGUgPSB7fTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKCFpc0FycmF5KGFnZ3JlZ2F0ZXMpKXtcblx0ICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdGVzID0gW2FnZ3JlZ2F0ZXNdO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPGFnZ3JlZ2F0ZXMubGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIGFnZ3JlZ2F0ZVthZ2dyZWdhdGVzW2lkeF0uYWdncmVnYXRlXSA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2FnZ3JlZ2F0ZXNbaWR4XS5maWVsZF0gPSBhZ2dyZWdhdGU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfcGFnZWFibGVRdWVyeU9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF93cmFwSW5FbXB0eUdyb3VwOiBmdW5jdGlvbihtb2RlbCkge1xuXHQgICAgICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cCgpLFxuXHQgICAgICAgICAgICAgICAgcGFyZW50LFxuXHQgICAgICAgICAgICAgICAgZ3JvdXAsXG5cdCAgICAgICAgICAgICAgICBpZHgsXG5cdCAgICAgICAgICAgICAgICBsZW5ndGg7XG5cblx0ICAgICAgICAgICAgZm9yIChpZHggPSBncm91cHMubGVuZ3RoLTEsIGxlbmd0aCA9IDA7IGlkeCA+PSBsZW5ndGg7IGlkeC0tKSB7XG5cdCAgICAgICAgICAgICAgICBncm91cCA9IGdyb3Vwc1tpZHhdO1xuXHQgICAgICAgICAgICAgICAgcGFyZW50ID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtb2RlbC5nZXQgPyBtb2RlbC5nZXQoZ3JvdXAuZmllbGQpIDogbW9kZWxbZ3JvdXAuZmllbGRdLFxuXHQgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBncm91cC5maWVsZCxcblx0ICAgICAgICAgICAgICAgICAgICBpdGVtczogcGFyZW50ID8gW3BhcmVudF0gOiBbbW9kZWxdLFxuXHQgICAgICAgICAgICAgICAgICAgIGhhc1N1Ymdyb3VwczogISFwYXJlbnQsXG5cdCAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlczogdGhpcy5fZW1wdHlBZ2dyZWdhdGVzKGdyb3VwLmFnZ3JlZ2F0ZXMpXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHBhcmVudDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgdG90YWxQYWdlczogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcblx0ICAgICAgICAgICAgcGFnZVNpemUgPSB0aGF0LnBhZ2VTaXplKCkgfHwgdGhhdC50b3RhbCgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBtYXRoLmNlaWwoKHRoYXQudG90YWwoKSB8fCAwKSAvIHBhZ2VTaXplKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgaW5SYW5nZTogZnVuY3Rpb24oc2tpcCwgdGFrZSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBlbmQgPSBtYXRoLm1pbihza2lwICsgdGFrZSwgdGhhdC50b3RhbCgpKTtcblxuXHQgICAgICAgICAgICBpZiAoIXRoYXQub3B0aW9ucy5zZXJ2ZXJQYWdpbmcgJiYgdGhhdC5fZGF0YS5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB0aGF0Ll9maW5kUmFuZ2Uoc2tpcCwgZW5kKS5sZW5ndGggPiAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBsYXN0UmFuZ2U6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5fcmFuZ2VzO1xuXHQgICAgICAgICAgICByZXR1cm4gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXSB8fCB7IHN0YXJ0OiAwLCBlbmQ6IDAsIGRhdGE6IFtdIH07XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGZpcnN0SXRlbVVpZDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciByYW5nZXMgPSB0aGlzLl9yYW5nZXM7XG5cdCAgICAgICAgICAgIHJldHVybiByYW5nZXMubGVuZ3RoICYmIHJhbmdlc1swXS5kYXRhLmxlbmd0aCAmJiByYW5nZXNbMF0uZGF0YVswXS51aWQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGVuYWJsZVJlcXVlc3RzSW5Qcm9ncmVzczogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3NraXBSZXF1ZXN0c0luUHJvZ3Jlc3MgPSBmYWxzZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3RpbWVTdGFtcDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgcmFuZ2U6IGZ1bmN0aW9uKHNraXAsIHRha2UsIGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRSZXF1ZXN0VGltZVN0YW1wID0gdGhpcy5fdGltZVN0YW1wKCk7XG5cdCAgICAgICAgICAgIHRoaXMuX3NraXBSZXF1ZXN0c0luUHJvZ3Jlc3MgPSB0cnVlO1xuXG5cdCAgICAgICAgICAgIHNraXAgPSBtYXRoLm1pbihza2lwIHx8IDAsIHRoaXMudG90YWwoKSk7XG5cdCAgICAgICAgICAgIGNhbGxiYWNrID0gaXNGdW5jdGlvbihjYWxsYmFjaykgPyBjYWxsYmFjayA6IG5vb3A7XG5cblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgcGFnZVNraXAgPSBtYXRoLm1heChtYXRoLmZsb29yKHNraXAgLyB0YWtlKSwgMCkgKiB0YWtlLFxuXHQgICAgICAgICAgICAgICAgc2l6ZSA9IG1hdGgubWluKHBhZ2VTa2lwICsgdGFrZSwgdGhhdC50b3RhbCgpKSxcblx0ICAgICAgICAgICAgICAgIGRhdGE7XG5cblx0ICAgICAgICAgICAgZGF0YSA9IHRoYXQuX2ZpbmRSYW5nZShza2lwLCBtYXRoLm1pbihza2lwICsgdGFrZSwgdGhhdC50b3RhbCgpKSk7XG5cblx0ICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoIHx8IHRoYXQudG90YWwoKSA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgdGhhdC5fcHJvY2Vzc1JhbmdlRGF0YShkYXRhLCBza2lwLCB0YWtlLCBwYWdlU2tpcCwgc2l6ZSk7XG5cdCAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHRha2UgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGF0Ll9yYW5nZUV4aXN0cyhwYWdlU2tpcCwgc2l6ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LnByZWZldGNoKHBhZ2VTa2lwLCB0YWtlLCBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXAgPiBwYWdlU2tpcCAmJiBzaXplIDwgdGhhdC50b3RhbCgpICYmICF0aGF0Ll9yYW5nZUV4aXN0cyhzaXplLCBtYXRoLm1pbihzaXplICsgdGFrZSwgdGhhdC50b3RhbCgpKSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucHJlZmV0Y2goc2l6ZSwgdGFrZSwgZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5yYW5nZShza2lwLCB0YWtlLCBjYWxsYmFjayApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnJhbmdlKHNraXAsIHRha2UsIGNhbGxiYWNrKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYWdlU2tpcCA8IHNraXApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0LnByZWZldGNoKHNpemUsIHRha2UsIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnJhbmdlKHNraXAsIHRha2UsIGNhbGxiYWNrICk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2ZpbmRSYW5nZTogZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICByYW5nZXMgPSB0aGF0Ll9yYW5nZXMsXG5cdCAgICAgICAgICAgICAgICByYW5nZSxcblx0ICAgICAgICAgICAgICAgIGRhdGEgPSBbXSxcblx0ICAgICAgICAgICAgICAgIHNraXBJZHgsXG5cdCAgICAgICAgICAgICAgICB0YWtlSWR4LFxuXHQgICAgICAgICAgICAgICAgc3RhcnRJbmRleCxcblx0ICAgICAgICAgICAgICAgIGVuZEluZGV4LFxuXHQgICAgICAgICAgICAgICAgcmFuZ2VEYXRhLFxuXHQgICAgICAgICAgICAgICAgcmFuZ2VFbmQsXG5cdCAgICAgICAgICAgICAgICBwcm9jZXNzZWQsXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zID0gdGhhdC5vcHRpb25zLFxuXHQgICAgICAgICAgICAgICAgcmVtb3RlID0gb3B0aW9ucy5zZXJ2ZXJTb3J0aW5nIHx8IG9wdGlvbnMuc2VydmVyUGFnaW5nIHx8IG9wdGlvbnMuc2VydmVyRmlsdGVyaW5nIHx8IG9wdGlvbnMuc2VydmVyR3JvdXBpbmcgfHwgb3B0aW9ucy5zZXJ2ZXJBZ2dyZWdhdGVzLFxuXHQgICAgICAgICAgICAgICAgZmxhdERhdGEsXG5cdCAgICAgICAgICAgICAgICBjb3VudCxcblx0ICAgICAgICAgICAgICAgIGxlbmd0aDtcblxuXHQgICAgICAgICAgICBmb3IgKHNraXBJZHggPSAwLCBsZW5ndGggPSByYW5nZXMubGVuZ3RoOyBza2lwSWR4IDwgbGVuZ3RoOyBza2lwSWR4KyspIHtcblx0ICAgICAgICAgICAgICAgIHJhbmdlID0gcmFuZ2VzW3NraXBJZHhdO1xuXHQgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID49IHJhbmdlLnN0YXJ0ICYmIHN0YXJ0IDw9IHJhbmdlLmVuZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMDtcblxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodGFrZUlkeCA9IHNraXBJZHg7IHRha2VJZHggPCBsZW5ndGg7IHRha2VJZHgrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHJhbmdlc1t0YWtlSWR4XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmxhdERhdGEgPSB0aGF0Ll9mbGF0RGF0YShyYW5nZS5kYXRhLCB0cnVlKTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmxhdERhdGEubGVuZ3RoICYmIHN0YXJ0ICsgY291bnQgPj0gcmFuZ2Uuc3RhcnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlRGF0YSA9IHJhbmdlLmRhdGE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZUVuZCA9IHJhbmdlLmVuZDtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZW1vdGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5pblBsYWNlU29ydCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWQgPSB0aGF0Ll9xdWVyeVByb2Nlc3MocmFuZ2UuZGF0YSwgeyBmaWx0ZXI6IHRoYXQuZmlsdGVyKCkgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvcnQgPSBub3JtYWxpemVHcm91cCh0aGF0Lmdyb3VwKCkgfHwgW10pLmNvbmNhdChub3JtYWxpemVTb3J0KHRoYXQuc29ydCgpIHx8IFtdKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3NlZCA9IHRoYXQuX3F1ZXJ5UHJvY2VzcyhyYW5nZS5kYXRhLCB7IHNvcnQ6IHNvcnQsIGZpbHRlcjogdGhhdC5maWx0ZXIoKSB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhdERhdGEgPSByYW5nZURhdGEgPSBwcm9jZXNzZWQuZGF0YTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZWQudG90YWwgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZUVuZCA9IHByb2Nlc3NlZC50b3RhbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ICsgY291bnQgPiByYW5nZS5zdGFydCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSAoc3RhcnQgKyBjb3VudCkgLSByYW5nZS5zdGFydDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZEluZGV4ID0gZmxhdERhdGEubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlRW5kID4gZW5kKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kSW5kZXggPSBlbmRJbmRleCAtIChyYW5nZUVuZCAtIGVuZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCArPSBlbmRJbmRleCAtIHN0YXJ0SW5kZXg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gdGhhdC5fbWVyZ2VHcm91cHMoZGF0YSwgcmFuZ2VEYXRhLCBzdGFydEluZGV4LCBlbmRJbmRleCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPD0gcmFuZ2UuZW5kICYmIGNvdW50ID09IGVuZCAtIHN0YXJ0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbWVyZ2VHcm91cHM6IGZ1bmN0aW9uKGRhdGEsIHJhbmdlLCBza2lwLCB0YWtlKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9pc1NlcnZlckdyb3VwZWQoKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSByYW5nZS50b0pTT04oKSxcblx0ICAgICAgICAgICAgICAgICAgICBwcmV2R3JvdXA7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHByZXZHcm91cCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgbWVyZ2VHcm91cHMocHJldkdyb3VwLCB0ZW1wLCBza2lwLCB0YWtlKTtcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuY29uY2F0KHRlbXApO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBkYXRhLmNvbmNhdChyYW5nZS5zbGljZShza2lwLCB0YWtlKSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9wcm9jZXNzUmFuZ2VEYXRhOiBmdW5jdGlvbihkYXRhLCBza2lwLCB0YWtlLCBwYWdlU2tpcCwgc2l6ZSkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgdGhhdC5fcGVuZGluZyA9IHVuZGVmaW5lZDtcblxuXHQgICAgICAgICAgICB0aGF0Ll9za2lwID0gc2tpcCA+IHRoYXQuc2tpcCgpID8gbWF0aC5taW4oc2l6ZSwgKHRoYXQudG90YWxQYWdlcygpIC0gMSkgKiB0aGF0LnRha2UoKSkgOiBwYWdlU2tpcDtcblxuXHQgICAgICAgICAgICB0aGF0Ll9jdXJyZW50UmFuZ2VTdGFydCA9IHNraXA7XG5cblx0ICAgICAgICAgICAgdGhhdC5fdGFrZSA9IHRha2U7XG5cblx0ICAgICAgICAgICAgdmFyIHBhZ2luZyA9IHRoYXQub3B0aW9ucy5zZXJ2ZXJQYWdpbmc7XG5cdCAgICAgICAgICAgIHZhciBzb3J0aW5nID0gdGhhdC5vcHRpb25zLnNlcnZlclNvcnRpbmc7XG5cdCAgICAgICAgICAgIHZhciBmaWx0ZXJpbmcgPSB0aGF0Lm9wdGlvbnMuc2VydmVyRmlsdGVyaW5nO1xuXHQgICAgICAgICAgICB2YXIgYWdncmVnYXRlcyA9IHRoYXQub3B0aW9ucy5zZXJ2ZXJBZ2dyZWdhdGVzO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgdGhhdC5vcHRpb25zLnNlcnZlclBhZ2luZyA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXRoYXQuX2lzU2VydmVyR3JvdXBlZCgpICYmICEodGhhdC5ncm91cCgpICYmIHRoYXQuZ3JvdXAoKS5sZW5ndGgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC5vcHRpb25zLnNlcnZlclNvcnRpbmcgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhhdC5vcHRpb25zLnNlcnZlckZpbHRlcmluZyA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB0aGF0Lm9wdGlvbnMuc2VydmVyUGFnaW5nID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHRoYXQub3B0aW9ucy5zZXJ2ZXJBZ2dyZWdhdGVzID0gdHJ1ZTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHBhZ2luZykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuX2RldGFjaE9ic2VydmFibGVQYXJlbnRzKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC5fZGF0YSA9IGRhdGEgPSB0aGF0Ll9vYnNlcnZlKGRhdGEpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhhdC5fcHJvY2VzcyhkYXRhKTtcblx0ICAgICAgICAgICAgfSBmaW5hbGx5IHtcblx0ICAgICAgICAgICAgICAgIHRoYXQub3B0aW9ucy5zZXJ2ZXJQYWdpbmcgPSBwYWdpbmc7XG5cdCAgICAgICAgICAgICAgICB0aGF0Lm9wdGlvbnMuc2VydmVyU29ydGluZyA9IHNvcnRpbmc7XG5cdCAgICAgICAgICAgICAgICB0aGF0Lm9wdGlvbnMuc2VydmVyRmlsdGVyaW5nID0gZmlsdGVyaW5nO1xuXHQgICAgICAgICAgICAgICAgdGhhdC5vcHRpb25zLnNlcnZlckFnZ3JlZ2F0ZXMgPSBhZ2dyZWdhdGVzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHNraXA6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cblx0ICAgICAgICAgICAgaWYgKHRoYXQuX3NraXAgPT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICh0aGF0Ll9wYWdlICE9PSB1bmRlZmluZWQgPyAodGhhdC5fcGFnZSAgLSAxKSAqICh0aGF0LnRha2UoKSB8fCAxKSA6IHVuZGVmaW5lZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoYXQuX3NraXA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGN1cnJlbnRSYW5nZVN0YXJ0OiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRSYW5nZVN0YXJ0IHx8IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHRha2U6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFrZSB8fCB0aGlzLl9wYWdlU2l6ZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3ByZWZldGNoU3VjY2Vzc0hhbmRsZXI6IGZ1bmN0aW9uIChza2lwLCBzaXplLCBjYWxsYmFjaywgZm9yY2UpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgdGltZXN0YW1wID0gdGhhdC5fdGltZVN0YW1wKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgICAgIHJhbmdlID0geyBzdGFydDogc2tpcCwgZW5kOiBzaXplLCBkYXRhOiBbXSwgdGltZXN0YW1wOiB0aGF0Ll90aW1lU3RhbXAoKSB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGlkeCxcblx0ICAgICAgICAgICAgICAgICAgICBsZW5ndGgsXG5cdCAgICAgICAgICAgICAgICAgICAgdGVtcDtcblxuXHQgICAgICAgICAgICAgICAgdGhhdC5fZGVxdWV1ZVJlcXVlc3QoKTtcblxuXHQgICAgICAgICAgICAgICAgdGhhdC50cmlnZ2VyKFJFUVVFU1RFTkQsIHsgcmVzcG9uc2U6IGRhdGEsIHR5cGU6IFwicmVhZFwiIH0pO1xuXG5cdCAgICAgICAgICAgICAgICBkYXRhID0gdGhhdC5yZWFkZXIucGFyc2UoZGF0YSk7XG5cblx0ICAgICAgICAgICAgICAgIHRlbXAgPSB0aGF0Ll9yZWFkRGF0YShkYXRhKTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHRlbXAubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSB0aGF0Ll9yYW5nZXMubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Ll9yYW5nZXNbaWR4XS5zdGFydCA9PT0gc2tpcCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGF0Ll9yYW5nZXNbaWR4XTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UucHJpc3RpbmVEYXRhID0gdGVtcDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLmRhdGEgPSB0aGF0Ll9vYnNlcnZlKHRlbXApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5kID0gcmFuZ2Uuc3RhcnQgKyB0aGF0Ll9mbGF0RGF0YShyYW5nZS5kYXRhLCB0cnVlKS5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9zb3J0UmFuZ2VzKCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9hZGRSYW5nZSh0aGF0Ll9vYnNlcnZlKHRlbXApLCBza2lwKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHRoYXQuX3RvdGFsID0gdGhhdC5yZWFkZXIudG90YWwoZGF0YSk7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChmb3JjZSB8fCAodGltZXN0YW1wID49IHRoYXQuX2N1cnJlbnRSZXF1ZXN0VGltZVN0YW1wIHx8ICF0aGF0Ll9za2lwUmVxdWVzdHNJblByb2dyZXNzKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiB0ZW1wLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQudHJpZ2dlcihDSEFOR0UsIHt9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHByZWZldGNoOiBmdW5jdGlvbihza2lwLCB0YWtlLCBjYWxsYmFjaykge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBzaXplID0gbWF0aC5taW4oc2tpcCArIHRha2UsIHRoYXQudG90YWwoKSksXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIHRha2U6IHRha2UsXG5cdCAgICAgICAgICAgICAgICAgICAgc2tpcDogc2tpcCxcblx0ICAgICAgICAgICAgICAgICAgICBwYWdlOiBza2lwIC8gdGFrZSArIDEsXG5cdCAgICAgICAgICAgICAgICAgICAgcGFnZVNpemU6IHRha2UsXG5cdCAgICAgICAgICAgICAgICAgICAgc29ydDogdGhhdC5fc29ydCxcblx0ICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IHRoYXQuX2ZpbHRlcixcblx0ICAgICAgICAgICAgICAgICAgICBncm91cDogdGhhdC5fZ3JvdXAsXG5cdCAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlOiB0aGF0Ll9hZ2dyZWdhdGVcblx0ICAgICAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgaWYgKCF0aGF0Ll9yYW5nZUV4aXN0cyhza2lwLCBzaXplKSkge1xuXHQgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoYXQuX3RpbWVvdXQpO1xuXG5cdCAgICAgICAgICAgICAgICB0aGF0Ll90aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGF0Ll9xdWV1ZVJlcXVlc3Qob3B0aW9ucywgZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhhdC50cmlnZ2VyKFJFUVVFU1RTVEFSVCwgeyB0eXBlOiBcInJlYWRcIiB9KSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC50cmFuc3BvcnQucmVhZCh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdGhhdC5fcGFyYW1zKG9wdGlvbnMpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRoYXQuX3ByZWZldGNoU3VjY2Vzc0hhbmRsZXIoc2tpcCwgc2l6ZSwgY2FsbGJhY2spLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZXJyb3IuYXBwbHkodGhhdCwgYXJncyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9kZXF1ZXVlUmVxdWVzdCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9LCAxMDApO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9tdWx0aXBsZVByZWZldGNoOiBmdW5jdGlvbihza2lwLCB0YWtlLCBjYWxsYmFjaykge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBzaXplID0gbWF0aC5taW4oc2tpcCArIHRha2UsIHRoYXQudG90YWwoKSksXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIHRha2U6IHRha2UsXG5cdCAgICAgICAgICAgICAgICAgICAgc2tpcDogc2tpcCxcblx0ICAgICAgICAgICAgICAgICAgICBwYWdlOiBza2lwIC8gdGFrZSArIDEsXG5cdCAgICAgICAgICAgICAgICAgICAgcGFnZVNpemU6IHRha2UsXG5cdCAgICAgICAgICAgICAgICAgICAgc29ydDogdGhhdC5fc29ydCxcblx0ICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IHRoYXQuX2ZpbHRlcixcblx0ICAgICAgICAgICAgICAgICAgICBncm91cDogdGhhdC5fZ3JvdXAsXG5cdCAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRlOiB0aGF0Ll9hZ2dyZWdhdGVcblx0ICAgICAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgaWYgKCF0aGF0Ll9yYW5nZUV4aXN0cyhza2lwLCBzaXplKSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGF0LnRyaWdnZXIoUkVRVUVTVFNUQVJULCB7IHR5cGU6IFwicmVhZFwiIH0pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC50cmFuc3BvcnQucmVhZCh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRoYXQuX3BhcmFtcyhvcHRpb25zKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogdGhhdC5fcHJlZmV0Y2hTdWNjZXNzSGFuZGxlcihza2lwLCBzaXplLCBjYWxsYmFjaywgdHJ1ZSlcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuXHQgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfcmFuZ2VFeGlzdHM6IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgcmFuZ2VzID0gdGhhdC5fcmFuZ2VzLFxuXHQgICAgICAgICAgICAgICAgaWR4LFxuXHQgICAgICAgICAgICAgICAgbGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIGZvciAoaWR4ID0gMCwgbGVuZ3RoID0gcmFuZ2VzLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKHJhbmdlc1tpZHhdLnN0YXJ0IDw9IHN0YXJ0ICYmIHJhbmdlc1tpZHhdLmVuZCA+PSBlbmQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2dldEN1cnJlbnRSYW5nZVNwYW46IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciByYW5nZXMgPSB0aGF0Ll9yYW5nZXM7XG5cdCAgICAgICAgICAgIHZhciBzdGFydCA9IHRoYXQuY3VycmVudFJhbmdlU3RhcnQoKTtcblx0ICAgICAgICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgKHRoYXQudGFrZSgpIHx8IDApO1xuXHQgICAgICAgICAgICB2YXIgcmFuZ2VTcGFuID0gW107XG5cdCAgICAgICAgICAgIHZhciByYW5nZTtcblx0ICAgICAgICAgICAgdmFyIGlkeDtcblx0ICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHJhbmdlcy5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICByYW5nZSA9IHJhbmdlc1tpZHhdO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoKHJhbmdlLnN0YXJ0IDw9IHN0YXJ0ICYmIHJhbmdlLmVuZCA+PSBzdGFydCkgfHwgKHJhbmdlLnN0YXJ0ID49IHN0YXJ0ICYmIHJhbmdlLnN0YXJ0IDw9IGVuZCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByYW5nZVNwYW4ucHVzaChyYW5nZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gcmFuZ2VTcGFuO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfcmVtb3ZlTW9kZWxGcm9tUmFuZ2VzOiBmdW5jdGlvbihtb2RlbCkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQsXG5cdCAgICAgICAgICAgICAgICByYW5nZTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpZHggPSAwLCBsZW5ndGggPSB0aGlzLl9yYW5nZXMubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICByYW5nZSA9IHRoaXMuX3Jhbmdlc1tpZHhdO1xuXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9lYWNoSXRlbShyYW5nZS5kYXRhLCBmdW5jdGlvbihpdGVtcykge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlbW92ZU1vZGVsKGl0ZW1zLCBtb2RlbCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdGhhdC5fdXBkYXRlUmFuZ2VzTGVuZ3RoKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9pbnNlcnRNb2RlbEluUmFuZ2U6IGZ1bmN0aW9uKGluZGV4LCBtb2RlbCkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciByYW5nZXMgPSB0aGF0Ll9yYW5nZXMgfHwgW107XG5cdCAgICAgICAgICAgIHZhciByYW5nZXNMZW5ndGggPSByYW5nZXMubGVuZ3RoO1xuXHQgICAgICAgICAgICB2YXIgcmFuZ2U7XG5cdCAgICAgICAgICAgIHZhciBpO1xuXG5cdCAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCByYW5nZXNMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgcmFuZ2UgPSByYW5nZXNbaV07XG5cblx0ICAgICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydCA8PSBpbmRleCAmJiByYW5nZS5lbmQgPj0gaW5kZXgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXRoYXQuX2dldEJ5VWlkKG1vZGVsLnVpZCwgcmFuZ2UuZGF0YSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuX2lzU2VydmVyR3JvdXBlZCgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5kYXRhLnNwbGljZShpbmRleCwgMCwgdGhhdC5fd3JhcEluRW1wdHlHcm91cChtb2RlbCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZGF0YS5zcGxpY2UoaW5kZXgsIDAsIG1vZGVsKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdGhhdC5fdXBkYXRlUmFuZ2VzTGVuZ3RoKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF91cGRhdGVSYW5nZXNMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cdCAgICAgICAgICAgIHZhciByYW5nZXMgPSB0aGF0Ll9yYW5nZXMgfHwgW107XG5cdCAgICAgICAgICAgIHZhciByYW5nZXNMZW5ndGggPSByYW5nZXMubGVuZ3RoO1xuXHQgICAgICAgICAgICB2YXIgbWlzbWF0Y2hGb3VuZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICB2YXIgbWlzbWF0Y2hMZW5ndGggPSAwO1xuXHQgICAgICAgICAgICB2YXIgbGVuZ3RoRGlmZmVyZW5jZSA9IDA7XG5cdCAgICAgICAgICAgIHZhciByYW5nZTtcblx0ICAgICAgICAgICAgdmFyIGk7XG5cblx0ICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJhbmdlc0xlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICByYW5nZSA9IHJhbmdlc1tpXTtcblx0ICAgICAgICAgICAgICAgIGxlbmd0aERpZmZlcmVuY2UgPSB0aGF0Ll9mbGF0RGF0YShyYW5nZS5kYXRhLCB0cnVlKS5sZW5ndGggLSBtYXRoLmFicyhyYW5nZS5lbmQgLSByYW5nZS5zdGFydCk7XG5cblx0ICAgICAgICAgICAgICAgIGlmICghbWlzbWF0Y2hGb3VuZCAmJiBsZW5ndGhEaWZmZXJlbmNlICE9PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbWlzbWF0Y2hGb3VuZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgbWlzbWF0Y2hMZW5ndGggPSBsZW5ndGhEaWZmZXJlbmNlO1xuXHQgICAgICAgICAgICAgICAgICAgIHJhbmdlLmVuZCArPSBtaXNtYXRjaExlbmd0aDtcblx0ICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgaWYgKG1pc21hdGNoRm91bmQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByYW5nZS5zdGFydCArPSBtaXNtYXRjaExlbmd0aDtcblx0ICAgICAgICAgICAgICAgICAgICByYW5nZS5lbmQgKz0gbWlzbWF0Y2hMZW5ndGg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgdmFyIFRyYW5zcG9ydCA9IHt9O1xuXG5cdCAgICBUcmFuc3BvcnQuY3JlYXRlID0gZnVuY3Rpb24ob3B0aW9ucywgZGF0YSwgZGF0YVNvdXJjZSkge1xuXHQgICAgICAgIHZhciB0cmFuc3BvcnQsXG5cdCAgICAgICAgICAgIHRyYW5zcG9ydE9wdGlvbnMgPSBvcHRpb25zLnRyYW5zcG9ydCA/ICQuZXh0ZW5kKHt9LCBvcHRpb25zLnRyYW5zcG9ydCkgOiBudWxsO1xuXG5cdCAgICAgICAgaWYgKHRyYW5zcG9ydE9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgdHJhbnNwb3J0T3B0aW9ucy5yZWFkID0gdHlwZW9mIHRyYW5zcG9ydE9wdGlvbnMucmVhZCA9PT0gU1RSSU5HID8geyB1cmw6IHRyYW5zcG9ydE9wdGlvbnMucmVhZCB9IDogdHJhbnNwb3J0T3B0aW9ucy5yZWFkO1xuXG5cdCAgICAgICAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09IFwianNkb1wiKSB7XG5cdCAgICAgICAgICAgICAgICB0cmFuc3BvcnRPcHRpb25zLmRhdGFTb3VyY2UgPSBkYXRhU291cmNlO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMudHlwZSkge1xuXHQgICAgICAgICAgICAgICAga2VuZG8uZGF0YS50cmFuc3BvcnRzID0ga2VuZG8uZGF0YS50cmFuc3BvcnRzIHx8IHt9O1xuXHQgICAgICAgICAgICAgICAga2VuZG8uZGF0YS5zY2hlbWFzID0ga2VuZG8uZGF0YS5zY2hlbWFzIHx8IHt9O1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoIWtlbmRvLmRhdGEudHJhbnNwb3J0c1tvcHRpb25zLnR5cGVdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAga2VuZG8ubG9nVG9Db25zb2xlKFwiVW5rbm93biBEYXRhU291cmNlIHRyYW5zcG9ydCB0eXBlICdcIiArIG9wdGlvbnMudHlwZSArIFwiJy5cXG5WZXJpZnkgdGhhdCByZWdpc3RyYXRpb24gc2NyaXB0cyBmb3IgdGhpcyB0eXBlIGFyZSBpbmNsdWRlZCBhZnRlciBLZW5kbyBVSSBvbiB0aGUgcGFnZS5cIiwgXCJ3YXJuXCIpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXNQbGFpbk9iamVjdChrZW5kby5kYXRhLnRyYW5zcG9ydHNbb3B0aW9ucy50eXBlXSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQgPSBuZXcga2VuZG8uZGF0YS50cmFuc3BvcnRzW29wdGlvbnMudHlwZV0oZXh0ZW5kKHRyYW5zcG9ydE9wdGlvbnMsIHsgZGF0YTogZGF0YSB9KSk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydE9wdGlvbnMgPSBleHRlbmQodHJ1ZSwge30sIGtlbmRvLmRhdGEudHJhbnNwb3J0c1tvcHRpb25zLnR5cGVdLCB0cmFuc3BvcnRPcHRpb25zKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5zY2hlbWEgPSBleHRlbmQodHJ1ZSwge30sIGtlbmRvLmRhdGEuc2NoZW1hc1tvcHRpb25zLnR5cGVdLCBvcHRpb25zLnNjaGVtYSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoIXRyYW5zcG9ydCkge1xuXHQgICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gaXNGdW5jdGlvbih0cmFuc3BvcnRPcHRpb25zLnJlYWQpID8gdHJhbnNwb3J0T3B0aW9ucyA6IG5ldyBSZW1vdGVUcmFuc3BvcnQodHJhbnNwb3J0T3B0aW9ucyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICB0cmFuc3BvcnQgPSBuZXcgTG9jYWxUcmFuc3BvcnQoeyBkYXRhOiBvcHRpb25zLmRhdGEgfHwgW10gfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0cmFuc3BvcnQ7XG5cdCAgICB9O1xuXG5cdCAgICBEYXRhU291cmNlLmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICAgICAgICBpZiAoaXNBcnJheShvcHRpb25zKSB8fCBvcHRpb25zIGluc3RhbmNlb2YgT2JzZXJ2YWJsZUFycmF5KSB7XG5cdCAgICAgICAgICAgb3B0aW9ucyA9IHsgZGF0YTogb3B0aW9ucyB9O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBkYXRhU291cmNlID0gb3B0aW9ucyB8fCB7fSxcblx0ICAgICAgICAgICAgZGF0YSA9IGRhdGFTb3VyY2UuZGF0YSxcblx0ICAgICAgICAgICAgZmllbGRzID0gZGF0YVNvdXJjZS5maWVsZHMsXG5cdCAgICAgICAgICAgIHRhYmxlID0gZGF0YVNvdXJjZS50YWJsZSxcblx0ICAgICAgICAgICAgc2VsZWN0ID0gZGF0YVNvdXJjZS5zZWxlY3QsXG5cdCAgICAgICAgICAgIGlkeCxcblx0ICAgICAgICAgICAgbGVuZ3RoLFxuXHQgICAgICAgICAgICBtb2RlbCA9IHt9LFxuXHQgICAgICAgICAgICBmaWVsZDtcblxuXHQgICAgICAgIGlmICghZGF0YSAmJiBmaWVsZHMgJiYgIWRhdGFTb3VyY2UudHJhbnNwb3J0KSB7XG5cdCAgICAgICAgICAgIGlmICh0YWJsZSkge1xuXHQgICAgICAgICAgICAgICAgZGF0YSA9IGluZmVyVGFibGUodGFibGUsIGZpZWxkcyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0KSB7XG5cdCAgICAgICAgICAgICAgICBkYXRhID0gaW5mZXJTZWxlY3Qoc2VsZWN0LCBmaWVsZHMpO1xuXG5cdCAgICAgICAgICAgICAgICBpZiAoZGF0YVNvdXJjZS5ncm91cCA9PT0gdW5kZWZpbmVkICYmIGRhdGFbMF0gJiYgZGF0YVswXS5vcHRncm91cCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YVNvdXJjZS5ncm91cCA9IFwib3B0Z3JvdXBcIjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGlmIChrZW5kby5kYXRhLk1vZGVsICYmIGZpZWxkcyAmJiAoIWRhdGFTb3VyY2Uuc2NoZW1hIHx8ICFkYXRhU291cmNlLnNjaGVtYS5tb2RlbCkpIHtcblx0ICAgICAgICAgICAgZm9yIChpZHggPSAwLCBsZW5ndGggPSBmaWVsZHMubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICBmaWVsZCA9IGZpZWxkc1tpZHhdO1xuXHQgICAgICAgICAgICAgICAgaWYgKGZpZWxkLnR5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBtb2RlbFtmaWVsZC5maWVsZF0gPSBmaWVsZDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICghaXNFbXB0eU9iamVjdChtb2RlbCkpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGFTb3VyY2Uuc2NoZW1hID0gZXh0ZW5kKHRydWUsIGRhdGFTb3VyY2Uuc2NoZW1hLCB7IG1vZGVsOiAgeyBmaWVsZHM6IG1vZGVsIH0gfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBkYXRhU291cmNlLmRhdGEgPSBkYXRhO1xuXG5cdCAgICAgICAgc2VsZWN0ID0gbnVsbDtcblx0ICAgICAgICBkYXRhU291cmNlLnNlbGVjdCA9IG51bGw7XG5cdCAgICAgICAgdGFibGUgPSBudWxsO1xuXHQgICAgICAgIGRhdGFTb3VyY2UudGFibGUgPSBudWxsO1xuXG5cdCAgICAgICAgcmV0dXJuIGRhdGFTb3VyY2UgaW5zdGFuY2VvZiBEYXRhU291cmNlID8gZGF0YVNvdXJjZSA6IG5ldyBEYXRhU291cmNlKGRhdGFTb3VyY2UpO1xuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gaW5mZXJTZWxlY3Qoc2VsZWN0LCBmaWVsZHMpIHtcblx0ICAgICAgICBzZWxlY3QgPSAkKHNlbGVjdClbMF07XG5cdCAgICAgICAgdmFyIG9wdGlvbnMgPSBzZWxlY3Qub3B0aW9ucztcblx0ICAgICAgICB2YXIgZmlyc3RGaWVsZCA9IGZpZWxkc1swXTtcblx0ICAgICAgICB2YXIgc2Vjb25kRmllbGQgPSBmaWVsZHNbMV07XG5cblx0ICAgICAgICB2YXIgZGF0YSA9IFtdO1xuXHQgICAgICAgIHZhciBpZHgsIGxlbmd0aDtcblx0ICAgICAgICB2YXIgb3B0Z3JvdXA7XG5cdCAgICAgICAgdmFyIG9wdGlvbjtcblx0ICAgICAgICB2YXIgcmVjb3JkO1xuXHQgICAgICAgIHZhciB2YWx1ZTtcblxuXHQgICAgICAgIGZvciAoaWR4ID0gMCwgbGVuZ3RoID0gb3B0aW9ucy5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgcmVjb3JkID0ge307XG5cdCAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbnNbaWR4XTtcblx0ICAgICAgICAgICAgb3B0Z3JvdXAgPSBvcHRpb24ucGFyZW50Tm9kZTtcblxuXHQgICAgICAgICAgICBpZiAob3B0Z3JvdXAgPT09IHNlbGVjdCkge1xuXHQgICAgICAgICAgICAgICAgb3B0Z3JvdXAgPSBudWxsO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKG9wdGlvbi5kaXNhYmxlZCB8fCAob3B0Z3JvdXAgJiYgb3B0Z3JvdXAuZGlzYWJsZWQpKSB7XG5cdCAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmIChvcHRncm91cCkge1xuXHQgICAgICAgICAgICAgICAgcmVjb3JkLm9wdGdyb3VwID0gb3B0Z3JvdXAubGFiZWw7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZWNvcmRbZmlyc3RGaWVsZC5maWVsZF0gPSBvcHRpb24udGV4dDtcblxuXHQgICAgICAgICAgICB2YWx1ZSA9IG9wdGlvbi5hdHRyaWJ1dGVzLnZhbHVlO1xuXG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5zcGVjaWZpZWQpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gb3B0aW9uLnZhbHVlO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBvcHRpb24udGV4dDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJlY29yZFtzZWNvbmRGaWVsZC5maWVsZF0gPSB2YWx1ZTtcblxuXHQgICAgICAgICAgICBkYXRhLnB1c2gocmVjb3JkKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gZGF0YTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gaW5mZXJUYWJsZSh0YWJsZSwgZmllbGRzKSB7XG5cdCAgICAgICAgdmFyIHRib2R5ID0gJCh0YWJsZSlbMF0udEJvZGllc1swXSxcblx0ICAgICAgICByb3dzID0gdGJvZHkgPyB0Ym9keS5yb3dzIDogW10sXG5cdCAgICAgICAgaWR4LFxuXHQgICAgICAgIGxlbmd0aCxcblx0ICAgICAgICBmaWVsZEluZGV4LFxuXHQgICAgICAgIGZpZWxkQ291bnQgPSBmaWVsZHMubGVuZ3RoLFxuXHQgICAgICAgIGRhdGEgPSBbXSxcblx0ICAgICAgICBjZWxscyxcblx0ICAgICAgICByZWNvcmQsXG5cdCAgICAgICAgY2VsbCxcblx0ICAgICAgICBlbXB0eTtcblxuXHQgICAgICAgIGZvciAoaWR4ID0gMCwgbGVuZ3RoID0gcm93cy5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcblx0ICAgICAgICAgICAgcmVjb3JkID0ge307XG5cdCAgICAgICAgICAgIGVtcHR5ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgY2VsbHMgPSByb3dzW2lkeF0uY2VsbHM7XG5cblx0ICAgICAgICAgICAgZm9yIChmaWVsZEluZGV4ID0gMDsgZmllbGRJbmRleCA8IGZpZWxkQ291bnQ7IGZpZWxkSW5kZXgrKykge1xuXHQgICAgICAgICAgICAgICAgY2VsbCA9IGNlbGxzW2ZpZWxkSW5kZXhdO1xuXHQgICAgICAgICAgICAgICAgaWYoY2VsbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcInRoXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlY29yZFtmaWVsZHNbZmllbGRJbmRleF0uZmllbGRdID0gY2VsbC5pbm5lckhUTUw7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYoIWVtcHR5KSB7XG5cdCAgICAgICAgICAgICAgICBkYXRhLnB1c2gocmVjb3JkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBkYXRhO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgTm9kZSA9IE1vZGVsLmRlZmluZSh7XG5cdCAgICAgICAgaWRGaWVsZDogXCJpZFwiLFxuXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgaGFzQ2hpbGRyZW4gPSB0aGF0Lmhhc0NoaWxkcmVuIHx8IHZhbHVlICYmIHZhbHVlLmhhc0NoaWxkcmVuLFxuXHQgICAgICAgICAgICAgICAgY2hpbGRyZW5GaWVsZCA9IFwiaXRlbXNcIixcblx0ICAgICAgICAgICAgICAgIGNoaWxkcmVuT3B0aW9ucyA9IHt9O1xuXG5cdCAgICAgICAgICAgIGtlbmRvLmRhdGEuTW9kZWwuZm4uaW5pdC5jYWxsKHRoYXQsIHZhbHVlKTtcblxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHRoYXQuY2hpbGRyZW4gPT09IFNUUklORykge1xuXHQgICAgICAgICAgICAgICAgY2hpbGRyZW5GaWVsZCA9IHRoYXQuY2hpbGRyZW47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBjaGlsZHJlbk9wdGlvbnMgPSB7XG5cdCAgICAgICAgICAgICAgICBzY2hlbWE6IHtcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhOiBjaGlsZHJlbkZpZWxkLFxuXHQgICAgICAgICAgICAgICAgICAgIG1vZGVsOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoaWxkcmVuOiBoYXNDaGlsZHJlbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRoYXQuaWRGaWVsZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzOiB0aGF0LmZpZWxkc1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIHRoYXQuY2hpbGRyZW4gIT09IFNUUklORykge1xuXHQgICAgICAgICAgICAgICAgZXh0ZW5kKGNoaWxkcmVuT3B0aW9ucywgdGhhdC5jaGlsZHJlbik7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBjaGlsZHJlbk9wdGlvbnMuZGF0YSA9IHZhbHVlO1xuXG5cdCAgICAgICAgICAgIGlmICghaGFzQ2hpbGRyZW4pIHtcblx0ICAgICAgICAgICAgICAgIGhhc0NoaWxkcmVuID0gY2hpbGRyZW5PcHRpb25zLnNjaGVtYS5kYXRhO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBoYXNDaGlsZHJlbiA9PT0gU1RSSU5HKSB7XG5cdCAgICAgICAgICAgICAgICBoYXNDaGlsZHJlbiA9IGtlbmRvLmdldHRlcihoYXNDaGlsZHJlbik7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihoYXNDaGlsZHJlbikpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBoYXNDaGlsZHJlbk9iamVjdCA9IGhhc0NoaWxkcmVuLmNhbGwodGhhdCwgdGhhdCk7XG5cblx0ICAgICAgICAgICAgICAgIGlmKGhhc0NoaWxkcmVuT2JqZWN0ICYmIGhhc0NoaWxkcmVuT2JqZWN0Lmxlbmd0aCA9PT0gMCl7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC5oYXNDaGlsZHJlbiA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNle1xuXHQgICAgICAgICAgICAgICAgICAgIHRoYXQuaGFzQ2hpbGRyZW4gPSAhIWhhc0NoaWxkcmVuT2JqZWN0O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdGhhdC5fY2hpbGRyZW5PcHRpb25zID0gY2hpbGRyZW5PcHRpb25zO1xuXG5cdCAgICAgICAgICAgIGlmICh0aGF0Lmhhc0NoaWxkcmVuKSB7XG5cdCAgICAgICAgICAgICAgICB0aGF0Ll9pbml0Q2hpbGRyZW4oKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoYXQuX2xvYWRlZCA9ICEhKHZhbHVlICYmIHZhbHVlLl9sb2FkZWQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfaW5pdENoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXHQgICAgICAgICAgICB2YXIgY2hpbGRyZW4sIHRyYW5zcG9ydCwgcGFyYW1ldGVyTWFwO1xuXG5cdCAgICAgICAgICAgIGlmICghKHRoYXQuY2hpbGRyZW4gaW5zdGFuY2VvZiBIaWVyYXJjaGljYWxEYXRhU291cmNlKSkge1xuXHQgICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGF0LmNoaWxkcmVuID0gbmV3IEhpZXJhcmNoaWNhbERhdGFTb3VyY2UodGhhdC5fY2hpbGRyZW5PcHRpb25zKTtcblxuXHQgICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gY2hpbGRyZW4udHJhbnNwb3J0O1xuXHQgICAgICAgICAgICAgICAgcGFyYW1ldGVyTWFwID0gdHJhbnNwb3J0LnBhcmFtZXRlck1hcDtcblxuXHQgICAgICAgICAgICAgICAgdHJhbnNwb3J0LnBhcmFtZXRlck1hcCA9IGZ1bmN0aW9uKGRhdGEsIHR5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhW3RoYXQuaWRGaWVsZCB8fCBcImlkXCJdID0gdGhhdC5pZDtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJNYXApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHBhcmFtZXRlck1hcChkYXRhLCB0eXBlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcblx0ICAgICAgICAgICAgICAgIH07XG5cblx0ICAgICAgICAgICAgICAgIGNoaWxkcmVuLnBhcmVudCA9IGZ1bmN0aW9uKCl7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQ7XG5cdCAgICAgICAgICAgICAgICB9O1xuXG5cdCAgICAgICAgICAgICAgICBjaGlsZHJlbi5iaW5kKENIQU5HRSwgZnVuY3Rpb24oZSl7XG5cdCAgICAgICAgICAgICAgICAgICAgZS5ub2RlID0gZS5ub2RlIHx8IHRoYXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhhdC50cmlnZ2VyKENIQU5HRSwgZSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICAgICAgY2hpbGRyZW4uYmluZChFUlJPUiwgZnVuY3Rpb24oZSl7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGF0LnBhcmVudCgpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZS5ub2RlID0gZS5ub2RlIHx8IHRoYXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24udHJpZ2dlcihFUlJPUiwgZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgICAgIHRoYXQuX3VwZGF0ZUNoaWxkcmVuRmllbGQoKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBhcHBlbmQ6IGZ1bmN0aW9uKG1vZGVsKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2luaXRDaGlsZHJlbigpO1xuXHQgICAgICAgICAgICB0aGlzLmxvYWRlZCh0cnVlKTtcblx0ICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5hZGQobW9kZWwpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBoYXNDaGlsZHJlbjogZmFsc2UsXG5cblx0ICAgICAgICBsZXZlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gdGhpcy5wYXJlbnROb2RlKCksXG5cdCAgICAgICAgICAgICAgICBsZXZlbCA9IDA7XG5cblx0ICAgICAgICAgICAgd2hpbGUgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5wYXJlbnROb2RlKSB7XG5cdCAgICAgICAgICAgICAgICBsZXZlbCsrO1xuXHQgICAgICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZSA/IHBhcmVudE5vZGUucGFyZW50Tm9kZSgpIDogbnVsbDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBsZXZlbDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3VwZGF0ZUNoaWxkcmVuRmllbGQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgZmllbGROYW1lID0gdGhpcy5fY2hpbGRyZW5PcHRpb25zLnNjaGVtYS5kYXRhO1xuXG5cdCAgICAgICAgICAgIHRoaXNbZmllbGROYW1lIHx8IFwiaXRlbXNcIl0gPSB0aGlzLmNoaWxkcmVuLmRhdGEoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2NoaWxkcmVuTG9hZGVkOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdGhpcy5fbG9hZGVkID0gdHJ1ZTtcblxuXHQgICAgICAgICAgICB0aGlzLl91cGRhdGVDaGlsZHJlbkZpZWxkKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGxvYWQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXHQgICAgICAgICAgICB2YXIgbWV0aG9kID0gXCJfcXVlcnlcIjtcblx0ICAgICAgICAgICAgdmFyIGNoaWxkcmVuLCBwcm9taXNlO1xuXG5cdCAgICAgICAgICAgIGlmICh0aGlzLmhhc0NoaWxkcmVuKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pbml0Q2hpbGRyZW4oKTtcblxuXHQgICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cdCAgICAgICAgICAgICAgICBvcHRpb25zW3RoaXMuaWRGaWVsZCB8fCBcImlkXCJdID0gdGhpcy5pZDtcblxuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5fZGF0YSA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSBcInJlYWRcIjtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgY2hpbGRyZW4ub25lKENIQU5HRSwgcHJveHkodGhpcy5fY2hpbGRyZW5Mb2FkZWQsIHRoaXMpKTtcblxuXHQgICAgICAgICAgICAgICAgaWYodGhpcy5fbWF0Y2hGaWx0ZXIpe1xuXHQgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZmlsdGVyID0geyBmaWVsZDogJ19tYXRjaEZpbHRlcicsIG9wZXJhdG9yOiAnZXEnLCB2YWx1ZTogdHJ1ZSB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBwcm9taXNlID0gY2hpbGRyZW5bbWV0aG9kXShvcHRpb25zKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMubG9hZGVkKHRydWUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2UgfHwgJC5EZWZlcnJlZCgpLnJlc29sdmUoKS5wcm9taXNlKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHBhcmVudE5vZGU6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLnBhcmVudCgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBhcnJheS5wYXJlbnQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgbG9hZGVkOiBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVkID0gdmFsdWU7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGVkO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHNob3VsZFNlcmlhbGl6ZTogZnVuY3Rpb24oZmllbGQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIE1vZGVsLmZuLnNob3VsZFNlcmlhbGl6ZS5jYWxsKHRoaXMsIGZpZWxkKSAmJlxuXHQgICAgICAgICAgICAgICAgICAgIGZpZWxkICE9PSBcImNoaWxkcmVuXCIgJiZcblx0ICAgICAgICAgICAgICAgICAgICBmaWVsZCAhPT0gXCJfbG9hZGVkXCIgJiZcblx0ICAgICAgICAgICAgICAgICAgICBmaWVsZCAhPT0gXCJoYXNDaGlsZHJlblwiICYmXG5cdCAgICAgICAgICAgICAgICAgICAgZmllbGQgIT09IFwiX2NoaWxkcmVuT3B0aW9uc1wiO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBmdW5jdGlvbiBkYXRhTWV0aG9kKG5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YSxcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCA9IERhdGFTb3VyY2UuZm5bbmFtZV0uYXBwbHkodGhpcywgc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcblxuXHQgICAgICAgICAgICBpZiAodGhpcy5fZGF0YSAhPSBkYXRhKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hdHRhY2hCdWJibGVIYW5kbGVycygpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgSGllcmFyY2hpY2FsRGF0YVNvdXJjZSA9IERhdGFTb3VyY2UuZXh0ZW5kKHtcblx0ICAgICAgICBpbml0OiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIHZhciBub2RlID0gTm9kZS5kZWZpbmUoe1xuXHQgICAgICAgICAgICAgICAgY2hpbGRyZW46IG9wdGlvbnNcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgaWYob3B0aW9ucy5maWx0ZXIgJiYgIW9wdGlvbnMuc2VydmVyRmlsdGVyaW5nKXtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2hpZXJhcmNoaWNhbEZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xuXHQgICAgICAgICAgICAgICAgb3B0aW9ucy5maWx0ZXIgPSBudWxsO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgRGF0YVNvdXJjZS5mbi5pbml0LmNhbGwodGhpcywgZXh0ZW5kKHRydWUsIHt9LCB7IHNjaGVtYTogeyBtb2RlbEJhc2U6IG5vZGUsIG1vZGVsOiBub2RlIH0gfSwgb3B0aW9ucykpO1xuXG5cdCAgICAgICAgICAgIHRoaXMuX2F0dGFjaEJ1YmJsZUhhbmRsZXJzKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9hdHRhY2hCdWJibGVIYW5kbGVyczogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuXHQgICAgICAgICAgICB0aGF0Ll9kYXRhLmJpbmQoRVJST1IsIGZ1bmN0aW9uKGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoYXQudHJpZ2dlcihFUlJPUiwgZSk7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICByZWFkOiBmdW5jdGlvbihkYXRhKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBEYXRhU291cmNlLmZuLnJlYWQuY2FsbCh0aGlzLCBkYXRhKTtcblxuXHQgICAgICAgICAgICBpZih0aGlzLl9oaWVyYXJjaGljYWxGaWx0ZXIpe1xuXHQgICAgICAgICAgICAgICAgaWYodGhpcy5fZGF0YSAmJiB0aGlzLl9kYXRhLmxlbmd0aCA+IDApe1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyKHRoaXMuX2hpZXJhcmNoaWNhbEZpbHRlcik7XG5cdCAgICAgICAgICAgICAgICB9ZWxzZXtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gdGhpcy5faGllcmFyY2hpY2FsRmlsdGVyO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlciA9IG5vcm1hbGl6ZUZpbHRlcih0aGlzLm9wdGlvbnMuZmlsdGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9oaWVyYXJjaGljYWxGaWx0ZXIgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihub2RlKXtcblx0ICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGUoKSxcblx0ICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgcmVzdWx0O1xuXG5cdCAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIHBhcmVudE5vZGUuX2luaXRDaGlsZHJlbikge1xuXHQgICAgICAgICAgICAgICAgZGF0YVNvdXJjZSA9IHBhcmVudE5vZGUuY2hpbGRyZW47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXN1bHQgPSBEYXRhU291cmNlLmZuLnJlbW92ZS5jYWxsKGRhdGFTb3VyY2UsIG5vZGUpO1xuXG5cdCAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmICFkYXRhU291cmNlLmRhdGEoKS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaGFzQ2hpbGRyZW4gPSBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHN1Y2Nlc3M6IGRhdGFNZXRob2QoXCJzdWNjZXNzXCIpLFxuXG5cdCAgICAgICAgZGF0YTogZGF0YU1ldGhvZChcImRhdGFcIiksXG5cblx0ICAgICAgICBpbnNlcnQ6IGZ1bmN0aW9uKGluZGV4LCBtb2RlbCkge1xuXHQgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50KCk7XG5cblx0ICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUgJiYgcGFyZW50Tm9kZS5faW5pdENoaWxkcmVuKSB7XG5cdCAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmhhc0NoaWxkcmVuID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuX2luaXRDaGlsZHJlbigpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIERhdGFTb3VyY2UuZm4uaW5zZXJ0LmNhbGwodGhpcywgaW5kZXgsIG1vZGVsKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZmlsdGVyOiBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmKCF0aGlzLm9wdGlvbnMuc2VydmVyRmlsdGVyaW5nICYmIHRoaXMuX21hcmtIaWVyYXJjaGljYWxRdWVyeSh2YWwpKXtcblx0ICAgICAgICAgICAgICAgIHZhbCA9IHsgbG9naWM6IFwib3JcIiwgZmlsdGVyczogW3ZhbCwge2ZpZWxkOidfbWF0Y2hGaWx0ZXInLCBvcGVyYXRvcjogJ2VxdWFscycsIHZhbHVlOiB0cnVlIH1dfTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHRoaXMudHJpZ2dlcihcInJlc2V0XCIpO1xuXHQgICAgICAgICAgICB0aGlzLl9xdWVyeSh7IGZpbHRlcjogdmFsLCBwYWdlOiAxIH0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbWFya0hpZXJhcmNoaWNhbFF1ZXJ5OiBmdW5jdGlvbihleHByZXNzaW9ucyl7XG5cdCAgICAgICAgICAgIHZhciBjb21waWxlZDtcblx0ICAgICAgICAgICAgdmFyIHByZWRpY2F0ZTtcblx0ICAgICAgICAgICAgdmFyIGZpZWxkcztcblx0ICAgICAgICAgICAgdmFyIG9wZXJhdG9ycztcblx0ICAgICAgICAgICAgdmFyIGZpbHRlcjtcblxuXHQgICAgICAgICAgICBleHByZXNzaW9ucyA9IG5vcm1hbGl6ZUZpbHRlcihleHByZXNzaW9ucyk7XG5cblx0ICAgICAgICAgICAgaWYgKCFleHByZXNzaW9ucyB8fCBleHByZXNzaW9ucy5maWx0ZXJzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlSGllcmFyY2hpY2FsRmlsdGVyKGZ1bmN0aW9uKCl7cmV0dXJuIHRydWU7fSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBjb21waWxlZCA9IFF1ZXJ5LmZpbHRlckV4cHIoZXhwcmVzc2lvbnMpO1xuXHQgICAgICAgICAgICBmaWVsZHMgPSBjb21waWxlZC5maWVsZHM7XG5cdCAgICAgICAgICAgIG9wZXJhdG9ycyA9IGNvbXBpbGVkLm9wZXJhdG9ycztcblxuXHQgICAgICAgICAgICBwcmVkaWNhdGUgPSBmaWx0ZXIgPSBuZXcgRnVuY3Rpb24oXCJkLCBfX2YsIF9fb1wiLCBcInJldHVybiBcIiArIGNvbXBpbGVkLmV4cHJlc3Npb24pO1xuXG5cdCAgICAgICAgICAgIGlmIChmaWVsZHMubGVuZ3RoIHx8IG9wZXJhdG9ycy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIGZpbHRlciA9IGZ1bmN0aW9uKGQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlKGQsIGZpZWxkcywgb3BlcmF0b3JzKTtcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGlzLl91cGRhdGVIaWVyYXJjaGljYWxGaWx0ZXIoZmlsdGVyKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgICBfdXBkYXRlSGllcmFyY2hpY2FsRmlsdGVyOiBmdW5jdGlvbihmaWx0ZXIpe1xuXHQgICAgICAgICAgICB2YXIgY3VycmVudDtcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgZGF0YS5sZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICAgY3VycmVudCA9IGRhdGFbaWR4XTtcblxuXHQgICAgICAgICAgICAgICAgIGlmKGN1cnJlbnQuaGFzQ2hpbGRyZW4pe1xuXHQgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Ll9tYXRjaEZpbHRlciA9IGN1cnJlbnQuY2hpbGRyZW4uX3VwZGF0ZUhpZXJhcmNoaWNhbEZpbHRlcihmaWx0ZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmKCFjdXJyZW50Ll9tYXRjaEZpbHRlcil7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuX21hdGNoRmlsdGVyID0gZmlsdGVyKGN1cnJlbnQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1lbHNle1xuXHQgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQuX21hdGNoRmlsdGVyID0gZmlsdGVyKGN1cnJlbnQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZihjdXJyZW50Ll9tYXRjaEZpbHRlcil7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZmluZDogZnVuY3Rpb24obWV0aG9kLCB2YWx1ZSkge1xuXHQgICAgICAgICAgICB2YXIgaWR4LCBsZW5ndGgsIG5vZGUsIGNoaWxkcmVuO1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cblx0ICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBub2RlID0gRGF0YVNvdXJjZS5mblttZXRob2RdLmNhbGwodGhpcywgdmFsdWUpO1xuXG5cdCAgICAgICAgICAgIGlmIChub2RlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9mbGF0RGF0YSh0aGlzLl9kYXRhKTtcblxuXHQgICAgICAgICAgICBmb3IgKGlkeCA9IDAsIGxlbmd0aCA9IGRhdGEubGVuZ3RoOyBpZHggPCBsZW5ndGg7IGlkeCsrKSB7XG5cdCAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IGRhdGFbaWR4XS5jaGlsZHJlbjtcblxuXHQgICAgICAgICAgICAgICAgaWYgKCEoY2hpbGRyZW4gaW5zdGFuY2VvZiBIaWVyYXJjaGljYWxEYXRhU291cmNlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBub2RlID0gY2hpbGRyZW5bbWV0aG9kXSh2YWx1ZSk7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbihpZCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluZChcImdldFwiLCBpZCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGdldEJ5VWlkOiBmdW5jdGlvbih1aWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmQoXCJnZXRCeVVpZFwiLCB1aWQpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICBmdW5jdGlvbiBpbmZlckxpc3QobGlzdCwgZmllbGRzKSB7XG5cdCAgICAgICAgdmFyIGl0ZW1zID0gJChsaXN0KS5jaGlsZHJlbigpLFxuXHQgICAgICAgICAgICBpZHgsXG5cdCAgICAgICAgICAgIGxlbmd0aCxcblx0ICAgICAgICAgICAgZGF0YSA9IFtdLFxuXHQgICAgICAgICAgICByZWNvcmQsXG5cdCAgICAgICAgICAgIHRleHRGaWVsZCA9IGZpZWxkc1swXS5maWVsZCxcblx0ICAgICAgICAgICAgdXJsRmllbGQgPSBmaWVsZHNbMV0gJiYgZmllbGRzWzFdLmZpZWxkLFxuXHQgICAgICAgICAgICBzcHJpdGVDc3NDbGFzc0ZpZWxkID0gZmllbGRzWzJdICYmIGZpZWxkc1syXS5maWVsZCxcblx0ICAgICAgICAgICAgaW1hZ2VVcmxGaWVsZCA9IGZpZWxkc1szXSAmJiBmaWVsZHNbM10uZmllbGQsXG5cdCAgICAgICAgICAgIGl0ZW0sXG5cdCAgICAgICAgICAgIGlkLFxuXHQgICAgICAgICAgICB0ZXh0Q2hpbGQsXG5cdCAgICAgICAgICAgIGNsYXNzTmFtZSxcblx0ICAgICAgICAgICAgY2hpbGRyZW47XG5cblx0ICAgICAgICBmdW5jdGlvbiBlbGVtZW50cyhjb2xsZWN0aW9uLCB0YWdOYW1lKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uLmZpbHRlcih0YWdOYW1lKS5hZGQoY29sbGVjdGlvbi5maW5kKHRhZ05hbWUpKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmb3IgKGlkeCA9IDAsIGxlbmd0aCA9IGl0ZW1zLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuXHQgICAgICAgICAgICByZWNvcmQgPSB7IF9sb2FkZWQ6IHRydWUgfTtcblx0ICAgICAgICAgICAgaXRlbSA9IGl0ZW1zLmVxKGlkeCk7XG5cblx0ICAgICAgICAgICAgdGV4dENoaWxkID0gaXRlbVswXS5maXJzdENoaWxkO1xuXHQgICAgICAgICAgICBjaGlsZHJlbiA9IGl0ZW0uY2hpbGRyZW4oKTtcblx0ICAgICAgICAgICAgbGlzdCA9IGNoaWxkcmVuLmZpbHRlcihcInVsXCIpO1xuXHQgICAgICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihcIjpub3QodWwpXCIpO1xuXG5cdCAgICAgICAgICAgIGlkID0gaXRlbS5hdHRyKFwiZGF0YS1pZFwiKTtcblxuXHQgICAgICAgICAgICBpZiAoaWQpIHtcblx0ICAgICAgICAgICAgICAgIHJlY29yZC5pZCA9IGlkO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHRleHRDaGlsZCkge1xuXHQgICAgICAgICAgICAgICAgcmVjb3JkW3RleHRGaWVsZF0gPSB0ZXh0Q2hpbGQubm9kZVR5cGUgPT0gMyA/IHRleHRDaGlsZC5ub2RlVmFsdWUgOiBjaGlsZHJlbi50ZXh0KCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAodXJsRmllbGQpIHtcblx0ICAgICAgICAgICAgICAgIHJlY29yZFt1cmxGaWVsZF0gPSBlbGVtZW50cyhjaGlsZHJlbiwgXCJhXCIpLmF0dHIoXCJocmVmXCIpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKGltYWdlVXJsRmllbGQpIHtcblx0ICAgICAgICAgICAgICAgIHJlY29yZFtpbWFnZVVybEZpZWxkXSA9IGVsZW1lbnRzKGNoaWxkcmVuLCBcImltZ1wiKS5hdHRyKFwic3JjXCIpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgaWYgKHNwcml0ZUNzc0NsYXNzRmllbGQpIHtcblx0ICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IGVsZW1lbnRzKGNoaWxkcmVuLCBcIi5rLXNwcml0ZVwiKS5wcm9wKFwiY2xhc3NOYW1lXCIpO1xuXHQgICAgICAgICAgICAgICAgcmVjb3JkW3Nwcml0ZUNzc0NsYXNzRmllbGRdID0gY2xhc3NOYW1lICYmICQudHJpbShjbGFzc05hbWUucmVwbGFjZShcImstc3ByaXRlXCIsIFwiXCIpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgcmVjb3JkLml0ZW1zID0gaW5mZXJMaXN0KGxpc3QuZXEoMCksIGZpZWxkcyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoaXRlbS5hdHRyKFwiZGF0YS1oYXNDaGlsZHJlblwiKSA9PSBcInRydWVcIikge1xuXHQgICAgICAgICAgICAgICAgcmVjb3JkLmhhc0NoaWxkcmVuID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGRhdGEucHVzaChyZWNvcmQpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBkYXRhO1xuXHQgICAgfVxuXG5cdCAgICBIaWVyYXJjaGljYWxEYXRhU291cmNlLmNyZWF0ZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0ICAgICAgICBvcHRpb25zID0gb3B0aW9ucyAmJiBvcHRpb25zLnB1c2ggPyB7IGRhdGE6IG9wdGlvbnMgfSA6IG9wdGlvbnM7XG5cblx0ICAgICAgICB2YXIgZGF0YVNvdXJjZSA9IG9wdGlvbnMgfHwge30sXG5cdCAgICAgICAgICAgIGRhdGEgPSBkYXRhU291cmNlLmRhdGEsXG5cdCAgICAgICAgICAgIGZpZWxkcyA9IGRhdGFTb3VyY2UuZmllbGRzLFxuXHQgICAgICAgICAgICBsaXN0ID0gZGF0YVNvdXJjZS5saXN0O1xuXG5cdCAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5fZGF0YVNvdXJjZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZGF0YS5fZGF0YVNvdXJjZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoIWRhdGEgJiYgZmllbGRzICYmICFkYXRhU291cmNlLnRyYW5zcG9ydCkge1xuXHQgICAgICAgICAgICBpZiAobGlzdCkge1xuXHQgICAgICAgICAgICAgICAgZGF0YSA9IGluZmVyTGlzdChsaXN0LCBmaWVsZHMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZGF0YVNvdXJjZS5kYXRhID0gZGF0YTtcblxuXHQgICAgICAgIHJldHVybiBkYXRhU291cmNlIGluc3RhbmNlb2YgSGllcmFyY2hpY2FsRGF0YVNvdXJjZSA/IGRhdGFTb3VyY2UgOiBuZXcgSGllcmFyY2hpY2FsRGF0YVNvdXJjZShkYXRhU291cmNlKTtcblx0ICAgIH07XG5cblx0ICAgIHZhciBCdWZmZXIgPSBrZW5kby5PYnNlcnZhYmxlLmV4dGVuZCh7XG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24oZGF0YVNvdXJjZSwgdmlld1NpemUsIGRpc2FibGVQcmVmZXRjaCkge1xuXHQgICAgICAgICAgICBrZW5kby5PYnNlcnZhYmxlLmZuLmluaXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICB0aGlzLl9wcmVmZXRjaGluZyA9IGZhbHNlO1xuXHQgICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UgPSBkYXRhU291cmNlO1xuXHQgICAgICAgICAgICB0aGlzLnByZWZldGNoID0gIWRpc2FibGVQcmVmZXRjaDtcblxuXHQgICAgICAgICAgICB2YXIgYnVmZmVyID0gdGhpcztcblxuXHQgICAgICAgICAgICBkYXRhU291cmNlLmJpbmQoXCJjaGFuZ2VcIiwgZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBidWZmZXIuX2NoYW5nZSgpO1xuXHQgICAgICAgICAgICB9KTtcblxuXHQgICAgICAgICAgICBkYXRhU291cmNlLmJpbmQoXCJyZXNldFwiLCBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIGJ1ZmZlci5fcmVzZXQoKTtcblx0ICAgICAgICAgICAgfSk7XG5cblx0ICAgICAgICAgICAgdGhpcy5fc3luY1dpdGhEYXRhU291cmNlKCk7XG5cblx0ICAgICAgICAgICAgdGhpcy5zZXRWaWV3U2l6ZSh2aWV3U2l6ZSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHNldFZpZXdTaXplOiBmdW5jdGlvbih2aWV3U2l6ZSkge1xuXHQgICAgICAgICAgICB0aGlzLnZpZXdTaXplID0gdmlld1NpemU7XG5cdCAgICAgICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGF0OiBmdW5jdGlvbihpbmRleCkgIHtcblx0ICAgICAgICAgICAgdmFyIHBhZ2VTaXplID0gdGhpcy5wYWdlU2l6ZSxcblx0ICAgICAgICAgICAgICAgIGl0ZW1QcmVzZW50ID0gdHJ1ZTtcblxuXHQgICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy50b3RhbCgpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJlbmRyZWFjaGVkXCIsIHtpbmRleDogaW5kZXggfSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICghdGhpcy51c2VSYW5nZXMpIHtcblx0ICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS52aWV3KClbaW5kZXhdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0aGlzLnVzZVJhbmdlcykge1xuXHQgICAgICAgICAgICAgICAgLy8gb3V0IG9mIHJhbmdlIHJlcXVlc3Rcblx0ICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHRoaXMuZGF0YU9mZnNldCB8fCBpbmRleCA+PSB0aGlzLnNraXAgKyBwYWdlU2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGl0ZW1QcmVzZW50ID0gdGhpcy5yYW5nZShNYXRoLmZsb29yKGluZGV4IC8gcGFnZVNpemUpICogcGFnZVNpemUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBwcmVmZXRjaFxuXHQgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLnByZWZldGNoVGhyZXNob2xkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlZmV0Y2goKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gbWlkLXJhbmdlIGp1bXAgLSBwcmVmZXRjaFRocmVzaG9sZCBhbmQgbmV4dFBhZ2VUaHJlc2hvbGQgbWF5IGJlIGVxdWFsLCBkbyBub3QgY2hhbmdlIHRvIGVsc2UgaWZcblx0ICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5taWRQYWdlVGhyZXNob2xkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5yYW5nZSh0aGlzLm5leHRNaWRSYW5nZSwgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvLyBuZXh0IHJhbmdlIGp1bXBcblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSB0aGlzLm5leHRQYWdlVGhyZXNob2xkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5yYW5nZSh0aGlzLm5leHRGdWxsUmFuZ2UpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gcHVsbC1iYWNrXG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gdGhpcy5wdWxsQmFja1RocmVzaG9sZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9mZnNldCA9PT0gdGhpcy5za2lwKSB7IC8vIGZyb20gZnVsbCByYW5nZSB0byBtaWQgcmFuZ2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yYW5nZSh0aGlzLnByZXZpb3VzTWlkUmFuZ2UpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGZyb20gbWlkIHJhbmdlIHRvIGZ1bGwgcmFuZ2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yYW5nZSh0aGlzLnByZXZpb3VzRnVsbFJhbmdlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpdGVtUHJlc2VudCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuYXQoaW5kZXggLSB0aGlzLmRhdGFPZmZzZXQpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJlbmRyZWFjaGVkXCIsIHsgaW5kZXg6IGluZGV4IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGluZGV4T2Y6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5kYXRhKCkuaW5kZXhPZihpdGVtKSArIHRoaXMuZGF0YU9mZnNldDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgdG90YWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5kYXRhU291cmNlLnRvdGFsKCksIDEwKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciBidWZmZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgcGFnZVNpemUgPSBidWZmZXIucGFnZVNpemUsXG5cdCAgICAgICAgICAgICAgICBvZmZzZXQgPSBidWZmZXIuc2tpcCAtIGJ1ZmZlci52aWV3U2l6ZSArIHBhZ2VTaXplLFxuXHQgICAgICAgICAgICAgICAgcGFnZVNraXAgPSBtYXRoLm1heChtYXRoLmZsb29yKG9mZnNldCAvIHBhZ2VTaXplKSwgMCkgKiBwYWdlU2l6ZTtcblxuXHQgICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcblx0ICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnByZWZldGNoKHBhZ2VTa2lwLCBwYWdlU2l6ZSwgZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBidWZmZXIuX2dvVG9SYW5nZShvZmZzZXQsIHRydWUpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgcmFuZ2U6IGZ1bmN0aW9uKG9mZnNldCwgbmV4dFJhbmdlKSB7XG5cdCAgICAgICAgICAgIGlmICh0aGlzLm9mZnNldCA9PT0gb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHZhciBidWZmZXIgPSB0aGlzLFxuXHQgICAgICAgICAgICAgICAgcGFnZVNpemUgPSB0aGlzLnBhZ2VTaXplLFxuXHQgICAgICAgICAgICAgICAgcGFnZVNraXAgPSBtYXRoLm1heChtYXRoLmZsb29yKG9mZnNldCAvIHBhZ2VTaXplKSwgMCkgKiBwYWdlU2l6ZSxcblx0ICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UgPSB0aGlzLmRhdGFTb3VyY2U7XG5cblx0ICAgICAgICAgICAgaWYgKG5leHRSYW5nZSkge1xuXHQgICAgICAgICAgICAgICAgcGFnZVNraXAgKz0gcGFnZVNpemU7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAoZGF0YVNvdXJjZS5pblJhbmdlKG9mZnNldCwgcGFnZVNpemUpKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlKCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9nb1RvUmFuZ2Uob2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJlZmV0Y2gpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGFTb3VyY2UucHJlZmV0Y2gocGFnZVNraXAsIHBhZ2VTaXplLCBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBidWZmZXIub2Zmc2V0ID0gb2Zmc2V0O1xuXHQgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5fcmVjYWxjdWxhdGUoKTtcblx0ICAgICAgICAgICAgICAgICAgICBidWZmZXIuX2dvVG9SYW5nZShvZmZzZXQsIHRydWUpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgc3luY0RhdGFTb3VyY2U6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG5cdCAgICAgICAgICAgIHRoaXMub2Zmc2V0ID0gbnVsbDtcblx0ICAgICAgICAgICAgdGhpcy5yYW5nZShvZmZzZXQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdGhpcy51bmJpbmQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3ByZWZldGNoOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMsXG5cdCAgICAgICAgICAgICAgICBwYWdlU2l6ZSA9IHRoaXMucGFnZVNpemUsXG5cdCAgICAgICAgICAgICAgICBwcmVmZXRjaE9mZnNldCA9IHRoaXMuc2tpcCArIHBhZ2VTaXplLFxuXHQgICAgICAgICAgICAgICAgZGF0YVNvdXJjZSA9IHRoaXMuZGF0YVNvdXJjZTtcblxuXHQgICAgICAgICAgICBpZiAoIWRhdGFTb3VyY2UuaW5SYW5nZShwcmVmZXRjaE9mZnNldCwgcGFnZVNpemUpICYmICF0aGlzLl9wcmVmZXRjaGluZyAmJiB0aGlzLnByZWZldGNoKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wcmVmZXRjaGluZyA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJwcmVmZXRjaGluZ1wiLCB7IHNraXA6IHByZWZldGNoT2Zmc2V0LCB0YWtlOiBwYWdlU2l6ZSB9KTtcblxuXHQgICAgICAgICAgICAgICAgZGF0YVNvdXJjZS5wcmVmZXRjaChwcmVmZXRjaE9mZnNldCwgcGFnZVNpemUsIGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5fcHJlZmV0Y2hpbmcgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICBidWZmZXIudHJpZ2dlcihcInByZWZldGNoZWRcIiwgeyBza2lwOiBwcmVmZXRjaE9mZnNldCwgdGFrZTogcGFnZVNpemUgfSk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZ29Ub1JhbmdlOiBmdW5jdGlvbihvZmZzZXQsIGV4cGFuZGluZykge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5vZmZzZXQgIT09IG9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgdGhpcy5kYXRhT2Zmc2V0ID0gb2Zmc2V0O1xuXHQgICAgICAgICAgICB0aGlzLl9leHBhbmRpbmcgPSBleHBhbmRpbmc7XG5cdCAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5yYW5nZShvZmZzZXQsIHRoaXMucGFnZVNpemUpO1xuXHQgICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UuZW5hYmxlUmVxdWVzdHNJblByb2dyZXNzKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9yZXNldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3N5bmNQZW5kaW5nID0gdHJ1ZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2NoYW5nZTogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciBkYXRhU291cmNlID0gdGhpcy5kYXRhU291cmNlO1xuXG5cdCAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy51c2VSYW5nZXMgPyBkYXRhU291cmNlLmxhc3RSYW5nZSgpLmVuZCA6IGRhdGFTb3VyY2UudmlldygpLmxlbmd0aDtcblxuXHQgICAgICAgICAgICBpZiAodGhpcy5fc3luY1BlbmRpbmcpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3N5bmNXaXRoRGF0YVNvdXJjZSgpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcmVjYWxjdWxhdGUoKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3N5bmNQZW5kaW5nID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJyZXNldFwiLCB7IG9mZnNldDogdGhpcy5vZmZzZXQgfSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGlzLnRyaWdnZXIoXCJyZXNpemVcIik7XG5cblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2V4cGFuZGluZykge1xuXHQgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKFwiZXhwYW5kXCIpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V4cGFuZGluZztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX3N5bmNXaXRoRGF0YVNvdXJjZTogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHZhciBkYXRhU291cmNlID0gdGhpcy5kYXRhU291cmNlO1xuXG5cdCAgICAgICAgICAgIHRoaXMuX2ZpcnN0SXRlbVVpZCA9IGRhdGFTb3VyY2UuZmlyc3RJdGVtVWlkKCk7XG5cdCAgICAgICAgICAgIHRoaXMuZGF0YU9mZnNldCA9IHRoaXMub2Zmc2V0ID0gZGF0YVNvdXJjZS5za2lwKCkgfHwgMDtcblx0ICAgICAgICAgICAgdGhpcy5wYWdlU2l6ZSA9IGRhdGFTb3VyY2UucGFnZVNpemUoKTtcblx0ICAgICAgICAgICAgdGhpcy51c2VSYW5nZXMgPSBkYXRhU291cmNlLm9wdGlvbnMuc2VydmVyUGFnaW5nO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfcmVjYWxjdWxhdGU6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgcGFnZVNpemUgPSB0aGlzLnBhZ2VTaXplLFxuXHQgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5vZmZzZXQsXG5cdCAgICAgICAgICAgICAgICB2aWV3U2l6ZSA9IHRoaXMudmlld1NpemUsXG5cdCAgICAgICAgICAgICAgICBza2lwID0gTWF0aC5jZWlsKG9mZnNldCAvIHBhZ2VTaXplKSAqIHBhZ2VTaXplO1xuXG5cdCAgICAgICAgICAgIHRoaXMuc2tpcCA9IHNraXA7XG5cdCAgICAgICAgICAgIHRoaXMubWlkUGFnZVRocmVzaG9sZCA9IHNraXAgKyBwYWdlU2l6ZSAtIDE7XG5cdCAgICAgICAgICAgIHRoaXMubmV4dFBhZ2VUaHJlc2hvbGQgPSBza2lwICsgdmlld1NpemUgLSAxO1xuXHQgICAgICAgICAgICB0aGlzLnByZWZldGNoVGhyZXNob2xkID0gc2tpcCArIE1hdGguZmxvb3IocGFnZVNpemUgLyAzICogMik7XG5cdCAgICAgICAgICAgIHRoaXMucHVsbEJhY2tUaHJlc2hvbGQgPSB0aGlzLm9mZnNldCAtIDE7XG5cblx0ICAgICAgICAgICAgdGhpcy5uZXh0TWlkUmFuZ2UgPSBza2lwICsgcGFnZVNpemUgLSB2aWV3U2l6ZTtcblx0ICAgICAgICAgICAgdGhpcy5uZXh0RnVsbFJhbmdlID0gc2tpcDtcblx0ICAgICAgICAgICAgdGhpcy5wcmV2aW91c01pZFJhbmdlID0gb2Zmc2V0IC0gdmlld1NpemU7XG5cdCAgICAgICAgICAgIHRoaXMucHJldmlvdXNGdWxsUmFuZ2UgPSBza2lwIC0gcGFnZVNpemU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIHZhciBCYXRjaEJ1ZmZlciA9IGtlbmRvLk9ic2VydmFibGUuZXh0ZW5kKHtcblx0ICAgICAgICBpbml0OiBmdW5jdGlvbihkYXRhU291cmNlLCBiYXRjaFNpemUpIHtcblx0ICAgICAgICAgICAgdmFyIGJhdGNoQnVmZmVyID0gdGhpcztcblxuXHQgICAgICAgICAgICBrZW5kby5PYnNlcnZhYmxlLmZuLmluaXQuY2FsbChiYXRjaEJ1ZmZlcik7XG5cblx0ICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlID0gZGF0YVNvdXJjZTtcblx0ICAgICAgICAgICAgdGhpcy5iYXRjaFNpemUgPSBiYXRjaFNpemU7XG5cdCAgICAgICAgICAgIHRoaXMuX3RvdGFsID0gMDtcblxuXHQgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXIoZGF0YVNvdXJjZSwgYmF0Y2hTaXplICogMyk7XG5cblx0ICAgICAgICAgICAgdGhpcy5idWZmZXIuYmluZCh7XG5cdCAgICAgICAgICAgICAgICBcImVuZHJlYWNoZWRcIjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXRjaEJ1ZmZlci50cmlnZ2VyKFwiZW5kcmVhY2hlZFwiLCB7IGluZGV4OiBlLmluZGV4IH0pO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIFwicHJlZmV0Y2hpbmdcIjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXRjaEJ1ZmZlci50cmlnZ2VyKFwicHJlZmV0Y2hpbmdcIiwgeyBza2lwOiBlLnNraXAsIHRha2U6IGUudGFrZSB9KTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBcInByZWZldGNoZWRcIjogZnVuY3Rpb24gKGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXRjaEJ1ZmZlci50cmlnZ2VyKFwicHJlZmV0Y2hlZFwiLCB7IHNraXA6IGUuc2tpcCwgdGFrZTogZS50YWtlIH0pO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIFwicmVzZXRcIjogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJhdGNoQnVmZmVyLl90b3RhbCA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgYmF0Y2hCdWZmZXIudHJpZ2dlcihcInJlc2V0XCIpO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIFwicmVzaXplXCI6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXRjaEJ1ZmZlci5fdG90YWwgPSBNYXRoLmNlaWwodGhpcy5sZW5ndGggLyBiYXRjaEJ1ZmZlci5iYXRjaFNpemUpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJhdGNoQnVmZmVyLnRyaWdnZXIoXCJyZXNpemVcIiwgeyB0b3RhbDogYmF0Y2hCdWZmZXIudG90YWwoKSwgb2Zmc2V0OiB0aGlzLm9mZnNldCB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHN5bmNEYXRhU291cmNlOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdGhpcy5idWZmZXIuc3luY0RhdGFTb3VyY2UoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYXQ6IGZ1bmN0aW9uKGluZGV4KSB7XG5cdCAgICAgICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcblx0ICAgICAgICAgICAgICAgIHNraXAgPSBpbmRleCAqIHRoaXMuYmF0Y2hTaXplLFxuXHQgICAgICAgICAgICAgICAgdGFrZSA9IHRoaXMuYmF0Y2hTaXplLFxuXHQgICAgICAgICAgICAgICAgdmlldyA9IFtdLFxuXHQgICAgICAgICAgICAgICAgaXRlbTtcblxuXHQgICAgICAgICAgICBpZiAoYnVmZmVyLm9mZnNldCA+IHNraXApIHtcblx0ICAgICAgICAgICAgICAgIGJ1ZmZlci5hdChidWZmZXIub2Zmc2V0IC0gMSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRha2U7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaXRlbSA9IGJ1ZmZlci5hdChza2lwICsgaSk7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpdGVtID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZpZXcucHVzaChpdGVtKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB2aWV3O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICB0b3RhbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl90b3RhbDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHRoaXMuYnVmZmVyLmRlc3Ryb3koKTtcblx0ICAgICAgICAgICAgdGhpcy51bmJpbmQoKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZXh0ZW5kKHRydWUsIGtlbmRvLmRhdGEsIHtcblx0ICAgICAgICByZWFkZXJzOiB7XG5cdCAgICAgICAgICAgIGpzb246IERhdGFSZWFkZXJcblx0ICAgICAgICB9LFxuXHQgICAgICAgIFF1ZXJ5OiBRdWVyeSxcblx0ICAgICAgICBEYXRhU291cmNlOiBEYXRhU291cmNlLFxuXHQgICAgICAgIEhpZXJhcmNoaWNhbERhdGFTb3VyY2U6IEhpZXJhcmNoaWNhbERhdGFTb3VyY2UsXG5cdCAgICAgICAgTm9kZTogTm9kZSxcblx0ICAgICAgICBPYnNlcnZhYmxlT2JqZWN0OiBPYnNlcnZhYmxlT2JqZWN0LFxuXHQgICAgICAgIE9ic2VydmFibGVBcnJheTogT2JzZXJ2YWJsZUFycmF5LFxuXHQgICAgICAgIExhenlPYnNlcnZhYmxlQXJyYXk6IExhenlPYnNlcnZhYmxlQXJyYXksXG5cdCAgICAgICAgTG9jYWxUcmFuc3BvcnQ6IExvY2FsVHJhbnNwb3J0LFxuXHQgICAgICAgIFJlbW90ZVRyYW5zcG9ydDogUmVtb3RlVHJhbnNwb3J0LFxuXHQgICAgICAgIENhY2hlOiBDYWNoZSxcblx0ICAgICAgICBEYXRhUmVhZGVyOiBEYXRhUmVhZGVyLFxuXHQgICAgICAgIE1vZGVsOiBNb2RlbCxcblx0ICAgICAgICBCdWZmZXI6IEJ1ZmZlcixcblx0ICAgICAgICBCYXRjaEJ1ZmZlcjogQmF0Y2hCdWZmZXJcblx0ICAgIH0pO1xuXHR9KSh3aW5kb3cua2VuZG8ualF1ZXJ5KTtcblxuXHRyZXR1cm4gd2luZG93LmtlbmRvO1xuXG5cdH0sIF9fd2VicGFja19yZXF1aXJlX18oMykpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMDQ3OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4va2VuZG8uZGF0YS5vZGF0YVwiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDEwNDg6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9rZW5kby5kYXRhLnhtbFwiKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///f78db54954381e284430\n");

/***/ })

/******/ });