/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/Anakeen/smartStructures/dev/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/*!****************************************************************************!*\
  !*** multi ./src/vendor/Anakeen/SmartStructures/Dsearch/Render/dsearch.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /home/charles/git/user-interfaces/src/vendor/Anakeen/SmartStructures/Dsearch/Render/dsearch.js */"3ce9a5f32f55f2d96d6f");


/***/ }),

/***/ "0aac488a388d7f2d0eea":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMGFhYzQ4OGEzODhkN2YyZDBlZWEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzP2Y2ZDMiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0aac488a388d7f2d0eea\n");

/***/ }),

/***/ "13cab0e927159d1d3ebb":
/*!********************************************************************************!*\
  !*** ./src/vendor/Anakeen/SmartStructures/Dsearch/Render/searchUIEventEdit.js ***!
  \********************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _searchUISEGrid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./searchUISEGrid */ \"c3c916b9a83e10a2f671\");\n/**\n * Created by Alex on 09/06/15.\n */\n\n/*\n Research result in edit mode\n */\n\n\n\n{\n  window.dcp.document.documentController(\n    \"addEventListener\",\n    \"ready\",\n    {\n      name: \"addDsearchResultEditEvent\",\n      documentCheck: function isDsearch(document) {\n        return document.renderMode === \"edit\" && document.type === \"search\";\n      }\n    },\n    function prepareResultEditEvents() {\n      var $documentController = $(this);\n      var $tab = $(\"#search-tabstrip\");\n      $tab.kendoTabStrip({\n        select: function(event) {\n          var $li = $(event.item);\n          if ($li.hasClass(\"result-tab\")) {\n            showTmpGrid(event, $documentController, $(\".result--content\"));\n          }\n          $li\n            .parent()\n            .find(\"li.dcpLabel--active\")\n            .removeClass(\"dcpLabel--active\");\n          $li.addClass(\"dcpLabel--active\");\n        },\n        show: function() {\n          // To update responsiveColumn\n          $(window).trigger(\"resize\");\n        }\n      });\n\n      $(this).documentController(\n        \"addEventListener\",\n        \"actionClick\",\n        {\n          name: \"previewEdit.editEvent\",\n          documentCheck: function isDSearch(document) {\n            return document.type === \"search\" && document.renderMode === \"edit\";\n          }\n        },\n        function eventButtonEdit(event, document, data) {\n          if (data.eventId === \"previewEdit\") {\n            $tab.kendoTabStrip(\"select\", \".result-tab\");\n            //showGrid(event, $documentController);\n          }\n        }\n      );\n    }\n  );\n\n  window.dcp.document.documentController(\n    \"addEventListener\",\n    \"close\",\n    {\n      name: \"removeDsearchResultEditEvent\",\n      documentCheck: function(document) {\n        return document.type === \"search\";\n      }\n    },\n    function() {\n      var $this = $(this);\n      $this.documentController(\"removeEventListener\", \".editEvent\");\n    }\n  );\n\n  window.dcp.document.documentController(\n    \"addEventListener\",\n    \"ready\",\n    {\n      name: \"searchviewresults\",\n      documentCheck: function(document) {\n        return document.type === \"search\";\n      }\n    },\n    function viewresult(event, document) {\n      var $result = $(\".report-result-content\");\n      if ($result.length === 1) {\n        Object(_searchUISEGrid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(document.id, $result);\n      }\n    }\n  );\n\n  function showTmpGrid(event, $documentController, $target) {\n    var $dataJSON = null;\n\n    $target.addClass(\"result--grid\");\n    $target.addClass(\"result--waiting\");\n    $dataJSON = $documentController\n      .data(\"dcpDocumentController\")\n      ._model.toJSON();\n    $dataJSON.document.attributes = $documentController\n      .data(\"dcpDocumentController\")\n      ._model.getValues(false);\n    $.ajax({\n      method: \"POST\",\n      url:\n        \"api/v2/smartstructures/dsearch/temporaryDoc/\" +\n        $documentController.documentController(\"getProperties\").family.name +\n        \"/\",\n      data: JSON.stringify($dataJSON),\n      dataType: \"json\",\n      contentType: \"application/json; charset=utf-8\"\n    })\n      .done(function creation(docCreated) {\n        var continueDefault = $documentController.documentController(\n          \"triggerEvent\",\n          \"custom:content\",\n          {\n            familyName: $documentController.documentController(\"getProperties\")\n              .family.name,\n            id: docCreated.data.document.properties.id,\n            title: $documentController.documentController(\"getProperties\").title\n          }\n        );\n        if (!continueDefault) {\n          event.preventDefault();\n        } else {\n          Object(_searchUISEGrid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(docCreated.data.document.properties.id, $target).fail(\n            function(errorMsg) {\n              $documentController.documentController(\"showMessage\", {\n                type: \"error\",\n                message: errorMsg\n              });\n            }\n          );\n        }\n      })\n      .fail(function failedCreation(jqXHR) {\n        var response = JSON.parse(jqXHR.responseText);\n        $documentController.documentController(\"showMessage\", {\n          type: \"error\",\n          message: response.exceptionMessage\n        });\n      });\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTNjYWIwZTkyNzE1OWQxZDNlYmIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9yL0FuYWtlZW4vU21hcnRTdHJ1Y3R1cmVzL0RzZWFyY2gvUmVuZGVyL3NlYXJjaFVJRXZlbnRFZGl0LmpzPzQxMDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDcmVhdGVkIGJ5IEFsZXggb24gMDkvMDYvMTUuXG4gKi9cblxuLypcbiBSZXNlYXJjaCByZXN1bHQgaW4gZWRpdCBtb2RlXG4gKi9cblxuaW1wb3J0IHNob3dHcmlkIGZyb20gXCIuL3NlYXJjaFVJU0VHcmlkXCI7XG5cbntcbiAgd2luZG93LmRjcC5kb2N1bWVudC5kb2N1bWVudENvbnRyb2xsZXIoXG4gICAgXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgXCJyZWFkeVwiLFxuICAgIHtcbiAgICAgIG5hbWU6IFwiYWRkRHNlYXJjaFJlc3VsdEVkaXRFdmVudFwiLFxuICAgICAgZG9jdW1lbnRDaGVjazogZnVuY3Rpb24gaXNEc2VhcmNoKGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5yZW5kZXJNb2RlID09PSBcImVkaXRcIiAmJiBkb2N1bWVudC50eXBlID09PSBcInNlYXJjaFwiO1xuICAgICAgfVxuICAgIH0sXG4gICAgZnVuY3Rpb24gcHJlcGFyZVJlc3VsdEVkaXRFdmVudHMoKSB7XG4gICAgICB2YXIgJGRvY3VtZW50Q29udHJvbGxlciA9ICQodGhpcyk7XG4gICAgICB2YXIgJHRhYiA9ICQoXCIjc2VhcmNoLXRhYnN0cmlwXCIpO1xuICAgICAgJHRhYi5rZW5kb1RhYlN0cmlwKHtcbiAgICAgICAgc2VsZWN0OiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHZhciAkbGkgPSAkKGV2ZW50Lml0ZW0pO1xuICAgICAgICAgIGlmICgkbGkuaGFzQ2xhc3MoXCJyZXN1bHQtdGFiXCIpKSB7XG4gICAgICAgICAgICBzaG93VG1wR3JpZChldmVudCwgJGRvY3VtZW50Q29udHJvbGxlciwgJChcIi5yZXN1bHQtLWNvbnRlbnRcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAkbGlcbiAgICAgICAgICAgIC5wYXJlbnQoKVxuICAgICAgICAgICAgLmZpbmQoXCJsaS5kY3BMYWJlbC0tYWN0aXZlXCIpXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3MoXCJkY3BMYWJlbC0tYWN0aXZlXCIpO1xuICAgICAgICAgICRsaS5hZGRDbGFzcyhcImRjcExhYmVsLS1hY3RpdmVcIik7XG4gICAgICAgIH0sXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIFRvIHVwZGF0ZSByZXNwb25zaXZlQ29sdW1uXG4gICAgICAgICAgJCh3aW5kb3cpLnRyaWdnZXIoXCJyZXNpemVcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAkKHRoaXMpLmRvY3VtZW50Q29udHJvbGxlcihcbiAgICAgICAgXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgICAgIFwiYWN0aW9uQ2xpY2tcIixcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwicHJldmlld0VkaXQuZWRpdEV2ZW50XCIsXG4gICAgICAgICAgZG9jdW1lbnRDaGVjazogZnVuY3Rpb24gaXNEU2VhcmNoKGRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQudHlwZSA9PT0gXCJzZWFyY2hcIiAmJiBkb2N1bWVudC5yZW5kZXJNb2RlID09PSBcImVkaXRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50QnV0dG9uRWRpdChldmVudCwgZG9jdW1lbnQsIGRhdGEpIHtcbiAgICAgICAgICBpZiAoZGF0YS5ldmVudElkID09PSBcInByZXZpZXdFZGl0XCIpIHtcbiAgICAgICAgICAgICR0YWIua2VuZG9UYWJTdHJpcChcInNlbGVjdFwiLCBcIi5yZXN1bHQtdGFiXCIpO1xuICAgICAgICAgICAgLy9zaG93R3JpZChldmVudCwgJGRvY3VtZW50Q29udHJvbGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgKTtcblxuICB3aW5kb3cuZGNwLmRvY3VtZW50LmRvY3VtZW50Q29udHJvbGxlcihcbiAgICBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICBcImNsb3NlXCIsXG4gICAge1xuICAgICAgbmFtZTogXCJyZW1vdmVEc2VhcmNoUmVzdWx0RWRpdEV2ZW50XCIsXG4gICAgICBkb2N1bWVudENoZWNrOiBmdW5jdGlvbihkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQudHlwZSA9PT0gXCJzZWFyY2hcIjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICR0aGlzLmRvY3VtZW50Q29udHJvbGxlcihcInJlbW92ZUV2ZW50TGlzdGVuZXJcIiwgXCIuZWRpdEV2ZW50XCIpO1xuICAgIH1cbiAgKTtcblxuICB3aW5kb3cuZGNwLmRvY3VtZW50LmRvY3VtZW50Q29udHJvbGxlcihcbiAgICBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICBcInJlYWR5XCIsXG4gICAge1xuICAgICAgbmFtZTogXCJzZWFyY2h2aWV3cmVzdWx0c1wiLFxuICAgICAgZG9jdW1lbnRDaGVjazogZnVuY3Rpb24oZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnR5cGUgPT09IFwic2VhcmNoXCI7XG4gICAgICB9XG4gICAgfSxcbiAgICBmdW5jdGlvbiB2aWV3cmVzdWx0KGV2ZW50LCBkb2N1bWVudCkge1xuICAgICAgdmFyICRyZXN1bHQgPSAkKFwiLnJlcG9ydC1yZXN1bHQtY29udGVudFwiKTtcbiAgICAgIGlmICgkcmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzaG93R3JpZChkb2N1bWVudC5pZCwgJHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICApO1xuXG4gIGZ1bmN0aW9uIHNob3dUbXBHcmlkKGV2ZW50LCAkZG9jdW1lbnRDb250cm9sbGVyLCAkdGFyZ2V0KSB7XG4gICAgdmFyICRkYXRhSlNPTiA9IG51bGw7XG5cbiAgICAkdGFyZ2V0LmFkZENsYXNzKFwicmVzdWx0LS1ncmlkXCIpO1xuICAgICR0YXJnZXQuYWRkQ2xhc3MoXCJyZXN1bHQtLXdhaXRpbmdcIik7XG4gICAgJGRhdGFKU09OID0gJGRvY3VtZW50Q29udHJvbGxlclxuICAgICAgLmRhdGEoXCJkY3BEb2N1bWVudENvbnRyb2xsZXJcIilcbiAgICAgIC5fbW9kZWwudG9KU09OKCk7XG4gICAgJGRhdGFKU09OLmRvY3VtZW50LmF0dHJpYnV0ZXMgPSAkZG9jdW1lbnRDb250cm9sbGVyXG4gICAgICAuZGF0YShcImRjcERvY3VtZW50Q29udHJvbGxlclwiKVxuICAgICAgLl9tb2RlbC5nZXRWYWx1ZXMoZmFsc2UpO1xuICAgICQuYWpheCh7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgdXJsOlxuICAgICAgICBcImFwaS92Mi9zbWFydHN0cnVjdHVyZXMvZHNlYXJjaC90ZW1wb3JhcnlEb2MvXCIgK1xuICAgICAgICAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcImdldFByb3BlcnRpZXNcIikuZmFtaWx5Lm5hbWUgK1xuICAgICAgICBcIi9cIixcbiAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KCRkYXRhSlNPTiksXG4gICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9KVxuICAgICAgLmRvbmUoZnVuY3Rpb24gY3JlYXRpb24oZG9jQ3JlYXRlZCkge1xuICAgICAgICB2YXIgY29udGludWVEZWZhdWx0ID0gJGRvY3VtZW50Q29udHJvbGxlci5kb2N1bWVudENvbnRyb2xsZXIoXG4gICAgICAgICAgXCJ0cmlnZ2VyRXZlbnRcIixcbiAgICAgICAgICBcImN1c3RvbTpjb250ZW50XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZmFtaWx5TmFtZTogJGRvY3VtZW50Q29udHJvbGxlci5kb2N1bWVudENvbnRyb2xsZXIoXCJnZXRQcm9wZXJ0aWVzXCIpXG4gICAgICAgICAgICAgIC5mYW1pbHkubmFtZSxcbiAgICAgICAgICAgIGlkOiBkb2NDcmVhdGVkLmRhdGEuZG9jdW1lbnQucHJvcGVydGllcy5pZCxcbiAgICAgICAgICAgIHRpdGxlOiAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcImdldFByb3BlcnRpZXNcIikudGl0bGVcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGlmICghY29udGludWVEZWZhdWx0KSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaG93R3JpZChkb2NDcmVhdGVkLmRhdGEuZG9jdW1lbnQucHJvcGVydGllcy5pZCwgJHRhcmdldCkuZmFpbChcbiAgICAgICAgICAgIGZ1bmN0aW9uKGVycm9yTXNnKSB7XG4gICAgICAgICAgICAgICRkb2N1bWVudENvbnRyb2xsZXIuZG9jdW1lbnRDb250cm9sbGVyKFwic2hvd01lc3NhZ2VcIiwge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvck1zZ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmZhaWwoZnVuY3Rpb24gZmFpbGVkQ3JlYXRpb24oanFYSFIpIHtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gSlNPTi5wYXJzZShqcVhIUi5yZXNwb25zZVRleHQpO1xuICAgICAgICAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcInNob3dNZXNzYWdlXCIsIHtcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgbWVzc2FnZTogcmVzcG9uc2UuZXhjZXB0aW9uTWVzc2FnZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICB9XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13cab0e927159d1d3ebb\n");

/***/ }),

/***/ "1e4534d1d62a11482e97":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"0aac488a388d7f2d0eea\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMWU0NTM0ZDFkNjJhMTE0ODJlOTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldCwgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQpe1xuICAgIHJldHVybiBwYXJlbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG59O1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXNzaW5nIGZ1bmN0aW9uIGluIG9wdGlvbnMsIHRoZW4gdXNlIGl0IGZvciByZXNvbHZlIFwiaGVhZFwiIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gVXNlZnVsIGZvciBTaGFkb3cgUm9vdCBzdHlsZSBpLmVcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICBpbnNlcnRJbnRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvb1wiKS5zaGFkb3dSb290IH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGdldFRhcmdldC5jYWxsKHRoaXMsIHRhcmdldCwgcGFyZW50KTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG5cdFx0XHRpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG5cdFx0fVxuXHRcdHJldHVybiBtZW1vW3RhcmdldF1cblx0fTtcbn0pKCk7XG5cbnZhciBzaW5nbGV0b24gPSBudWxsO1xudmFyXHRzaW5nbGV0b25Db3VudGVyID0gMDtcbnZhclx0c3R5bGVzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xuXG52YXJcdGZpeFVybHMgPSByZXF1aXJlKFwiLi91cmxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcblx0aWYgKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xuXHRcdGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdG9wdGlvbnMuYXR0cnMgPSB0eXBlb2Ygb3B0aW9ucy5hdHRycyA9PT0gXCJvYmplY3RcIiA/IG9wdGlvbnMuYXR0cnMgOiB7fTtcblxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG4gICAgICAgIGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJvYmplY3RcIiAmJiBvcHRpb25zLmluc2VydEF0LmJlZm9yZSkge1xuXHRcdHZhciBuZXh0U2libGluZyA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUsIHRhcmdldCk7XG5cdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbmV4dFNpYmxpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIltTdHlsZSBMb2FkZXJdXFxuXFxuIEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnICgnb3B0aW9ucy5pbnNlcnRBdCcpIGZvdW5kLlxcbiBNdXN0IGJlICd0b3AnLCAnYm90dG9tJywgb3IgT2JqZWN0LlxcbiAoaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIjaW5zZXJ0YXQpXFxuXCIpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudCAoc3R5bGUpIHtcblx0aWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0c3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG5cblx0dmFyIGlkeCA9IHN0eWxlc0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZSk7XG5cdGlmKGlkeCA+PSAwKSB7XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcblx0fVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cblx0aWYob3B0aW9ucy5hdHRycy5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcblx0XHRpZiAobm9uY2UpIHtcblx0XHRcdG9wdGlvbnMuYXR0cnMubm9uY2UgPSBub25jZTtcblx0XHR9XG5cdH1cblxuXHRhZGRBdHRycyhzdHlsZSwgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZSk7XG5cblx0cmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuXG5cdGlmKG9wdGlvbnMuYXR0cnMudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHR9XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBnZXROb25jZSgpIHtcblx0aWYgKHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiBfX3dlYnBhY2tfbm9uY2VfXztcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSB0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbidcblx0XHQgPyBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKSBcblx0XHQgOiBvcHRpb25zLnRyYW5zZm9ybS5kZWZhdWx0KG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1e4534d1d62a11482e97\n");

/***/ }),

/***/ "3c1ed794a91929edd3f3":
/*!*******************************************************************************!*\
  !*** ./src/vendor/Anakeen/SmartStructures/Dsearch/Render/searchAttributes.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/*global define*/\n\n/*\nReturn attributes list information from a family which can be used as criteria\n */\n\nconst searchAttributes = {};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (familyIdentifier => {\n  if (!searchAttributes[familyIdentifier]) {\n    searchAttributes[familyIdentifier] = new Promise(\n      (xhrResolve, xhrReject) => {\n        $.getJSON(\n          \"api/v2/smartstructures/dsearch/attributes/\" + familyIdentifier\n        )\n          .done(xhrResolve)\n          .fail(xhrReject);\n      }\n    );\n  }\n  return searchAttributes[familyIdentifier];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiM2MxZWQ3OTRhOTE5MjllZGQzZjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9yL0FuYWtlZW4vU21hcnRTdHJ1Y3R1cmVzL0RzZWFyY2gvUmVuZGVyL3NlYXJjaEF0dHJpYnV0ZXMuanM/MzI3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCBkZWZpbmUqL1xuXG4vKlxuUmV0dXJuIGF0dHJpYnV0ZXMgbGlzdCBpbmZvcm1hdGlvbiBmcm9tIGEgZmFtaWx5IHdoaWNoIGNhbiBiZSB1c2VkIGFzIGNyaXRlcmlhXG4gKi9cblxuY29uc3Qgc2VhcmNoQXR0cmlidXRlcyA9IHt9O1xuXG5leHBvcnQgZGVmYXVsdCBmYW1pbHlJZGVudGlmaWVyID0+IHtcbiAgaWYgKCFzZWFyY2hBdHRyaWJ1dGVzW2ZhbWlseUlkZW50aWZpZXJdKSB7XG4gICAgc2VhcmNoQXR0cmlidXRlc1tmYW1pbHlJZGVudGlmaWVyXSA9IG5ldyBQcm9taXNlKFxuICAgICAgKHhoclJlc29sdmUsIHhoclJlamVjdCkgPT4ge1xuICAgICAgICAkLmdldEpTT04oXG4gICAgICAgICAgXCJhcGkvdjIvc21hcnRzdHJ1Y3R1cmVzL2RzZWFyY2gvYXR0cmlidXRlcy9cIiArIGZhbWlseUlkZW50aWZpZXJcbiAgICAgICAgKVxuICAgICAgICAgIC5kb25lKHhoclJlc29sdmUpXG4gICAgICAgICAgLmZhaWwoeGhyUmVqZWN0KTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHJldHVybiBzZWFyY2hBdHRyaWJ1dGVzW2ZhbWlseUlkZW50aWZpZXJdO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3c1ed794a91929edd3f3\n");

/***/ }),

/***/ "3ce9a5f32f55f2d96d6f":
/*!**********************************************************************!*\
  !*** ./src/vendor/Anakeen/SmartStructures/Dsearch/Render/dsearch.js ***!
  \**********************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _searchRender_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./searchRender.css */ \"6222be51013c910e07b6\");\n/* harmony import */ var _searchRender_css__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_searchRender_css__WEBPACK_IMPORTED_MODULE_0__);\n\n\n$.getJSON(\"api/v2/i18n/SEARCH_UI_HTML5\").done(catalog => {\n  window.dsearch = window.dsearch || {};\n  window.dsearch.catalog = catalog;\n  __webpack_require__(/*! ./searchAttributeHelper */ \"713b020e474dfbb6d981\");\n  __webpack_require__(/*! ./searchUI */ \"ceecf6b70dccf1a612bd\");\n  __webpack_require__(/*! ./searchUIEventEdit */ \"13cab0e927159d1d3ebb\");\n  __webpack_require__(/*! ./searchUICreationEvent */ \"ab6bdeb063d9c611c7bb\");\n  __webpack_require__(/*! ./searchUIEventView */ \"983488a87ba2f917c196\");\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiM2NlOWE1ZjMyZjU1ZjJkOTZkNmYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9yL0FuYWtlZW4vU21hcnRTdHJ1Y3R1cmVzL0RzZWFyY2gvUmVuZGVyL2RzZWFyY2guanM/Nzc1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXCIuL3NlYXJjaFJlbmRlci5jc3NcIjtcblxuJC5nZXRKU09OKFwiYXBpL3YyL2kxOG4vU0VBUkNIX1VJX0hUTUw1XCIpLmRvbmUoY2F0YWxvZyA9PiB7XG4gIHdpbmRvdy5kc2VhcmNoID0gd2luZG93LmRzZWFyY2ggfHwge307XG4gIHdpbmRvdy5kc2VhcmNoLmNhdGFsb2cgPSBjYXRhbG9nO1xuICByZXF1aXJlKFwiLi9zZWFyY2hBdHRyaWJ1dGVIZWxwZXJcIik7XG4gIHJlcXVpcmUoXCIuL3NlYXJjaFVJXCIpO1xuICByZXF1aXJlKFwiLi9zZWFyY2hVSUV2ZW50RWRpdFwiKTtcbiAgcmVxdWlyZShcIi4vc2VhcmNoVUlDcmVhdGlvbkV2ZW50XCIpO1xuICByZXF1aXJlKFwiLi9zZWFyY2hVSUV2ZW50Vmlld1wiKTtcbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3ce9a5f32f55f2d96d6f\n");

/***/ }),

/***/ "6222be51013c910e07b6":
/*!****************************************************************************!*\
  !*** ./src/vendor/Anakeen/SmartStructures/Dsearch/Render/searchRender.css ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../../../../../node_modules/css-loader!./searchRender.css */ \"66ef11e1707292dd8fee\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../../../../../node_modules/style-loader/lib/addStyles.js */ \"1e4534d1d62a11482e97\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIyMmJlNTEwMTNjOTEwZTA3YjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9yL0FuYWtlZW4vU21hcnRTdHJ1Y3R1cmVzL0RzZWFyY2gvUmVuZGVyL3NlYXJjaFJlbmRlci5jc3M/MTdmNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9zZWFyY2hSZW5kZXIuY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gdW5kZWZpbmVkO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3NlYXJjaFJlbmRlci5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL3NlYXJjaFJlbmRlci5jc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6222be51013c910e07b6\n");

/***/ }),

/***/ "66ef11e1707292dd8fee":
/*!******************************************************************************************************!*\
  !*** ./node_modules/css-loader!./src/vendor/Anakeen/SmartStructures/Dsearch/Render/searchRender.css ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../../../../../node_modules/css-loader/lib/css-base.js */ \"c138e55a31f3f8960e99\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \".dcpDocument--view.dcpDocument,\\n.dcpDocument--view .dcpDsearch__body,\\n.dcpDocument--view .dcpDsearch__body .report-result-content,\\n.dcpDocument--view .dcpDsearch__body .report-result-content ank-se-grid\\n{\\n    display:flex;\\n    flex-direction: column;\\n    flex:1;\\n    min-height: 0;\\n}\\n\\n.dcpDocument--edit.dcpDocument,\\n.dcpDocument--edit .dcpDsearch__body,\\n.dcpDocument--edit .dcpDsearch__body > .k-tabstrip-wrapper,\\n.dcpDocument--edit .dcpDsearch__body > .k-tabstrip-wrapper > .dcpDocument__tabs {\\n    display: flex;\\n    flex-direction: column;\\n    flex: 1;\\n    min-height: 0;\\n}\\n\\n.dcpDocument--view.dcpDocument, .dcpDocument--edit.dcpDocument {\\n    max-height: 100vh;\\n    height: 100vh;\\n}\\n\\n.dcpDsearch__body {\\n    padding: 1.166rem 0 0 0;\\n}\\n\\n.dcpAttribute__content[data-attrid=se_funcs] .k-dropdown-wrap .k-state-default {\\n    width: 100%;\\n    position: absolute;\\n}\\n\\n.dcpAttribute__content[data-attrid=se_funcs] .k-widget.k-dropdown.k-header {\\n    width: 100%;\\n}\\n\\n.dcpAttribute__content[data-attrid=se_keys] .k-widget.k-datepicker.k-header {\\n    width: 100%;\\n}\\n\\n/* css rules for icons' position */\\n\\n.dcpAttribute__content[data-attrid=se_attrids] .k-combobox .k-i-arrow-s {\\n    margin-top: -7px;\\n    margin-left: -7px;\\n}\\n\\n.dcpAttribute__content[data-attrid=se_funcs] .k-dropdown-wrap .k-i-arrow-s {\\n    margin-top: -7px;\\n    margin-left: -7px;\\n}\\n\\n.dcpAttribute__content[data-attrid=se_keys] .k-combobox .k-i-arrow-s {\\n    margin-top: -7px;\\n    margin-left: -7px;\\n}\\n\\n/* css rules @table/column float size */\\n\\n.dcpArray--not_custom .dcpArray__head__cell[data-attrid=se_attrids] {\\n    width : 30%;\\n}\\n.dcpArray--not_custom .dcpArray__head__cell[data-attrid=se_funcs] {\\n    width : 30%;\\n}\\n\\n\\n.dcpArray--custom .dcpArray__head__cell[data-attrid=se_attrids] {\\n    width : 20%;\\n}\\n.dcpArray--custom .dcpArray__head__cell[data-attrid=se_funcs] {\\n    width : 20%;\\n}\\n.dcpArray--custom .dcpArray__head__cell[data-attrid=se_ols] {\\n    width : 5em;\\n}\\n\\n.dcpArray--custom .dcpArray__head__cell[data-attrid=se_leftp] {\\n    width : 6em;\\n}\\n.dcpAttribute__content[data-attrid=se_leftp] .dcpAttribute__value--enumbuttons{\\n    height: 30px;\\n}\\n.dcpAttribute__content[data-attrid=se_leftp] .selected{\\n    height: 28px;\\n}\\n\\n.dcpArray--custom .dcpArray__head__cell[data-attrid=se_rightp] {\\n    width : 6em;\\n}\\n.dcpAttribute__content[data-attrid=se_rightp] .dcpAttribute__value--enumbuttons{\\n    height: 30px;\\n}\\n.dcpAttribute__content[data-attrid=se_rightp] .selected{\\n    height: 28px;\\n}\\n\\n.dcpArray__head__cell{\\n    min-width: 5em;\\n}\\n\\n/* css rules for key fields with method button */\\n\\n.dcpAttribute__content[data-attrid=se_keys] .button--on.k-header.k-widget {\\n    width : calc(100% - 2em);\\n}\\n.dcpAttribute__content[data-attrid=se_keys] .button--on.k-textbox {\\n    width : calc(100% - 2em);\\n}\\n\\n.dcpAttribute__content[data-attrid=se_keys] .button--off{\\n    width:99%;\\n}\\n\\n.funcBtn {\\n    height: 30px;\\n    padding: 0 5px;\\n}\\n\\n/* css rules for result */\\n\\n.content--result{\\n    width: 100%;\\n    height: 450px;\\n    border: none;\\n}\\n\\n/* hide se_fam @se_crit */\\n\\n.dcpFrame__content[data-attrid=se_crit] .dcpAttribute[data-attrid=se_famid]{\\n    display: none;\\n}\\n\\n\\n/* boolean && operands buttons */\\n\\n.dcpAttribute__content[data-attrid=se_leftp] .dcpAttribute__content__buttons{\\n    display:none;\\n}\\n.dcpAttribute__content[data-attrid=se_rightp] .dcpAttribute__content__buttons{\\n    display:none;\\n}\\n.dcpAttribute__content[data-attrid=se_ols] .dcpAttribute__content__buttons{\\n    display:none;\\n}\\n\\n/* condition radio list */\\n\\n.dcpAttribute__content[data-attrid=se_ol] .dcpAttribute__value--enumbuttons {\\n    border: none;\\n}\\n.dcpAttribute__content[data-attrid=se_ol] .dcpAttribute__content__buttons {\\n    display:none;\\n}\\n.dcpAttribute__left[data-attrid=se_ol] {\\n    width:20%;\\n}\\n\\n\\n.dcpArray__body[data-attrid=se_t_detail] .dcpAttribute__value--edit.k-widget {\\n    border:0;\\n}\\n.dcpArray__body[data-attrid=se_t_detail] .dcpAttribute__value--enumbuttons.orientation-bool .dcpAttribute__value--toggle .dcpAttribute__value--text {\\n    min-width:2em;\\n    width:100%;\\n}\\n\\n.dcpArray__body[data-attrid=se_t_detail] .dcpAttribute__value--enumbuttons.orientation-bool .dcpAttribute__value--toggle.off .dcpAttribute__value--text {\\n    display: list-item;\\n}\\n/* result border */\\n\\n.result--grid {\\n    border: solid 1px #cecece;\\n    margin: 10px;\\n}\\n.dcpDocument--view .result--grid {\\n    border: none;\\n\\n}\\n.result--content {\\n    overflow:visible!important;\\n}\\n.result--waiting.result--grid .dataTables_wrapper {\\n    visibility:hidden;\\n}\\n\\n.result-waiting {\\n    display: none;\\n}\\n.dcpTab--loading .result-waiting,\\n.result--waiting.result--grid .result-waiting {\\n    display: block;\\n    background-color: #eaeaea;\\n    text-align: center;\\n    padding: 10px;\\n    font-size: initial;\\n   /* position: absolute;*/\\n    width: calc(100% - 15px);\\n    height: 100%;\\n    min-height: 200px;\\n}\\n.result-waiting-text {\\n    border: solid 1px grey;\\n    display: inline-block;\\n    padding: 0 1em;\\n    background-color: white;\\n}\\n.result-waiting-text img {\\n    height: 6em;\\n}\\n\\nli.menu__element.menu__element--item[data-menu-id=view] {\\n    background: #157EFB;\\n    color:white;\\n}\\nli.menu__element.menu__element--item[data-menu-id=view]:hover {\\n    background: #156ad5;\\n}\\nli.menu__element.menu__element--item[data-menu-id=view].k-item.k-state-hover a.k-link:hover {\\n    color:white;\\n}\\n\\n.search-tabs ul.k-tabstrip-items li {\\n    max-width: 15em;\\n    width:calc(25% - 2px);\\n}\\n\\n.search-tabs ul.k-tabstrip-items {\\n    padding-left:2em;\\n}\\n\\n.search-tabs .k-tabstrip-items .k-loading.k-complete {\\n    border: none;\\n}\\n\\n.dcpTab--loading .dcpCustomTemplate--content{\\n    visibility: hidden;\\n}\\n.report-title {\\n    font-size: 120%;\\n    text-align: center;\\n    padding: 0.5em;\\n}\\n.search-grid.table tr.odd {\\n    background-color:#f7f7f7;\\n}\\n.search-grid.table tbody tr:hover {\\n    background-color: rgba(185, 225, 255, 0.5);\\n}\\n\\nthead.tableFloatingHeaderOriginal th {\\n    background-color: white;\\n}\\n.search-grid tfoot td {\\n    font-weight: bold;\\n}\\n.dataTables_wrapper > .row:first-child {\\n    display:none;\\n}\\n\\n.row[data-attrid=se_ol] {\\n    width:auto;\\n}\\n.row[data-attrid=se_ol] .dcpAttribute__value--enumlabel {\\n    max-width:30em;\\n    width:22em;\\n}\\n.row[data-attrid=se_ol] .dcpAttribute__value--enumbuttons {\\n    width:auto;\\n}\\n\\n.dcpSearch-desc {\\n    display:flex;\\n    flex-direction: row;\\n}\\n\\n.dcpSearch-desc .dcpCustomTemplate--content {\\n    flex-grow:1;\\n    margin: 1rem;\\n}\\n\\n.dsearch-result-window .k-window-content,\\n.dsearch-result-window .k-window-content .dsearch-result-grid {\\n    display: flex;\\n    flex-direction: column;\\n    flex: 1;\\n}\\n\\n@media screen and (max-width: 600px) {\\n    .dcpSearch-desc {\\n    flex-direction: column;\\n  }\\n}\", \"\"]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjZlZjExZTE3MDcyOTJkZDhmZWUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9yL0FuYWtlZW4vU21hcnRTdHJ1Y3R1cmVzL0RzZWFyY2gvUmVuZGVyL3NlYXJjaFJlbmRlci5jc3M/YWZhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKGZhbHNlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5kY3BEb2N1bWVudC0tdmlldy5kY3BEb2N1bWVudCxcXG4uZGNwRG9jdW1lbnQtLXZpZXcgLmRjcERzZWFyY2hfX2JvZHksXFxuLmRjcERvY3VtZW50LS12aWV3IC5kY3BEc2VhcmNoX19ib2R5IC5yZXBvcnQtcmVzdWx0LWNvbnRlbnQsXFxuLmRjcERvY3VtZW50LS12aWV3IC5kY3BEc2VhcmNoX19ib2R5IC5yZXBvcnQtcmVzdWx0LWNvbnRlbnQgYW5rLXNlLWdyaWRcXG57XFxuICAgIGRpc3BsYXk6ZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgZmxleDoxO1xcbiAgICBtaW4taGVpZ2h0OiAwO1xcbn1cXG5cXG4uZGNwRG9jdW1lbnQtLWVkaXQuZGNwRG9jdW1lbnQsXFxuLmRjcERvY3VtZW50LS1lZGl0IC5kY3BEc2VhcmNoX19ib2R5LFxcbi5kY3BEb2N1bWVudC0tZWRpdCAuZGNwRHNlYXJjaF9fYm9keSA+IC5rLXRhYnN0cmlwLXdyYXBwZXIsXFxuLmRjcERvY3VtZW50LS1lZGl0IC5kY3BEc2VhcmNoX19ib2R5ID4gLmstdGFic3RyaXAtd3JhcHBlciA+IC5kY3BEb2N1bWVudF9fdGFicyB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIGZsZXg6IDE7XFxuICAgIG1pbi1oZWlnaHQ6IDA7XFxufVxcblxcbi5kY3BEb2N1bWVudC0tdmlldy5kY3BEb2N1bWVudCwgLmRjcERvY3VtZW50LS1lZGl0LmRjcERvY3VtZW50IHtcXG4gICAgbWF4LWhlaWdodDogMTAwdmg7XFxuICAgIGhlaWdodDogMTAwdmg7XFxufVxcblxcbi5kY3BEc2VhcmNoX19ib2R5IHtcXG4gICAgcGFkZGluZzogMS4xNjZyZW0gMCAwIDA7XFxufVxcblxcbi5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRbZGF0YS1hdHRyaWQ9c2VfZnVuY3NdIC5rLWRyb3Bkb3duLXdyYXAgLmstc3RhdGUtZGVmYXVsdCB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcblxcbi5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRbZGF0YS1hdHRyaWQ9c2VfZnVuY3NdIC5rLXdpZGdldC5rLWRyb3Bkb3duLmstaGVhZGVyIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxufVxcblxcbi5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRbZGF0YS1hdHRyaWQ9c2Vfa2V5c10gLmstd2lkZ2V0LmstZGF0ZXBpY2tlci5rLWhlYWRlciB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbn1cXG5cXG4vKiBjc3MgcnVsZXMgZm9yIGljb25zJyBwb3NpdGlvbiAqL1xcblxcbi5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRbZGF0YS1hdHRyaWQ9c2VfYXR0cmlkc10gLmstY29tYm9ib3ggLmstaS1hcnJvdy1zIHtcXG4gICAgbWFyZ2luLXRvcDogLTdweDtcXG4gICAgbWFyZ2luLWxlZnQ6IC03cHg7XFxufVxcblxcbi5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRbZGF0YS1hdHRyaWQ9c2VfZnVuY3NdIC5rLWRyb3Bkb3duLXdyYXAgLmstaS1hcnJvdy1zIHtcXG4gICAgbWFyZ2luLXRvcDogLTdweDtcXG4gICAgbWFyZ2luLWxlZnQ6IC03cHg7XFxufVxcblxcbi5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRbZGF0YS1hdHRyaWQ9c2Vfa2V5c10gLmstY29tYm9ib3ggLmstaS1hcnJvdy1zIHtcXG4gICAgbWFyZ2luLXRvcDogLTdweDtcXG4gICAgbWFyZ2luLWxlZnQ6IC03cHg7XFxufVxcblxcbi8qIGNzcyBydWxlcyBAdGFibGUvY29sdW1uIGZsb2F0IHNpemUgKi9cXG5cXG4uZGNwQXJyYXktLW5vdF9jdXN0b20gLmRjcEFycmF5X19oZWFkX19jZWxsW2RhdGEtYXR0cmlkPXNlX2F0dHJpZHNdIHtcXG4gICAgd2lkdGggOiAzMCU7XFxufVxcbi5kY3BBcnJheS0tbm90X2N1c3RvbSAuZGNwQXJyYXlfX2hlYWRfX2NlbGxbZGF0YS1hdHRyaWQ9c2VfZnVuY3NdIHtcXG4gICAgd2lkdGggOiAzMCU7XFxufVxcblxcblxcbi5kY3BBcnJheS0tY3VzdG9tIC5kY3BBcnJheV9faGVhZF9fY2VsbFtkYXRhLWF0dHJpZD1zZV9hdHRyaWRzXSB7XFxuICAgIHdpZHRoIDogMjAlO1xcbn1cXG4uZGNwQXJyYXktLWN1c3RvbSAuZGNwQXJyYXlfX2hlYWRfX2NlbGxbZGF0YS1hdHRyaWQ9c2VfZnVuY3NdIHtcXG4gICAgd2lkdGggOiAyMCU7XFxufVxcbi5kY3BBcnJheS0tY3VzdG9tIC5kY3BBcnJheV9faGVhZF9fY2VsbFtkYXRhLWF0dHJpZD1zZV9vbHNdIHtcXG4gICAgd2lkdGggOiA1ZW07XFxufVxcblxcbi5kY3BBcnJheS0tY3VzdG9tIC5kY3BBcnJheV9faGVhZF9fY2VsbFtkYXRhLWF0dHJpZD1zZV9sZWZ0cF0ge1xcbiAgICB3aWR0aCA6IDZlbTtcXG59XFxuLmRjcEF0dHJpYnV0ZV9fY29udGVudFtkYXRhLWF0dHJpZD1zZV9sZWZ0cF0gLmRjcEF0dHJpYnV0ZV9fdmFsdWUtLWVudW1idXR0b25ze1xcbiAgICBoZWlnaHQ6IDMwcHg7XFxufVxcbi5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRbZGF0YS1hdHRyaWQ9c2VfbGVmdHBdIC5zZWxlY3RlZHtcXG4gICAgaGVpZ2h0OiAyOHB4O1xcbn1cXG5cXG4uZGNwQXJyYXktLWN1c3RvbSAuZGNwQXJyYXlfX2hlYWRfX2NlbGxbZGF0YS1hdHRyaWQ9c2VfcmlnaHRwXSB7XFxuICAgIHdpZHRoIDogNmVtO1xcbn1cXG4uZGNwQXR0cmlidXRlX19jb250ZW50W2RhdGEtYXR0cmlkPXNlX3JpZ2h0cF0gLmRjcEF0dHJpYnV0ZV9fdmFsdWUtLWVudW1idXR0b25ze1xcbiAgICBoZWlnaHQ6IDMwcHg7XFxufVxcbi5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRbZGF0YS1hdHRyaWQ9c2VfcmlnaHRwXSAuc2VsZWN0ZWR7XFxuICAgIGhlaWdodDogMjhweDtcXG59XFxuXFxuLmRjcEFycmF5X19oZWFkX19jZWxse1xcbiAgICBtaW4td2lkdGg6IDVlbTtcXG59XFxuXFxuLyogY3NzIHJ1bGVzIGZvciBrZXkgZmllbGRzIHdpdGggbWV0aG9kIGJ1dHRvbiAqL1xcblxcbi5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRbZGF0YS1hdHRyaWQ9c2Vfa2V5c10gLmJ1dHRvbi0tb24uay1oZWFkZXIuay13aWRnZXQge1xcbiAgICB3aWR0aCA6IGNhbGMoMTAwJSAtIDJlbSk7XFxufVxcbi5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRbZGF0YS1hdHRyaWQ9c2Vfa2V5c10gLmJ1dHRvbi0tb24uay10ZXh0Ym94IHtcXG4gICAgd2lkdGggOiBjYWxjKDEwMCUgLSAyZW0pO1xcbn1cXG5cXG4uZGNwQXR0cmlidXRlX19jb250ZW50W2RhdGEtYXR0cmlkPXNlX2tleXNdIC5idXR0b24tLW9mZntcXG4gICAgd2lkdGg6OTklO1xcbn1cXG5cXG4uZnVuY0J0biB7XFxuICAgIGhlaWdodDogMzBweDtcXG4gICAgcGFkZGluZzogMCA1cHg7XFxufVxcblxcbi8qIGNzcyBydWxlcyBmb3IgcmVzdWx0ICovXFxuXFxuLmNvbnRlbnQtLXJlc3VsdHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogNDUwcHg7XFxuICAgIGJvcmRlcjogbm9uZTtcXG59XFxuXFxuLyogaGlkZSBzZV9mYW0gQHNlX2NyaXQgKi9cXG5cXG4uZGNwRnJhbWVfX2NvbnRlbnRbZGF0YS1hdHRyaWQ9c2VfY3JpdF0gLmRjcEF0dHJpYnV0ZVtkYXRhLWF0dHJpZD1zZV9mYW1pZF17XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcblxcbi8qIGJvb2xlYW4gJiYgb3BlcmFuZHMgYnV0dG9ucyAqL1xcblxcbi5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRbZGF0YS1hdHRyaWQ9c2VfbGVmdHBdIC5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRfX2J1dHRvbnN7XFxuICAgIGRpc3BsYXk6bm9uZTtcXG59XFxuLmRjcEF0dHJpYnV0ZV9fY29udGVudFtkYXRhLWF0dHJpZD1zZV9yaWdodHBdIC5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRfX2J1dHRvbnN7XFxuICAgIGRpc3BsYXk6bm9uZTtcXG59XFxuLmRjcEF0dHJpYnV0ZV9fY29udGVudFtkYXRhLWF0dHJpZD1zZV9vbHNdIC5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRfX2J1dHRvbnN7XFxuICAgIGRpc3BsYXk6bm9uZTtcXG59XFxuXFxuLyogY29uZGl0aW9uIHJhZGlvIGxpc3QgKi9cXG5cXG4uZGNwQXR0cmlidXRlX19jb250ZW50W2RhdGEtYXR0cmlkPXNlX29sXSAuZGNwQXR0cmlidXRlX192YWx1ZS0tZW51bWJ1dHRvbnMge1xcbiAgICBib3JkZXI6IG5vbmU7XFxufVxcbi5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRbZGF0YS1hdHRyaWQ9c2Vfb2xdIC5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRfX2J1dHRvbnMge1xcbiAgICBkaXNwbGF5Om5vbmU7XFxufVxcbi5kY3BBdHRyaWJ1dGVfX2xlZnRbZGF0YS1hdHRyaWQ9c2Vfb2xdIHtcXG4gICAgd2lkdGg6MjAlO1xcbn1cXG5cXG5cXG4uZGNwQXJyYXlfX2JvZHlbZGF0YS1hdHRyaWQ9c2VfdF9kZXRhaWxdIC5kY3BBdHRyaWJ1dGVfX3ZhbHVlLS1lZGl0Lmstd2lkZ2V0IHtcXG4gICAgYm9yZGVyOjA7XFxufVxcbi5kY3BBcnJheV9fYm9keVtkYXRhLWF0dHJpZD1zZV90X2RldGFpbF0gLmRjcEF0dHJpYnV0ZV9fdmFsdWUtLWVudW1idXR0b25zLm9yaWVudGF0aW9uLWJvb2wgLmRjcEF0dHJpYnV0ZV9fdmFsdWUtLXRvZ2dsZSAuZGNwQXR0cmlidXRlX192YWx1ZS0tdGV4dCB7XFxuICAgIG1pbi13aWR0aDoyZW07XFxuICAgIHdpZHRoOjEwMCU7XFxufVxcblxcbi5kY3BBcnJheV9fYm9keVtkYXRhLWF0dHJpZD1zZV90X2RldGFpbF0gLmRjcEF0dHJpYnV0ZV9fdmFsdWUtLWVudW1idXR0b25zLm9yaWVudGF0aW9uLWJvb2wgLmRjcEF0dHJpYnV0ZV9fdmFsdWUtLXRvZ2dsZS5vZmYgLmRjcEF0dHJpYnV0ZV9fdmFsdWUtLXRleHQge1xcbiAgICBkaXNwbGF5OiBsaXN0LWl0ZW07XFxufVxcbi8qIHJlc3VsdCBib3JkZXIgKi9cXG5cXG4ucmVzdWx0LS1ncmlkIHtcXG4gICAgYm9yZGVyOiBzb2xpZCAxcHggI2NlY2VjZTtcXG4gICAgbWFyZ2luOiAxMHB4O1xcbn1cXG4uZGNwRG9jdW1lbnQtLXZpZXcgLnJlc3VsdC0tZ3JpZCB7XFxuICAgIGJvcmRlcjogbm9uZTtcXG5cXG59XFxuLnJlc3VsdC0tY29udGVudCB7XFxuICAgIG92ZXJmbG93OnZpc2libGUhaW1wb3J0YW50O1xcbn1cXG4ucmVzdWx0LS13YWl0aW5nLnJlc3VsdC0tZ3JpZCAuZGF0YVRhYmxlc193cmFwcGVyIHtcXG4gICAgdmlzaWJpbGl0eTpoaWRkZW47XFxufVxcblxcbi5yZXN1bHQtd2FpdGluZyB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5kY3BUYWItLWxvYWRpbmcgLnJlc3VsdC13YWl0aW5nLFxcbi5yZXN1bHQtLXdhaXRpbmcucmVzdWx0LS1ncmlkIC5yZXN1bHQtd2FpdGluZyB7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWFlYWVhO1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgIGZvbnQtc2l6ZTogaW5pdGlhbDtcXG4gICAvKiBwb3NpdGlvbjogYWJzb2x1dGU7Ki9cXG4gICAgd2lkdGg6IGNhbGMoMTAwJSAtIDE1cHgpO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIG1pbi1oZWlnaHQ6IDIwMHB4O1xcbn1cXG4ucmVzdWx0LXdhaXRpbmctdGV4dCB7XFxuICAgIGJvcmRlcjogc29saWQgMXB4IGdyZXk7XFxuICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgcGFkZGluZzogMCAxZW07XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbn1cXG4ucmVzdWx0LXdhaXRpbmctdGV4dCBpbWcge1xcbiAgICBoZWlnaHQ6IDZlbTtcXG59XFxuXFxubGkubWVudV9fZWxlbWVudC5tZW51X19lbGVtZW50LS1pdGVtW2RhdGEtbWVudS1pZD12aWV3XSB7XFxuICAgIGJhY2tncm91bmQ6ICMxNTdFRkI7XFxuICAgIGNvbG9yOndoaXRlO1xcbn1cXG5saS5tZW51X19lbGVtZW50Lm1lbnVfX2VsZW1lbnQtLWl0ZW1bZGF0YS1tZW51LWlkPXZpZXddOmhvdmVyIHtcXG4gICAgYmFja2dyb3VuZDogIzE1NmFkNTtcXG59XFxubGkubWVudV9fZWxlbWVudC5tZW51X19lbGVtZW50LS1pdGVtW2RhdGEtbWVudS1pZD12aWV3XS5rLWl0ZW0uay1zdGF0ZS1ob3ZlciBhLmstbGluazpob3ZlciB7XFxuICAgIGNvbG9yOndoaXRlO1xcbn1cXG5cXG4uc2VhcmNoLXRhYnMgdWwuay10YWJzdHJpcC1pdGVtcyBsaSB7XFxuICAgIG1heC13aWR0aDogMTVlbTtcXG4gICAgd2lkdGg6Y2FsYygyNSUgLSAycHgpO1xcbn1cXG5cXG4uc2VhcmNoLXRhYnMgdWwuay10YWJzdHJpcC1pdGVtcyB7XFxuICAgIHBhZGRpbmctbGVmdDoyZW07XFxufVxcblxcbi5zZWFyY2gtdGFicyAuay10YWJzdHJpcC1pdGVtcyAuay1sb2FkaW5nLmstY29tcGxldGUge1xcbiAgICBib3JkZXI6IG5vbmU7XFxufVxcblxcbi5kY3BUYWItLWxvYWRpbmcgLmRjcEN1c3RvbVRlbXBsYXRlLS1jb250ZW50e1xcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxufVxcbi5yZXBvcnQtdGl0bGUge1xcbiAgICBmb250LXNpemU6IDEyMCU7XFxuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gICAgcGFkZGluZzogMC41ZW07XFxufVxcbi5zZWFyY2gtZ3JpZC50YWJsZSB0ci5vZGQge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiNmN2Y3Zjc7XFxufVxcbi5zZWFyY2gtZ3JpZC50YWJsZSB0Ym9keSB0cjpob3ZlciB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTg1LCAyMjUsIDI1NSwgMC41KTtcXG59XFxuXFxudGhlYWQudGFibGVGbG9hdGluZ0hlYWRlck9yaWdpbmFsIHRoIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxufVxcbi5zZWFyY2gtZ3JpZCB0Zm9vdCB0ZCB7XFxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG4uZGF0YVRhYmxlc193cmFwcGVyID4gLnJvdzpmaXJzdC1jaGlsZCB7XFxuICAgIGRpc3BsYXk6bm9uZTtcXG59XFxuXFxuLnJvd1tkYXRhLWF0dHJpZD1zZV9vbF0ge1xcbiAgICB3aWR0aDphdXRvO1xcbn1cXG4ucm93W2RhdGEtYXR0cmlkPXNlX29sXSAuZGNwQXR0cmlidXRlX192YWx1ZS0tZW51bWxhYmVsIHtcXG4gICAgbWF4LXdpZHRoOjMwZW07XFxuICAgIHdpZHRoOjIyZW07XFxufVxcbi5yb3dbZGF0YS1hdHRyaWQ9c2Vfb2xdIC5kY3BBdHRyaWJ1dGVfX3ZhbHVlLS1lbnVtYnV0dG9ucyB7XFxuICAgIHdpZHRoOmF1dG87XFxufVxcblxcbi5kY3BTZWFyY2gtZGVzYyB7XFxuICAgIGRpc3BsYXk6ZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG59XFxuXFxuLmRjcFNlYXJjaC1kZXNjIC5kY3BDdXN0b21UZW1wbGF0ZS0tY29udGVudCB7XFxuICAgIGZsZXgtZ3JvdzoxO1xcbiAgICBtYXJnaW46IDFyZW07XFxufVxcblxcbi5kc2VhcmNoLXJlc3VsdC13aW5kb3cgLmstd2luZG93LWNvbnRlbnQsXFxuLmRzZWFyY2gtcmVzdWx0LXdpbmRvdyAuay13aW5kb3ctY29udGVudCAuZHNlYXJjaC1yZXN1bHQtZ3JpZCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAgIGZsZXg6IDE7XFxufVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDYwMHB4KSB7XFxuICAgIC5kY3BTZWFyY2gtZGVzYyB7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICB9XFxufVwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///66ef11e1707292dd8fee\n");

/***/ }),

/***/ "698d75b157f24ae829cc":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk4ZDc1YjE1N2YyNGFlODI5Y2MuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsIGV2YWwpKFwidGhpc1wiKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///698d75b157f24ae829cc\n");

/***/ }),

/***/ "6d281ded32c7dc89e58d":
/*!*********************************************************!*\
  !*** ./src/Apps/DOCUMENT/IHM/i18n/translatorFactory.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*global define*/\n// use \"text!dcpContextRoot/api/v2/i18n/DOCUMENT\" to get only DDUI translation\n\nwindow.dcp = window.dcp || {};\n\n(function umdRequire(root, requireFunction) {\n  \"use strict\";\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (requireFunction),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n  root.dcp.translatorFactory = requireFunction([]);\n})(window, function require_translatorFactory() {\n  \"use strict\";\n\n  var isString = function isString(obj) {\n    return typeof obj === \"string\";\n  };\n\n  return function catalog(translation) {\n    if (isString(translation)) {\n      try {\n        translation = JSON.parse(translation);\n      } catch (e) {\n        translation = { data: { catalog: {} } };\n        console.error(\"Locale catalog error : \" + e.message);\n      }\n    }\n\n    return {\n      _catalog: translation.data.catalog,\n      _locale: translation.data.locale,\n\n      /**\n       * Return key translation\n       * @param key text to translate\n       * @returns string\n       */\n      _: function i18n_gettext(key) {\n        if (key && this._catalog[key]) {\n          return this._catalog[key];\n        }\n        return key;\n      },\n      /**\n       * Return key translation in context\n       * @param key text to translate\n       * @param ctxt context\n       * @returns {*}\n       */\n      ___: function i18n_pgettext(key, ctxt) {\n        if (\n          key &&\n          this._catalog &&\n          this._catalog._msgctxt_ &&\n          this._catalog._msgctxt_[ctxt] &&\n          this._catalog._msgctxt_[ctxt][key]\n        ) {\n          return this._catalog._msgctxt_[ctxt][key];\n        }\n        return key;\n      },\n      /**\n       * Return some info on the current locale\n       *\n       * @returns {locale|{culture}|*|string|string}\n       */\n      getLocale: function i18n_getLocale() {\n        return this._locale;\n      }\n    };\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNmQyODFkZWQzMmM3ZGM4OWU1OGQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQXBwcy9ET0NVTUVOVC9JSE0vaTE4bi90cmFuc2xhdG9yRmFjdG9yeS5qcz9mM2NiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFsIGRlZmluZSovXG4vLyB1c2UgXCJ0ZXh0IWRjcENvbnRleHRSb290L2FwaS92Mi9pMThuL0RPQ1VNRU5UXCIgdG8gZ2V0IG9ubHkgRERVSSB0cmFuc2xhdGlvblxuXG53aW5kb3cuZGNwID0gd2luZG93LmRjcCB8fCB7fTtcblxuKGZ1bmN0aW9uIHVtZFJlcXVpcmUocm9vdCwgcmVxdWlyZUZ1bmN0aW9uKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbXSwgcmVxdWlyZUZ1bmN0aW9uKTtcbiAgfVxuICByb290LmRjcC50cmFuc2xhdG9yRmFjdG9yeSA9IHJlcXVpcmVGdW5jdGlvbihbXSk7XG59KSh3aW5kb3csIGZ1bmN0aW9uIHJlcXVpcmVfdHJhbnNsYXRvckZhY3RvcnkoKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiO1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbiBjYXRhbG9nKHRyYW5zbGF0aW9uKSB7XG4gICAgaWYgKGlzU3RyaW5nKHRyYW5zbGF0aW9uKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdHJhbnNsYXRpb24gPSBKU09OLnBhcnNlKHRyYW5zbGF0aW9uKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdHJhbnNsYXRpb24gPSB7IGRhdGE6IHsgY2F0YWxvZzoge30gfSB9O1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTG9jYWxlIGNhdGFsb2cgZXJyb3IgOiBcIiArIGUubWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIF9jYXRhbG9nOiB0cmFuc2xhdGlvbi5kYXRhLmNhdGFsb2csXG4gICAgICBfbG9jYWxlOiB0cmFuc2xhdGlvbi5kYXRhLmxvY2FsZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm4ga2V5IHRyYW5zbGF0aW9uXG4gICAgICAgKiBAcGFyYW0ga2V5IHRleHQgdG8gdHJhbnNsYXRlXG4gICAgICAgKiBAcmV0dXJucyBzdHJpbmdcbiAgICAgICAqL1xuICAgICAgXzogZnVuY3Rpb24gaTE4bl9nZXR0ZXh0KGtleSkge1xuICAgICAgICBpZiAoa2V5ICYmIHRoaXMuX2NhdGFsb2dba2V5XSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jYXRhbG9nW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFJldHVybiBrZXkgdHJhbnNsYXRpb24gaW4gY29udGV4dFxuICAgICAgICogQHBhcmFtIGtleSB0ZXh0IHRvIHRyYW5zbGF0ZVxuICAgICAgICogQHBhcmFtIGN0eHQgY29udGV4dFxuICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgKi9cbiAgICAgIF9fXzogZnVuY3Rpb24gaTE4bl9wZ2V0dGV4dChrZXksIGN0eHQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSAmJlxuICAgICAgICAgIHRoaXMuX2NhdGFsb2cgJiZcbiAgICAgICAgICB0aGlzLl9jYXRhbG9nLl9tc2djdHh0XyAmJlxuICAgICAgICAgIHRoaXMuX2NhdGFsb2cuX21zZ2N0eHRfW2N0eHRdICYmXG4gICAgICAgICAgdGhpcy5fY2F0YWxvZy5fbXNnY3R4dF9bY3R4dF1ba2V5XVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2F0YWxvZy5fbXNnY3R4dF9bY3R4dF1ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJuIHNvbWUgaW5mbyBvbiB0aGUgY3VycmVudCBsb2NhbGVcbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7bG9jYWxlfHtjdWx0dXJlfXwqfHN0cmluZ3xzdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIGdldExvY2FsZTogZnVuY3Rpb24gaTE4bl9nZXRMb2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6d281ded32c7dc89e58d\n");

/***/ }),

/***/ "6da807eb38805b380fc6":
/*!****************************************************************************!*\
  !*** ./src/vendor/Anakeen/SmartStructures/Dsearch/Render/searchCatalog.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst i18nFactory = __webpack_require__(/*! dcpDocument/i18n/translatorFactory */ \"6d281ded32c7dc89e58d\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (i18nFactory(window.dsearch.catalog));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNmRhODA3ZWIzODgwNWIzODBmYzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9yL0FuYWtlZW4vU21hcnRTdHJ1Y3R1cmVzL0RzZWFyY2gvUmVuZGVyL3NlYXJjaENhdGFsb2cuanM/MWIwNiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpMThuRmFjdG9yeSA9IHJlcXVpcmUoXCJkY3BEb2N1bWVudC9pMThuL3RyYW5zbGF0b3JGYWN0b3J5XCIpO1xuXG5leHBvcnQgZGVmYXVsdCBpMThuRmFjdG9yeSh3aW5kb3cuZHNlYXJjaC5jYXRhbG9nKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6da807eb38805b380fc6\n");

/***/ }),

/***/ "713b020e474dfbb6d981":
/*!************************************************************************************!*\
  !*** ./src/vendor/Anakeen/SmartStructures/Dsearch/Render/searchAttributeHelper.js ***!
  \************************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _searchCatalog__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./searchCatalog */ \"6da807eb38805b380fc6\");\n/* harmony import */ var _searchAttributes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./searchAttributes */ \"3c1ed794a91929edd3f3\");\n/**\n * Created by Alex on 21/04/15.\n */\n/*global define, require, console*/\n\nconst _ = __webpack_require__(/*! underscore */ \"8e08e542008e4aef1f58\");\n\n\n\n{\n  var dataAttributesNew = [];\n  var dataAttributes = [];\n  var $wf = null;\n\n  window.dcp.document.documentController(\n    \"addEventListener\",\n    \"ready\",\n    {\n      name: \"addDsearchAttributesEvents\",\n      documentCheck: function(document) {\n        return document.type === \"search\";\n      }\n    },\n    function prepareAttributesEvents() {\n      $(this).documentController(\n        \"addEventListener\",\n        \"ready\",\n        {\n          name: \"searchAttributesReady.sAttr\",\n          documentCheck: function isDSearch(document) {\n            return document.type === \"search\";\n          }\n        },\n        /**\n         * prepare attributes list and attributes kendo widget\n         */\n        function prepareAttributesReady() {\n          var $documentController = $(this);\n          var famid = $(this).documentController(\"getValues\").se_famid.value;\n\n          if (famid === null) {\n            famid = \"\";\n          }\n          if ($(\".dcpArray__content[data-attrid=se_t_detail]\").length === 0) {\n            return;\n          }\n\n          Object(_searchAttributes__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(famid)\n            .then(function requestAttributesAttributesReady(data) {\n              dataAttributes = [];\n              /**\n               * initialize attribute list\n               */\n              $.each(data.data, function eachDataAttributesReady(key, val) {\n                var myObject = {\n                  id: val.id,\n                  label: val.label,\n                  label_parent: val.parent.label,\n                  type: val.type\n                };\n                if (val.type !== \"array\") {\n                  dataAttributes.push(myObject);\n                }\n              });\n              /**\n               * initialize the workflow attribute generic value\n               */\n              if (dataAttributes[dataAttributes.length - 1].type === \"wid\") {\n                $wf = dataAttributes[dataAttributes.length - 1];\n              } else {\n                $wf = null;\n              }\n              findIfWorkflow(dataAttributes, $documentController);\n            })\n            .then(function doneAttributesReady() {\n              $(\".dcpAttribute__value[name=se_attrids]\").each(\n                function eachAttributesAttributesReady() {\n                  /**\n                   * create/update attributes kendo widget\n                   */\n                  if ($(this).data(\"kendoComboBox\") !== undefined) {\n                    var $dataSource = new kendo.data.DataSource({\n                      data: dataAttributes,\n                      group: { field: \"label_parent\" }\n                    });\n                    $(\".dcpAttribute__value[name=se_attrids]\")\n                      .data(\"kendoComboBox\")\n                      .setDataSource($dataSource);\n                  } else {\n                    var $environment = $(this);\n                    initKendoComboBox(dataAttributes, $environment);\n                  }\n                }\n              );\n            });\n        }\n      );\n\n      $(this).documentController(\n        \"addEventListener\",\n        \"attributeArrayChange\",\n        {\n          name: \"searchAttributesAddArray.sAttr\",\n          documentCheck: function isDSearch(document) {\n            return document.type === \"search\";\n          },\n          attributeCheck: function isArray(attribute) {\n            if (attribute.id === \"se_t_detail\") {\n              return true;\n            }\n          }\n        },\n        /**\n         * init attributes kendo widget on a new raw\n         */\n        function displayChange(event, document, attribut, type, options) {\n          if (type === \"addLine\") {\n            $(\".dcpAttribute__value[name=se_attrids]\").each(\n              function eachAttributesAttributesAddarray(key) {\n                if (key === options) {\n                  var $environment = $(this);\n                  initKendoComboBox(dataAttributes, $environment);\n                }\n              }\n            );\n          }\n        }\n      );\n\n      $(this).documentController(\n        \"addEventListener\",\n        \"change\",\n        {\n          name: \"searchAttributesRevChanged.sAttr\",\n          documentCheck: function isDSearch(document) {\n            return document.type === \"search\";\n          },\n          attributeCheck: function isFamily(attribute) {\n            if (attribute.id === \"se_latest\") {\n              return true;\n            }\n          }\n        },\n        /**\n         * Update workflow attribute's value and attributes kendo widget's data\n         * triggered if revision value change\n         */\n        function displayRevisionChange() {\n          var $documentController = $(this);\n          findIfWorkflow(dataAttributes, $documentController);\n          $(\".dcpAttribute__value[name=se_attrids]\").each(\n            function eachAttributesAttributesRevchanged() {\n              if ($(this).data(\"kendoComboBox\") !== undefined) {\n                var $dataSource = new kendo.data.DataSource({\n                  data: dataAttributes,\n                  group: { field: \"label_parent\" }\n                });\n                $(this)\n                  .data(\"kendoComboBox\")\n                  .setDataSource($dataSource);\n              }\n            }\n          );\n        }\n      );\n\n      $(this).documentController(\n        \"addEventListener\",\n        \"change\",\n        {\n          name: \"searchAttributesFamilyChanged.sAttr\",\n          documentCheck: function isDSearch(document) {\n            return document.type === \"search\";\n          },\n          attributeCheck: function isFamily(attribute) {\n            if (attribute.id === \"se_famid\") {\n              return true;\n            }\n          }\n        },\n        /**\n         * Update attributes list, attributes kendo widget's data and workflow attribute value if necessary,\n         * triggered if the family value change\n         * @param event standard jQuery event\n         * @param document current document object\n         * @param attribute current attribute object\n         * @param options current, previous, and initial values\n         */\n        function displayChange(event, document, attribute, options) {\n          var famid = $(this).documentController(\"getValues\").se_famid.value;\n          var $documentController = $(this);\n          dataAttributesNew = [];\n          Object(_searchAttributes__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(famid)\n            .then(function requestAttributesAttributesFamilychanged(data) {\n              $.each(data.data, function eachDataAttributesFamilychanged(\n                key,\n                val\n              ) {\n                var myObject = {\n                  id: val.id,\n                  label: val.label,\n                  label_parent: val.parent.label,\n                  type: val.type\n                };\n                if (val.type !== \"array\") {\n                  dataAttributesNew.push(myObject);\n                }\n              });\n              /**\n               * update the workflow attribute generic value\n               */\n              if (\n                dataAttributesNew[dataAttributesNew.length - 1].type === \"wid\"\n              ) {\n                $wf = dataAttributesNew[dataAttributesNew.length - 1];\n              } else {\n                $wf = null;\n              }\n              findIfWorkflow(dataAttributesNew, $documentController);\n            })\n            .then(function doneAttributesFamilychanged() {\n              if (\n                Array.isArray(\n                  $documentController.documentController(\"getValues\").se_attrids\n                )\n              ) {\n                /**\n                 * Test if attributes selected are still in current family\n                 * Show an error message if not\n                 */\n                $documentController.documentController(\n                  \"cleanAttributeErrorMessage\",\n                  \"se_attrids\"\n                );\n                $.each(\n                  $documentController.documentController(\"getValues\")\n                    .se_attrids,\n                  function eachAttridsAttributesFamilychanged(key, val) {\n                    var attrId = val.value;\n                    var $controle = 0;\n\n                    $.each(\n                      dataAttributesNew,\n                      function eachNewDataattributesAttributesFamilychanged(\n                        mkey,\n                        mval\n                      ) {\n                        if (attrId === mval.id) {\n                          $controle = 1;\n                        }\n                      }\n                    );\n                    if ($controle === 0 && !itemEmpty(attrId)) {\n                      $documentController.documentController(\n                        \"setAttributeErrorMessage\",\n                        \"se_attrids\",\n                        _searchCatalog__WEBPACK_IMPORTED_MODULE_0__[\"default\"].___(\"Invalid attribute\", \"dsearch\"),\n                        key\n                      );\n                      var myOperator = $documentController.documentController(\n                        \"getValues\"\n                      ).se_funcs[options];\n                      setVisibility(myOperator, options, $documentController);\n                    }\n                  }\n                );\n              }\n              dataAttributes = dataAttributesNew;\n              $(\".dcpAttribute__value[name=se_attrids]\").each(\n                function eachAttributesAttributesFamilychanged() {\n                  /**\n                   * Update attributes kendo widget's data\n                   */\n                  if ($(this).data(\"kendoComboBox\") !== undefined) {\n                    var $dataSource = new kendo.data.DataSource({\n                      data: dataAttributes,\n                      group: { field: \"label_parent\" }\n                    });\n                    $(this)\n                      .data(\"kendoComboBox\")\n                      .setDataSource($dataSource);\n                  }\n                }\n              );\n            });\n        }\n      );\n    }\n  );\n\n  window.dcp.document.documentController(\n    \"addEventListener\",\n    \"close\",\n    {\n      name: \"removeDsearchAttributesEvent\",\n      documentCheck: function(document) {\n        return document.type === \"search\";\n      }\n    },\n    function() {\n      var $this = $(this);\n      $this.documentController(\"removeEventListener\", \".sAttr\");\n    }\n  );\n\n  /**\n   * Initialize a kendoComboBox widget on a specific object\n   * @param dataAttributes list of attributes, used to set the data\n   * @param $environment place to put the widget\n   */\n  function initKendoComboBox(dataAttributes, $environment) {\n    $environment.kendoComboBox({\n      width: 200,\n      placeholder: \"Choisir attribut\",\n      clearButton: false,\n      filter: \"contains\",\n      minLength: 0,\n      dataValueField: \"id\",\n      dataTextField: \"label\",\n      dataSource: {\n        data: dataAttributes,\n        group: { field: \"label_parent\" }\n      }\n    });\n    $environment.data(\"kendoComboBox\").list.css(\"min-width\", \"300px\");\n  }\n\n  /**\n   * check if an item is empty/undefined\n   * @param myItem, the item to test\n   * @returns {boolean}\n   */\n  function itemEmpty(myItem) {\n    return (\n      myItem === undefined ||\n      myItem === null ||\n      myItem.value === null ||\n      myItem.value === \"\"\n    );\n  }\n\n  /**\n   * Set keys visibilities\n   * @param myOperator operator used to know if you show or hide the keys field\n   * @param $index index of the field in the table\n   * @param $documentController the document controller of the document\n   */\n  function setVisibility(myOperator, $index, $documentController) {\n    var myKeyword;\n    var minorKeyword;\n    var visible = false;\n    $(\".dcpAttribute__value[name=se_keys]\").each(function eachKeysSetVisibility(\n      key,\n      value\n    ) {\n      if (key === $index) {\n        myKeyword = value;\n      }\n    });\n    minorKeyword = $documentController.documentController(\"getValues\").se_keys[\n      $index\n    ];\n    if (myKeyword !== undefined) {\n      var $label = null;\n\n      _.each([], function emptyEachSetVisibility(data) {\n        if (myOperator !== undefined) {\n          if (myOperator !== null) {\n            if (myOperator.value === data.id) {\n              $label = data.label;\n            }\n          }\n        }\n      });\n\n      if ($label === null) {\n        visible = false;\n      } else {\n        /*\n            check if the operator has a \"right\" operand\n             */\n        visible = $label.indexOf(\"{right}\") !== -1;\n      }\n      var $parent = $(myKeyword).closest(\"div\");\n      if (visible) {\n        $parent.show();\n      } else {\n        $parent.hide();\n        myKeyword.value = null;\n        minorKeyword.value = null;\n        minorKeyword.displayValue = null;\n      }\n    }\n  }\n\n  /**\n   * find if current family is a workflow\n   * replace the workflow attribute by a new based on generic workflow attribute\n   * @param $data attribute list\n   * @param $documentController\n   * @returns {boolean}\n   */\n  function findIfWorkflow($data, $documentController) {\n    var $lastAttribute = $data[$data.length - 1];\n    var $revAttribute = $documentController.documentController(\"getValues\")\n      .se_latest;\n    var myObject;\n    if ($lastAttribute.type === \"wid\") {\n      $data.pop();\n      if ($revAttribute.value === \"yes\") {\n        myObject = {\n          id: $wf.id,\n          label: $wf.label[0],\n          label_parent: $wf.label_parent,\n          type: \"wid\"\n        };\n        $data.push(myObject);\n      } else if ($revAttribute.value === \"no\") {\n        myObject = {\n          id: $wf.id,\n          label: $wf.label[1],\n          label_parent: $wf.label_parent,\n          type: \"wid\"\n        };\n        $data.push(myObject);\n      } else {\n        myObject = {\n          id: $wf.id,\n          label: $wf.label[2],\n          label_parent: $wf.label_parent,\n          type: \"wid\"\n        };\n        $data.push(myObject);\n      }\n      return true;\n    }\n    return false;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzEzYjAyMGU0NzRkZmJiNmQ5ODEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9yL0FuYWtlZW4vU21hcnRTdHJ1Y3R1cmVzL0RzZWFyY2gvUmVuZGVyL3NlYXJjaEF0dHJpYnV0ZUhlbHBlci5qcz83NGFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3JlYXRlZCBieSBBbGV4IG9uIDIxLzA0LzE1LlxuICovXG4vKmdsb2JhbCBkZWZpbmUsIHJlcXVpcmUsIGNvbnNvbGUqL1xuXG5jb25zdCBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG5pbXBvcnQgaTE4biBmcm9tIFwiLi9zZWFyY2hDYXRhbG9nXCI7XG5pbXBvcnQgc2VhcmNoQXR0cmlidXRlcyBmcm9tIFwiLi9zZWFyY2hBdHRyaWJ1dGVzXCI7XG5cbntcbiAgdmFyIGRhdGFBdHRyaWJ1dGVzTmV3ID0gW107XG4gIHZhciBkYXRhQXR0cmlidXRlcyA9IFtdO1xuICB2YXIgJHdmID0gbnVsbDtcblxuICB3aW5kb3cuZGNwLmRvY3VtZW50LmRvY3VtZW50Q29udHJvbGxlcihcbiAgICBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICBcInJlYWR5XCIsXG4gICAge1xuICAgICAgbmFtZTogXCJhZGREc2VhcmNoQXR0cmlidXRlc0V2ZW50c1wiLFxuICAgICAgZG9jdW1lbnRDaGVjazogZnVuY3Rpb24oZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnR5cGUgPT09IFwic2VhcmNoXCI7XG4gICAgICB9XG4gICAgfSxcbiAgICBmdW5jdGlvbiBwcmVwYXJlQXR0cmlidXRlc0V2ZW50cygpIHtcbiAgICAgICQodGhpcykuZG9jdW1lbnRDb250cm9sbGVyKFxuICAgICAgICBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICAgICAgXCJyZWFkeVwiLFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJzZWFyY2hBdHRyaWJ1dGVzUmVhZHkuc0F0dHJcIixcbiAgICAgICAgICBkb2N1bWVudENoZWNrOiBmdW5jdGlvbiBpc0RTZWFyY2goZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC50eXBlID09PSBcInNlYXJjaFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByZXBhcmUgYXR0cmlidXRlcyBsaXN0IGFuZCBhdHRyaWJ1dGVzIGtlbmRvIHdpZGdldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gcHJlcGFyZUF0dHJpYnV0ZXNSZWFkeSgpIHtcbiAgICAgICAgICB2YXIgJGRvY3VtZW50Q29udHJvbGxlciA9ICQodGhpcyk7XG4gICAgICAgICAgdmFyIGZhbWlkID0gJCh0aGlzKS5kb2N1bWVudENvbnRyb2xsZXIoXCJnZXRWYWx1ZXNcIikuc2VfZmFtaWQudmFsdWU7XG5cbiAgICAgICAgICBpZiAoZmFtaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGZhbWlkID0gXCJcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCQoXCIuZGNwQXJyYXlfX2NvbnRlbnRbZGF0YS1hdHRyaWQ9c2VfdF9kZXRhaWxdXCIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlYXJjaEF0dHJpYnV0ZXMoZmFtaWQpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiByZXF1ZXN0QXR0cmlidXRlc0F0dHJpYnV0ZXNSZWFkeShkYXRhKSB7XG4gICAgICAgICAgICAgIGRhdGFBdHRyaWJ1dGVzID0gW107XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBpbml0aWFsaXplIGF0dHJpYnV0ZSBsaXN0XG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAkLmVhY2goZGF0YS5kYXRhLCBmdW5jdGlvbiBlYWNoRGF0YUF0dHJpYnV0ZXNSZWFkeShrZXksIHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciBteU9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICAgIGlkOiB2YWwuaWQsXG4gICAgICAgICAgICAgICAgICBsYWJlbDogdmFsLmxhYmVsLFxuICAgICAgICAgICAgICAgICAgbGFiZWxfcGFyZW50OiB2YWwucGFyZW50LmxhYmVsLFxuICAgICAgICAgICAgICAgICAgdHlwZTogdmFsLnR5cGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh2YWwudHlwZSAhPT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICAgICAgICBkYXRhQXR0cmlidXRlcy5wdXNoKG15T2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogaW5pdGlhbGl6ZSB0aGUgd29ya2Zsb3cgYXR0cmlidXRlIGdlbmVyaWMgdmFsdWVcbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGlmIChkYXRhQXR0cmlidXRlc1tkYXRhQXR0cmlidXRlcy5sZW5ndGggLSAxXS50eXBlID09PSBcIndpZFwiKSB7XG4gICAgICAgICAgICAgICAgJHdmID0gZGF0YUF0dHJpYnV0ZXNbZGF0YUF0dHJpYnV0ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHdmID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmaW5kSWZXb3JrZmxvdyhkYXRhQXR0cmlidXRlcywgJGRvY3VtZW50Q29udHJvbGxlcik7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gZG9uZUF0dHJpYnV0ZXNSZWFkeSgpIHtcbiAgICAgICAgICAgICAgJChcIi5kY3BBdHRyaWJ1dGVfX3ZhbHVlW25hbWU9c2VfYXR0cmlkc11cIikuZWFjaChcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBlYWNoQXR0cmlidXRlc0F0dHJpYnV0ZXNSZWFkeSgpIHtcbiAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICogY3JlYXRlL3VwZGF0ZSBhdHRyaWJ1dGVzIGtlbmRvIHdpZGdldFxuICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICBpZiAoJCh0aGlzKS5kYXRhKFwia2VuZG9Db21ib0JveFwiKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAkZGF0YVNvdXJjZSA9IG5ldyBrZW5kby5kYXRhLkRhdGFTb3VyY2Uoe1xuICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiB7IGZpZWxkOiBcImxhYmVsX3BhcmVudFwiIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICQoXCIuZGNwQXR0cmlidXRlX192YWx1ZVtuYW1lPXNlX2F0dHJpZHNdXCIpXG4gICAgICAgICAgICAgICAgICAgICAgLmRhdGEoXCJrZW5kb0NvbWJvQm94XCIpXG4gICAgICAgICAgICAgICAgICAgICAgLnNldERhdGFTb3VyY2UoJGRhdGFTb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRlbnZpcm9ubWVudCA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGluaXRLZW5kb0NvbWJvQm94KGRhdGFBdHRyaWJ1dGVzLCAkZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICAkKHRoaXMpLmRvY3VtZW50Q29udHJvbGxlcihcbiAgICAgICAgXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgICAgIFwiYXR0cmlidXRlQXJyYXlDaGFuZ2VcIixcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwic2VhcmNoQXR0cmlidXRlc0FkZEFycmF5LnNBdHRyXCIsXG4gICAgICAgICAgZG9jdW1lbnRDaGVjazogZnVuY3Rpb24gaXNEU2VhcmNoKGRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQudHlwZSA9PT0gXCJzZWFyY2hcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF0dHJpYnV0ZUNoZWNrOiBmdW5jdGlvbiBpc0FycmF5KGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5pZCA9PT0gXCJzZV90X2RldGFpbFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluaXQgYXR0cmlidXRlcyBrZW5kbyB3aWRnZXQgb24gYSBuZXcgcmF3XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBkaXNwbGF5Q2hhbmdlKGV2ZW50LCBkb2N1bWVudCwgYXR0cmlidXQsIHR5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRMaW5lXCIpIHtcbiAgICAgICAgICAgICQoXCIuZGNwQXR0cmlidXRlX192YWx1ZVtuYW1lPXNlX2F0dHJpZHNdXCIpLmVhY2goXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGVhY2hBdHRyaWJ1dGVzQXR0cmlidXRlc0FkZGFycmF5KGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciAkZW52aXJvbm1lbnQgPSAkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgaW5pdEtlbmRvQ29tYm9Cb3goZGF0YUF0dHJpYnV0ZXMsICRlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgJCh0aGlzKS5kb2N1bWVudENvbnRyb2xsZXIoXG4gICAgICAgIFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgICBcImNoYW5nZVwiLFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJzZWFyY2hBdHRyaWJ1dGVzUmV2Q2hhbmdlZC5zQXR0clwiLFxuICAgICAgICAgIGRvY3VtZW50Q2hlY2s6IGZ1bmN0aW9uIGlzRFNlYXJjaChkb2N1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnR5cGUgPT09IFwic2VhcmNoXCI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdHRyaWJ1dGVDaGVjazogZnVuY3Rpb24gaXNGYW1pbHkoYXR0cmlidXRlKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlLmlkID09PSBcInNlX2xhdGVzdFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB3b3JrZmxvdyBhdHRyaWJ1dGUncyB2YWx1ZSBhbmQgYXR0cmlidXRlcyBrZW5kbyB3aWRnZXQncyBkYXRhXG4gICAgICAgICAqIHRyaWdnZXJlZCBpZiByZXZpc2lvbiB2YWx1ZSBjaGFuZ2VcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGRpc3BsYXlSZXZpc2lvbkNoYW5nZSgpIHtcbiAgICAgICAgICB2YXIgJGRvY3VtZW50Q29udHJvbGxlciA9ICQodGhpcyk7XG4gICAgICAgICAgZmluZElmV29ya2Zsb3coZGF0YUF0dHJpYnV0ZXMsICRkb2N1bWVudENvbnRyb2xsZXIpO1xuICAgICAgICAgICQoXCIuZGNwQXR0cmlidXRlX192YWx1ZVtuYW1lPXNlX2F0dHJpZHNdXCIpLmVhY2goXG4gICAgICAgICAgICBmdW5jdGlvbiBlYWNoQXR0cmlidXRlc0F0dHJpYnV0ZXNSZXZjaGFuZ2VkKCkge1xuICAgICAgICAgICAgICBpZiAoJCh0aGlzKS5kYXRhKFwia2VuZG9Db21ib0JveFwiKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyICRkYXRhU291cmNlID0gbmV3IGtlbmRvLmRhdGEuRGF0YVNvdXJjZSh7XG4gICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgIGdyb3VwOiB7IGZpZWxkOiBcImxhYmVsX3BhcmVudFwiIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAkKHRoaXMpXG4gICAgICAgICAgICAgICAgICAuZGF0YShcImtlbmRvQ29tYm9Cb3hcIilcbiAgICAgICAgICAgICAgICAgIC5zZXREYXRhU291cmNlKCRkYXRhU291cmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgICQodGhpcykuZG9jdW1lbnRDb250cm9sbGVyKFxuICAgICAgICBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwic2VhcmNoQXR0cmlidXRlc0ZhbWlseUNoYW5nZWQuc0F0dHJcIixcbiAgICAgICAgICBkb2N1bWVudENoZWNrOiBmdW5jdGlvbiBpc0RTZWFyY2goZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC50eXBlID09PSBcInNlYXJjaFwiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXR0cmlidXRlQ2hlY2s6IGZ1bmN0aW9uIGlzRmFtaWx5KGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5pZCA9PT0gXCJzZV9mYW1pZFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBhdHRyaWJ1dGVzIGxpc3QsIGF0dHJpYnV0ZXMga2VuZG8gd2lkZ2V0J3MgZGF0YSBhbmQgd29ya2Zsb3cgYXR0cmlidXRlIHZhbHVlIGlmIG5lY2Vzc2FyeSxcbiAgICAgICAgICogdHJpZ2dlcmVkIGlmIHRoZSBmYW1pbHkgdmFsdWUgY2hhbmdlXG4gICAgICAgICAqIEBwYXJhbSBldmVudCBzdGFuZGFyZCBqUXVlcnkgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIGRvY3VtZW50IGN1cnJlbnQgZG9jdW1lbnQgb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGUgY3VycmVudCBhdHRyaWJ1dGUgb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIGN1cnJlbnQsIHByZXZpb3VzLCBhbmQgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGRpc3BsYXlDaGFuZ2UoZXZlbnQsIGRvY3VtZW50LCBhdHRyaWJ1dGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgZmFtaWQgPSAkKHRoaXMpLmRvY3VtZW50Q29udHJvbGxlcihcImdldFZhbHVlc1wiKS5zZV9mYW1pZC52YWx1ZTtcbiAgICAgICAgICB2YXIgJGRvY3VtZW50Q29udHJvbGxlciA9ICQodGhpcyk7XG4gICAgICAgICAgZGF0YUF0dHJpYnV0ZXNOZXcgPSBbXTtcbiAgICAgICAgICBzZWFyY2hBdHRyaWJ1dGVzKGZhbWlkKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gcmVxdWVzdEF0dHJpYnV0ZXNBdHRyaWJ1dGVzRmFtaWx5Y2hhbmdlZChkYXRhKSB7XG4gICAgICAgICAgICAgICQuZWFjaChkYXRhLmRhdGEsIGZ1bmN0aW9uIGVhY2hEYXRhQXR0cmlidXRlc0ZhbWlseWNoYW5nZWQoXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgbXlPYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgICBpZDogdmFsLmlkLFxuICAgICAgICAgICAgICAgICAgbGFiZWw6IHZhbC5sYWJlbCxcbiAgICAgICAgICAgICAgICAgIGxhYmVsX3BhcmVudDogdmFsLnBhcmVudC5sYWJlbCxcbiAgICAgICAgICAgICAgICAgIHR5cGU6IHZhbC50eXBlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodmFsLnR5cGUgIT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgZGF0YUF0dHJpYnV0ZXNOZXcucHVzaChteU9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIHVwZGF0ZSB0aGUgd29ya2Zsb3cgYXR0cmlidXRlIGdlbmVyaWMgdmFsdWVcbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBkYXRhQXR0cmlidXRlc05ld1tkYXRhQXR0cmlidXRlc05ldy5sZW5ndGggLSAxXS50eXBlID09PSBcIndpZFwiXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICR3ZiA9IGRhdGFBdHRyaWJ1dGVzTmV3W2RhdGFBdHRyaWJ1dGVzTmV3Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICR3ZiA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZmluZElmV29ya2Zsb3coZGF0YUF0dHJpYnV0ZXNOZXcsICRkb2N1bWVudENvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIGRvbmVBdHRyaWJ1dGVzRmFtaWx5Y2hhbmdlZCgpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoXG4gICAgICAgICAgICAgICAgICAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcImdldFZhbHVlc1wiKS5zZV9hdHRyaWRzXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUZXN0IGlmIGF0dHJpYnV0ZXMgc2VsZWN0ZWQgYXJlIHN0aWxsIGluIGN1cnJlbnQgZmFtaWx5XG4gICAgICAgICAgICAgICAgICogU2hvdyBhbiBlcnJvciBtZXNzYWdlIGlmIG5vdFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICRkb2N1bWVudENvbnRyb2xsZXIuZG9jdW1lbnRDb250cm9sbGVyKFxuICAgICAgICAgICAgICAgICAgXCJjbGVhbkF0dHJpYnV0ZUVycm9yTWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgICAgXCJzZV9hdHRyaWRzXCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICQuZWFjaChcbiAgICAgICAgICAgICAgICAgICRkb2N1bWVudENvbnRyb2xsZXIuZG9jdW1lbnRDb250cm9sbGVyKFwiZ2V0VmFsdWVzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zZV9hdHRyaWRzLFxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZWFjaEF0dHJpZHNBdHRyaWJ1dGVzRmFtaWx5Y2hhbmdlZChrZXksIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cklkID0gdmFsLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgJGNvbnRyb2xlID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAkLmVhY2goXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YUF0dHJpYnV0ZXNOZXcsXG4gICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZWFjaE5ld0RhdGFhdHRyaWJ1dGVzQXR0cmlidXRlc0ZhbWlseWNoYW5nZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICBta2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgbXZhbFxuICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJJZCA9PT0gbXZhbC5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAkY29udHJvbGUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCRjb250cm9sZSA9PT0gMCAmJiAhaXRlbUVtcHR5KGF0dHJJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic2V0QXR0cmlidXRlRXJyb3JNZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNlX2F0dHJpZHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGkxOG4uX19fKFwiSW52YWxpZCBhdHRyaWJ1dGVcIiwgXCJkc2VhcmNoXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbXlPcGVyYXRvciA9ICRkb2N1bWVudENvbnRyb2xsZXIuZG9jdW1lbnRDb250cm9sbGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJnZXRWYWx1ZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICkuc2VfZnVuY3Nbb3B0aW9uc107XG4gICAgICAgICAgICAgICAgICAgICAgc2V0VmlzaWJpbGl0eShteU9wZXJhdG9yLCBvcHRpb25zLCAkZG9jdW1lbnRDb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YUF0dHJpYnV0ZXMgPSBkYXRhQXR0cmlidXRlc05ldztcbiAgICAgICAgICAgICAgJChcIi5kY3BBdHRyaWJ1dGVfX3ZhbHVlW25hbWU9c2VfYXR0cmlkc11cIikuZWFjaChcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBlYWNoQXR0cmlidXRlc0F0dHJpYnV0ZXNGYW1pbHljaGFuZ2VkKCkge1xuICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgKiBVcGRhdGUgYXR0cmlidXRlcyBrZW5kbyB3aWRnZXQncyBkYXRhXG4gICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgIGlmICgkKHRoaXMpLmRhdGEoXCJrZW5kb0NvbWJvQm94XCIpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICRkYXRhU291cmNlID0gbmV3IGtlbmRvLmRhdGEuRGF0YVNvdXJjZSh7XG4gICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6IHsgZmllbGQ6IFwibGFiZWxfcGFyZW50XCIgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgIC5kYXRhKFwia2VuZG9Db21ib0JveFwiKVxuICAgICAgICAgICAgICAgICAgICAgIC5zZXREYXRhU291cmNlKCRkYXRhU291cmNlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICk7XG5cbiAgd2luZG93LmRjcC5kb2N1bWVudC5kb2N1bWVudENvbnRyb2xsZXIoXG4gICAgXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgXCJjbG9zZVwiLFxuICAgIHtcbiAgICAgIG5hbWU6IFwicmVtb3ZlRHNlYXJjaEF0dHJpYnV0ZXNFdmVudFwiLFxuICAgICAgZG9jdW1lbnRDaGVjazogZnVuY3Rpb24oZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnR5cGUgPT09IFwic2VhcmNoXCI7XG4gICAgICB9XG4gICAgfSxcbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAkdGhpcy5kb2N1bWVudENvbnRyb2xsZXIoXCJyZW1vdmVFdmVudExpc3RlbmVyXCIsIFwiLnNBdHRyXCIpO1xuICAgIH1cbiAgKTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIGtlbmRvQ29tYm9Cb3ggd2lkZ2V0IG9uIGEgc3BlY2lmaWMgb2JqZWN0XG4gICAqIEBwYXJhbSBkYXRhQXR0cmlidXRlcyBsaXN0IG9mIGF0dHJpYnV0ZXMsIHVzZWQgdG8gc2V0IHRoZSBkYXRhXG4gICAqIEBwYXJhbSAkZW52aXJvbm1lbnQgcGxhY2UgdG8gcHV0IHRoZSB3aWRnZXRcbiAgICovXG4gIGZ1bmN0aW9uIGluaXRLZW5kb0NvbWJvQm94KGRhdGFBdHRyaWJ1dGVzLCAkZW52aXJvbm1lbnQpIHtcbiAgICAkZW52aXJvbm1lbnQua2VuZG9Db21ib0JveCh7XG4gICAgICB3aWR0aDogMjAwLFxuICAgICAgcGxhY2Vob2xkZXI6IFwiQ2hvaXNpciBhdHRyaWJ1dFwiLFxuICAgICAgY2xlYXJCdXR0b246IGZhbHNlLFxuICAgICAgZmlsdGVyOiBcImNvbnRhaW5zXCIsXG4gICAgICBtaW5MZW5ndGg6IDAsXG4gICAgICBkYXRhVmFsdWVGaWVsZDogXCJpZFwiLFxuICAgICAgZGF0YVRleHRGaWVsZDogXCJsYWJlbFwiLFxuICAgICAgZGF0YVNvdXJjZToge1xuICAgICAgICBkYXRhOiBkYXRhQXR0cmlidXRlcyxcbiAgICAgICAgZ3JvdXA6IHsgZmllbGQ6IFwibGFiZWxfcGFyZW50XCIgfVxuICAgICAgfVxuICAgIH0pO1xuICAgICRlbnZpcm9ubWVudC5kYXRhKFwia2VuZG9Db21ib0JveFwiKS5saXN0LmNzcyhcIm1pbi13aWR0aFwiLCBcIjMwMHB4XCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIGNoZWNrIGlmIGFuIGl0ZW0gaXMgZW1wdHkvdW5kZWZpbmVkXG4gICAqIEBwYXJhbSBteUl0ZW0sIHRoZSBpdGVtIHRvIHRlc3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpdGVtRW1wdHkobXlJdGVtKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG15SXRlbSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBteUl0ZW0gPT09IG51bGwgfHxcbiAgICAgIG15SXRlbS52YWx1ZSA9PT0gbnVsbCB8fFxuICAgICAgbXlJdGVtLnZhbHVlID09PSBcIlwiXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQga2V5cyB2aXNpYmlsaXRpZXNcbiAgICogQHBhcmFtIG15T3BlcmF0b3Igb3BlcmF0b3IgdXNlZCB0byBrbm93IGlmIHlvdSBzaG93IG9yIGhpZGUgdGhlIGtleXMgZmllbGRcbiAgICogQHBhcmFtICRpbmRleCBpbmRleCBvZiB0aGUgZmllbGQgaW4gdGhlIHRhYmxlXG4gICAqIEBwYXJhbSAkZG9jdW1lbnRDb250cm9sbGVyIHRoZSBkb2N1bWVudCBjb250cm9sbGVyIG9mIHRoZSBkb2N1bWVudFxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VmlzaWJpbGl0eShteU9wZXJhdG9yLCAkaW5kZXgsICRkb2N1bWVudENvbnRyb2xsZXIpIHtcbiAgICB2YXIgbXlLZXl3b3JkO1xuICAgIHZhciBtaW5vcktleXdvcmQ7XG4gICAgdmFyIHZpc2libGUgPSBmYWxzZTtcbiAgICAkKFwiLmRjcEF0dHJpYnV0ZV9fdmFsdWVbbmFtZT1zZV9rZXlzXVwiKS5lYWNoKGZ1bmN0aW9uIGVhY2hLZXlzU2V0VmlzaWJpbGl0eShcbiAgICAgIGtleSxcbiAgICAgIHZhbHVlXG4gICAgKSB7XG4gICAgICBpZiAoa2V5ID09PSAkaW5kZXgpIHtcbiAgICAgICAgbXlLZXl3b3JkID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbWlub3JLZXl3b3JkID0gJGRvY3VtZW50Q29udHJvbGxlci5kb2N1bWVudENvbnRyb2xsZXIoXCJnZXRWYWx1ZXNcIikuc2Vfa2V5c1tcbiAgICAgICRpbmRleFxuICAgIF07XG4gICAgaWYgKG15S2V5d29yZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgJGxhYmVsID0gbnVsbDtcblxuICAgICAgXy5lYWNoKFtdLCBmdW5jdGlvbiBlbXB0eUVhY2hTZXRWaXNpYmlsaXR5KGRhdGEpIHtcbiAgICAgICAgaWYgKG15T3BlcmF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChteU9wZXJhdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobXlPcGVyYXRvci52YWx1ZSA9PT0gZGF0YS5pZCkge1xuICAgICAgICAgICAgICAkbGFiZWwgPSBkYXRhLmxhYmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICgkbGFiZWwgPT09IG51bGwpIHtcbiAgICAgICAgdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLypcbiAgICAgICAgICAgIGNoZWNrIGlmIHRoZSBvcGVyYXRvciBoYXMgYSBcInJpZ2h0XCIgb3BlcmFuZFxuICAgICAgICAgICAgICovXG4gICAgICAgIHZpc2libGUgPSAkbGFiZWwuaW5kZXhPZihcIntyaWdodH1cIikgIT09IC0xO1xuICAgICAgfVxuICAgICAgdmFyICRwYXJlbnQgPSAkKG15S2V5d29yZCkuY2xvc2VzdChcImRpdlwiKTtcbiAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICRwYXJlbnQuc2hvdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHBhcmVudC5oaWRlKCk7XG4gICAgICAgIG15S2V5d29yZC52YWx1ZSA9IG51bGw7XG4gICAgICAgIG1pbm9yS2V5d29yZC52YWx1ZSA9IG51bGw7XG4gICAgICAgIG1pbm9yS2V5d29yZC5kaXNwbGF5VmFsdWUgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGN1cnJlbnQgZmFtaWx5IGlzIGEgd29ya2Zsb3dcbiAgICogcmVwbGFjZSB0aGUgd29ya2Zsb3cgYXR0cmlidXRlIGJ5IGEgbmV3IGJhc2VkIG9uIGdlbmVyaWMgd29ya2Zsb3cgYXR0cmlidXRlXG4gICAqIEBwYXJhbSAkZGF0YSBhdHRyaWJ1dGUgbGlzdFxuICAgKiBAcGFyYW0gJGRvY3VtZW50Q29udHJvbGxlclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGZpbmRJZldvcmtmbG93KCRkYXRhLCAkZG9jdW1lbnRDb250cm9sbGVyKSB7XG4gICAgdmFyICRsYXN0QXR0cmlidXRlID0gJGRhdGFbJGRhdGEubGVuZ3RoIC0gMV07XG4gICAgdmFyICRyZXZBdHRyaWJ1dGUgPSAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcImdldFZhbHVlc1wiKVxuICAgICAgLnNlX2xhdGVzdDtcbiAgICB2YXIgbXlPYmplY3Q7XG4gICAgaWYgKCRsYXN0QXR0cmlidXRlLnR5cGUgPT09IFwid2lkXCIpIHtcbiAgICAgICRkYXRhLnBvcCgpO1xuICAgICAgaWYgKCRyZXZBdHRyaWJ1dGUudmFsdWUgPT09IFwieWVzXCIpIHtcbiAgICAgICAgbXlPYmplY3QgPSB7XG4gICAgICAgICAgaWQ6ICR3Zi5pZCxcbiAgICAgICAgICBsYWJlbDogJHdmLmxhYmVsWzBdLFxuICAgICAgICAgIGxhYmVsX3BhcmVudDogJHdmLmxhYmVsX3BhcmVudCxcbiAgICAgICAgICB0eXBlOiBcIndpZFwiXG4gICAgICAgIH07XG4gICAgICAgICRkYXRhLnB1c2gobXlPYmplY3QpO1xuICAgICAgfSBlbHNlIGlmICgkcmV2QXR0cmlidXRlLnZhbHVlID09PSBcIm5vXCIpIHtcbiAgICAgICAgbXlPYmplY3QgPSB7XG4gICAgICAgICAgaWQ6ICR3Zi5pZCxcbiAgICAgICAgICBsYWJlbDogJHdmLmxhYmVsWzFdLFxuICAgICAgICAgIGxhYmVsX3BhcmVudDogJHdmLmxhYmVsX3BhcmVudCxcbiAgICAgICAgICB0eXBlOiBcIndpZFwiXG4gICAgICAgIH07XG4gICAgICAgICRkYXRhLnB1c2gobXlPYmplY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXlPYmplY3QgPSB7XG4gICAgICAgICAgaWQ6ICR3Zi5pZCxcbiAgICAgICAgICBsYWJlbDogJHdmLmxhYmVsWzJdLFxuICAgICAgICAgIGxhYmVsX3BhcmVudDogJHdmLmxhYmVsX3BhcmVudCxcbiAgICAgICAgICB0eXBlOiBcIndpZFwiXG4gICAgICAgIH07XG4gICAgICAgICRkYXRhLnB1c2gobXlPYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///713b020e474dfbb6d981\n");

/***/ }),

/***/ "8e08e542008e4aef1f58":
/*!***********************************************!*\
  !*** ./node_modules/underscore/underscore.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.9.1\n//     http://underscorejs.org\n//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` (`self`) in the browser, `global`\n  // on the server, or `this` in some virtual machines. We use `self`\n  // instead of `window` for `WebWorker` support.\n  var root = typeof self == 'object' && self.self === self && self ||\n            typeof global == 'object' && global.global === global && global ||\n            this ||\n            {};\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype;\n  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeCreate = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function(){};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for their old module API. If we're in\n  // the browser, add `_` as a global object.\n  // (`nodeType` is checked to ensure that `module`\n  // and `exports` are not HTML elements.)\n  if ( true && !exports.nodeType) {\n    if ( true && !module.nodeType && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.9.1';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      // The 2-argument case is omitted because we’re not using it.\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  var builtinIteratee;\n\n  // An internal function to generate callbacks that can be applied to each\n  // element in a collection, returning the desired result — either `identity`,\n  // an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);\n    return _.property(value);\n  };\n\n  // External wrapper for our callback generator. Users may customize\n  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.\n  // This abstraction hides the internal-only argCount argument.\n  _.iteratee = builtinIteratee = function(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // Some functions take a variable number of arguments, or a few expected\n  // arguments at the beginning and then a variable number of values to operate\n  // on. This helper accumulates all remaining arguments past the function’s\n  // argument length (or an explicit `startIndex`), into an array that becomes\n  // the last argument. Similar to ES6’s \"rest parameter\".\n  var restArguments = function(func, startIndex) {\n    startIndex = startIndex == null ? func.length - 1 : +startIndex;\n    return function() {\n      var length = Math.max(arguments.length - startIndex, 0),\n          rest = Array(length),\n          index = 0;\n      for (; index < length; index++) {\n        rest[index] = arguments[index + startIndex];\n      }\n      switch (startIndex) {\n        case 0: return func.call(this, rest);\n        case 1: return func.call(this, arguments[0], rest);\n        case 2: return func.call(this, arguments[0], arguments[1], rest);\n      }\n      var args = Array(startIndex + 1);\n      for (index = 0; index < startIndex; index++) {\n        args[index] = arguments[index];\n      }\n      args[startIndex] = rest;\n      return func.apply(this, args);\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var shallowProperty = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  var has = function(obj, path) {\n    return obj != null && hasOwnProperty.call(obj, path);\n  }\n\n  var deepGet = function(obj, path) {\n    var length = path.length;\n    for (var i = 0; i < length; i++) {\n      if (obj == null) return void 0;\n      obj = obj[path[i]];\n    }\n    return length ? obj : void 0;\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object.\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = shallowProperty('length');\n  var isArrayLike = function(collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  var createReduce = function(dir) {\n    // Wrap code that reassigns argument variables in a separate function than\n    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)\n    var reducer = function(obj, iteratee, memo, initial) {\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      if (!initial) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    };\n\n    return function(obj, iteratee, memo, context) {\n      var initial = arguments.length >= 3;\n      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);\n    };\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;\n    var key = keyFinder(obj, predicate, context);\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = restArguments(function(obj, path, args) {\n    var contextPath, func;\n    if (_.isFunction(path)) {\n      func = path;\n    } else if (_.isArray(path)) {\n      contextPath = path.slice(0, -1);\n      path = path[path.length - 1];\n    }\n    return _.map(obj, function(context) {\n      var method = func;\n      if (!method) {\n        if (contextPath && contextPath.length) {\n          context = deepGet(context, contextPath);\n        }\n        if (context == null) return void 0;\n        method = context[path];\n      }\n      return method == null ? method : method.apply(context, args);\n    });\n  });\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value != null && value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(v, index, list) {\n        computed = iteratee(v, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = v;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection.\n  _.shuffle = function(obj) {\n    return _.sample(obj, Infinity);\n  };\n\n  // Sample **n** random values from a collection using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);\n    var length = getLength(sample);\n    n = Math.max(Math.min(n, length), 0);\n    var last = length - 1;\n    for (var index = 0; index < n; index++) {\n      var rand = _.random(index, last);\n      var temp = sample[index];\n      sample[index] = sample[rand];\n      sample[rand] = temp;\n    }\n    return sample.slice(0, n);\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    var index = 0;\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function(value, key, list) {\n      return {\n        value: value,\n        index: index++,\n        criteria: iteratee(value, key, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior, partition) {\n    return function(obj, iteratee, context) {\n      var result = partition ? [[], []] : {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  var reStrSymbol = /[^\\ud800-\\udfff]|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff]/g;\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (_.isString(obj)) {\n      // Keep surrogate pair characters together\n      return obj.match(reStrSymbol);\n    }\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = group(function(result, value, pass) {\n    result[pass ? 0 : 1].push(value);\n  }, true);\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null || array.length < 1) return n == null ? void 0 : [];\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function(array, n, guard) {\n    if (array == null || array.length < 1) return n == null ? void 0 : [];\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, Boolean);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, output) {\n    output = output || [];\n    var idx = output.length;\n    for (var i = 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        // Flatten current level of array or arguments object.\n        if (shallow) {\n          var j = 0, len = value.length;\n          while (j < len) output[idx++] = value[j++];\n        } else {\n          flatten(value, shallow, strict, output);\n          idx = output.length;\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = restArguments(function(array, otherArrays) {\n    return _.difference(array, otherArrays);\n  });\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // The faster algorithm will not work with an iteratee if the iteratee\n  // is not a one-to-one function, so providing an iteratee will disable\n  // the faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted && !iteratee) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = restArguments(function(arrays) {\n    return _.uniq(flatten(arrays, true, true));\n  });\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      var j;\n      for (j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = restArguments(function(array, rest) {\n    rest = flatten(rest, true, true);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  });\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices.\n  _.unzip = function(array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = restArguments(_.unzip);\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values. Passing by pairs is the reverse of _.pairs.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions.\n  var createPredicateIndexFinder = function(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  };\n\n  // Returns the first index on an array-like that passes a predicate test.\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions.\n  var createIndexFinder = function(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n          i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  };\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    if (!step) {\n      step = stop < start ? -1 : 1;\n    }\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Chunk a single array into multiple arrays, each containing `count` or fewer\n  // items.\n  _.chunk = function(array, count) {\n    if (count == null || count < 1) return [];\n    var result = [];\n    var i = 0, length = array.length;\n    while (i < length) {\n      result.push(slice.call(array, i, i += count));\n    }\n    return result;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments.\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = restArguments(function(func, context, args) {\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var bound = restArguments(function(callArgs) {\n      return executeBound(func, bound, context, this, args.concat(callArgs));\n    });\n    return bound;\n  });\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder by default, allowing any combination of arguments to be\n  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.\n  _.partial = restArguments(function(func, boundArgs) {\n    var placeholder = _.partial.placeholder;\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  });\n\n  _.partial.placeholder = _;\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = restArguments(function(obj, keys) {\n    keys = flatten(keys, false, false);\n    var index = keys.length;\n    if (index < 1) throw new Error('bindAll must be passed function names');\n    while (index--) {\n      var key = keys[index];\n      obj[key] = _.bind(obj[key], obj);\n    }\n  });\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = restArguments(function(func, wait, args) {\n    return setTimeout(function() {\n      return func.apply(null, args);\n    }, wait);\n  });\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var timeout, context, args, result;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n\n    throttled.cancel = function() {\n      clearTimeout(timeout);\n      previous = 0;\n      timeout = context = args = null;\n    };\n\n    return throttled;\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n\n    var later = function(context, args) {\n      timeout = null;\n      if (args) result = func.apply(context, args);\n    };\n\n    var debounced = restArguments(function(args) {\n      if (timeout) clearTimeout(timeout);\n      if (immediate) {\n        var callNow = !timeout;\n        timeout = setTimeout(later, wait);\n        if (callNow) result = func.apply(this, args);\n      } else {\n        timeout = _.delay(later, wait, this, args);\n      }\n\n      return result;\n    });\n\n    debounced.cancel = function() {\n      clearTimeout(timeout);\n      timeout = null;\n    };\n\n    return debounced;\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  _.restArguments = restArguments;\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  var collectNonEnumProps = function(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  };\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`.\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object.\n  // In contrast to _.map it returns an object.\n  _.mapObject = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = _.keys(obj),\n        length = keys.length,\n        results = {};\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys[index];\n      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  // The opposite of _.object.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`.\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, defaults) {\n    return function(obj) {\n      var length = arguments.length;\n      if (defaults) obj = Object(obj);\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!defaults || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s).\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test.\n  _.findKey = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj), key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Internal pick helper function to determine if `obj` has key `key`.\n  var keyInObj = function(value, key, obj) {\n    return key in obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = restArguments(function(obj, keys) {\n    var result = {}, iteratee = keys[0];\n    if (obj == null) return result;\n    if (_.isFunction(iteratee)) {\n      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);\n      keys = _.allKeys(obj);\n    } else {\n      iteratee = keyInObj;\n      keys = flatten(keys, false, false);\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  });\n\n  // Return a copy of the object without the blacklisted properties.\n  _.omit = restArguments(function(obj, keys) {\n    var iteratee = keys[0], context;\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n      if (keys.length > 1) context = keys[1];\n    } else {\n      keys = _.map(flatten(keys, false, false), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  });\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq, deepEq;\n  eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // `null` or `undefined` only equal to itself (strict comparison).\n    if (a == null || b == null) return false;\n    // `NaN`s are equivalent, but non-reflexive.\n    if (a !== a) return b !== b;\n    // Exhaust primitive checks\n    var type = typeof a;\n    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;\n    return deepEq(a, b, aStack, bStack);\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  deepEq = function(a, b, aStack, bStack) {\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN.\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n      case '[object Symbol]':\n        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).\n  var nodelist = root.document && root.document.childNodes;\n  if ( true && typeof Int8Array != 'object' && typeof nodelist != 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`?\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && isNaN(obj);\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, path) {\n    if (!_.isArray(path)) {\n      return has(obj, path);\n    }\n    var length = path.length;\n    for (var i = 0; i < length; i++) {\n      var key = path[i];\n      if (obj == null || !hasOwnProperty.call(obj, key)) {\n        return false;\n      }\n      obj = obj[key];\n    }\n    return !!length;\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  // Creates a function that, when passed an object, will traverse that object’s\n  // properties down the given `path`, specified as an array of keys or indexes.\n  _.property = function(path) {\n    if (!_.isArray(path)) {\n      return shallowProperty(path);\n    }\n    return function(obj) {\n      return deepGet(obj, path);\n    };\n  };\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function(obj) {\n    if (obj == null) {\n      return function(){};\n    }\n    return function(path) {\n      return !_.isArray(path) ? obj[path] : deepGet(obj, path);\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function(attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n  // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped.\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // Traverses the children of `obj` along `path`. If a child is a function, it\n  // is invoked with its parent as context. Returns the value of the final\n  // child, or `fallback` if any child is undefined.\n  _.result = function(obj, path, fallback) {\n    if (!_.isArray(path)) path = [path];\n    var length = path.length;\n    if (!length) {\n      return _.isFunction(fallback) ? fallback.call(obj) : fallback;\n    }\n    for (var i = 0; i < length; i++) {\n      var prop = obj == null ? void 0 : obj[path[i]];\n      if (prop === void 0) {\n        prop = fallback;\n        i = length; // Ensure we don't continue iterating.\n      }\n      obj = _.isFunction(prop) ? prop.call(obj) : prop;\n    }\n    return obj;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate: /<%([\\s\\S]+?)%>/g,\n    interpolate: /<%=([\\s\\S]+?)%>/g,\n    escape: /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\": \"'\",\n    '\\\\': '\\\\',\n    '\\r': 'r',\n    '\\n': 'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escapeRegExp = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offset.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    var render;\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var chainResult = function(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return chainResult(this, func.apply(_, args));\n      };\n    });\n    return _;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return chainResult(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return chainResult(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function() {\n    return String(this._wrapped);\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return _;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n}());\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"698d75b157f24ae829cc\"), __webpack_require__(/*! ./../webpack/buildin/module.js */ \"f586cf5b9f4b7719b2c1\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOGUwOGU1NDIwMDhlNGFlZjFmNTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzPzE3ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gICAgIFVuZGVyc2NvcmUuanMgMS45LjFcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTggSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCAoYHNlbGZgKSBpbiB0aGUgYnJvd3NlciwgYGdsb2JhbGBcbiAgLy8gb24gdGhlIHNlcnZlciwgb3IgYHRoaXNgIGluIHNvbWUgdmlydHVhbCBtYWNoaW5lcy4gV2UgdXNlIGBzZWxmYFxuICAvLyBpbnN0ZWFkIG9mIGB3aW5kb3dgIGZvciBgV2ViV29ya2VyYCBzdXBwb3J0LlxuICB2YXIgcm9vdCA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmIHx8XG4gICAgICAgICAgICB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbC5nbG9iYWwgPT09IGdsb2JhbCAmJiBnbG9iYWwgfHxcbiAgICAgICAgICAgIHRoaXMgfHxcbiAgICAgICAgICAgIHt9O1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XG5cbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcbiAgdmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIFN5bWJvbFByb3RvID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2wucHJvdG90eXBlIDogbnVsbDtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyIHB1c2ggPSBBcnJheVByb3RvLnB1c2gsXG4gICAgICBzbGljZSA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgICB0b1N0cmluZyA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhciBuYXRpdmVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIG5hdGl2ZUtleXMgPSBPYmplY3Qua2V5cyxcbiAgICAgIG5hdGl2ZUNyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG5cbiAgLy8gTmFrZWQgZnVuY3Rpb24gcmVmZXJlbmNlIGZvciBzdXJyb2dhdGUtcHJvdG90eXBlLXN3YXBwaW5nLlxuICB2YXIgQ3RvciA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cbiAgdmFyIF8gPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgXykgcmV0dXJuIG9iajtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xuICAgIHRoaXMuX3dyYXBwZWQgPSBvYmo7XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgKipOb2RlLmpzKiosIHdpdGhcbiAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgZm9yIHRoZWlyIG9sZCBtb2R1bGUgQVBJLiBJZiB3ZSdyZSBpblxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QuXG4gIC8vIChgbm9kZVR5cGVgIGlzIGNoZWNrZWQgdG8gZW5zdXJlIHRoYXQgYG1vZHVsZWBcbiAgLy8gYW5kIGBleHBvcnRzYCBhcmUgbm90IEhUTUwgZWxlbWVudHMuKVxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgJiYgIWV4cG9ydHMubm9kZVR5cGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuXyA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjkuMSc7XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVmZmljaWVudCAoZm9yIGN1cnJlbnQgZW5naW5lcykgdmVyc2lvblxuICAvLyBvZiB0aGUgcGFzc2VkLWluIGNhbGxiYWNrLCB0byBiZSByZXBlYXRlZGx5IGFwcGxpZWQgaW4gb3RoZXIgVW5kZXJzY29yZVxuICAvLyBmdW5jdGlvbnMuXG4gIHZhciBvcHRpbWl6ZUNiID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSByZXR1cm4gZnVuYztcbiAgICBzd2l0Y2ggKGFyZ0NvdW50ID09IG51bGwgPyAzIDogYXJnQ291bnQpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIC8vIFRoZSAyLWFyZ3VtZW50IGNhc2UgaXMgb21pdHRlZCBiZWNhdXNlIHdl4oCZcmUgbm90IHVzaW5nIGl0LlxuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGJ1aWx0aW5JdGVyYXRlZTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjYWxsYmFja3MgdGhhdCBjYW4gYmUgYXBwbGllZCB0byBlYWNoXG4gIC8vIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uLCByZXR1cm5pbmcgdGhlIGRlc2lyZWQgcmVzdWx0IOKAlCBlaXRoZXIgYGlkZW50aXR5YCxcbiAgLy8gYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmIChfLml0ZXJhdGVlICE9PSBidWlsdGluSXRlcmF0ZWUpIHJldHVybiBfLml0ZXJhdGVlKHZhbHVlLCBjb250ZXh0KTtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIF8uaWRlbnRpdHk7XG4gICAgaWYgKF8uaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybiBvcHRpbWl6ZUNiKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCk7XG4gICAgaWYgKF8uaXNPYmplY3QodmFsdWUpICYmICFfLmlzQXJyYXkodmFsdWUpKSByZXR1cm4gXy5tYXRjaGVyKHZhbHVlKTtcbiAgICByZXR1cm4gXy5wcm9wZXJ0eSh2YWx1ZSk7XG4gIH07XG5cbiAgLy8gRXh0ZXJuYWwgd3JhcHBlciBmb3Igb3VyIGNhbGxiYWNrIGdlbmVyYXRvci4gVXNlcnMgbWF5IGN1c3RvbWl6ZVxuICAvLyBgXy5pdGVyYXRlZWAgaWYgdGhleSB3YW50IGFkZGl0aW9uYWwgcHJlZGljYXRlL2l0ZXJhdGVlIHNob3J0aGFuZCBzdHlsZXMuXG4gIC8vIFRoaXMgYWJzdHJhY3Rpb24gaGlkZXMgdGhlIGludGVybmFsLW9ubHkgYXJnQ291bnQgYXJndW1lbnQuXG4gIF8uaXRlcmF0ZWUgPSBidWlsdGluSXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCkge1xuICAgIHJldHVybiBjYih2YWx1ZSwgY29udGV4dCwgSW5maW5pdHkpO1xuICB9O1xuXG4gIC8vIFNvbWUgZnVuY3Rpb25zIHRha2UgYSB2YXJpYWJsZSBudW1iZXIgb2YgYXJndW1lbnRzLCBvciBhIGZldyBleHBlY3RlZFxuICAvLyBhcmd1bWVudHMgYXQgdGhlIGJlZ2lubmluZyBhbmQgdGhlbiBhIHZhcmlhYmxlIG51bWJlciBvZiB2YWx1ZXMgdG8gb3BlcmF0ZVxuICAvLyBvbi4gVGhpcyBoZWxwZXIgYWNjdW11bGF0ZXMgYWxsIHJlbWFpbmluZyBhcmd1bWVudHMgcGFzdCB0aGUgZnVuY3Rpb27igJlzXG4gIC8vIGFyZ3VtZW50IGxlbmd0aCAob3IgYW4gZXhwbGljaXQgYHN0YXJ0SW5kZXhgKSwgaW50byBhbiBhcnJheSB0aGF0IGJlY29tZXNcbiAgLy8gdGhlIGxhc3QgYXJndW1lbnQuIFNpbWlsYXIgdG8gRVM24oCZcyBcInJlc3QgcGFyYW1ldGVyXCIuXG4gIHZhciByZXN0QXJndW1lbnRzID0gZnVuY3Rpb24oZnVuYywgc3RhcnRJbmRleCkge1xuICAgIHN0YXJ0SW5kZXggPSBzdGFydEluZGV4ID09IG51bGwgPyBmdW5jLmxlbmd0aCAtIDEgOiArc3RhcnRJbmRleDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoYXJndW1lbnRzLmxlbmd0aCAtIHN0YXJ0SW5kZXgsIDApLFxuICAgICAgICAgIHJlc3QgPSBBcnJheShsZW5ndGgpLFxuICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICByZXN0W2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCArIHN0YXJ0SW5kZXhdO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChzdGFydEluZGV4KSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCByZXN0KTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXMsIGFyZ3VtZW50c1swXSwgcmVzdCk7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgcmVzdCk7XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IEFycmF5KHN0YXJ0SW5kZXggKyAxKTtcbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHN0YXJ0SW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgfVxuICAgICAgYXJnc1tzdGFydEluZGV4XSA9IHJlc3Q7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIGFub3RoZXIuXG4gIHZhciBiYXNlQ3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KHByb3RvdHlwZSkpIHJldHVybiB7fTtcbiAgICBpZiAobmF0aXZlQ3JlYXRlKSByZXR1cm4gbmF0aXZlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBDdG9yO1xuICAgIEN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHZhciBzaGFsbG93UHJvcGVydHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBoYXMgPSBmdW5jdGlvbihvYmosIHBhdGgpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHBhdGgpO1xuICB9XG5cbiAgdmFyIGRlZXBHZXQgPSBmdW5jdGlvbihvYmosIHBhdGgpIHtcbiAgICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgICAgb2JqID0gb2JqW3BhdGhbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoID8gb2JqIDogdm9pZCAwO1xuICB9O1xuXG4gIC8vIEhlbHBlciBmb3IgY29sbGVjdGlvbiBtZXRob2RzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgY29sbGVjdGlvblxuICAvLyBzaG91bGQgYmUgaXRlcmF0ZWQgYXMgYW4gYXJyYXkgb3IgYXMgYW4gb2JqZWN0LlxuICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICAvLyBBdm9pZHMgYSB2ZXJ5IG5hc3R5IGlPUyA4IEpJVCBidWcgb24gQVJNLTY0LiAjMjA5NFxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIGdldExlbmd0aCA9IHNoYWxsb3dQcm9wZXJ0eSgnbGVuZ3RoJyk7XG4gIHZhciBpc0FycmF5TGlrZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgbGVuZ3RoID0gZ2V0TGVuZ3RoKGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInICYmIGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8PSBNQVhfQVJSQVlfSU5ERVg7XG4gIH07XG5cbiAgLy8gQ29sbGVjdGlvbiBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBUaGUgY29ybmVyc3RvbmUsIGFuIGBlYWNoYCBpbXBsZW1lbnRhdGlvbiwgYWthIGBmb3JFYWNoYC5cbiAgLy8gSGFuZGxlcyByYXcgb2JqZWN0cyBpbiBhZGRpdGlvbiB0byBhcnJheS1saWtlcy4gVHJlYXRzIGFsbFxuICAvLyBzcGFyc2UgYXJyYXktbGlrZXMgYXMgaWYgdGhleSB3ZXJlIGRlbnNlLlxuICBfLmVhY2ggPSBfLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgaSwgbGVuZ3RoO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpba2V5c1tpXV0sIGtleXNbaV0sIG9iaik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQuXG4gIF8ubWFwID0gXy5jb2xsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoLFxuICAgICAgICByZXN1bHRzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgcmVzdWx0c1tpbmRleF0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIHJlZHVjaW5nIGZ1bmN0aW9uIGl0ZXJhdGluZyBsZWZ0IG9yIHJpZ2h0LlxuICB2YXIgY3JlYXRlUmVkdWNlID0gZnVuY3Rpb24oZGlyKSB7XG4gICAgLy8gV3JhcCBjb2RlIHRoYXQgcmVhc3NpZ25zIGFyZ3VtZW50IHZhcmlhYmxlcyBpbiBhIHNlcGFyYXRlIGZ1bmN0aW9uIHRoYW5cbiAgICAvLyB0aGUgb25lIHRoYXQgYWNjZXNzZXMgYGFyZ3VtZW50cy5sZW5ndGhgIHRvIGF2b2lkIGEgcGVyZiBoaXQuICgjMTk5MSlcbiAgICB2YXIgcmVkdWNlciA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGluaXRpYWwpIHtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgbWVtbyA9IG9ialtrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleF07XG4gICAgICAgIGluZGV4ICs9IGRpcjtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdGVlKG1lbW8sIG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgdmFyIGluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID49IDM7XG4gICAgICByZXR1cm4gcmVkdWNlcihvYmosIG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDQpLCBtZW1vLCBpbml0aWFsKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcbiAgLy8gb3IgYGZvbGRsYC5cbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBjcmVhdGVSZWR1Y2UoMSk7XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gY3JlYXRlUmVkdWNlKC0xKTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXG4gIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIga2V5RmluZGVyID0gaXNBcnJheUxpa2Uob2JqKSA/IF8uZmluZEluZGV4IDogXy5maW5kS2V5O1xuICAgIHZhciBrZXkgPSBrZXlGaW5kZXIob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIGlmIChrZXkgIT09IHZvaWQgMCAmJiBrZXkgIT09IC0xKSByZXR1cm4gb2JqW2tleV07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm5lZ2F0ZShjYihwcmVkaWNhdGUpKSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFsbGAuXG4gIF8uZXZlcnkgPSBfLmFsbCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKCFwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IG1hdGNoZXMgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbnlgLlxuICBfLnNvbWUgPSBfLmFueSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiBpdGVtICh1c2luZyBgPT09YCkuXG4gIC8vIEFsaWFzZWQgYXMgYGluY2x1ZGVzYCBhbmQgYGluY2x1ZGVgLlxuICBfLmNvbnRhaW5zID0gXy5pbmNsdWRlcyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgaXRlbSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICBpZiAodHlwZW9mIGZyb21JbmRleCAhPSAnbnVtYmVyJyB8fCBndWFyZCkgZnJvbUluZGV4ID0gMDtcbiAgICByZXR1cm4gXy5pbmRleE9mKG9iaiwgaXRlbSwgZnJvbUluZGV4KSA+PSAwO1xuICB9O1xuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICBfLmludm9rZSA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24ob2JqLCBwYXRoLCBhcmdzKSB7XG4gICAgdmFyIGNvbnRleHRQYXRoLCBmdW5jO1xuICAgIGlmIChfLmlzRnVuY3Rpb24ocGF0aCkpIHtcbiAgICAgIGZ1bmMgPSBwYXRoO1xuICAgIH0gZWxzZSBpZiAoXy5pc0FycmF5KHBhdGgpKSB7XG4gICAgICBjb250ZXh0UGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICAgICAgcGF0aCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIG1ldGhvZCA9IGZ1bmM7XG4gICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICBpZiAoY29udGV4dFBhdGggJiYgY29udGV4dFBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgY29udGV4dCA9IGRlZXBHZXQoY29udGV4dCwgY29udGV4dFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgICAgIG1ldGhvZCA9IGNvbnRleHRbcGF0aF07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWV0aG9kID09IG51bGwgPyBtZXRob2QgOiBtZXRob2QuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBfLm1hcChvYmosIF8ucHJvcGVydHkoa2V5KSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmlsdGVyYDogc2VsZWN0aW5nIG9ubHkgb2JqZWN0c1xuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLndoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5maW5kV2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IC1JbmZpbml0eSwgbGFzdENvbXB1dGVkID0gLUluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgfHwgdHlwZW9mIGl0ZXJhdGVlID09ICdudW1iZXInICYmIHR5cGVvZiBvYmpbMF0gIT0gJ29iamVjdCcgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgPiByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHYsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodiwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPiBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IC1JbmZpbml0eSAmJiByZXN1bHQgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHY7XG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWluaW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5taW4gPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IEluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSBJbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsIHx8IHR5cGVvZiBpdGVyYXRlZSA9PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqWzBdICE9ICdvYmplY3QnICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2LCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHYsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkIDwgbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSBJbmZpbml0eSAmJiByZXN1bHQgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdjtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24uXG4gIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLnNhbXBsZShvYmosIEluZmluaXR5KTtcbiAgfTtcblxuICAvLyBTYW1wbGUgKipuKiogcmFuZG9tIHZhbHVlcyBmcm9tIGEgY29sbGVjdGlvbiB1c2luZyB0aGUgbW9kZXJuIHZlcnNpb24gb2YgdGhlXG4gIC8vIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXLigJNZYXRlc19zaHVmZmxlKS5cbiAgLy8gSWYgKipuKiogaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudC5cbiAgLy8gVGhlIGludGVybmFsIGBndWFyZGAgYXJndW1lbnQgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgbWFwYC5cbiAgXy5zYW1wbGUgPSBmdW5jdGlvbihvYmosIG4sIGd1YXJkKSB7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xuICAgICAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgICAgcmV0dXJuIG9ialtfLnJhbmRvbShvYmoubGVuZ3RoIC0gMSldO1xuICAgIH1cbiAgICB2YXIgc2FtcGxlID0gaXNBcnJheUxpa2Uob2JqKSA/IF8uY2xvbmUob2JqKSA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChzYW1wbGUpO1xuICAgIG4gPSBNYXRoLm1heChNYXRoLm1pbihuLCBsZW5ndGgpLCAwKTtcbiAgICB2YXIgbGFzdCA9IGxlbmd0aCAtIDE7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IG47IGluZGV4KyspIHtcbiAgICAgIHZhciByYW5kID0gXy5yYW5kb20oaW5kZXgsIGxhc3QpO1xuICAgICAgdmFyIHRlbXAgPSBzYW1wbGVbaW5kZXhdO1xuICAgICAgc2FtcGxlW2luZGV4XSA9IHNhbXBsZVtyYW5kXTtcbiAgICAgIHNhbXBsZVtyYW5kXSA9IHRlbXA7XG4gICAgfVxuICAgIHJldHVybiBzYW1wbGUuc2xpY2UoMCwgbik7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgrKyxcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvciwgcGFydGl0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBwYXJ0aXRpb24gPyBbW10sIFtdXSA6IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGtleSA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgb2JqKTtcbiAgICAgICAgYmVoYXZpb3IocmVzdWx0LCB2YWx1ZSwga2V5KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcbiAgLy8gdG8gZ3JvdXAgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjcml0ZXJpb24uXG4gIF8uZ3JvdXBCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChoYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTsgZWxzZSByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gIH0pO1xuXG4gIC8vIEluZGV4ZXMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiwgc2ltaWxhciB0byBgZ3JvdXBCeWAsIGJ1dCBmb3JcbiAgLy8gd2hlbiB5b3Uga25vdyB0aGF0IHlvdXIgaW5kZXggdmFsdWVzIHdpbGwgYmUgdW5pcXVlLlxuICBfLmluZGV4QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9KTtcblxuICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3NcbiAgLy8gZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBjb3VudCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gIC8vIGNyaXRlcmlvbi5cbiAgXy5jb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKGhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICB2YXIgcmVTdHJTeW1ib2wgPSAvW15cXHVkODAwLVxcdWRmZmZdfFtcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl18W1xcdWQ4MDAtXFx1ZGZmZl0vZztcbiAgLy8gU2FmZWx5IGNyZWF0ZSBhIHJlYWwsIGxpdmUgYXJyYXkgZnJvbSBhbnl0aGluZyBpdGVyYWJsZS5cbiAgXy50b0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBbXTtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikpIHJldHVybiBzbGljZS5jYWxsKG9iaik7XG4gICAgaWYgKF8uaXNTdHJpbmcob2JqKSkge1xuICAgICAgLy8gS2VlcCBzdXJyb2dhdGUgcGFpciBjaGFyYWN0ZXJzIHRvZ2V0aGVyXG4gICAgICByZXR1cm4gb2JqLm1hdGNoKHJlU3RyU3ltYm9sKTtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHJldHVybiBfLm1hcChvYmosIF8uaWRlbnRpdHkpO1xuICAgIHJldHVybiBfLnZhbHVlcyhvYmopO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC5cbiAgXy5zaXplID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gMDtcbiAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqKSA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XG4gIH07XG5cbiAgLy8gU3BsaXQgYSBjb2xsZWN0aW9uIGludG8gdHdvIGFycmF5czogb25lIHdob3NlIGVsZW1lbnRzIGFsbCBzYXRpc2Z5IHRoZSBnaXZlblxuICAvLyBwcmVkaWNhdGUsIGFuZCBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIGRvIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gIF8ucGFydGl0aW9uID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwgcGFzcykge1xuICAgIHJlc3VsdFtwYXNzID8gMCA6IDFdLnB1c2godmFsdWUpO1xuICB9LCB0cnVlKTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwgfHwgYXJyYXkubGVuZ3RoIDwgMSkgcmV0dXJuIG4gPT0gbnVsbCA/IHZvaWQgMCA6IFtdO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsIHx8IGFycmF5Lmxlbmd0aCA8IDEpIHJldHVybiBuID09IG51bGwgPyB2b2lkIDAgOiBbXTtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIF8ucmVzdChhcnJheSwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gbikpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGZpcnN0IGVudHJ5IG9mIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgdGFpbGAgYW5kIGBkcm9wYC5cbiAgLy8gRXNwZWNpYWxseSB1c2VmdWwgb24gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgYW4gKipuKiogd2lsbCByZXR1cm5cbiAgLy8gdGhlIHJlc3QgTiB2YWx1ZXMgaW4gdGhlIGFycmF5LlxuICBfLnJlc3QgPSBfLnRhaWwgPSBfLmRyb3AgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgbiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pO1xuICB9O1xuXG4gIC8vIFRyaW0gb3V0IGFsbCBmYWxzeSB2YWx1ZXMgZnJvbSBhbiBhcnJheS5cbiAgXy5jb21wYWN0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIEJvb2xlYW4pO1xuICB9O1xuXG4gIC8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIG9mIGEgcmVjdXJzaXZlIGBmbGF0dGVuYCBmdW5jdGlvbi5cbiAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbihpbnB1dCwgc2hhbGxvdywgc3RyaWN0LCBvdXRwdXQpIHtcbiAgICBvdXRwdXQgPSBvdXRwdXQgfHwgW107XG4gICAgdmFyIGlkeCA9IG91dHB1dC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChpbnB1dCk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmIChfLmlzQXJyYXkodmFsdWUpIHx8IF8uaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICAvLyBGbGF0dGVuIGN1cnJlbnQgbGV2ZWwgb2YgYXJyYXkgb3IgYXJndW1lbnRzIG9iamVjdC5cbiAgICAgICAgaWYgKHNoYWxsb3cpIHtcbiAgICAgICAgICB2YXIgaiA9IDAsIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaiA8IGxlbikgb3V0cHV0W2lkeCsrXSA9IHZhbHVlW2orK107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgc3RyaWN0LCBvdXRwdXQpO1xuICAgICAgICAgIGlkeCA9IG91dHB1dC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCkge1xuICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgLy8gRmxhdHRlbiBvdXQgYW4gYXJyYXksIGVpdGhlciByZWN1cnNpdmVseSAoYnkgZGVmYXVsdCksIG9yIGp1c3Qgb25lIGxldmVsLlxuICBfLmZsYXR0ZW4gPSBmdW5jdGlvbihhcnJheSwgc2hhbGxvdykge1xuICAgIHJldHVybiBmbGF0dGVuKGFycmF5LCBzaGFsbG93LCBmYWxzZSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgdmFsdWUocykuXG4gIF8ud2l0aG91dCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oYXJyYXksIG90aGVyQXJyYXlzKSB7XG4gICAgcmV0dXJuIF8uZGlmZmVyZW5jZShhcnJheSwgb3RoZXJBcnJheXMpO1xuICB9KTtcblxuICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeVxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIFRoZSBmYXN0ZXIgYWxnb3JpdGhtIHdpbGwgbm90IHdvcmsgd2l0aCBhbiBpdGVyYXRlZSBpZiB0aGUgaXRlcmF0ZWVcbiAgLy8gaXMgbm90IGEgb25lLXRvLW9uZSBmdW5jdGlvbiwgc28gcHJvdmlkaW5nIGFuIGl0ZXJhdGVlIHdpbGwgZGlzYWJsZVxuICAvLyB0aGUgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCAmJiAhaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKCFpIHx8IHNlZW4gIT09IGNvbXB1dGVkKSByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgIH0gZWxzZSBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKHNlZW4sIGNvbXB1dGVkKSkge1xuICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFfLmNvbnRhaW5zKHJlc3VsdCwgdmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIHVuaW9uOiBlYWNoIGRpc3RpbmN0IGVsZW1lbnQgZnJvbSBhbGwgb2ZcbiAgLy8gdGhlIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8udW5pb24gPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGFycmF5cykge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcnJheXMsIHRydWUsIHRydWUpKTtcbiAgfSk7XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV2ZXJ5IGl0ZW0gc2hhcmVkIGJldHdlZW4gYWxsIHRoZVxuICAvLyBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGFycmF5W2ldO1xuICAgICAgaWYgKF8uY29udGFpbnMocmVzdWx0LCBpdGVtKSkgY29udGludWU7XG4gICAgICB2YXIgajtcbiAgICAgIGZvciAoaiA9IDE7IGogPCBhcmdzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKGFyZ3VtZW50c1tqXSwgaXRlbSkpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGogPT09IGFyZ3NMZW5ndGgpIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihhcnJheSwgcmVzdCkge1xuICAgIHJlc3QgPSBmbGF0dGVuKHJlc3QsIHRydWUsIHRydWUpO1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgZnVuY3Rpb24odmFsdWUpe1xuICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKHJlc3QsIHZhbHVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gQ29tcGxlbWVudCBvZiBfLnppcC4gVW56aXAgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgYW5kIGdyb3Vwc1xuICAvLyBlYWNoIGFycmF5J3MgZWxlbWVudHMgb24gc2hhcmVkIGluZGljZXMuXG4gIF8udW56aXAgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSAmJiBfLm1heChhcnJheSwgZ2V0TGVuZ3RoKS5sZW5ndGggfHwgMDtcbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBfLnBsdWNrKGFycmF5LCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgXy56aXAgPSByZXN0QXJndW1lbnRzKF8udW56aXApO1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy4gUGFzc2luZyBieSBwYWlycyBpcyB0aGUgcmV2ZXJzZSBvZiBfLnBhaXJzLlxuICBfLm9iamVjdCA9IGZ1bmN0aW9uKGxpc3QsIHZhbHVlcykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGxpc3QpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1bMF1dID0gbGlzdFtpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBmaW5kSW5kZXggYW5kIGZpbmRMYXN0SW5kZXggZnVuY3Rpb25zLlxuICB2YXIgY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIgPSBmdW5jdGlvbihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgaW5kZXggb24gYW4gYXJyYXktbGlrZSB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0LlxuICBfLmZpbmRJbmRleCA9IGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKDEpO1xuICBfLmZpbmRMYXN0SW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigtMSk7XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdGVlKG9iaik7XG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVttaWRdKSA8IHZhbHVlKSBsb3cgPSBtaWQgKyAxOyBlbHNlIGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgaW5kZXhPZiBhbmQgbGFzdEluZGV4T2YgZnVuY3Rpb25zLlxuICB2YXIgY3JlYXRlSW5kZXhGaW5kZXIgPSBmdW5jdGlvbihkaXIsIHByZWRpY2F0ZUZpbmQsIHNvcnRlZEluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICAgIHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIGlmICh0eXBlb2YgaWR4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgaSA9IGlkeCA+PSAwID8gaWR4IDogTWF0aC5tYXgoaWR4ICsgbGVuZ3RoLCBpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZW5ndGggPSBpZHggPj0gMCA/IE1hdGgubWluKGlkeCArIDEsIGxlbmd0aCkgOiBpZHggKyBsZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNvcnRlZEluZGV4ICYmIGlkeCAmJiBsZW5ndGgpIHtcbiAgICAgICAgaWR4ID0gc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgICByZXR1cm4gYXJyYXlbaWR4XSA9PT0gaXRlbSA/IGlkeCA6IC0xO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgICAgaWR4ID0gcHJlZGljYXRlRmluZChzbGljZS5jYWxsKGFycmF5LCBpLCBsZW5ndGgpLCBfLmlzTmFOKTtcbiAgICAgICAgcmV0dXJuIGlkeCA+PSAwID8gaWR4ICsgaSA6IC0xO1xuICAgICAgfVxuICAgICAgZm9yIChpZHggPSBkaXIgPiAwID8gaSA6IGxlbmd0aCAtIDE7IGlkeCA+PSAwICYmIGlkeCA8IGxlbmd0aDsgaWR4ICs9IGRpcikge1xuICAgICAgICBpZiAoYXJyYXlbaWR4XSA9PT0gaXRlbSkgcmV0dXJuIGlkeDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKDEsIF8uZmluZEluZGV4LCBfLnNvcnRlZEluZGV4KTtcbiAgXy5sYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBfLmZpbmRMYXN0SW5kZXgpO1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIGlmICghc3RlcCkge1xuICAgICAgc3RlcCA9IHN0b3AgPCBzdGFydCA/IC0xIDogMTtcbiAgICB9XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIENodW5rIGEgc2luZ2xlIGFycmF5IGludG8gbXVsdGlwbGUgYXJyYXlzLCBlYWNoIGNvbnRhaW5pbmcgYGNvdW50YCBvciBmZXdlclxuICAvLyBpdGVtcy5cbiAgXy5jaHVuayA9IGZ1bmN0aW9uKGFycmF5LCBjb3VudCkge1xuICAgIGlmIChjb3VudCA9PSBudWxsIHx8IGNvdW50IDwgMSkgcmV0dXJuIFtdO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0LnB1c2goc2xpY2UuY2FsbChhcnJheSwgaSwgaSArPSBjb3VudCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgdmFyIGV4ZWN1dGVCb3VuZCA9IGZ1bmN0aW9uKHNvdXJjZUZ1bmMsIGJvdW5kRnVuYywgY29udGV4dCwgY2FsbGluZ0NvbnRleHQsIGFyZ3MpIHtcbiAgICBpZiAoIShjYWxsaW5nQ29udGV4dCBpbnN0YW5jZW9mIGJvdW5kRnVuYykpIHJldHVybiBzb3VyY2VGdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIHZhciBzZWxmID0gYmFzZUNyZWF0ZShzb3VyY2VGdW5jLnByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IHNvdXJjZUZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgaWYgKF8uaXNPYmplY3QocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcbiAgLy8gb3B0aW9uYWxseSkuIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBGdW5jdGlvbi5iaW5kYCBpZlxuICAvLyBhdmFpbGFibGUuXG4gIF8uYmluZCA9IHJlc3RBcmd1bWVudHMoZnVuY3Rpb24oZnVuYywgY29udGV4dCwgYXJncykge1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdCaW5kIG11c3QgYmUgY2FsbGVkIG9uIGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgYm91bmQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGNhbGxBcmdzKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChjYWxsQXJncykpO1xuICAgIH0pO1xuICAgIHJldHVybiBib3VuZDtcbiAgfSk7XG5cbiAgLy8gUGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb24gYnkgY3JlYXRpbmcgYSB2ZXJzaW9uIHRoYXQgaGFzIGhhZCBzb21lIG9mIGl0c1xuICAvLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC4gXyBhY3RzXG4gIC8vIGFzIGEgcGxhY2Vob2xkZXIgYnkgZGVmYXVsdCwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZVxuICAvLyBwcmUtZmlsbGVkLiBTZXQgYF8ucGFydGlhbC5wbGFjZWhvbGRlcmAgZm9yIGEgY3VzdG9tIHBsYWNlaG9sZGVyIGFyZ3VtZW50LlxuICBfLnBhcnRpYWwgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGZ1bmMsIGJvdW5kQXJncykge1xuICAgIHZhciBwbGFjZWhvbGRlciA9IF8ucGFydGlhbC5wbGFjZWhvbGRlcjtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IHBsYWNlaG9sZGVyID8gYXJndW1lbnRzW3Bvc2l0aW9uKytdIDogYm91bmRBcmdzW2ldO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgYXJndW1lbnRzLmxlbmd0aCkgYXJncy5wdXNoKGFyZ3VtZW50c1twb3NpdGlvbisrXSk7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCB0aGlzLCB0aGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfSk7XG5cbiAgXy5wYXJ0aWFsLnBsYWNlaG9sZGVyID0gXztcblxuICAvLyBCaW5kIGEgbnVtYmVyIG9mIGFuIG9iamVjdCdzIG1ldGhvZHMgdG8gdGhhdCBvYmplY3QuIFJlbWFpbmluZyBhcmd1bWVudHNcbiAgLy8gYXJlIHRoZSBtZXRob2QgbmFtZXMgdG8gYmUgYm91bmQuIFVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCBhbGwgY2FsbGJhY2tzXG4gIC8vIGRlZmluZWQgb24gYW4gb2JqZWN0IGJlbG9uZyB0byBpdC5cbiAgXy5iaW5kQWxsID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihvYmosIGtleXMpIHtcbiAgICBrZXlzID0gZmxhdHRlbihrZXlzLCBmYWxzZSwgZmFsc2UpO1xuICAgIHZhciBpbmRleCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChpbmRleCA8IDEpIHRocm93IG5ldyBFcnJvcignYmluZEFsbCBtdXN0IGJlIHBhc3NlZCBmdW5jdGlvbiBuYW1lcycpO1xuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vaXplID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgY2FjaGUgPSBtZW1vaXplLmNhY2hlO1xuICAgICAgdmFyIGFkZHJlc3MgPSAnJyArIChoYXNoZXIgPyBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleSk7XG4gICAgICBpZiAoIWhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfSk7XG5cbiAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzXG4gIC8vIGNsZWFyZWQuXG4gIF8uZGVmZXIgPSBfLnBhcnRpYWwoXy5kZWxheSwgXywgMSk7XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4gIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuICAvLyBhcyBtdWNoIGFzIGl0IGNhbiwgd2l0aG91dCBldmVyIGdvaW5nIG1vcmUgdGhhbiBvbmNlIHBlciBgd2FpdGAgZHVyYXRpb247XG4gIC8vIGJ1dCBpZiB5b3UnZCBsaWtlIHRvIGRpc2FibGUgdGhlIGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlLCBwYXNzXG4gIC8vIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuICBfLnRocm90dGxlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgIHZhciB0aW1lb3V0LCBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdmFyIHRocm90dGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vdyA9IF8ubm93KCk7XG4gICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gbm93O1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHRocm90dGxlZC5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHByZXZpb3VzID0gMDtcbiAgICAgIHRpbWVvdXQgPSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcblxuICAgIHJldHVybiB0aHJvdHRsZWQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgaWYgKGFyZ3MpIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfTtcblxuICAgIHZhciBkZWJvdW5jZWQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIGlmICh0aW1lb3V0KSBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICBpZiAoaW1tZWRpYXRlKSB7XG4gICAgICAgIHZhciBjYWxsTm93ID0gIXRpbWVvdXQ7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgICAgaWYgKGNhbGxOb3cpIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gXy5kZWxheShsYXRlciwgd2FpdCwgdGhpcywgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICBkZWJvdW5jZWQuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQtaW4gcHJlZGljYXRlLlxuICBfLm5lZ2F0ZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgc3RhcnQgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSBzdGFydDtcbiAgICAgIHZhciByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIG9uIGFuZCBhZnRlciB0aGUgTnRoIGNhbGwuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHVwIHRvIChidXQgbm90IGluY2x1ZGluZykgdGhlIE50aCBjYWxsLlxuICBfLmJlZm9yZSA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgdmFyIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPiAwKSB7XG4gICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAodGltZXMgPD0gMSkgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBfLnBhcnRpYWwoXy5iZWZvcmUsIDIpO1xuXG4gIF8ucmVzdEFyZ3VtZW50cyA9IHJlc3RBcmd1bWVudHM7XG5cbiAgLy8gT2JqZWN0IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gS2V5cyBpbiBJRSA8IDkgdGhhdCB3b24ndCBiZSBpdGVyYXRlZCBieSBgZm9yIGtleSBpbiAuLi5gIGFuZCB0aHVzIG1pc3NlZC5cbiAgdmFyIGhhc0VudW1CdWcgPSAhe3RvU3RyaW5nOiBudWxsfS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKTtcbiAgdmFyIG5vbkVudW1lcmFibGVQcm9wcyA9IFsndmFsdWVPZicsICdpc1Byb3RvdHlwZU9mJywgJ3RvU3RyaW5nJyxcbiAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLCAnaGFzT3duUHJvcGVydHknLCAndG9Mb2NhbGVTdHJpbmcnXTtcblxuICB2YXIgY29sbGVjdE5vbkVudW1Qcm9wcyA9IGZ1bmN0aW9uKG9iaiwga2V5cykge1xuICAgIHZhciBub25FbnVtSWR4ID0gbm9uRW51bWVyYWJsZVByb3BzLmxlbmd0aDtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBvYmouY29uc3RydWN0b3I7XG4gICAgdmFyIHByb3RvID0gXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgfHwgT2JqUHJvdG87XG5cbiAgICAvLyBDb25zdHJ1Y3RvciBpcyBhIHNwZWNpYWwgY2FzZS5cbiAgICB2YXIgcHJvcCA9ICdjb25zdHJ1Y3Rvcic7XG4gICAgaWYgKGhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgbmFtZXMgb2YgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2AuXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgb2JqZWN0LlxuICAvLyBJbiBjb250cmFzdCB0byBfLm1hcCBpdCByZXR1cm5zIGFuIG9iamVjdC5cbiAgXy5tYXBPYmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgcmVzdWx0c1tjdXJyZW50S2V5XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ29udmVydCBhbiBvYmplY3QgaW50byBhIGxpc3Qgb2YgYFtrZXksIHZhbHVlXWAgcGFpcnMuXG4gIC8vIFRoZSBvcHBvc2l0ZSBvZiBfLm9iamVjdC5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2AuXG4gIF8uZnVuY3Rpb25zID0gXy5tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmpba2V5XSkpIG5hbWVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLnNvcnQoKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYXNzaWduZXIgZnVuY3Rpb25zLlxuICB2YXIgY3JlYXRlQXNzaWduZXIgPSBmdW5jdGlvbihrZXlzRnVuYywgZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChkZWZhdWx0cykgb2JqID0gT2JqZWN0KG9iaik7XG4gICAgICBpZiAobGVuZ3RoIDwgMiB8fCBvYmogPT0gbnVsbCkgcmV0dXJuIG9iajtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF0sXG4gICAgICAgICAgICBrZXlzID0ga2V5c0Z1bmMoc291cmNlKSxcbiAgICAgICAgICAgIGwgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoIWRlZmF1bHRzIHx8IG9ialtrZXldID09PSB2b2lkIDApIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgfTtcblxuICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cbiAgXy5leHRlbmQgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMpO1xuXG4gIC8vIEFzc2lnbnMgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIG93biBwcm9wZXJ0aWVzIGluIHRoZSBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbilcbiAgXy5leHRlbmRPd24gPSBfLmFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKF8ua2V5cyk7XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3Qga2V5IG9uIGFuIG9iamVjdCB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0LlxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfTtcblxuICAvLyBJbnRlcm5hbCBwaWNrIGhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgaWYgYG9iamAgaGFzIGtleSBga2V5YC5cbiAgdmFyIGtleUluT2JqID0gZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqKSB7XG4gICAgcmV0dXJuIGtleSBpbiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5waWNrID0gcmVzdEFyZ3VtZW50cyhmdW5jdGlvbihvYmosIGtleXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sIGl0ZXJhdGVlID0ga2V5c1swXTtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA+IDEpIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwga2V5c1sxXSk7XG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0ga2V5SW5PYmo7XG4gICAgICBrZXlzID0gZmxhdHRlbihrZXlzLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgb2JqID0gT2JqZWN0KG9iaik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgaWYgKGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iaikpIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCB3aXRob3V0IHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLm9taXQgPSByZXN0QXJndW1lbnRzKGZ1bmN0aW9uKG9iaiwga2V5cykge1xuICAgIHZhciBpdGVyYXRlZSA9IGtleXNbMF0sIGNvbnRleHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHtcbiAgICAgIGl0ZXJhdGVlID0gXy5uZWdhdGUoaXRlcmF0ZWUpO1xuICAgICAgaWYgKGtleXMubGVuZ3RoID4gMSkgY29udGV4dCA9IGtleXNbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMgPSBfLm1hcChmbGF0dGVuKGtleXMsIGZhbHNlLCBmYWxzZSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9KTtcblxuICAvLyBGaWxsIGluIGEgZ2l2ZW4gb2JqZWN0IHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICBfLmRlZmF1bHRzID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzLCB0cnVlKTtcblxuICAvLyBDcmVhdGVzIGFuIG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhlIGdpdmVuIHByb3RvdHlwZSBvYmplY3QuXG4gIC8vIElmIGFkZGl0aW9uYWwgcHJvcGVydGllcyBhcmUgcHJvdmlkZWQgdGhlbiB0aGV5IHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4gIC8vIGNyZWF0ZWQgb2JqZWN0LlxuICBfLmNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSwgcHJvcHMpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIGlmIChwcm9wcykgXy5leHRlbmRPd24ocmVzdWx0LCBwcm9wcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSAoc2hhbGxvdy1jbG9uZWQpIGR1cGxpY2F0ZSBvZiBhbiBvYmplY3QuXG4gIF8uY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopO1xuICB9O1xuXG4gIC8vIEludm9rZXMgaW50ZXJjZXB0b3Igd2l0aCB0aGUgb2JqLCBhbmQgdGhlbiByZXR1cm5zIG9iai5cbiAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sIGluXG4gIC8vIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuICBfLnRhcCA9IGZ1bmN0aW9uKG9iaiwgaW50ZXJjZXB0b3IpIHtcbiAgICBpbnRlcmNlcHRvcihvYmopO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2YgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uaXNNYXRjaCA9IGZ1bmN0aW9uKG9iamVjdCwgYXR0cnMpIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhhdHRycyksIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkgcmV0dXJuICFsZW5ndGg7XG4gICAgdmFyIG9iaiA9IE9iamVjdChvYmplY3QpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG9ialtrZXldIHx8ICEoa2V5IGluIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICB2YXIgZXEsIGRlZXBFcTtcbiAgZXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICAgIC8vIGBudWxsYCBvciBgdW5kZWZpbmVkYCBvbmx5IGVxdWFsIHRvIGl0c2VsZiAoc3RyaWN0IGNvbXBhcmlzb24pLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICBpZiAoYSAhPT0gYSkgcmV0dXJuIGIgIT09IGI7XG4gICAgLy8gRXhoYXVzdCBwcmltaXRpdmUgY2hlY2tzXG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgYTtcbiAgICBpZiAodHlwZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlICE9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBkZWVwRXEoYSwgYiwgYVN0YWNrLCBiU3RhY2spO1xuICB9O1xuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIGRlZXBFcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG4gICAgaWYgKGEgaW5zdGFuY2VvZiBfKSBhID0gYS5fd3JhcHBlZDtcbiAgICBpZiAoYiBpbnN0YW5jZW9mIF8pIGIgPSBiLl93cmFwcGVkO1xuICAgIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG4gICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSk7XG4gICAgaWYgKGNsYXNzTmFtZSAhPT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCByZWd1bGFyIGV4cHJlc3Npb25zLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAvLyBSZWdFeHBzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgZm9yIGNvbXBhcmlzb24gKE5vdGU6ICcnICsgL2EvaSA9PT0gJy9hL2knKVxuICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxuICAgICAgICByZXR1cm4gJycgKyBhID09PSAnJyArIGI7XG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgICAgICAvLyBPYmplY3QoTmFOKSBpcyBlcXVpdmFsZW50IHRvIE5hTi5cbiAgICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjtcbiAgICAgICAgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJldHVybiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IFN5bWJvbF0nOlxuICAgICAgICByZXR1cm4gU3ltYm9sUHJvdG8udmFsdWVPZi5jYWxsKGEpID09PSBTeW1ib2xQcm90by52YWx1ZU9mLmNhbGwoYik7XG4gICAgfVxuXG4gICAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICBpZiAoIWFyZUFycmF5cykge1xuICAgICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShfLmlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICYmICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cblxuICAgIC8vIEluaXRpYWxpemluZyBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAvLyBJdCdzIGRvbmUgaGVyZSBzaW5jZSB3ZSBvbmx5IG5lZWQgdGhlbSBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIGNvbXBhcmlzb24uXG4gICAgYVN0YWNrID0gYVN0YWNrIHx8IFtdO1xuICAgIGJTdGFjayA9IGJTdGFjayB8fCBbXTtcbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT09IGI7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wdXNoKGEpO1xuICAgIGJTdGFjay5wdXNoKGIpO1xuXG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGFyZUFycmF5cykge1xuICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmICghZXEoYVtsZW5ndGhdLCBiW2xlbmd0aF0sIGFTdGFjaywgYlN0YWNrKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKGEpLCBrZXk7XG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cbiAgICAgIGlmIChfLmtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgICAga2V5ID0ga2V5c1tsZW5ndGhdO1xuICAgICAgICBpZiAoIShoYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvciwgaXNNYXAsIGlzV2Vha01hcCwgaXNTZXQsIGlzV2Vha1NldC5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InLCAnU3ltYm9sJywgJ01hcCcsICdXZWFrTWFwJywgJ1NldCcsICdXZWFrU2V0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgJyArIG5hbWUgKyAnXSc7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRGVmaW5lIGEgZmFsbGJhY2sgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGluIGJyb3dzZXJzIChhaGVtLCBJRSA8IDkpLCB3aGVyZVxuICAvLyB0aGVyZSBpc24ndCBhbnkgaW5zcGVjdGFibGUgXCJBcmd1bWVudHNcIiB0eXBlLlxuICBpZiAoIV8uaXNBcmd1bWVudHMoYXJndW1lbnRzKSkge1xuICAgIF8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBoYXMob2JqLCAnY2FsbGVlJyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIGBpc0Z1bmN0aW9uYCBpZiBhcHByb3ByaWF0ZS4gV29yayBhcm91bmQgc29tZSB0eXBlb2YgYnVncyBpbiBvbGQgdjgsXG4gIC8vIElFIDExICgjMTYyMSksIFNhZmFyaSA4ICgjMTkyOSksIGFuZCBQaGFudG9tSlMgKCMyMjM2KS5cbiAgdmFyIG5vZGVsaXN0ID0gcm9vdC5kb2N1bWVudCAmJiByb290LmRvY3VtZW50LmNoaWxkTm9kZXM7XG4gIGlmICh0eXBlb2YgLy4vICE9ICdmdW5jdGlvbicgJiYgdHlwZW9mIEludDhBcnJheSAhPSAnb2JqZWN0JyAmJiB0eXBlb2Ygbm9kZWxpc3QgIT0gJ2Z1bmN0aW9uJykge1xuICAgIF8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT0gJ2Z1bmN0aW9uJyB8fCBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gSXMgYSBnaXZlbiBvYmplY3QgYSBmaW5pdGUgbnVtYmVyP1xuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICFfLmlzU3ltYm9sKG9iaikgJiYgaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/XG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIGlzTmFOKG9iaik7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGJvb2xlYW4/XG4gIF8uaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgZXF1YWwgdG8gbnVsbD9cbiAgXy5pc051bGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkP1xuICBfLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xuICB9O1xuXG4gIC8vIFNob3J0Y3V0IGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gcHJvcGVydHkgZGlyZWN0bHlcbiAgLy8gb24gaXRzZWxmIChpbiBvdGhlciB3b3Jkcywgbm90IG9uIGEgcHJvdG90eXBlKS5cbiAgXy5oYXMgPSBmdW5jdGlvbihvYmosIHBhdGgpIHtcbiAgICBpZiAoIV8uaXNBcnJheShwYXRoKSkge1xuICAgICAgcmV0dXJuIGhhcyhvYmosIHBhdGgpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IHBhdGhbaV07XG4gICAgICBpZiAob2JqID09IG51bGwgfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iaiA9IG9ialtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gISFsZW5ndGg7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRlZXMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvLyBQcmVkaWNhdGUtZ2VuZXJhdGluZyBmdW5jdGlvbnMuIE9mdGVuIHVzZWZ1bCBvdXRzaWRlIG9mIFVuZGVyc2NvcmUuXG4gIF8uY29uc3RhbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9O1xuXG4gIF8ubm9vcCA9IGZ1bmN0aW9uKCl7fTtcblxuICAvLyBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBwYXNzZWQgYW4gb2JqZWN0LCB3aWxsIHRyYXZlcnNlIHRoYXQgb2JqZWN04oCZc1xuICAvLyBwcm9wZXJ0aWVzIGRvd24gdGhlIGdpdmVuIGBwYXRoYCwgc3BlY2lmaWVkIGFzIGFuIGFycmF5IG9mIGtleXMgb3IgaW5kZXhlcy5cbiAgXy5wcm9wZXJ0eSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBpZiAoIV8uaXNBcnJheShwYXRoKSkge1xuICAgICAgcmV0dXJuIHNoYWxsb3dQcm9wZXJ0eShwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIGRlZXBHZXQob2JqLCBwYXRoKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKXt9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgcmV0dXJuICFfLmlzQXJyYXkocGF0aCkgPyBvYmpbcGF0aF0gOiBkZWVwR2V0KG9iaiwgcGF0aCk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cbiAgdmFyIGVzY2FwZU1hcCA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICdgJzogJyYjeDYwOydcbiAgfTtcbiAgdmFyIHVuZXNjYXBlTWFwID0gXy5pbnZlcnQoZXNjYXBlTWFwKTtcblxuICAvLyBGdW5jdGlvbnMgZm9yIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nIHN0cmluZ3MgdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG4gIHZhciBjcmVhdGVFc2NhcGVyID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGVzY2FwZXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hcFttYXRjaF07XG4gICAgfTtcbiAgICAvLyBSZWdleGVzIGZvciBpZGVudGlmeWluZyBhIGtleSB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWQuXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gVHJhdmVyc2VzIHRoZSBjaGlsZHJlbiBvZiBgb2JqYCBhbG9uZyBgcGF0aGAuIElmIGEgY2hpbGQgaXMgYSBmdW5jdGlvbiwgaXRcbiAgLy8gaXMgaW52b2tlZCB3aXRoIGl0cyBwYXJlbnQgYXMgY29udGV4dC4gUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZpbmFsXG4gIC8vIGNoaWxkLCBvciBgZmFsbGJhY2tgIGlmIGFueSBjaGlsZCBpcyB1bmRlZmluZWQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqLCBwYXRoLCBmYWxsYmFjaykge1xuICAgIGlmICghXy5pc0FycmF5KHBhdGgpKSBwYXRoID0gW3BhdGhdO1xuICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgcmV0dXJuIF8uaXNGdW5jdGlvbihmYWxsYmFjaykgPyBmYWxsYmFjay5jYWxsKG9iaikgOiBmYWxsYmFjaztcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHByb3AgPSBvYmogPT0gbnVsbCA/IHZvaWQgMCA6IG9ialtwYXRoW2ldXTtcbiAgICAgIGlmIChwcm9wID09PSB2b2lkIDApIHtcbiAgICAgICAgcHJvcCA9IGZhbGxiYWNrO1xuICAgICAgICBpID0gbGVuZ3RoOyAvLyBFbnN1cmUgd2UgZG9uJ3QgY29udGludWUgaXRlcmF0aW5nLlxuICAgICAgfVxuICAgICAgb2JqID0gXy5pc0Z1bmN0aW9uKHByb3ApID8gcHJvcC5jYWxsKG9iaikgOiBwcm9wO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGludGVnZXIgaWQgKHVuaXF1ZSB3aXRoaW4gdGhlIGVudGlyZSBjbGllbnQgc2Vzc2lvbikuXG4gIC8vIFVzZWZ1bCBmb3IgdGVtcG9yYXJ5IERPTSBpZHMuXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuICBfLnVuaXF1ZUlkID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgdmFyIGlkID0gKytpZENvdW50ZXIgKyAnJztcbiAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDtcbiAgfTtcblxuICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGVcbiAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAgZXZhbHVhdGU6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGU6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZTogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgJ1xccic6ICdyJyxcbiAgICAnXFxuJzogJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlUmVnRXhwID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XG4gIH07XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgLy8gTkI6IGBvbGRTZXR0aW5nc2Agb25seSBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgc2V0dGluZ3MsIG9sZFNldHRpbmdzKSB7XG4gICAgaWYgKCFzZXR0aW5ncyAmJiBvbGRTZXR0aW5ncykgc2V0dGluZ3MgPSBvbGRTZXR0aW5ncztcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXG4gICAgdmFyIG1hdGNoZXIgPSBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UoZXNjYXBlUmVnRXhwLCBlc2NhcGVDaGFyKTtcbiAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgaW50ZXJwb2xhdGUgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChldmFsdWF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xuICAgICAgfVxuXG4gICAgICAvLyBBZG9iZSBWTXMgbmVlZCB0aGUgbWF0Y2ggcmV0dXJuZWQgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBvZmZzZXQuXG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgIC8vIElmIGEgdmFyaWFibGUgaXMgbm90IHNwZWNpZmllZCwgcGxhY2UgZGF0YSB2YWx1ZXMgaW4gbG9jYWwgc2NvcGUuXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcblxuICAgIHNvdXJjZSA9IFwidmFyIF9fdCxfX3A9JycsX19qPUFycmF5LnByb3RvdHlwZS5qb2luLFwiICtcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXG4gICAgICBzb3VyY2UgKyAncmV0dXJuIF9fcDtcXG4nO1xuXG4gICAgdmFyIHJlbmRlcjtcbiAgICB0cnkge1xuICAgICAgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHZhciBhcmd1bWVudCA9IHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonO1xuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgYXJndW1lbnQgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9O1xuXG4gIC8vIEFkZCBhIFwiY2hhaW5cIiBmdW5jdGlvbi4gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGluc3RhbmNlID0gXyhvYmopO1xuICAgIGluc3RhbmNlLl9jaGFpbiA9IHRydWU7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciBjaGFpblJlc3VsdCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBvYmopIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX2NoYWluID8gXyhvYmopLmNoYWluKCkgOiBvYmo7XG4gIH07XG5cbiAgLy8gQWRkIHlvdXIgb3duIGN1c3RvbSBmdW5jdGlvbnMgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm1peGluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgXy5lYWNoKF8uZnVuY3Rpb25zKG9iaiksIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gX1tuYW1lXSA9IG9ialtuYW1lXTtcbiAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW3RoaXMuX3dyYXBwZWRdO1xuICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiBjaGFpblJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIF87XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiBjaGFpblJlc3VsdCh0aGlzLCBvYmopO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFkZCBhbGwgYWNjZXNzb3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjaGFpblJlc3VsdCh0aGlzLCBtZXRob2QuYXBwbHkodGhpcy5fd3JhcHBlZCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXG4gIF8ucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gUHJvdmlkZSB1bndyYXBwaW5nIHByb3h5IGZvciBzb21lIG1ldGhvZHMgdXNlZCBpbiBlbmdpbmUgb3BlcmF0aW9uc1xuICAvLyBzdWNoIGFzIGFyaXRobWV0aWMgYW5kIEpTT04gc3RyaW5naWZpY2F0aW9uLlxuICBfLnByb3RvdHlwZS52YWx1ZU9mID0gXy5wcm90b3R5cGUudG9KU09OID0gXy5wcm90b3R5cGUudmFsdWU7XG5cbiAgXy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gU3RyaW5nKHRoaXMuX3dyYXBwZWQpO1xuICB9O1xuXG4gIC8vIEFNRCByZWdpc3RyYXRpb24gaGFwcGVucyBhdCB0aGUgZW5kIGZvciBjb21wYXRpYmlsaXR5IHdpdGggQU1EIGxvYWRlcnNcbiAgLy8gdGhhdCBtYXkgbm90IGVuZm9yY2UgbmV4dC10dXJuIHNlbWFudGljcyBvbiBtb2R1bGVzLiBFdmVuIHRob3VnaCBnZW5lcmFsXG4gIC8vIHByYWN0aWNlIGZvciBBTUQgcmVnaXN0cmF0aW9uIGlzIHRvIGJlIGFub255bW91cywgdW5kZXJzY29yZSByZWdpc3RlcnNcbiAgLy8gYXMgYSBuYW1lZCBtb2R1bGUgYmVjYXVzZSwgbGlrZSBqUXVlcnksIGl0IGlzIGEgYmFzZSBsaWJyYXJ5IHRoYXQgaXNcbiAgLy8gcG9wdWxhciBlbm91Z2ggdG8gYmUgYnVuZGxlZCBpbiBhIHRoaXJkIHBhcnR5IGxpYiwgYnV0IG5vdCBiZSBwYXJ0IG9mXG4gIC8vIGFuIEFNRCBsb2FkIHJlcXVlc3QuIFRob3NlIGNhc2VzIGNvdWxkIGdlbmVyYXRlIGFuIGVycm9yIHdoZW4gYW5cbiAgLy8gYW5vbnltb3VzIGRlZmluZSgpIGlzIGNhbGxlZCBvdXRzaWRlIG9mIGEgbG9hZGVyIHJlcXVlc3QuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59KCkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8e08e542008e4aef1f58\n");

/***/ }),

/***/ "983488a87ba2f917c196":
/*!********************************************************************************!*\
  !*** ./src/vendor/Anakeen/SmartStructures/Dsearch/Render/searchUIEventView.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Created by Alex on 23/06/15.\n */\n\n/*\nResearch result in consult mode\n */\n\n/*global define, require, console*/\n\n{\n  window.dcp.document.documentController(\n    \"addEventListener\",\n    \"ready\",\n    {\n      name: \"addDsearchResultViewEvent\",\n      documentCheck: function(document) {\n        return document.type === \"search\";\n      }\n    },\n    function prepareResultViewEvents() {\n      $(this).documentController(\n        \"addEventListener\",\n        \"actionClick\",\n        {\n          name: \"previewConsult.viewEvent\",\n          documentCheck: function isDSearch(document) {\n            return document.type === \"search\" && document.renderMode === \"view\";\n          }\n        },\n        function eventButtonView(event, document, data) {\n          var $documentController = $(this);\n          if (data.eventId === \"previewConsult\") {\n            var continueDefault = $documentController.documentController(\n              \"triggerEvent\",\n              \"custom:content\",\n              {\n                familyName: $documentController.documentController(\n                  \"getProperties\"\n                ).family.name,\n                id: $documentController.documentController(\"getProperties\").id,\n                title: $documentController.documentController(\"getProperties\")\n                  .title\n              }\n            );\n            if (!continueDefault) {\n              event.preventDefault();\n            } else {\n              var $window = $(\"<div />\");\n              $(\"body\").append($window);\n              $window.kendoWindow({\n                title: $documentController.documentController(\"getProperties\")\n                  .title,\n                content: {\n                  template: `\n                    <ank-se-grid url-config=\"/api/v2/smartstructures/dsearch/gridConfig/<collection>\" \n                                 collection=\"${\n                                   $documentController.documentController(\n                                     \"getProperties\"\n                                   ).id\n                                 }\" \n                                 class=\"dsearch-result-grid\">\n                    </ank-se-grid>`\n                },\n                position: {\n                  top: 0,\n                  left: 0\n                },\n                open: function openWindow(event) {\n                  event.sender.wrapper.addClass(\"dsearch-result-window\");\n                },\n                pinned: false,\n                width: \"90%\",\n                height: \"90%\",\n                actions: [\"Minimize\", \"Maximize\", \"Close\"]\n              });\n              $window.kendoWindow(\"center\");\n            }\n          }\n        }\n      );\n    }\n  );\n\n  window.dcp.document.documentController(\n    \"addEventListener\",\n    \"close\",\n    {\n      name: \"removeDsearchResultViewEvent\",\n      documentCheck: function(document) {\n        return document.type === \"search\";\n      }\n    },\n    function() {\n      var $this = $(this);\n      var $child = $(\n        $(\"body\").children($(\"<div/>\"))[\n          $(\"body\").children($(\"<div/>\")).length - 1\n        ]\n      );\n      if ($child[0].className === \"k-widget k-window\") {\n        $child.remove();\n      }\n      $this.documentController(\"removeEventListener\", \".viewEvent\");\n    }\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTgzNDg4YTg3YmEyZjkxN2MxOTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9yL0FuYWtlZW4vU21hcnRTdHJ1Y3R1cmVzL0RzZWFyY2gvUmVuZGVyL3NlYXJjaFVJRXZlbnRWaWV3LmpzP2MzOTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDcmVhdGVkIGJ5IEFsZXggb24gMjMvMDYvMTUuXG4gKi9cblxuLypcblJlc2VhcmNoIHJlc3VsdCBpbiBjb25zdWx0IG1vZGVcbiAqL1xuXG4vKmdsb2JhbCBkZWZpbmUsIHJlcXVpcmUsIGNvbnNvbGUqL1xuXG57XG4gIHdpbmRvdy5kY3AuZG9jdW1lbnQuZG9jdW1lbnRDb250cm9sbGVyKFxuICAgIFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgIFwicmVhZHlcIixcbiAgICB7XG4gICAgICBuYW1lOiBcImFkZERzZWFyY2hSZXN1bHRWaWV3RXZlbnRcIixcbiAgICAgIGRvY3VtZW50Q2hlY2s6IGZ1bmN0aW9uKGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC50eXBlID09PSBcInNlYXJjaFwiO1xuICAgICAgfVxuICAgIH0sXG4gICAgZnVuY3Rpb24gcHJlcGFyZVJlc3VsdFZpZXdFdmVudHMoKSB7XG4gICAgICAkKHRoaXMpLmRvY3VtZW50Q29udHJvbGxlcihcbiAgICAgICAgXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgICAgIFwiYWN0aW9uQ2xpY2tcIixcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwicHJldmlld0NvbnN1bHQudmlld0V2ZW50XCIsXG4gICAgICAgICAgZG9jdW1lbnRDaGVjazogZnVuY3Rpb24gaXNEU2VhcmNoKGRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQudHlwZSA9PT0gXCJzZWFyY2hcIiAmJiBkb2N1bWVudC5yZW5kZXJNb2RlID09PSBcInZpZXdcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50QnV0dG9uVmlldyhldmVudCwgZG9jdW1lbnQsIGRhdGEpIHtcbiAgICAgICAgICB2YXIgJGRvY3VtZW50Q29udHJvbGxlciA9ICQodGhpcyk7XG4gICAgICAgICAgaWYgKGRhdGEuZXZlbnRJZCA9PT0gXCJwcmV2aWV3Q29uc3VsdFwiKSB7XG4gICAgICAgICAgICB2YXIgY29udGludWVEZWZhdWx0ID0gJGRvY3VtZW50Q29udHJvbGxlci5kb2N1bWVudENvbnRyb2xsZXIoXG4gICAgICAgICAgICAgIFwidHJpZ2dlckV2ZW50XCIsXG4gICAgICAgICAgICAgIFwiY3VzdG9tOmNvbnRlbnRcIixcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZhbWlseU5hbWU6ICRkb2N1bWVudENvbnRyb2xsZXIuZG9jdW1lbnRDb250cm9sbGVyKFxuICAgICAgICAgICAgICAgICAgXCJnZXRQcm9wZXJ0aWVzXCJcbiAgICAgICAgICAgICAgICApLmZhbWlseS5uYW1lLFxuICAgICAgICAgICAgICAgIGlkOiAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcImdldFByb3BlcnRpZXNcIikuaWQsXG4gICAgICAgICAgICAgICAgdGl0bGU6ICRkb2N1bWVudENvbnRyb2xsZXIuZG9jdW1lbnRDb250cm9sbGVyKFwiZ2V0UHJvcGVydGllc1wiKVxuICAgICAgICAgICAgICAgICAgLnRpdGxlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIWNvbnRpbnVlRGVmYXVsdCkge1xuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyICR3aW5kb3cgPSAkKFwiPGRpdiAvPlwiKTtcbiAgICAgICAgICAgICAgJChcImJvZHlcIikuYXBwZW5kKCR3aW5kb3cpO1xuICAgICAgICAgICAgICAkd2luZG93LmtlbmRvV2luZG93KHtcbiAgICAgICAgICAgICAgICB0aXRsZTogJGRvY3VtZW50Q29udHJvbGxlci5kb2N1bWVudENvbnRyb2xsZXIoXCJnZXRQcm9wZXJ0aWVzXCIpXG4gICAgICAgICAgICAgICAgICAudGl0bGUsXG4gICAgICAgICAgICAgICAgY29udGVudDoge1xuICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgICAgICAgICAgICAgPGFuay1zZS1ncmlkIHVybC1jb25maWc9XCIvYXBpL3YyL3NtYXJ0c3RydWN0dXJlcy9kc2VhcmNoL2dyaWRDb25maWcvPGNvbGxlY3Rpb24+XCIgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uPVwiJHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGRvY3VtZW50Q29udHJvbGxlci5kb2N1bWVudENvbnRyb2xsZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZXRQcm9wZXJ0aWVzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKS5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVwiIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJkc2VhcmNoLXJlc3VsdC1ncmlkXCI+XG4gICAgICAgICAgICAgICAgICAgIDwvYW5rLXNlLWdyaWQ+YFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uIG9wZW5XaW5kb3coZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgIGV2ZW50LnNlbmRlci53cmFwcGVyLmFkZENsYXNzKFwiZHNlYXJjaC1yZXN1bHQtd2luZG93XCIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGlubmVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3aWR0aDogXCI5MCVcIixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiOTAlXCIsXG4gICAgICAgICAgICAgICAgYWN0aW9uczogW1wiTWluaW1pemVcIiwgXCJNYXhpbWl6ZVwiLCBcIkNsb3NlXCJdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAkd2luZG93LmtlbmRvV2luZG93KFwiY2VudGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICk7XG5cbiAgd2luZG93LmRjcC5kb2N1bWVudC5kb2N1bWVudENvbnRyb2xsZXIoXG4gICAgXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgXCJjbG9zZVwiLFxuICAgIHtcbiAgICAgIG5hbWU6IFwicmVtb3ZlRHNlYXJjaFJlc3VsdFZpZXdFdmVudFwiLFxuICAgICAgZG9jdW1lbnRDaGVjazogZnVuY3Rpb24oZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnR5cGUgPT09IFwic2VhcmNoXCI7XG4gICAgICB9XG4gICAgfSxcbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICB2YXIgJGNoaWxkID0gJChcbiAgICAgICAgJChcImJvZHlcIikuY2hpbGRyZW4oJChcIjxkaXYvPlwiKSlbXG4gICAgICAgICAgJChcImJvZHlcIikuY2hpbGRyZW4oJChcIjxkaXYvPlwiKSkubGVuZ3RoIC0gMVxuICAgICAgICBdXG4gICAgICApO1xuICAgICAgaWYgKCRjaGlsZFswXS5jbGFzc05hbWUgPT09IFwiay13aWRnZXQgay13aW5kb3dcIikge1xuICAgICAgICAkY2hpbGQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICAkdGhpcy5kb2N1bWVudENvbnRyb2xsZXIoXCJyZW1vdmVFdmVudExpc3RlbmVyXCIsIFwiLnZpZXdFdmVudFwiKTtcbiAgICB9XG4gICk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///983488a87ba2f917c196\n");

/***/ }),

/***/ "ab6bdeb063d9c611c7bb":
/*!************************************************************************************!*\
  !*** ./src/vendor/Anakeen/SmartStructures/Dsearch/Render/searchUICreationEvent.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Created by Alex on 06/07/15.\n */\n\n/*\nAsk for a document title in creation mode\n */\n\n{\n  window.dcp.document.documentController(\n    \"addEventListener\",\n    \"ready\",\n    {\n      name: \"addDsearchCreationEvent\",\n      documentCheck: function(document) {\n        return document.type === \"search\";\n      }\n    },\n    function prepareResultViewEvents() {\n      /*\n            add a pop-up window to define a name to the new document\n             */\n      $(this).documentController(\n        \"addEventListener\",\n        \"actionClick\",\n        {\n          name: \"confirmCreation.createEvent\",\n          documentCheck: function isDSearch(document) {\n            return (\n              document.type === \"search\" && document.viewId === \"!coreCreation\"\n            );\n          }\n        },\n        function eventButtonView(event, document, data) {\n          if (data.eventId === \"confirmCreation\") {\n            var $window = $('<div class=\"windowConfirm\"/>');\n            $(\"body\").append($window);\n            $window.kendoWindow({\n              width: \"300px\",\n              height: \"85px\",\n              position: {\n                top: \"20%\",\n                left: \"30%\"\n              },\n              resizable: false,\n              modal: true,\n              title: i18n.___(\"type a title\", \"SEvents\"),\n              close: function() {\n                $(\".closeBtn\").remove();\n              }\n            });\n            var windowContent = $(\n              \".dcpCustomTemplate--content[data-attrid='ba_title']\"\n            );\n            windowContent.show();\n            var nameTitle = $(\".dcpAttribute__left[data-attrid='ba_title']\");\n            nameTitle.hide();\n            var nameInput = $(\".dcpAttribute__right[data-attrid='ba_title']\");\n            nameInput.find(\"input\").css(\"height\", \"32px\");\n            nameInput.css(\"width\", \"98%\");\n\n            var button = $('<button class=\"closeBtn\">Ok</button>');\n            button.css(\"margin-left\", \"88%\");\n            button.css(\"margin-top\", \"2%\");\n            var dialog = $($window).data(\"kendoWindow\");\n            dialog.content(windowContent.append(button));\n\n            button.click(function clickOnCreateButton() {\n              window.dcp.document.documentController(\"saveDocument\");\n              dialog.close();\n            });\n          }\n        }\n      );\n\n      $(this).documentController(\n        \"addEventListener\",\n        \"actionClick\",\n        {\n          name: \"confirmCreation&Close.createEvent\",\n          documentCheck: function isDSearch(document) {\n            return (\n              document.type === \"search\" && document.viewId === \"!coreCreation\"\n            );\n          }\n        },\n        function eventButtonView(event, document, data) {\n          if (data.eventId === \"confirmCreationClose\") {\n            var $window = $('<div class=\"windowConfirm\"/>');\n            $(\"body\").append($window);\n            $window.kendoWindow({\n              width: \"300px\",\n              height: \"85px\",\n              position: {\n                top: \"20%\",\n                left: \"30%\"\n              },\n              resizable: false,\n              modal: true,\n              title: i18n.___(\"type a title\", \"SEvents\"),\n              close: function() {\n                $(\".closeBtn\").remove();\n              }\n            });\n            var windowContent = $(\n              \".dcpCustomTemplate--content[data-attrid='ba_title']\"\n            );\n            windowContent.show();\n            var nameTitle = $(\".dcpAttribute__left[data-attrid='ba_title']\");\n            nameTitle.hide();\n            var nameInput = $(\".dcpAttribute__right[data-attrid='ba_title']\");\n            nameInput.find(\"input\").css(\"height\", \"32px\");\n            nameInput.css(\"width\", \"98%\");\n\n            var button = $('<button class=\"closeBtn\">Ok</button>');\n            button.css(\"margin-left\", \"88%\");\n            button.css(\"margin-top\", \"2%\");\n            var dialog = $($window).data(\"kendoWindow\");\n            dialog.content(windowContent.append(button));\n\n            button.click(function clickOnCreateButton() {\n              window.dcp.document.documentController(\"saveDocument\");\n              dialog.close();\n              window.dcp.document.documentController(\n                \"addEventListener\",\n                \"afterSave\",\n                {\n                  name: \"switchToViewAfterSave.createEvent\"\n                },\n                function reloadInConsultation(event, document) {\n                  window.dcp.document.documentController(\"fetchDocument\", {\n                    initid: document.id,\n                    revision: -1,\n                    viewId: \"!defaultConsultation\"\n                  });\n                }\n              );\n            });\n          }\n        }\n      );\n    }\n  );\n\n  window.dcp.document.documentController(\n    \"addEventListener\",\n    \"close\",\n    {\n      name: \"removeDsearchCreateEvent\",\n      documentCheck: function(document) {\n        return document.type === \"search\";\n      }\n    },\n    function() {\n      var $this = $(this);\n      $this.documentController(\"removeEventListener\", \".createEvent\");\n    }\n  );\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWI2YmRlYjA2M2Q5YzYxMWM3YmIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9yL0FuYWtlZW4vU21hcnRTdHJ1Y3R1cmVzL0RzZWFyY2gvUmVuZGVyL3NlYXJjaFVJQ3JlYXRpb25FdmVudC5qcz9kNTYxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ3JlYXRlZCBieSBBbGV4IG9uIDA2LzA3LzE1LlxuICovXG5cbi8qXG5Bc2sgZm9yIGEgZG9jdW1lbnQgdGl0bGUgaW4gY3JlYXRpb24gbW9kZVxuICovXG5cbntcbiAgd2luZG93LmRjcC5kb2N1bWVudC5kb2N1bWVudENvbnRyb2xsZXIoXG4gICAgXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgXCJyZWFkeVwiLFxuICAgIHtcbiAgICAgIG5hbWU6IFwiYWRkRHNlYXJjaENyZWF0aW9uRXZlbnRcIixcbiAgICAgIGRvY3VtZW50Q2hlY2s6IGZ1bmN0aW9uKGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC50eXBlID09PSBcInNlYXJjaFwiO1xuICAgICAgfVxuICAgIH0sXG4gICAgZnVuY3Rpb24gcHJlcGFyZVJlc3VsdFZpZXdFdmVudHMoKSB7XG4gICAgICAvKlxuICAgICAgICAgICAgYWRkIGEgcG9wLXVwIHdpbmRvdyB0byBkZWZpbmUgYSBuYW1lIHRvIHRoZSBuZXcgZG9jdW1lbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgJCh0aGlzKS5kb2N1bWVudENvbnRyb2xsZXIoXG4gICAgICAgIFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgICBcImFjdGlvbkNsaWNrXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImNvbmZpcm1DcmVhdGlvbi5jcmVhdGVFdmVudFwiLFxuICAgICAgICAgIGRvY3VtZW50Q2hlY2s6IGZ1bmN0aW9uIGlzRFNlYXJjaChkb2N1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgZG9jdW1lbnQudHlwZSA9PT0gXCJzZWFyY2hcIiAmJiBkb2N1bWVudC52aWV3SWQgPT09IFwiIWNvcmVDcmVhdGlvblwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24gZXZlbnRCdXR0b25WaWV3KGV2ZW50LCBkb2N1bWVudCwgZGF0YSkge1xuICAgICAgICAgIGlmIChkYXRhLmV2ZW50SWQgPT09IFwiY29uZmlybUNyZWF0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciAkd2luZG93ID0gJCgnPGRpdiBjbGFzcz1cIndpbmRvd0NvbmZpcm1cIi8+Jyk7XG4gICAgICAgICAgICAkKFwiYm9keVwiKS5hcHBlbmQoJHdpbmRvdyk7XG4gICAgICAgICAgICAkd2luZG93LmtlbmRvV2luZG93KHtcbiAgICAgICAgICAgICAgd2lkdGg6IFwiMzAwcHhcIixcbiAgICAgICAgICAgICAgaGVpZ2h0OiBcIjg1cHhcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB0b3A6IFwiMjAlXCIsXG4gICAgICAgICAgICAgICAgbGVmdDogXCIzMCVcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICByZXNpemFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICBtb2RhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgdGl0bGU6IGkxOG4uX19fKFwidHlwZSBhIHRpdGxlXCIsIFwiU0V2ZW50c1wiKSxcbiAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICQoXCIuY2xvc2VCdG5cIikucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHdpbmRvd0NvbnRlbnQgPSAkKFxuICAgICAgICAgICAgICBcIi5kY3BDdXN0b21UZW1wbGF0ZS0tY29udGVudFtkYXRhLWF0dHJpZD0nYmFfdGl0bGUnXVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgd2luZG93Q29udGVudC5zaG93KCk7XG4gICAgICAgICAgICB2YXIgbmFtZVRpdGxlID0gJChcIi5kY3BBdHRyaWJ1dGVfX2xlZnRbZGF0YS1hdHRyaWQ9J2JhX3RpdGxlJ11cIik7XG4gICAgICAgICAgICBuYW1lVGl0bGUuaGlkZSgpO1xuICAgICAgICAgICAgdmFyIG5hbWVJbnB1dCA9ICQoXCIuZGNwQXR0cmlidXRlX19yaWdodFtkYXRhLWF0dHJpZD0nYmFfdGl0bGUnXVwiKTtcbiAgICAgICAgICAgIG5hbWVJbnB1dC5maW5kKFwiaW5wdXRcIikuY3NzKFwiaGVpZ2h0XCIsIFwiMzJweFwiKTtcbiAgICAgICAgICAgIG5hbWVJbnB1dC5jc3MoXCJ3aWR0aFwiLCBcIjk4JVwiKTtcblxuICAgICAgICAgICAgdmFyIGJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJjbG9zZUJ0blwiPk9rPC9idXR0b24+Jyk7XG4gICAgICAgICAgICBidXR0b24uY3NzKFwibWFyZ2luLWxlZnRcIiwgXCI4OCVcIik7XG4gICAgICAgICAgICBidXR0b24uY3NzKFwibWFyZ2luLXRvcFwiLCBcIjIlXCIpO1xuICAgICAgICAgICAgdmFyIGRpYWxvZyA9ICQoJHdpbmRvdykuZGF0YShcImtlbmRvV2luZG93XCIpO1xuICAgICAgICAgICAgZGlhbG9nLmNvbnRlbnQod2luZG93Q29udGVudC5hcHBlbmQoYnV0dG9uKSk7XG5cbiAgICAgICAgICAgIGJ1dHRvbi5jbGljayhmdW5jdGlvbiBjbGlja09uQ3JlYXRlQnV0dG9uKCkge1xuICAgICAgICAgICAgICB3aW5kb3cuZGNwLmRvY3VtZW50LmRvY3VtZW50Q29udHJvbGxlcihcInNhdmVEb2N1bWVudFwiKTtcbiAgICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgICQodGhpcykuZG9jdW1lbnRDb250cm9sbGVyKFxuICAgICAgICBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICAgICAgXCJhY3Rpb25DbGlja1wiLFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJjb25maXJtQ3JlYXRpb24mQ2xvc2UuY3JlYXRlRXZlbnRcIixcbiAgICAgICAgICBkb2N1bWVudENoZWNrOiBmdW5jdGlvbiBpc0RTZWFyY2goZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGRvY3VtZW50LnR5cGUgPT09IFwic2VhcmNoXCIgJiYgZG9jdW1lbnQudmlld0lkID09PSBcIiFjb3JlQ3JlYXRpb25cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIGV2ZW50QnV0dG9uVmlldyhldmVudCwgZG9jdW1lbnQsIGRhdGEpIHtcbiAgICAgICAgICBpZiAoZGF0YS5ldmVudElkID09PSBcImNvbmZpcm1DcmVhdGlvbkNsb3NlXCIpIHtcbiAgICAgICAgICAgIHZhciAkd2luZG93ID0gJCgnPGRpdiBjbGFzcz1cIndpbmRvd0NvbmZpcm1cIi8+Jyk7XG4gICAgICAgICAgICAkKFwiYm9keVwiKS5hcHBlbmQoJHdpbmRvdyk7XG4gICAgICAgICAgICAkd2luZG93LmtlbmRvV2luZG93KHtcbiAgICAgICAgICAgICAgd2lkdGg6IFwiMzAwcHhcIixcbiAgICAgICAgICAgICAgaGVpZ2h0OiBcIjg1cHhcIixcbiAgICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgICB0b3A6IFwiMjAlXCIsXG4gICAgICAgICAgICAgICAgbGVmdDogXCIzMCVcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICByZXNpemFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICBtb2RhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgdGl0bGU6IGkxOG4uX19fKFwidHlwZSBhIHRpdGxlXCIsIFwiU0V2ZW50c1wiKSxcbiAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICQoXCIuY2xvc2VCdG5cIikucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHdpbmRvd0NvbnRlbnQgPSAkKFxuICAgICAgICAgICAgICBcIi5kY3BDdXN0b21UZW1wbGF0ZS0tY29udGVudFtkYXRhLWF0dHJpZD0nYmFfdGl0bGUnXVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgd2luZG93Q29udGVudC5zaG93KCk7XG4gICAgICAgICAgICB2YXIgbmFtZVRpdGxlID0gJChcIi5kY3BBdHRyaWJ1dGVfX2xlZnRbZGF0YS1hdHRyaWQ9J2JhX3RpdGxlJ11cIik7XG4gICAgICAgICAgICBuYW1lVGl0bGUuaGlkZSgpO1xuICAgICAgICAgICAgdmFyIG5hbWVJbnB1dCA9ICQoXCIuZGNwQXR0cmlidXRlX19yaWdodFtkYXRhLWF0dHJpZD0nYmFfdGl0bGUnXVwiKTtcbiAgICAgICAgICAgIG5hbWVJbnB1dC5maW5kKFwiaW5wdXRcIikuY3NzKFwiaGVpZ2h0XCIsIFwiMzJweFwiKTtcbiAgICAgICAgICAgIG5hbWVJbnB1dC5jc3MoXCJ3aWR0aFwiLCBcIjk4JVwiKTtcblxuICAgICAgICAgICAgdmFyIGJ1dHRvbiA9ICQoJzxidXR0b24gY2xhc3M9XCJjbG9zZUJ0blwiPk9rPC9idXR0b24+Jyk7XG4gICAgICAgICAgICBidXR0b24uY3NzKFwibWFyZ2luLWxlZnRcIiwgXCI4OCVcIik7XG4gICAgICAgICAgICBidXR0b24uY3NzKFwibWFyZ2luLXRvcFwiLCBcIjIlXCIpO1xuICAgICAgICAgICAgdmFyIGRpYWxvZyA9ICQoJHdpbmRvdykuZGF0YShcImtlbmRvV2luZG93XCIpO1xuICAgICAgICAgICAgZGlhbG9nLmNvbnRlbnQod2luZG93Q29udGVudC5hcHBlbmQoYnV0dG9uKSk7XG5cbiAgICAgICAgICAgIGJ1dHRvbi5jbGljayhmdW5jdGlvbiBjbGlja09uQ3JlYXRlQnV0dG9uKCkge1xuICAgICAgICAgICAgICB3aW5kb3cuZGNwLmRvY3VtZW50LmRvY3VtZW50Q29udHJvbGxlcihcInNhdmVEb2N1bWVudFwiKTtcbiAgICAgICAgICAgICAgZGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICAgIHdpbmRvdy5kY3AuZG9jdW1lbnQuZG9jdW1lbnRDb250cm9sbGVyKFxuICAgICAgICAgICAgICAgIFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgICAgICAgICAgIFwiYWZ0ZXJTYXZlXCIsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJzd2l0Y2hUb1ZpZXdBZnRlclNhdmUuY3JlYXRlRXZlbnRcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVsb2FkSW5Db25zdWx0YXRpb24oZXZlbnQsIGRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICB3aW5kb3cuZGNwLmRvY3VtZW50LmRvY3VtZW50Q29udHJvbGxlcihcImZldGNoRG9jdW1lbnRcIiwge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWQ6IGRvY3VtZW50LmlkLFxuICAgICAgICAgICAgICAgICAgICByZXZpc2lvbjogLTEsXG4gICAgICAgICAgICAgICAgICAgIHZpZXdJZDogXCIhZGVmYXVsdENvbnN1bHRhdGlvblwiXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICApO1xuXG4gIHdpbmRvdy5kY3AuZG9jdW1lbnQuZG9jdW1lbnRDb250cm9sbGVyKFxuICAgIFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgIFwiY2xvc2VcIixcbiAgICB7XG4gICAgICBuYW1lOiBcInJlbW92ZURzZWFyY2hDcmVhdGVFdmVudFwiLFxuICAgICAgZG9jdW1lbnRDaGVjazogZnVuY3Rpb24oZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnR5cGUgPT09IFwic2VhcmNoXCI7XG4gICAgICB9XG4gICAgfSxcbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAkdGhpcy5kb2N1bWVudENvbnRyb2xsZXIoXCJyZW1vdmVFdmVudExpc3RlbmVyXCIsIFwiLmNyZWF0ZUV2ZW50XCIpO1xuICAgIH1cbiAgKTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///ab6bdeb063d9c611c7bb\n");

/***/ }),

/***/ "c138e55a31f3f8960e99":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYzEzOGU1NWEzMWYzZjg5NjBlOTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/MjM1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///c138e55a31f3f8960e99\n");

/***/ }),

/***/ "c3c916b9a83e10a2f671":
/*!*****************************************************************************!*\
  !*** ./src/vendor/Anakeen/SmartStructures/Dsearch/Render/searchUISEGrid.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ((searchId, $target) => {\n  var $r = $.Deferred();\n  $target.find(\".search-grid\").remove();\n  $target.removeClass(\"result--on\");\n  var $table = $(\n    `<ank-se-grid url-config=\"/api/v2/smartstructures/dsearch/gridConfig/<collection>\" server-paging=\"true\" server-sorting=\"true\" server-filtering=\"true\" collection=\"${searchId}\" class=\"search-grid\">\n      </ank-se-grid>`\n  );\n  $target.append($table);\n  $target.removeClass(\"result--waiting\").addClass(\"result--on\");\n  $r.resolve();\n  return $r;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYzNjOTE2YjlhODNlMTBhMmY2NzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9yL0FuYWtlZW4vU21hcnRTdHJ1Y3R1cmVzL0RzZWFyY2gvUmVuZGVyL3NlYXJjaFVJU0VHcmlkLmpzP2Q1YjMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgKHNlYXJjaElkLCAkdGFyZ2V0KSA9PiB7XG4gIHZhciAkciA9ICQuRGVmZXJyZWQoKTtcbiAgJHRhcmdldC5maW5kKFwiLnNlYXJjaC1ncmlkXCIpLnJlbW92ZSgpO1xuICAkdGFyZ2V0LnJlbW92ZUNsYXNzKFwicmVzdWx0LS1vblwiKTtcbiAgdmFyICR0YWJsZSA9ICQoXG4gICAgYDxhbmstc2UtZ3JpZCB1cmwtY29uZmlnPVwiL2FwaS92Mi9zbWFydHN0cnVjdHVyZXMvZHNlYXJjaC9ncmlkQ29uZmlnLzxjb2xsZWN0aW9uPlwiIHNlcnZlci1wYWdpbmc9XCJ0cnVlXCIgc2VydmVyLXNvcnRpbmc9XCJ0cnVlXCIgc2VydmVyLWZpbHRlcmluZz1cInRydWVcIiBjb2xsZWN0aW9uPVwiJHtzZWFyY2hJZH1cIiBjbGFzcz1cInNlYXJjaC1ncmlkXCI+XG4gICAgICA8L2Fuay1zZS1ncmlkPmBcbiAgKTtcbiAgJHRhcmdldC5hcHBlbmQoJHRhYmxlKTtcbiAgJHRhcmdldC5yZW1vdmVDbGFzcyhcInJlc3VsdC0td2FpdGluZ1wiKS5hZGRDbGFzcyhcInJlc3VsdC0tb25cIik7XG4gICRyLnJlc29sdmUoKTtcbiAgcmV0dXJuICRyO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///c3c916b9a83e10a2f671\n");

/***/ }),

/***/ "ceecf6b70dccf1a612bd":
/*!***********************************************************************!*\
  !*** ./src/vendor/Anakeen/SmartStructures/Dsearch/Render/searchUI.js ***!
  \***********************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _searchCatalog__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./searchCatalog */ \"6da807eb38805b380fc6\");\n/* harmony import */ var _searchAttributes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./searchAttributes */ \"3c1ed794a91929edd3f3\");\n/**\n * Created by Alex on 27/05/15.\n */\n/*global define, require, console*/\n\nconst _ = __webpack_require__(/*! underscore */ \"8e08e542008e4aef1f58\");\n\n\n\n{\n  var myOperators = [];\n  var thisOperators = [];\n  var myAttributes = [];\n  var myWorkflows = [];\n  var $attrid;\n  var $wf = null;\n  var $beforeMeth = [];\n  var $checkMeth = false;\n\n  window.dcp.document.documentController(\n    \"addEventListener\",\n    \"ready\",\n    {\n      name: \"addDsearchEvents\",\n      documentCheck: function(document) {\n        return document.renderMode === \"edit\" && document.type === \"search\";\n      }\n    },\n    function prepareEvents() {\n      $(this).documentController(\n        \"addEventListener\",\n        \"ready\",\n        {\n          name: \"initDivResult.dsearch\",\n          documentCheck: function isDSearch(document) {\n            return document.type === \"search\";\n          }\n        },\n        function initDivResultEdit(event, document) {\n          if (\n            document.renderMode === \"edit\" ||\n            document.renderMode === \"create\"\n          ) {\n            var $result = $(\".result--content\");\n            if ($result.length === 0) {\n              var $div = $('<div class=\"result--content\"/>');\n              $div.insertAfter($(\".document\"));\n            }\n          } else {\n            $(\".result--content\").remove();\n          }\n        }\n      );\n\n      $(this).documentController(\n        \"addEventListener\",\n        \"ready\",\n        {\n          name: \"searchReady.dsearch\",\n          documentCheck: function isDSearch(document) {\n            return document.type === \"search\" && document.renderMode === \"edit\";\n          }\n        },\n        /**\n         * Initialize attributes, operators, and workflow states lists\n         * Initialize kendo widgets at keys and operators fields\n         * Set visibilities according to initial values\n         */\n        function prepareSearchDocUI(event, document) {\n          var $documentController = $(this);\n          var famid = $(this).documentController(\"getValues\").se_famid.value;\n          var testWorkflow = false;\n\n          if ($(\".dcpArray__content[data-attrid=se_t_detail]\").length === 0) {\n            return;\n          }\n\n          /*\n                 Hide title field if in creation mode\n                 */\n          if (document.viewId === \"!coreCreation\") {\n            $(\".dcpCustomTemplate--content[data-attrid='ba_title']\").hide();\n          } else {\n            $(\".dcpCustomTemplate--content[data-attrid='ba_title']\").show();\n          }\n\n          $documentController.documentController(\n            \"addEventListener\",\n            \"beforeClose\",\n            {\n              name: \"preventClose.dsearch\",\n              documentCheck: function isDsearch(document) {\n                return document.type === \"search\";\n              }\n            },\n            function preventCloseDsearch() {\n              $(\"#grid\").remove();\n            }\n          );\n\n          if (famid === null) {\n            famid = \"\";\n          }\n\n          Object(_searchAttributes__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(famid)\n            .then(function requestAttributesSReady(data) {\n              myAttributes = [];\n              $.each(data.data, function eachDataAttributesSReady(key, value) {\n                myAttributes.push(value);\n              });\n              /**\n               * update the workflow attribute generic value\n               */\n              if (myAttributes[myAttributes.length - 1].type === \"wid\") {\n                $wf = myAttributes[myAttributes.length - 1];\n              } else {\n                $wf = null;\n              }\n              testWorkflow = findIfWorkflow(myAttributes, $documentController);\n            })\n            .then(function doneFirstSReady() {\n              $.getJSON(\n                \"api/v2/smartstructures/dsearch/operators/\",\n                function requestOperatorsSReady(data) {\n                  myOperators = [];\n                  $.each(data.data, function eachDataOperatorsSReady(\n                    key,\n                    value\n                  ) {\n                    myOperators.push(value);\n                  });\n                }\n              ).done(function doneSecondSReady() {\n                var $r = $.Deferred();\n                if (testWorkflow) {\n                  $.getJSON(\n                    \"api/v2/documents/\" +\n                      famid +\n                      \"/workflows/states/?allStates=1\",\n                    function requestWorkflows(data) {\n                      myWorkflows = [];\n                      $.each(data.data.states, function eachStatesSReady(\n                        key,\n                        value\n                      ) {\n                        myWorkflows.push(value);\n                      });\n                      $r.resolve();\n                    }\n                  );\n                } else {\n                  $r.resolve();\n                }\n\n                $r.done(function() {\n                  $.each(\n                    $documentController.documentController(\"getValues\")\n                      .se_attrids,\n                    function eachDocAttridsSReady($index, myAttribute) {\n                      var myChangedAttribute;\n                      if (myAttribute !== undefined) {\n                        if (!itemEmpty(myAttribute)) {\n                          if (\n                            myAttribute.value === \"activity\" ||\n                            myAttribute.value === \"fixstate\"\n                          ) {\n                            myAttribute.value = \"state\";\n                          }\n                          $.each(\n                            myAttributes,\n                            function eachPersoAttributesSReady(key, value) {\n                              if (myAttribute.value === value.id) {\n                                myChangedAttribute = {\n                                  id: value.id,\n                                  label: value.label,\n                                  type: value.type\n                                };\n                                if (myAttribute.value === \"state\") {\n                                  myAttribute.displayValue = value.label;\n                                }\n                              }\n                            }\n                          );\n                          if (\n                            myAttribute.value === \"state\" &&\n                            myChangedAttribute\n                          ) {\n                            myChangedAttribute.type = \"wid\";\n                          }\n                        } else {\n                          myChangedAttribute = null;\n                        }\n                        thisOperators = [];\n                        initOperators(\n                          myOperators,\n                          myChangedAttribute,\n                          thisOperators\n                        );\n                        defineDropDown($index, thisOperators);\n                      }\n                    }\n                  );\n                  $(\".dcpAttribute__value[name=se_keys]\").each(\n                    function eachKeysSReady(index) {\n                      var $environment = $(this);\n                      var $methods = [];\n                      var myAttribute = $documentController.documentController(\n                        \"getValues\"\n                      ).se_attrids[index];\n                      var myOperator = $documentController.documentController(\n                        \"getValues\"\n                      ).se_funcs[index];\n                      var $type = defineTypeIdAttribute(\n                        myAttribute,\n                        myAttributes\n                      );\n\n                      deleteButton($environment);\n\n                      if (\n                        myAttribute !== undefined &&\n                        myOperator !== undefined\n                      ) {\n                        /*\n                                     if the widget is a comboBox, the current input is saved in the place where it should be\n                                     */\n                        if (\n                          !itemEmpty(myOperator) &&\n                          (myOperator.value === \"=\" ||\n                            myOperator.value === \"!=\" ||\n                            myOperator.value === \"~y\")\n                        ) {\n                          if ($type === \"enum[]\" || $type === \"enum\") {\n                            if ($(this).data(\"kendoComboBox\") === undefined) {\n                              $environment[0].aNode = $environment.parent()[0].firstElementChild;\n                              initKendoComboBox(famid, $environment, $attrid);\n                            }\n                          } else if ($type === \"docid\" || $type === \"docid[]\") {\n                            if ($(this).data(\"kendoComboBox\") === undefined) {\n                              $environment[0].aNode = $environment.parent()[0].firstElementChild;\n                              initKendoComboBoxRelation(\n                                famid,\n                                $environment,\n                                $attrid\n                              );\n                            }\n                          } else if (\n                            !itemEmpty(myOperator) &&\n                            $type === \"wid\"\n                          ) {\n                            if ($(this).data(\"kendoComboBox\") === undefined) {\n                              $environment[0].aNode = $environment.parent()[0].firstElementChild;\n                              initKendoComboBoxWorkflow(\n                                $environment,\n                                $documentController\n                              );\n                            }\n                          }\n                        }\n                        /**\n                         * If the widget is a datePicker, an another input is created to link the datePicker with\n                         */\n                        if (\n                          !itemEmpty(myOperator) &&\n                          ($type === \"date\" ||\n                            $type === \"timestamp\" ||\n                            $type === \"time\")\n                        ) {\n                          if ($environment.parent()[0].children.length === 1) {\n                            var $input = $(\"<input />\").attr({ type: \"text\" });\n                            $input.insertBefore($environment[0]);\n                            $environment.hide();\n                            var date = $($environment).val();\n\n                            if (date && date.indexOf(\"(\") === -1) {\n                              $($input).val(date);\n                            }\n\n                            if ($type === \"date\") {\n                              initDatePicker($input, index);\n                            } else if ($type === \"timestamp\") {\n                              initDateTimePicker($input, index);\n                            } else if ($type === \"time\") {\n                              initTimePicker($input, index);\n                            }\n\n                            if (date.indexOf(\"(\") !== -1) {\n                              $($input).val(date);\n                            }\n                            // $input[0].disabled = \"true\";\n                          }\n                        }\n\n                        /**\n                         * If attribute has a method, define associated dropdown and button\n                         */\n                        $.each(\n                          myAttributes,\n                          function eachAttributesSReadyMethods(key, value) {\n                            if (myAttribute.value === value.id) {\n                              $methods = value.methods;\n                            }\n                          }\n                        );\n\n                        if ($methods && $methods.length !== 0) {\n                          $(\n                            $(\".dcpAttribute__content[data-attrid=se_keys]\")[\n                              index\n                            ]\n                          )\n                            .find(\"span:first\")\n                            .addClass(\"button--on\")\n                            .removeClass(\"button--off\");\n                          $(\n                            $(\".dcpAttribute__content[data-attrid=se_keys]\")[\n                              index\n                            ]\n                          )\n                            .find(\"input:first\")\n                            .addClass(\"button--on\")\n                            .removeClass(\"button--off\");\n                          createButtonMethods($environment, $methods);\n                        } else {\n                          $(\n                            $(\".dcpAttribute__content[data-attrid=se_keys]\")[\n                              index\n                            ]\n                          )\n                            .find(\"span:first\")\n                            .removeClass(\"button--on\")\n                            .addClass(\"button--off\");\n                          $(\n                            $(\".dcpAttribute__content[data-attrid=se_keys]\")[\n                              index\n                            ]\n                          )\n                            .find(\"input:first\")\n                            .removeClass(\"button--on\")\n                            .addClass(\"button--off\");\n                          deleteButtonMethods($environment);\n                        }\n                      }\n                    }\n                  );\n                  $.each(\n                    $documentController.documentController(\"getValues\")\n                      .se_funcs,\n                    function eachDocFuncsSReady($index, myOperator) {\n                      setVisibility(myOperator, $index, $documentController);\n                    }\n                  );\n\n                  $(\".dcpTab__content\").removeClass(\"dcpTab--loading\");\n                });\n              });\n              conditionVisibility($documentController);\n            });\n        }\n      );\n\n      $(this).documentController(\n        \"addEventListener\",\n        \"change\",\n        {\n          name: \"searchVisibilityRevChanged.dsearch\",\n          documentCheck: function isDSearch(document) {\n            return document.type === \"search\" && document.renderMode === \"edit\";\n          },\n          attributeCheck: function isFamily(attribute) {\n            if (attribute.id === \"se_latest\") {\n              return true;\n            }\n          }\n        },\n        /**\n         * update the displayValue of workflows when revision value changed\n         */\n        function displayVisRevisionChange() {\n          var $documentController = $(this);\n          findIfWorkflow(myAttributes, $documentController);\n\n          var typeRevision = $(this).documentController(\"getValues\").se_latest\n            .value;\n          var myObject;\n          var dataWorkflow = [];\n          _.each(myWorkflows, function eachPersoWorkflowsLatestChanged(item) {\n            if (\n              typeRevision === \"fixed\" ||\n              typeRevision === \"allfixed\" ||\n              typeRevision === \"lastfixed\"\n            ) {\n              myObject = {\n                id: item.id,\n                label: item.label\n              };\n            } else if (item.activity !== \"\") {\n              if (typeRevision === \"yes\") {\n                myObject = {\n                  id: item.id,\n                  label: item.activity\n                };\n              } else {\n                myObject = {\n                  id: item.id,\n                  label: item.label + \"/\" + item.activity\n                };\n              }\n            } else {\n              if (typeRevision === \"yes\") {\n                myObject = {\n                  id: item.id,\n                  label: item.label\n                };\n              } else {\n                myObject = {\n                  id: item.id,\n                  label: item.label\n                };\n              }\n            }\n            dataWorkflow.push(myObject);\n          });\n\n          $(\".dcpAttribute__value[name=se_keys]\").each(\n            function eachKeysLatestChanged() {\n              if ($(this).data(\"kendoComboBox\") !== undefined) {\n                var $dataSource = new kendo.data.DataSource({\n                  data: dataWorkflow,\n                  dataValueField: \"id\",\n                  dataTextField: \"label\"\n                });\n                $(this)\n                  .data(\"kendoComboBox\")\n                  .setDataSource($dataSource);\n              }\n            }\n          );\n        }\n      );\n\n      $(this).documentController(\n        \"addEventListener\",\n        \"change\",\n        {\n          name: \"searchFuncsAttributeChanged.dsearch\",\n          documentCheck: function isDSearch(document) {\n            return document.type === \"search\" && document.renderMode === \"edit\";\n          },\n          attributeCheck: function isFamily(attribute) {\n            if (attribute.id === \"se_attrids\") {\n              return true;\n            }\n          }\n        },\n        /**\n         * re-initialized or update a raw if an attribute changed\n         * @param event unused\n         * @param document unused\n         * @param attribute unused\n         * @param values current, previous and initial attribute value\n         */\n        function displayAttrChange(event, document, attribute, values) {\n          conditionVisibility($(this));\n          var $nodeToSave = null;\n          var $parent = null;\n          var $index = null;\n          var $methods = [];\n          var famid = $(this).documentController(\"getValues\").se_famid.value;\n          var $documentController = $(this);\n          var current = values.current;\n          var prev = values.previous;\n\n          var $environment = null;\n          var $funcEl = null;\n          var $displayAttribute;\n\n          if (current.length !== prev.length) {\n            return;\n          }\n          $.each(current, function eachCurrentAttridsChanged(key) {\n            if (current[key] !== prev[key]) {\n              $index = key;\n            }\n          });\n\n          $(\".dcpAttribute__value[name=se_funcs]\").each(\n            function eachFuncsAttridsChanged(key, value) {\n              if (key === $index) {\n                $environment = $(this);\n                $funcEl = value;\n              }\n            }\n          );\n          $(\".dcpAttribute__value[name=se_attrids]\").each(\n            function eachAttridsAttridsChanged(key) {\n              if (key === $index) {\n                $displayAttribute = $(this);\n              }\n            }\n          );\n          var myAttribute = $documentController.documentController(\"getValues\")\n            .se_attrids[$index];\n          var myOperator = $documentController.documentController(\"getValues\")\n            .se_funcs[$index];\n          var myChangedAttribute;\n          var attributeExists = false;\n          var $type;\n          var $seKeys = [];\n\n          // key values reloaded\n          if (!itemEmpty(myOperator) && !itemEmpty(myAttribute)) {\n            if (\n              myOperator.value !== \"is null\" &&\n              myOperator.value !== \"is not null\" &&\n              myOperator.value !== \"><\"\n            ) {\n              $documentController.documentController(\"setValue\", \"se_keys\", {\n                value: \"\",\n                index: $index\n              });\n            } else {\n              $documentController.documentController(\"setValue\", \"se_keys\", {\n                value: \"foo\",\n                index: $index\n              });\n            }\n\n            _.each(myAttributes, function eachAttributesDefineTypeId(data) {\n              if (data.id === myAttribute.value) {\n                attributeExists = true;\n              }\n            });\n          } else {\n            attributeExists = true;\n          }\n\n          $seKeys = $(\".dcpAttribute__value[name=se_keys]\");\n          if (!itemEmpty(myAttribute) && attributeExists) {\n            $documentController.documentController(\n              \"cleanAttributeErrorMessage\",\n              \"se_attrids\"\n            );\n\n            $.each(\n              $documentController.documentController(\"getValues\").se_attrids,\n              function eachAttridsAttributesFamilychanged(key, val) {\n                var attrId = val.value;\n                var $controle = 0;\n\n                $.each(\n                  myAttributes,\n                  function eachNewDataattributesAttributesFamilychanged(\n                    mkey,\n                    mval\n                  ) {\n                    if (attrId === mval.id) {\n                      $controle = 1;\n                    }\n                  }\n                );\n                if ($controle === 0 && !itemEmpty(attrId)) {\n                  $documentController.documentController(\n                    \"setAttributeErrorMessage\",\n                    \"se_attrids\",\n                    _searchCatalog__WEBPACK_IMPORTED_MODULE_0__[\"default\"].___(\"Invalid attribute\", \"dsearch\"),\n                    key\n                  );\n                }\n              }\n            );\n\n            if ($funcEl !== undefined) {\n              if ($funcEl.parentElement !== undefined) {\n                if ($funcEl.parentElement.style.visibility === \"hidden\") {\n                  $funcEl.parentElement.style.visibility = \"visible\";\n                }\n                $funcEl.parentElement.offsetParent.style.visibility = \"visible\";\n              }\n            }\n            if (myAttribute.value !== null) {\n              $.each(myAttributes, function eachPersoAttributesAttridsChanged(\n                key,\n                value\n              ) {\n                if (myAttribute.value === value.id) {\n                  myChangedAttribute = {\n                    id: value.id,\n                    label: value.label,\n                    type: value.type\n                  };\n                  if (myChangedAttribute.type === undefined) {\n                    myChangedAttribute.type = \"wid\";\n                  }\n                }\n              });\n            } else {\n              myChangedAttribute = null;\n            }\n\n            thisOperators = [];\n            initOperators(myOperators, myChangedAttribute, thisOperators);\n\n            if ($environment.data(\"kendoDropDownList\") !== undefined) {\n              $environment.data(\"kendoDropDownList\").destroy();\n            }\n            defineDropDown($index, thisOperators);\n            myOperator.value = thisOperators[0].monId;\n            $documentController.documentController(\"setValue\", \"se_funcs\", {\n              value: thisOperators[0].monId,\n              index: $index\n            });\n            $environment.data(\"kendoDropDownList\").select(\n              $environment\n                .data(\"kendoDropDownList\")\n                .ul.children()\n                .eq(0)\n            );\n            $seKeys.each(function eachKeysFirstEnvAttridsChanged(key) {\n              if (key === $index) {\n                $environment = $(this);\n              }\n            });\n            /**\n             * delete everything there was before on the keys field\n             */\n            if ($environment.closest(\"div\").find(\"button\").length !== 0) {\n              if ($checkMeth) {\n                $environment\n                  .closest(\"div\")\n                  .find(\"button\")\n                  .trigger(\"click\");\n              }\n            }\n            deleteButtonMethods($environment);\n            if (\n              $environment.parent()[0].children.length === 2 ||\n              $environment.parent()[0].children.length === 3\n            ) {\n              destroyDatePicker($environment);\n            }\n            if (\n              $environment.data(\"kendoComboBox\") !== undefined &&\n              $environment[0].aNode !== undefined\n            ) {\n              $environment.data(\"kendoComboBox\").destroy();\n              $nodeToSave = $environment[0].aNode;\n              $parent = $environment.parent()[0].parentElement;\n              $parent.firstElementChild.remove();\n              $parent.insertBefore($nodeToSave, $parent.lastElementChild);\n              $nodeToSave.style.display = \"block\";\n            }\n            $type = defineTypeIdAttribute(myAttribute, myAttributes);\n            if (myAttribute !== undefined && myOperator !== undefined) {\n              /*\n                         if the widget is a comboBox, the current input is saved in the place where it should be\n                         */\n              if (\n                !itemEmpty(myOperator) &&\n                (myOperator.value === \"=\" ||\n                  myOperator.value === \"!=\" ||\n                  myOperator.value === \"~y\")\n              ) {\n                if ($type === \"enum[]\" || $type === \"enum\") {\n                  if ($environment.data(\"kendoComboBox\") === undefined) {\n                    $seKeys.each(function eachKeysIEnumAttridsChanged(key) {\n                      if (key === $index) {\n                        $environment[0].aNode = $environment.parent()[0].firstElementChild;\n                        initKendoComboBox(famid, $environment, $attrid);\n                      }\n                    });\n                  }\n                } else if ($type === \"docid\" || $type === \"docid[]\") {\n                  if ($environment.data(\"kendoComboBox\") === undefined) {\n                    $seKeys.each(function eachKeysIRelationAttridsChanged(key) {\n                      if (key === $index) {\n                        $environment[0].aNode = $environment.parent()[0].firstElementChild;\n                        initKendoComboBoxRelation(famid, $environment, $attrid);\n                      }\n                    });\n                  }\n                } else if ($type === \"wid\") {\n                  if ($environment.data(\"kendoComboBox\") === undefined) {\n                    $seKeys.each(function eachKeysIWorklowAttridsChanged(key) {\n                      if (key === $index) {\n                        $environment[0].aNode = $environment.parent()[0].firstElementChild;\n                        initKendoComboBoxWorkflow(\n                          $environment,\n                          $documentController\n                        );\n                      }\n                    });\n                  }\n                }\n              }\n              /**\n               * If the widget is a datePicker, an another input is created to link the datePicker with\n               */\n              if (\n                !itemEmpty(myOperator) &&\n                ($type === \"date\" || $type === \"timestamp\" || $type === \"time\")\n              ) {\n                if ($environment.parent()[0].children.length === 1) {\n                  var $input = $(\"<input />\").attr({ type: \"text\" }); // create a second input to separate value and display value\n                  $input.insertBefore($environment[0]);\n                  $environment.hide();\n                  if ($type === \"date\") {\n                    initDatePicker($input, $index);\n                  } else if ($type === \"timestamp\") {\n                    initDateTimePicker($input, $index);\n                  } else if ($type === \"time\") {\n                    initTimePicker($input, $index);\n                  }\n                  //$input[0].disabled = \"true\";\n                }\n              }\n\n              /**\n               * If attribute has a method, define associated dropdown and button\n               */\n              $.each(myAttributes, function eachAttributesSReadyMethods(\n                key,\n                value\n              ) {\n                if (myAttribute.value === value.id) {\n                  $methods = value.methods;\n                }\n              });\n\n              if ($methods && $methods.length !== 0) {\n                $($(\".dcpAttribute__content[data-attrid=se_keys]\")[$index])\n                  .find(\"span:first\")\n                  .addClass(\"button--on\")\n                  .removeClass(\"button--off\");\n                $($(\".dcpAttribute__content[data-attrid=se_keys]\")[$index])\n                  .find(\"input:first\")\n                  .addClass(\"button--on\")\n                  .removeClass(\"button--off\");\n                createButtonMethods($environment, $methods);\n              } else {\n                $($(\".dcpAttribute__content[data-attrid=se_keys]\")[$index])\n                  .find(\"span:first\")\n                  .removeClass(\"button--on\")\n                  .addClass(\"button--off\");\n                $($(\".dcpAttribute__content[data-attrid=se_keys]\")[$index])\n                  .find(\"input:first\")\n                  .removeClass(\"button--on\")\n                  .addClass(\"button--off\");\n                deleteButtonMethods($environment);\n              }\n            }\n            setVisibility(myOperator, $index, $documentController);\n          } else {\n            /* reload values */\n            if (!attributeExists) {\n              $documentController.documentController(\"setValue\", \"se_keys\", {\n                value: \"foo\",\n                index: $index\n              });\n              $documentController.documentController(\"setValue\", \"se_attrids\", {\n                value: \"\",\n                index: $index\n              });\n            }\n            /*\n                     without a selected attribute, widget should be deleted\n                     */\n            if ($displayAttribute !== undefined) {\n              if ($displayAttribute.data(\"kendoComboBox\") !== undefined) {\n                $displayAttribute.data(\"kendoComboBox\").value(\"\");\n              }\n            }\n            if ($funcEl !== undefined) {\n              if (!itemEmpty($funcEl) && $funcEl.dataset.role !== undefined) {\n                // role is undefined if there is no widget\n                $funcEl.parentElement.style.visibility = \"hidden\";\n                $funcEl.parentElement.offsetParent.style.visibility = \"hidden\";\n                $funcEl.value = null;\n                myOperator.value = null;\n              }\n              $seKeys.each(function eachKeysSecondEnvAttridsChanged(key) {\n                if (key === $index) {\n                  $environment = $(this);\n                }\n              });\n              if (\n                !itemEmpty($environment) &&\n                ($environment.parent()[0].children.length === 3 ||\n                  $environment.parent()[0].children.length === 4)\n              ) {\n                destroyDatePicker($environment);\n              }\n              if (\n                !itemEmpty($environment) &&\n                $environment.data(\"kendoComboBox\") !== undefined &&\n                $environment[0].aNode !== undefined\n              ) {\n                $environment.data(\"kendoComboBox\").destroy();\n                $nodeToSave = $environment[0].aNode;\n                $parent = $environment.parent()[0].parentElement;\n                $parent.firstElementChild.remove();\n                $parent.insertBefore($nodeToSave, $parent.lastElementChild);\n                $nodeToSave.style.display = \"block\";\n              }\n              setVisibility(myOperator, $index, $documentController);\n            }\n          }\n        }\n      );\n\n      $(this).documentController(\n        \"addEventListener\",\n        \"change\",\n        {\n          name: \"searchFuncsFamidChanged.dsearch\",\n          documentCheck: function isDSearch(document) {\n            return document.type === \"search\" && document.renderMode === \"edit\";\n          },\n          attributeCheck: function isOperator(attribute) {\n            if (attribute.id === \"se_famid\") {\n              return true;\n            }\n          }\n        },\n        /**\n         * update attributes and workflows list if the family change\n         */\n        function displayFuncsFamidChange() {\n          var famid = $(this).documentController(\"getValues\").se_famid.value;\n          var $documentController = $(this);\n          var testWorkflow = false;\n\n          if (famid === null) {\n            famid = \"\";\n          }\n\n          Object(_searchAttributes__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(famid)\n            .then(function requestAttributesFamidChanged(data) {\n              myAttributes = [];\n              $.each(data.data, function eachDataAttributesFamidChanged(\n                key,\n                value\n              ) {\n                myAttributes.push(value);\n              });\n              /**\n               * update the workflow attribute generic value\n               */\n              if (myAttributes[myAttributes.length - 1].type === \"wid\") {\n                $wf = myAttributes[myAttributes.length - 1];\n              } else {\n                $wf = null;\n              }\n              testWorkflow = findIfWorkflow(myAttributes, $documentController);\n            })\n            .then(function doneFamidChanged() {\n              if (testWorkflow) {\n                $.getJSON(\n                  \"api/v2/documents/\" +\n                    famid +\n                    \"/workflows/states/?allStates=1\",\n                  function requestWorkflowsFamidChanged(data) {\n                    myWorkflows = [];\n                    $.each(\n                      data.data.states,\n                      function eachDataStatesFamidChanged(key, value) {\n                        myWorkflows.push(value);\n                      }\n                    );\n                  }\n                );\n              }\n            });\n        }\n      );\n\n      $(this).documentController(\n        \"addEventListener\",\n        \"change\",\n        {\n          name: \"searchFuncsConditionChanged.dsearch\",\n          documentCheck: function isDSearch(document) {\n            return document.type === \"search\" && document.renderMode === \"edit\";\n          },\n          attributeCheck: function isFamily(attribute) {\n            if (attribute.id === \"se_ol\") {\n              return true;\n            }\n          }\n        },\n        /**\n         * update visibilities when the condition field change\n         * initialize operand field if switch to personalization mode\n         * @param event unused\n         * @param document unused\n         * @param attribute unused\n         * @param values current, previous and initial\n         */\n        function displayConditionChange(event, document, attribute, values) {\n          var $documentController = $(this);\n          var $tabOperands = [];\n          conditionVisibility($documentController);\n          if (\n            (values.current.value === \"perso\" &&\n              values.previous.value === \"and\") ||\n            values.current.value === \"and\"\n          ) {\n            $(\".dcpAttribute__value[name=se_ols]\").each(\n              function eachOperandsOlChangedAnd() {\n                $tabOperands.push({ value: \"and\", displayValue: \"et\" });\n              }\n            );\n            $documentController.documentController(\n              \"setValue\",\n              \"se_ols\",\n              $tabOperands\n            );\n          } else if (\n            (values.current.value === \"perso\" &&\n              values.previous.value === \"or\") ||\n            values.current.value === \"or\"\n          ) {\n            $(\".dcpAttribute__value[name=se_ols]\").each(\n              function eachOperandOlChangedOr() {\n                $tabOperands.push({ value: \"or\", displayValue: \"ou\" });\n              }\n            );\n            $documentController.documentController(\n              \"setValue\",\n              \"se_ols\",\n              $tabOperands\n            );\n          }\n        }\n      );\n\n      $(this).documentController(\n        \"addEventListener\",\n        \"change\",\n        {\n          name: \"searchVisibilityFuncsChanged.dsearch\",\n          documentCheck: function isDSearch(document) {\n            return document.type === \"search\" && document.renderMode === \"edit\";\n          },\n          attributeCheck: function isOperator(attribute) {\n            if (attribute.id === \"se_funcs\") {\n              return true;\n            }\n          }\n        },\n        /**\n         * initialize the keywords field widget according to the attribute's type\n         * @param values current, previous and initial of the changed func\n         * @param event unused\n         * @param document unused\n         * @param attribute unused\n         *\n         */\n        function displayFuncChange(event, document, attribute, values) {\n          var $parent;\n          var $nodeToSave;\n          var $index = null;\n          var $documentController = $(this);\n          var current = values.current;\n          var prev = values.previous;\n          $.each(current, function eachCurrentFuncsChanged(key) {\n            if (current[key] !== prev[key]) {\n              $index = key;\n            }\n          });\n          var myOperator = $documentController.documentController(\"getValues\")\n            .se_funcs[$index];\n          var myAttribute = $documentController.documentController(\"getValues\")\n            .se_attrids[$index];\n          var famid = $(this).documentController(\"getValues\").se_famid.value;\n          var $environment = null;\n          var $seKeys = $(\".dcpAttribute__value[name=se_keys]\");\n          var $type;\n\n          $seKeys.each(function eachKeysFuncsChanged(key) {\n            if (key === $index) {\n              $environment = $(this);\n            }\n          });\n          if (\n            !itemEmpty($environment) &&\n            $environment.closest(\"div\").find(\"button\").length !== 0\n          ) {\n            if ($checkMeth) {\n              $environment\n                .closest(\"div\")\n                .find(\"button\")\n                .trigger(\"click\");\n            }\n          }\n\n          $type = defineTypeIdAttribute(myAttribute, myAttributes);\n          // key values reloaded\n          if (!itemEmpty(myOperator)) {\n            if (\n              myOperator.value !== \"is null\" &&\n              myOperator.value !== \"is not null\" &&\n              myOperator.value !== \"><\"\n            ) {\n              // $documentController.documentController(\"setValue\", \"se_keys\", {value: \"\", index: $index});\n            } else {\n              $documentController.documentController(\"setValue\", \"se_keys\", {\n                value: \"\",\n                index: $index\n              });\n              if ($type === \"date\") {\n                $environment\n                  .parent()\n                  .find(\".k-picker-wrap input\")\n                  .val(\"\");\n              }\n            }\n          }\n          var $init = false;\n          if (myAttribute !== undefined && myOperator !== undefined) {\n            /*\n                     if the widget is a comboBox, the current input is saved in the place where it should be\n                     */\n            if (\n              !itemEmpty(myOperator) &&\n              !$checkMeth &&\n              ($type === \"enum[]\" ||\n                $type === \"enum\" ||\n                $type === \"docid\" ||\n                $type === \"docid[]\" ||\n                $type === \"wid\")\n            ) {\n              if (\n                !itemEmpty($environment) &&\n                $environment.data(\"kendoComboBox\") !== undefined &&\n                $environment[0].aNode !== undefined\n              ) {\n                $environment.data(\"kendoComboBox\").destroy();\n                $nodeToSave = $environment[0].aNode;\n                $parent = $environment.parent()[0].parentElement;\n                $parent.firstElementChild.remove();\n                $parent.insertBefore($nodeToSave, $parent.lastElementChild);\n                $nodeToSave.style.display = \"block\";\n              }\n            }\n            if (\n              !itemEmpty(myOperator) &&\n              (myOperator.value === \"=\" ||\n                myOperator.value === \"!=\" ||\n                myOperator.value === \"~y\") &&\n              ($type === \"enum[]\" || $type === \"enum\")\n            ) {\n              if ($environment.data(\"kendoComboBox\") === undefined) {\n                $seKeys.each(function eachKeysIEnumFuncsChanged(key) {\n                  if (key === $index) {\n                    $environment[0].aNode = $environment.parent()[0].firstElementChild;\n                    initKendoComboBox(famid, $environment, $attrid);\n                  }\n                });\n              }\n            } else if (\n              !itemEmpty(myOperator) &&\n              ($type === \"docid\" || $type === \"docid[]\") &&\n              (myOperator.value === \"=\" ||\n                myOperator.value === \"!=\" ||\n                myOperator.value === \"~y\")\n            ) {\n              if ($environment.data(\"kendoComboBox\") === undefined) {\n                $seKeys.each(function eachKeysIRelationFuncsChanged(key) {\n                  if (key === $index) {\n                    $environment[0].aNode = $environment.parent()[0].firstElementChild;\n                    initKendoComboBoxRelation(famid, $environment, $attrid);\n                  }\n                });\n              }\n            } else if (\n              !itemEmpty(myOperator) &&\n              $type === \"wid\" &&\n              (myOperator.value === \"=\" || myOperator.value === \"!=\")\n            ) {\n              if ($environment.data(\"kendoComboBox\") === undefined) {\n                $seKeys.each(function eachKeysIWorkflowsFuncsChanged(key) {\n                  if (key === $index) {\n                    $environment[0].aNode = $environment.parent()[0].firstElementChild;\n                    initKendoComboBoxWorkflow(\n                      $environment,\n                      $documentController\n                    );\n                  }\n                });\n              }\n            }\n            if (\n              !itemEmpty(myOperator) &&\n              ($type === \"date\" || $type === \"timestamp\" || $type === \"time\") &&\n              (myOperator.value !== \"is null\" &&\n                myOperator.value !== \"is not null\" &&\n                myOperator.value !== \"><\")\n            ) {\n              if ($environment.parent()[0].children.length === 1) {\n                var $input = $(\"<input />\").attr({ type: \"text\" }); // create a second input to separate value and display value\n                $input.insertBefore($environment[0]);\n                $environment.hide();\n                if ($type === \"date\") {\n                  initDatePicker($input, $index);\n                } else if ($type === \"timestamp\") {\n                  initDateTimePicker($input, $index);\n                } else if ($type === \"time\") {\n                  initTimePicker($input, $index);\n                }\n                //$input[0].disabled = \"true\";\n              }\n            }\n          } else if ($environment !== undefined) {\n            /*\n                 without a selected attribute widget should be deleted\n                 */\n            if (\n              !$init &&\n              !itemEmpty($environment) &&\n              ($environment.parent()[0].children.length === 2 ||\n                $environment.parent()[0].children.length === 3)\n            ) {\n              destroyDatePicker($environment);\n            }\n            if (\n              !$init &&\n              !itemEmpty($environment) &&\n              $environment.data(\"kendoComboBox\") !== undefined &&\n              $environment[0].aNode !== undefined\n            ) {\n              $environment.data(\"kendoComboBox\").destroy();\n              $nodeToSave = $environment[0].aNode;\n              $parent = $environment.parent()[0].parentElement;\n              $parent.firstElementChild.remove();\n              $parent.insertBefore($nodeToSave, $parent.lastElementChild);\n              $nodeToSave.style.display = \"block\";\n            }\n          }\n          if (myOperator !== undefined) {\n            setVisibility(myOperator, $index, $documentController);\n          }\n        }\n      );\n\n      $(this).documentController(\n        \"addEventListener\",\n        \"attributeArrayChange\",\n        {\n          name: \"searchFuncsAddArray.dsearch\",\n          documentCheck: function isDSearch(document) {\n            return document.type === \"search\" && document.renderMode === \"edit\";\n          },\n          attributeCheck: function isArray(attribute) {\n            if (attribute.id === \"se_t_detail\") {\n              return true;\n            }\n          }\n        },\n        /**\n         * set all previous parameters to a new line\n         * as visibilities, button deletion...\n         * @param event unused\n         * @param document unused\n         * @param attribut unused\n         * @param type unused\n         * @param options raw of the button to delete\n         */\n        function displayChange(event, document, attribut, type, options) {\n          var $documentController = $(this);\n          var $environment = null;\n          if (type === \"addLine\") {\n            var $funcEl;\n            var $funcInput = $documentController.documentController(\"getValues\")\n              .se_funcs[options];\n            $(\".dcpAttribute__value[name=se_funcs]\").each(\n              function eachFuncsArrayModified(key, val) {\n                if (key === options) {\n                  $funcEl = val;\n                }\n              }\n            );\n            if ($funcEl !== undefined) {\n              $funcEl.offsetParent.style.visibility = \"hidden\";\n              $funcEl.value = null;\n              $funcInput.value = null;\n            }\n            $(\".dcpAttribute__value[name=se_keys]\").each(\n              function eachKeysArrayModified(key) {\n                if (key === options) {\n                  $environment = $(this);\n                }\n              }\n            );\n            var myOperator = $documentController.documentController(\"getValues\")\n              .se_funcs[options];\n            setVisibility(myOperator, options, $documentController);\n            deleteButton($environment);\n          }\n          conditionVisibility($documentController);\n        }\n      );\n    }\n  );\n\n  window.dcp.document.documentController(\n    \"addEventListener\",\n    \"close\",\n    {\n      name: \"removeDsearchEvent\",\n      documentCheck: function(document) {\n        return document.type === \"search\";\n      }\n    },\n    function() {\n      var $this = $(this);\n      $this.documentController(\"removeEventListener\", \".dsearch\");\n    }\n  );\n\n  /**\n   * set visibilities according to condition field / swap classes to  make css easier\n   * set visibilities of parenthesis and operand fields\n   * @param $documentController of current document\n   */\n  function conditionVisibility($documentController) {\n    var $condition = $documentController.documentController(\"getValues\").se_ol;\n    if ($condition && $condition.value !== \"perso\") {\n      $(\".dcpArray__content[data-attrid=se_t_detail] > table\")\n        .removeClass(\"dcpArray--custom\")\n        .addClass(\"dcpArray--not_custom\");\n      $documentController.documentController(\"hideAttribute\", \"se_ols\");\n      $('.dcpArray__head__cell[data-attrid=\"se_ols\"]').hide();\n      $documentController.documentController(\"hideAttribute\", \"se_rightp\");\n      $('.dcpArray__head__cell[data-attrid=\"se_rightp\"]').hide();\n      $documentController.documentController(\"hideAttribute\", \"se_leftp\");\n      $('.dcpArray__head__cell[data-attrid=\"se_leftp\"]').hide();\n    } else {\n      $(\".dcpArray__content[data-attrid=se_t_detail] > table\")\n        .removeClass(\"dcpArray--not_custom\")\n        .addClass(\"dcpArray--custom\");\n      $documentController.documentController(\"showAttribute\", \"se_ols\");\n      $('.dcpArray__head__cell[data-attrid=\"se_ols\"]').show();\n      $documentController.documentController(\"showAttribute\", \"se_rightp\");\n      $('.dcpArray__head__cell[data-attrid=\"se_rightp\"]').show();\n      $documentController.documentController(\"showAttribute\", \"se_leftp\");\n      $('.dcpArray__head__cell[data-attrid=\"se_leftp\"]').show();\n      $(\".dcpAttribute__value[name=se_ols]\").each(function(key, val) {\n        if (key === 0) {\n          $(val.closest(\"div\")).hide();\n        } else {\n          $(val.closest(\"div\")).show();\n        }\n      });\n    }\n  }\n\n  /**\n   * remove a bootstrap button from a specific place\n   * @param $environment place to remove the button\n   */\n  function deleteButton($environment) {\n    var $parent = $($environment).closest(\"div\");\n    if ($parent[0] !== undefined) {\n      var $button = $parent[0].lastElementChild;\n      $button.remove();\n    }\n  }\n\n  /**\n   * initialize a datePicker kendo widget\n   * @param $environment place to put the widget\n   * @param $index index of the raw\n   */\n  function initDatePicker($environment, $index) {\n    $environment.kendoDatePicker({\n      parseFormats: [\"yyyy-MM-dd\"],\n      format: null, // standard format depends of the user's langage\n      /*\n             trigger a fonction that change the value of the date from the displayValue according to ISO 8601\n             */\n      change: function changeDatePickerValure() {\n        var keywordObj = null;\n        $(\".dcpAttribute__value[name=se_keys]\").each(\n          function eachKeysChangeDatePicker(key, value) {\n            if (key === $index) {\n              keywordObj = value;\n            }\n          }\n        );\n        var date = this.value();\n        if (date) {\n          var jour;\n          if (date.getDate() / 10 < 1) {\n            jour = \"0\" + date.getDate();\n          } else jour = date.getDate();\n          var mois;\n          if ((date.getMonth() + 1) / 10 < 1) {\n            mois = date.getMonth() + 1;\n            mois = \"0\" + mois;\n          } else mois = date.getMonth() + 1;\n          $(keywordObj).val(date.getFullYear() + \"-\" + mois + \"-\" + jour);\n        } else {\n          $(keywordObj).val(\"\");\n        }\n        $(keywordObj).trigger(\"change\");\n      }\n    });\n  }\n\n  /**\n   * initialize a datePicker kendo widget\n   * @param $environment place to put the widget\n   * @param $index index of the raw\n   */\n  function initDateTimePicker($environment, $index) {\n    $environment.kendoDateTimePicker({\n      parseFormats: [\n        \"yyyy-MM-dd HH:mm:ss\",\n        \"yyyy-MM-ddTHH:mm:ss\",\n        \"yyyy-MM-ddTHH:mm\"\n      ],\n      timeFormat: \"HH:mm\",\n      format: null, // standard format depends of the user's langage\n      /*\n             trigger a fonction that change the value of the date from the displayValue according to ISO 8601\n             */\n      change: function changeDatePickerValure() {\n        var keywordObj = null;\n        $(\".dcpAttribute__value[name=se_keys]\").each(\n          function eachKeysChangeDatePicker(key, value) {\n            if (key === $index) {\n              keywordObj = value;\n            }\n          }\n        );\n\n        var timeDate = this.value();\n        var sTimeDate = \"\";\n        if (timeDate) {\n          sTimeDate =\n            timeDate.getFullYear() +\n            \"-\" +\n            searchPadNumber(timeDate.getMonth() + 1) +\n            \"-\" +\n            searchPadNumber(timeDate.getDate()) +\n            \" \" +\n            searchPadNumber(timeDate.getHours()) +\n            \":\" +\n            searchPadNumber(timeDate.getMinutes()) +\n            \":\" +\n            searchPadNumber(timeDate.getSeconds());\n        }\n        $(keywordObj).val(sTimeDate);\n        $(keywordObj).trigger(\"change\");\n      }\n    });\n  }\n\n  /**\n   * initialize a datePicker kendo widget\n   * @param $environment place to put the widget\n   * @param $index index of the raw\n   */\n  function initTimePicker($environment, $index) {\n    $environment.kendoTimePicker({\n      timeDataFormat: [\"HH:mm\", \"HH:mm:ss\"],\n      format: null, // standard format depends of the user's langage\n      /*\n             trigger a fonction that change the value of the date from the displayValue according to ISO 8601\n             */\n      change: function changeDatePickerValure() {\n        var keywordObj = null;\n        $(\".dcpAttribute__value[name=se_keys]\").each(\n          function eachKeysChangeDatePicker(key, value) {\n            if (key === $index) {\n              keywordObj = value;\n            }\n          }\n        );\n        var timeDate = this.value();\n        var time = \"\";\n        if (timeDate) {\n          time =\n            searchPadNumber(timeDate.getHours()) +\n            \":\" +\n            searchPadNumber(timeDate.getMinutes());\n        }\n        $(keywordObj).val(time);\n        $(keywordObj).trigger(\"change\");\n      }\n    });\n  }\n\n  function searchPadNumber(number) {\n    if (number < 10) {\n      return \"0\" + number;\n    }\n    return number;\n  }\n\n  /**\n   * remove a datePicker kendo widget from the DOM\n   * @param $environment place to delete the widget\n   */\n  function destroyDatePicker($environment) {\n    var $parent = $environment.parent()[0];\n    $parent.children[0].remove();\n    $environment.show();\n  }\n\n  /**\n   * define attribute type and id\n   * @param myAttribute selected attribute\n   * @param myAttributes list of attributes\n   */\n  function defineTypeIdAttribute(myAttribute, myAttributes) {\n    var $atype = \"\";\n    if (!itemEmpty(myAttribute)) {\n      _.each(myAttributes, function eachAttributesDefineTypeId(data) {\n        if (data.id === myAttribute.value) {\n          $atype = data.type;\n        }\n      });\n      $attrid = myAttribute.value;\n    } else {\n      $atype = \"\";\n    }\n    if (!$atype && myAttribute.value === \"activity\") {\n      $atype = \"wid\";\n      myAttribute.value = \"state\";\n    }\n\n    return $atype;\n  }\n\n  /**\n   * Initialize workflow keywords kendoComboBox widget\n   * @param $environment place to put the widget\n   * @param $documentController of current document\n   */\n  function initKendoComboBoxWorkflow($environment, $documentController) {\n    var typeRevision = $documentController.documentController(\"getValues\")\n      .se_latest.value;\n    var myObject;\n    var dataWorkflow = [];\n    /*\n         initialize the workflows keys list, depending on the revision value\n         */\n    _.each(myWorkflows, function eachWorkflowsIWorkflow(item) {\n      if (\n        typeRevision === \"fixed\" ||\n        typeRevision === \"allfixed\" ||\n        typeRevision === \"lastfixed\"\n      ) {\n        myObject = {\n          id: item.id,\n          label: item.label\n        };\n      } else if (item.activity !== \"\") {\n        if (typeRevision === \"yes\") {\n          myObject = {\n            id: item.id,\n            label: item.activity\n          };\n        } else {\n          myObject = {\n            id: item.id,\n            label: item.label + \"/\" + item.activity\n          };\n        }\n      } else {\n        if (typeRevision === \"yes\") {\n          myObject = {\n            id: item.id,\n            label: item.label\n          };\n        } else {\n          myObject = {\n            id: item.id,\n            label: item.label\n          };\n        }\n      }\n      dataWorkflow.push(myObject);\n    });\n    $environment.kendoComboBox({\n      width: 200,\n      filter: \"contains\",\n      clearButton: false,\n      minLength: 0,\n      dataValueField: \"id\",\n      dataTextField: \"label\",\n      dataSource: dataWorkflow\n    });\n    $environment.data(\"kendoComboBox\").list.css(\"min-width\", \"300px\");\n  }\n\n  /**\n   * define the dropDownList kendo widget on the operator field @ the specified index\n   * @param $index index of the raw\n   * @param myOperators list  of operators\n   */\n  function defineDropDown($index, myOperators) {\n    $(\".dcpAttribute__value[name=se_funcs]\").each(function eachFuncsDefineDD(\n      key\n    ) {\n      if (key === $index) {\n        /*\n                 update or create the widget\n                 */\n        if ($(this).data(\"kendoDropDownList\") !== undefined) {\n          var $dataSource = new kendo.data.DataSource({\n            data: myOperators\n          });\n          $(this)\n            .data(\"kendoDropDownList\")\n            .setDataSource($dataSource);\n        } else {\n          $(this).kendoDropDownList({\n            dataSource: myOperators,\n            dataTextField: \"monTitre\",\n            dataValueField: \"monId\",\n            template: '<span class=\"k-state-default\">#= monTitre #</span>',\n            valueTemplate: \"<span> #= monTitre# </span>\",\n            index: 0\n          });\n          $(this)\n            .data(\"kendoDropDownList\")\n            .list.css(\"min-width\", \"300px\");\n        }\n        /*\n                 remove bootstrap button\n                 */\n        if ($(this)[0].parentElement.parentElement.children.length === 2) {\n          $(this)[0].parentElement.parentElement.lastElementChild.remove();\n        }\n      }\n    });\n  }\n\n  /**\n   * Initialize relation keywords kendoComboBox widget\n   * @param famid id of the current family\n   * @param $environment place to put the widget\n   * @param attrid id of the current attribute\n   */\n  function initKendoComboBoxRelation(famid, $environment, attrid) {\n    $environment.kendoComboBox({\n      width: 200,\n      filter: \"contains\",\n      dataValueField: \"id\",\n      dataTextField: \"htmlTitle\",\n      clearButton: false,\n      dataSource: {\n        type: \"json\",\n        serverFiltering: true,\n        transport: {\n          /**\n           * function to get data\n           * @param options param to return success or error data\n           */\n          read: function readDatasIRelation(options) {\n            var filter = \"\";\n            if (options.data.filter !== undefined) {\n              if (options.data.filter.filters[0] !== undefined) {\n                filter = options.data.filter.filters[0].value;\n              }\n            }\n            $.ajax({\n              type: \"GET\",\n              url:\n                \"api/v2/smartstructures/dsearch/relations/\" +\n                famid +\n                \"/\" +\n                attrid +\n                \"?slice=25&offset=0&keyword=\" +\n                filter,\n              dataType: \"json\",\n              success: function succesRequestRelationsIRelation(result) {\n                var info = [];\n                _.each(result.data, function eachResultRelationsIRelation(\n                  item\n                ) {\n                  info.push({\n                    id: item.id,\n                    htmlTitle: item.htmlTitle\n                  });\n                });\n                options.success(info);\n              },\n              error: function errorRequestRelationsIRelation(result) {\n                options.error(result);\n              }\n            });\n          }\n        }\n      }\n    });\n    $environment.data(\"kendoComboBox\").list.css(\"min-width\", \"300px\");\n  }\n\n  /**\n   * Initialize enum keywords kendoComboBox widget\n   * @param famid id of the current family\n   * @param $environment place to put the widget\n   * @param attrid id of the current attribute\n   */\n  function initKendoComboBox(famid, $environment, attrid) {\n    $environment.kendoComboBox({\n      width: 200,\n      filter: \"contains\",\n      clearButton: false,\n      dataValueField: \"value\",\n      dataTextField: \"displayValue\",\n      dataSource: {\n        type: \"json\",\n        serverFiltering: true,\n        transport: {\n          /**\n           * function to get data\n           * @param options param to return success or error data\n           */\n          read: function readDatasIEnum(options) {\n            var filter = \"\";\n            if (\n              options.data.filter !== undefined &&\n              options.data.filter.filters[0] !== undefined\n            ) {\n              filter = {\n                keyword: options.data.filter.filters[0].value,\n                operator: options.data.filter.filters[0].operator\n              };\n            }\n            $.ajax({\n              type: \"GET\",\n              url: \"api/v2/families/\" + famid + \"/enumerates/\" + attrid,\n              data: filter,\n              dataType: \"json\",\n              success: function succesRequestEnumsIEnum(result) {\n                var info = [];\n                _.each(result.data.enumItems, function eachResultEnumsIEnum(\n                  enumItem\n                ) {\n                  info.push({\n                    value: enumItem.key,\n                    displayValue: enumItem.label\n                  });\n                });\n                options.success(info);\n              },\n              error: function errorRequestEnumsIEnum(result) {\n                options.error(result);\n              }\n            });\n          }\n        }\n      }\n    });\n    $environment.data(\"kendoComboBox\").list.css(\"min-width\", \"300px\");\n  }\n\n  /**\n   * Initialize list of operator with the type of the selected attribute\n   * @param data list of all operators\n   * @param myChangedAttribute attribute selected\n   * @param operators list to init\n   */\n  function initOperators(data, myChangedAttribute, operators) {\n    if (myChangedAttribute !== null && myChangedAttribute !== undefined) {\n      $.each(data, function eachDataInitOperators(key, value) {\n        var myObject;\n        if (value.compatibleTypes === null) {\n          myObject = {\n            monId: value.id,\n            monTitre: value.title\n          };\n          if (value.typedTitle[myChangedAttribute.type] !== undefined) {\n            myObject.monTitre = value.typedTitle[myChangedAttribute.type];\n          }\n          operators.push(myObject);\n        } else if (\n          /*\n                 check if the type is compatible with the operator\n                 */\n          value.compatibleTypes.indexOf(myChangedAttribute.type) !== -1\n        ) {\n          myObject = {\n            monId: value.id,\n            monTitre: value.title\n          };\n          if (value.typedTitle[myChangedAttribute.type] !== undefined) {\n            myObject.monTitre = value.typedTitle[myChangedAttribute.type];\n          }\n          operators.push(myObject);\n        }\n      });\n    }\n  }\n\n  /**\n   * check if an item is empty/undefined\n   * @param myItem, the item to test\n   * @returns {boolean}\n   */\n  function itemEmpty(myItem) {\n    return (\n      myItem === undefined ||\n      myItem === null ||\n      myItem.value === null ||\n      myItem.value === \"\"\n    );\n  }\n\n  /**\n   * find if current family is a workflow\n   * replace the workflow attribute by a new based on generic workflow attribute\n   * @param $data attribute list\n   * @param $documentController\n   * @returns {boolean}\n   */\n  function findIfWorkflow($data, $documentController) {\n    var $lastAttribute = $data[$data.length - 1];\n    var $revAttribute = $documentController.documentController(\"getValues\")\n      .se_latest;\n    var myObject;\n    if ($lastAttribute.type === \"wid\" && !itemEmpty($revAttribute)) {\n      $data.pop();\n      if ($revAttribute.value === \"yes\") {\n        myObject = {\n          id: $wf.id,\n          label: $wf.label[0],\n          label_parent: $wf.parent.label,\n          type: \"wid\"\n        };\n        $data.push(myObject);\n      } else if ($revAttribute.value === \"no\") {\n        myObject = {\n          id: $wf.id,\n          label: $wf.label[1],\n          label_parent: $wf.parent.label,\n          type: \"wid\"\n        };\n        $data.push(myObject);\n      } else {\n        myObject = {\n          id: $wf.id,\n          label: $wf.label[2],\n          label_parent: $wf.parent.label,\n          type: \"wid\"\n        };\n        $data.push(myObject);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Set keys visibilities\n   * @param myOperator operator used to know if you show or hide the keys field\n   * @param $index index of the field in the table\n   * @param $documentController the document controller of the document\n   */\n  function setVisibility(myOperator, $index, $documentController) {\n    var myKeyword;\n    var minorKeyword;\n    var visible = false;\n    var $environment = null;\n    $(\".dcpAttribute__value[name=se_keys]\").each(function eachKeysSetVisibility(\n      key,\n      value\n    ) {\n      if (key === $index) {\n        $environment = $(this);\n        myKeyword = value;\n      }\n    });\n    minorKeyword = $documentController.documentController(\"getValues\").se_keys[\n      $index\n    ];\n    if (myKeyword !== undefined) {\n      var $label = null;\n\n      _.each(myOperators, function eachOperatorsSetVisibility(data) {\n        if (myOperator !== undefined) {\n          if (myOperator !== null) {\n            if (myOperator.value === data.id) {\n              $label = data.label;\n            }\n          }\n        }\n      });\n\n      if ($label === null) {\n        visible = false;\n      } else {\n        /*\n             check if the operator has a \"right\" operand\n             */\n        visible = $label.indexOf(\"{right}\") !== -1;\n      }\n      var $parent = $environment.closest(\"div\");\n      if (visible) {\n        $parent.show();\n      } else {\n        $parent.hide();\n        myKeyword.value = null;\n        minorKeyword.value = null;\n        minorKeyword.displayValue = null;\n      }\n    }\n  }\n\n  /**\n   * create bootstrap button to show methods associated to current attribute\n   * @param $environment\n   * @param $methods\n   */\n  function createButtonMethods($environment, $methods) {\n    var $myButton = $('<button class=\"funcBtn\">&Sigma;</button>');\n    var $inputs = $($environment.closest(\"div\").find(\"input\"));\n    var $index = $beforeMeth.length;\n    var $methodInput;\n    $beforeMeth[$index] = null;\n\n    $myButton.click(function clickOnMethodsButton() {\n      if ($beforeMeth[$index] == null) {\n        if ($inputs.length === 2) {\n          $($($inputs[0]).closest(\"span\")[0].parentElement).hide();\n          $methodInput = $($inputs[$inputs.length - 1]);\n          $methodInput.show();\n\n          $methodInput.val(\"\");\n          $methodInput.trigger(\"change\");\n        }\n        $beforeMeth[$index] = $inputs[$inputs.length - 1];\n        $environment.kendoComboBox({\n          width: 200,\n          filter: \"contains\",\n          clearButton: false,\n          minLength: 0,\n          dataValueField: \"method\",\n          dataTextField: \"method\",\n          template: \"#: label #\",\n          dataSource: $methods\n        });\n        $checkMeth = true;\n        $environment.data(\"kendoComboBox\").list.css(\"min-width\", \"300px\");\n        $($environment.closest(\"div\").find(\"span\"))\n          .addClass(\"button--on\")\n          .removeClass(\"button--off\");\n      } else {\n        $environment.data(\"kendoComboBox\").destroy();\n        var $nodeToSave = $beforeMeth[$index];\n        var $parent = $environment.parent()[0].parentElement;\n        $parent.children[$inputs.length - 1].remove();\n        $parent.insertBefore($nodeToSave, $parent.lastElementChild);\n        $nodeToSave.style.display = \"block\";\n        if ($inputs.length === 2) {\n          $($inputs[$inputs.length - 1]).hide();\n          $($($inputs[0]).closest(\"span\")[0].parentElement).show();\n          $($nodeToSave).val(\"\");\n          $($nodeToSave).trigger(\"change\");\n          $($inputs[0]).val(\"\");\n        }\n        $checkMeth = false;\n        $beforeMeth[$index] = null;\n      }\n    });\n    $myButton.kendoButton();\n    $myButton.insertAfter($inputs[$inputs.length - 1]);\n  }\n\n  function deleteButtonMethods($environment) {\n    $($environment.closest(\"div\").find(\"button\")).remove();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2VlY2Y2YjcwZGNjZjFhNjEyYmQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvdmVuZG9yL0FuYWtlZW4vU21hcnRTdHJ1Y3R1cmVzL0RzZWFyY2gvUmVuZGVyL3NlYXJjaFVJLmpzPzYzMzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDcmVhdGVkIGJ5IEFsZXggb24gMjcvMDUvMTUuXG4gKi9cbi8qZ2xvYmFsIGRlZmluZSwgcmVxdWlyZSwgY29uc29sZSovXG5cbmNvbnN0IF8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcbmltcG9ydCBpMThuIGZyb20gXCIuL3NlYXJjaENhdGFsb2dcIjtcbmltcG9ydCBzZWFyY2hBdHRyaWJ1dGVzIGZyb20gXCIuL3NlYXJjaEF0dHJpYnV0ZXNcIjtcblxue1xuICB2YXIgbXlPcGVyYXRvcnMgPSBbXTtcbiAgdmFyIHRoaXNPcGVyYXRvcnMgPSBbXTtcbiAgdmFyIG15QXR0cmlidXRlcyA9IFtdO1xuICB2YXIgbXlXb3JrZmxvd3MgPSBbXTtcbiAgdmFyICRhdHRyaWQ7XG4gIHZhciAkd2YgPSBudWxsO1xuICB2YXIgJGJlZm9yZU1ldGggPSBbXTtcbiAgdmFyICRjaGVja01ldGggPSBmYWxzZTtcblxuICB3aW5kb3cuZGNwLmRvY3VtZW50LmRvY3VtZW50Q29udHJvbGxlcihcbiAgICBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICBcInJlYWR5XCIsXG4gICAge1xuICAgICAgbmFtZTogXCJhZGREc2VhcmNoRXZlbnRzXCIsXG4gICAgICBkb2N1bWVudENoZWNrOiBmdW5jdGlvbihkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQucmVuZGVyTW9kZSA9PT0gXCJlZGl0XCIgJiYgZG9jdW1lbnQudHlwZSA9PT0gXCJzZWFyY2hcIjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZ1bmN0aW9uIHByZXBhcmVFdmVudHMoKSB7XG4gICAgICAkKHRoaXMpLmRvY3VtZW50Q29udHJvbGxlcihcbiAgICAgICAgXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgICAgIFwicmVhZHlcIixcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiaW5pdERpdlJlc3VsdC5kc2VhcmNoXCIsXG4gICAgICAgICAgZG9jdW1lbnRDaGVjazogZnVuY3Rpb24gaXNEU2VhcmNoKGRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQudHlwZSA9PT0gXCJzZWFyY2hcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uIGluaXREaXZSZXN1bHRFZGl0KGV2ZW50LCBkb2N1bWVudCkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbmRlck1vZGUgPT09IFwiZWRpdFwiIHx8XG4gICAgICAgICAgICBkb2N1bWVudC5yZW5kZXJNb2RlID09PSBcImNyZWF0ZVwiXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgJHJlc3VsdCA9ICQoXCIucmVzdWx0LS1jb250ZW50XCIpO1xuICAgICAgICAgICAgaWYgKCRyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIHZhciAkZGl2ID0gJCgnPGRpdiBjbGFzcz1cInJlc3VsdC0tY29udGVudFwiLz4nKTtcbiAgICAgICAgICAgICAgJGRpdi5pbnNlcnRBZnRlcigkKFwiLmRvY3VtZW50XCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJChcIi5yZXN1bHQtLWNvbnRlbnRcIikucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICAkKHRoaXMpLmRvY3VtZW50Q29udHJvbGxlcihcbiAgICAgICAgXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgICAgIFwicmVhZHlcIixcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwic2VhcmNoUmVhZHkuZHNlYXJjaFwiLFxuICAgICAgICAgIGRvY3VtZW50Q2hlY2s6IGZ1bmN0aW9uIGlzRFNlYXJjaChkb2N1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnR5cGUgPT09IFwic2VhcmNoXCIgJiYgZG9jdW1lbnQucmVuZGVyTW9kZSA9PT0gXCJlZGl0XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZSBhdHRyaWJ1dGVzLCBvcGVyYXRvcnMsIGFuZCB3b3JrZmxvdyBzdGF0ZXMgbGlzdHNcbiAgICAgICAgICogSW5pdGlhbGl6ZSBrZW5kbyB3aWRnZXRzIGF0IGtleXMgYW5kIG9wZXJhdG9ycyBmaWVsZHNcbiAgICAgICAgICogU2V0IHZpc2liaWxpdGllcyBhY2NvcmRpbmcgdG8gaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHByZXBhcmVTZWFyY2hEb2NVSShldmVudCwgZG9jdW1lbnQpIHtcbiAgICAgICAgICB2YXIgJGRvY3VtZW50Q29udHJvbGxlciA9ICQodGhpcyk7XG4gICAgICAgICAgdmFyIGZhbWlkID0gJCh0aGlzKS5kb2N1bWVudENvbnRyb2xsZXIoXCJnZXRWYWx1ZXNcIikuc2VfZmFtaWQudmFsdWU7XG4gICAgICAgICAgdmFyIHRlc3RXb3JrZmxvdyA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKCQoXCIuZGNwQXJyYXlfX2NvbnRlbnRbZGF0YS1hdHRyaWQ9c2VfdF9kZXRhaWxdXCIpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgIEhpZGUgdGl0bGUgZmllbGQgaWYgaW4gY3JlYXRpb24gbW9kZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgIGlmIChkb2N1bWVudC52aWV3SWQgPT09IFwiIWNvcmVDcmVhdGlvblwiKSB7XG4gICAgICAgICAgICAkKFwiLmRjcEN1c3RvbVRlbXBsYXRlLS1jb250ZW50W2RhdGEtYXR0cmlkPSdiYV90aXRsZSddXCIpLmhpZGUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJChcIi5kY3BDdXN0b21UZW1wbGF0ZS0tY29udGVudFtkYXRhLWF0dHJpZD0nYmFfdGl0bGUnXVwiKS5zaG93KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgJGRvY3VtZW50Q29udHJvbGxlci5kb2N1bWVudENvbnRyb2xsZXIoXG4gICAgICAgICAgICBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICAgICAgICAgIFwiYmVmb3JlQ2xvc2VcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogXCJwcmV2ZW50Q2xvc2UuZHNlYXJjaFwiLFxuICAgICAgICAgICAgICBkb2N1bWVudENoZWNrOiBmdW5jdGlvbiBpc0RzZWFyY2goZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQudHlwZSA9PT0gXCJzZWFyY2hcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHByZXZlbnRDbG9zZURzZWFyY2goKSB7XG4gICAgICAgICAgICAgICQoXCIjZ3JpZFwiKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKGZhbWlkID09PSBudWxsKSB7XG4gICAgICAgICAgICBmYW1pZCA9IFwiXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VhcmNoQXR0cmlidXRlcyhmYW1pZClcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIHJlcXVlc3RBdHRyaWJ1dGVzU1JlYWR5KGRhdGEpIHtcbiAgICAgICAgICAgICAgbXlBdHRyaWJ1dGVzID0gW107XG4gICAgICAgICAgICAgICQuZWFjaChkYXRhLmRhdGEsIGZ1bmN0aW9uIGVhY2hEYXRhQXR0cmlidXRlc1NSZWFkeShrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbXlBdHRyaWJ1dGVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIHVwZGF0ZSB0aGUgd29ya2Zsb3cgYXR0cmlidXRlIGdlbmVyaWMgdmFsdWVcbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGlmIChteUF0dHJpYnV0ZXNbbXlBdHRyaWJ1dGVzLmxlbmd0aCAtIDFdLnR5cGUgPT09IFwid2lkXCIpIHtcbiAgICAgICAgICAgICAgICAkd2YgPSBteUF0dHJpYnV0ZXNbbXlBdHRyaWJ1dGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICR3ZiA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGVzdFdvcmtmbG93ID0gZmluZElmV29ya2Zsb3cobXlBdHRyaWJ1dGVzLCAkZG9jdW1lbnRDb250cm9sbGVyKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiBkb25lRmlyc3RTUmVhZHkoKSB7XG4gICAgICAgICAgICAgICQuZ2V0SlNPTihcbiAgICAgICAgICAgICAgICBcImFwaS92Mi9zbWFydHN0cnVjdHVyZXMvZHNlYXJjaC9vcGVyYXRvcnMvXCIsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVxdWVzdE9wZXJhdG9yc1NSZWFkeShkYXRhKSB7XG4gICAgICAgICAgICAgICAgICBteU9wZXJhdG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgJC5lYWNoKGRhdGEuZGF0YSwgZnVuY3Rpb24gZWFjaERhdGFPcGVyYXRvcnNTUmVhZHkoXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBteU9wZXJhdG9ycy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKS5kb25lKGZ1bmN0aW9uIGRvbmVTZWNvbmRTUmVhZHkoKSB7XG4gICAgICAgICAgICAgICAgdmFyICRyID0gJC5EZWZlcnJlZCgpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0V29ya2Zsb3cpIHtcbiAgICAgICAgICAgICAgICAgICQuZ2V0SlNPTihcbiAgICAgICAgICAgICAgICAgICAgXCJhcGkvdjIvZG9jdW1lbnRzL1wiICtcbiAgICAgICAgICAgICAgICAgICAgICBmYW1pZCArXG4gICAgICAgICAgICAgICAgICAgICAgXCIvd29ya2Zsb3dzL3N0YXRlcy8/YWxsU3RhdGVzPTFcIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVxdWVzdFdvcmtmbG93cyhkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbXlXb3JrZmxvd3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goZGF0YS5kYXRhLnN0YXRlcywgZnVuY3Rpb24gZWFjaFN0YXRlc1NSZWFkeShcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBteVdvcmtmbG93cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAkci5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICRyLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkci5kb25lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgJC5lYWNoKFxuICAgICAgICAgICAgICAgICAgICAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcImdldFZhbHVlc1wiKVxuICAgICAgICAgICAgICAgICAgICAgIC5zZV9hdHRyaWRzLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBlYWNoRG9jQXR0cmlkc1NSZWFkeSgkaW5kZXgsIG15QXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG15Q2hhbmdlZEF0dHJpYnV0ZTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobXlBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtRW1wdHkobXlBdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBteUF0dHJpYnV0ZS52YWx1ZSA9PT0gXCJhY3Rpdml0eVwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXlBdHRyaWJ1dGUudmFsdWUgPT09IFwiZml4c3RhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBteUF0dHJpYnV0ZS52YWx1ZSA9IFwic3RhdGVcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVhY2hQZXJzb0F0dHJpYnV0ZXNTUmVhZHkoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG15QXR0cmlidXRlLnZhbHVlID09PSB2YWx1ZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBteUNoYW5nZWRBdHRyaWJ1dGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHZhbHVlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiB2YWx1ZS5sYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB2YWx1ZS50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChteUF0dHJpYnV0ZS52YWx1ZSA9PT0gXCJzdGF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXlBdHRyaWJ1dGUuZGlzcGxheVZhbHVlID0gdmFsdWUubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBteUF0dHJpYnV0ZS52YWx1ZSA9PT0gXCJzdGF0ZVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXlDaGFuZ2VkQXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG15Q2hhbmdlZEF0dHJpYnV0ZS50eXBlID0gXCJ3aWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbXlDaGFuZ2VkQXR0cmlidXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNPcGVyYXRvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRPcGVyYXRvcnMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG15T3BlcmF0b3JzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBteUNoYW5nZWRBdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNPcGVyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVEcm9wRG93bigkaW5kZXgsIHRoaXNPcGVyYXRvcnMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICQoXCIuZGNwQXR0cmlidXRlX192YWx1ZVtuYW1lPXNlX2tleXNdXCIpLmVhY2goXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVhY2hLZXlzU1JlYWR5KGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyICRlbnZpcm9ubWVudCA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyICRtZXRob2RzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG15QXR0cmlidXRlID0gJGRvY3VtZW50Q29udHJvbGxlci5kb2N1bWVudENvbnRyb2xsZXIoXG4gICAgICAgICAgICAgICAgICAgICAgICBcImdldFZhbHVlc1wiXG4gICAgICAgICAgICAgICAgICAgICAgKS5zZV9hdHRyaWRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbXlPcGVyYXRvciA9ICRkb2N1bWVudENvbnRyb2xsZXIuZG9jdW1lbnRDb250cm9sbGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJnZXRWYWx1ZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICkuc2VfZnVuY3NbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciAkdHlwZSA9IGRlZmluZVR5cGVJZEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIG15QXR0cmlidXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXlBdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZUJ1dHRvbigkZW52aXJvbm1lbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgbXlBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbXlPcGVyYXRvciAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHRoZSB3aWRnZXQgaXMgYSBjb21ib0JveCwgdGhlIGN1cnJlbnQgaW5wdXQgaXMgc2F2ZWQgaW4gdGhlIHBsYWNlIHdoZXJlIGl0IHNob3VsZCBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICFpdGVtRW1wdHkobXlPcGVyYXRvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKG15T3BlcmF0b3IudmFsdWUgPT09IFwiPVwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXlPcGVyYXRvci52YWx1ZSA9PT0gXCIhPVwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXlPcGVyYXRvci52YWx1ZSA9PT0gXCJ+eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkdHlwZSA9PT0gXCJlbnVtW11cIiB8fCAkdHlwZSA9PT0gXCJlbnVtXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJCh0aGlzKS5kYXRhKFwia2VuZG9Db21ib0JveFwiKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZW52aXJvbm1lbnRbMF0uYU5vZGUgPSAkZW52aXJvbm1lbnQucGFyZW50KClbMF0uZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0S2VuZG9Db21ib0JveChmYW1pZCwgJGVudmlyb25tZW50LCAkYXR0cmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHR5cGUgPT09IFwiZG9jaWRcIiB8fCAkdHlwZSA9PT0gXCJkb2NpZFtdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJCh0aGlzKS5kYXRhKFwia2VuZG9Db21ib0JveFwiKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZW52aXJvbm1lbnRbMF0uYU5vZGUgPSAkZW52aXJvbm1lbnQucGFyZW50KClbMF0uZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0S2VuZG9Db21ib0JveFJlbGF0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYW1pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkYXR0cmlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXRlbUVtcHR5KG15T3BlcmF0b3IpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHR5cGUgPT09IFwid2lkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCQodGhpcykuZGF0YShcImtlbmRvQ29tYm9Cb3hcIikgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGVudmlyb25tZW50WzBdLmFOb2RlID0gJGVudmlyb25tZW50LnBhcmVudCgpWzBdLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdEtlbmRvQ29tYm9Cb3hXb3JrZmxvdyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZG9jdW1lbnRDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgd2lkZ2V0IGlzIGEgZGF0ZVBpY2tlciwgYW4gYW5vdGhlciBpbnB1dCBpcyBjcmVhdGVkIHRvIGxpbmsgdGhlIGRhdGVQaWNrZXIgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICFpdGVtRW1wdHkobXlPcGVyYXRvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCR0eXBlID09PSBcImRhdGVcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0eXBlID09PSBcInRpbWVzdGFtcFwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHR5cGUgPT09IFwidGltZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkZW52aXJvbm1lbnQucGFyZW50KClbMF0uY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyICRpbnB1dCA9ICQoXCI8aW5wdXQgLz5cIikuYXR0cih7IHR5cGU6IFwidGV4dFwiIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRpbnB1dC5pbnNlcnRCZWZvcmUoJGVudmlyb25tZW50WzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZW52aXJvbm1lbnQuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRlID0gJCgkZW52aXJvbm1lbnQpLnZhbCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGUgJiYgZGF0ZS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJGlucHV0KS52YWwoZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCR0eXBlID09PSBcImRhdGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdERhdGVQaWNrZXIoJGlucHV0LCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkdHlwZSA9PT0gXCJ0aW1lc3RhbXBcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdERhdGVUaW1lUGlja2VyKCRpbnB1dCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHR5cGUgPT09IFwidGltZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0VGltZVBpY2tlcigkaW5wdXQsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZS5pbmRleE9mKFwiKFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoJGlucHV0KS52YWwoZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICRpbnB1dFswXS5kaXNhYmxlZCA9IFwidHJ1ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogSWYgYXR0cmlidXRlIGhhcyBhIG1ldGhvZCwgZGVmaW5lIGFzc29jaWF0ZWQgZHJvcGRvd24gYW5kIGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG15QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZWFjaEF0dHJpYnV0ZXNTUmVhZHlNZXRob2RzKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobXlBdHRyaWJ1dGUudmFsdWUgPT09IHZhbHVlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkbWV0aG9kcyA9IHZhbHVlLm1ldGhvZHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJG1ldGhvZHMgJiYgJG1ldGhvZHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIi5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRbZGF0YS1hdHRyaWQ9c2Vfa2V5c11cIilbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKFwic3BhbjpmaXJzdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcImJ1dHRvbi0tb25cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoXCJidXR0b24tLW9mZlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiLmRjcEF0dHJpYnV0ZV9fY29udGVudFtkYXRhLWF0dHJpZD1zZV9rZXlzXVwiKVtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoXCJpbnB1dDpmaXJzdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcImJ1dHRvbi0tb25cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoXCJidXR0b24tLW9mZlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlQnV0dG9uTWV0aG9kcygkZW52aXJvbm1lbnQsICRtZXRob2RzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIi5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRbZGF0YS1hdHRyaWQ9c2Vfa2V5c11cIilbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKFwic3BhbjpmaXJzdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcImJ1dHRvbi0tb25cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJidXR0b24tLW9mZlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKFwiLmRjcEF0dHJpYnV0ZV9fY29udGVudFtkYXRhLWF0dHJpZD1zZV9rZXlzXVwiKVtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmQoXCJpbnB1dDpmaXJzdFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcImJ1dHRvbi0tb25cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJidXR0b24tLW9mZlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlQnV0dG9uTWV0aG9kcygkZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICQuZWFjaChcbiAgICAgICAgICAgICAgICAgICAgJGRvY3VtZW50Q29udHJvbGxlci5kb2N1bWVudENvbnRyb2xsZXIoXCJnZXRWYWx1ZXNcIilcbiAgICAgICAgICAgICAgICAgICAgICAuc2VfZnVuY3MsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVhY2hEb2NGdW5jc1NSZWFkeSgkaW5kZXgsIG15T3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRWaXNpYmlsaXR5KG15T3BlcmF0b3IsICRpbmRleCwgJGRvY3VtZW50Q29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICQoXCIuZGNwVGFiX19jb250ZW50XCIpLnJlbW92ZUNsYXNzKFwiZGNwVGFiLS1sb2FkaW5nXCIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uZGl0aW9uVmlzaWJpbGl0eSgkZG9jdW1lbnRDb250cm9sbGVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICAkKHRoaXMpLmRvY3VtZW50Q29udHJvbGxlcihcbiAgICAgICAgXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgICAgIFwiY2hhbmdlXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInNlYXJjaFZpc2liaWxpdHlSZXZDaGFuZ2VkLmRzZWFyY2hcIixcbiAgICAgICAgICBkb2N1bWVudENoZWNrOiBmdW5jdGlvbiBpc0RTZWFyY2goZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC50eXBlID09PSBcInNlYXJjaFwiICYmIGRvY3VtZW50LnJlbmRlck1vZGUgPT09IFwiZWRpdFwiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXR0cmlidXRlQ2hlY2s6IGZ1bmN0aW9uIGlzRmFtaWx5KGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5pZCA9PT0gXCJzZV9sYXRlc3RcIikge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1cGRhdGUgdGhlIGRpc3BsYXlWYWx1ZSBvZiB3b3JrZmxvd3Mgd2hlbiByZXZpc2lvbiB2YWx1ZSBjaGFuZ2VkXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBkaXNwbGF5VmlzUmV2aXNpb25DaGFuZ2UoKSB7XG4gICAgICAgICAgdmFyICRkb2N1bWVudENvbnRyb2xsZXIgPSAkKHRoaXMpO1xuICAgICAgICAgIGZpbmRJZldvcmtmbG93KG15QXR0cmlidXRlcywgJGRvY3VtZW50Q29udHJvbGxlcik7XG5cbiAgICAgICAgICB2YXIgdHlwZVJldmlzaW9uID0gJCh0aGlzKS5kb2N1bWVudENvbnRyb2xsZXIoXCJnZXRWYWx1ZXNcIikuc2VfbGF0ZXN0XG4gICAgICAgICAgICAudmFsdWU7XG4gICAgICAgICAgdmFyIG15T2JqZWN0O1xuICAgICAgICAgIHZhciBkYXRhV29ya2Zsb3cgPSBbXTtcbiAgICAgICAgICBfLmVhY2gobXlXb3JrZmxvd3MsIGZ1bmN0aW9uIGVhY2hQZXJzb1dvcmtmbG93c0xhdGVzdENoYW5nZWQoaXRlbSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0eXBlUmV2aXNpb24gPT09IFwiZml4ZWRcIiB8fFxuICAgICAgICAgICAgICB0eXBlUmV2aXNpb24gPT09IFwiYWxsZml4ZWRcIiB8fFxuICAgICAgICAgICAgICB0eXBlUmV2aXNpb24gPT09IFwibGFzdGZpeGVkXCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBteU9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICBsYWJlbDogaXRlbS5sYWJlbFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpdGVtLmFjdGl2aXR5ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlUmV2aXNpb24gPT09IFwieWVzXCIpIHtcbiAgICAgICAgICAgICAgICBteU9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgbGFiZWw6IGl0ZW0uYWN0aXZpdHlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG15T2JqZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICBsYWJlbDogaXRlbS5sYWJlbCArIFwiL1wiICsgaXRlbS5hY3Rpdml0eVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlUmV2aXNpb24gPT09IFwieWVzXCIpIHtcbiAgICAgICAgICAgICAgICBteU9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgICAgICAgbGFiZWw6IGl0ZW0ubGFiZWxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG15T2JqZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICBsYWJlbDogaXRlbS5sYWJlbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFXb3JrZmxvdy5wdXNoKG15T2JqZWN0KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgICQoXCIuZGNwQXR0cmlidXRlX192YWx1ZVtuYW1lPXNlX2tleXNdXCIpLmVhY2goXG4gICAgICAgICAgICBmdW5jdGlvbiBlYWNoS2V5c0xhdGVzdENoYW5nZWQoKSB7XG4gICAgICAgICAgICAgIGlmICgkKHRoaXMpLmRhdGEoXCJrZW5kb0NvbWJvQm94XCIpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgJGRhdGFTb3VyY2UgPSBuZXcga2VuZG8uZGF0YS5EYXRhU291cmNlKHtcbiAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFXb3JrZmxvdyxcbiAgICAgICAgICAgICAgICAgIGRhdGFWYWx1ZUZpZWxkOiBcImlkXCIsXG4gICAgICAgICAgICAgICAgICBkYXRhVGV4dEZpZWxkOiBcImxhYmVsXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAkKHRoaXMpXG4gICAgICAgICAgICAgICAgICAuZGF0YShcImtlbmRvQ29tYm9Cb3hcIilcbiAgICAgICAgICAgICAgICAgIC5zZXREYXRhU291cmNlKCRkYXRhU291cmNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgICQodGhpcykuZG9jdW1lbnRDb250cm9sbGVyKFxuICAgICAgICBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwic2VhcmNoRnVuY3NBdHRyaWJ1dGVDaGFuZ2VkLmRzZWFyY2hcIixcbiAgICAgICAgICBkb2N1bWVudENoZWNrOiBmdW5jdGlvbiBpc0RTZWFyY2goZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC50eXBlID09PSBcInNlYXJjaFwiICYmIGRvY3VtZW50LnJlbmRlck1vZGUgPT09IFwiZWRpdFwiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXR0cmlidXRlQ2hlY2s6IGZ1bmN0aW9uIGlzRmFtaWx5KGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5pZCA9PT0gXCJzZV9hdHRyaWRzXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogcmUtaW5pdGlhbGl6ZWQgb3IgdXBkYXRlIGEgcmF3IGlmIGFuIGF0dHJpYnV0ZSBjaGFuZ2VkXG4gICAgICAgICAqIEBwYXJhbSBldmVudCB1bnVzZWRcbiAgICAgICAgICogQHBhcmFtIGRvY3VtZW50IHVudXNlZFxuICAgICAgICAgKiBAcGFyYW0gYXR0cmlidXRlIHVudXNlZFxuICAgICAgICAgKiBAcGFyYW0gdmFsdWVzIGN1cnJlbnQsIHByZXZpb3VzIGFuZCBpbml0aWFsIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGlzcGxheUF0dHJDaGFuZ2UoZXZlbnQsIGRvY3VtZW50LCBhdHRyaWJ1dGUsIHZhbHVlcykge1xuICAgICAgICAgIGNvbmRpdGlvblZpc2liaWxpdHkoJCh0aGlzKSk7XG4gICAgICAgICAgdmFyICRub2RlVG9TYXZlID0gbnVsbDtcbiAgICAgICAgICB2YXIgJHBhcmVudCA9IG51bGw7XG4gICAgICAgICAgdmFyICRpbmRleCA9IG51bGw7XG4gICAgICAgICAgdmFyICRtZXRob2RzID0gW107XG4gICAgICAgICAgdmFyIGZhbWlkID0gJCh0aGlzKS5kb2N1bWVudENvbnRyb2xsZXIoXCJnZXRWYWx1ZXNcIikuc2VfZmFtaWQudmFsdWU7XG4gICAgICAgICAgdmFyICRkb2N1bWVudENvbnRyb2xsZXIgPSAkKHRoaXMpO1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gdmFsdWVzLmN1cnJlbnQ7XG4gICAgICAgICAgdmFyIHByZXYgPSB2YWx1ZXMucHJldmlvdXM7XG5cbiAgICAgICAgICB2YXIgJGVudmlyb25tZW50ID0gbnVsbDtcbiAgICAgICAgICB2YXIgJGZ1bmNFbCA9IG51bGw7XG4gICAgICAgICAgdmFyICRkaXNwbGF5QXR0cmlidXRlO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQubGVuZ3RoICE9PSBwcmV2Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAkLmVhY2goY3VycmVudCwgZnVuY3Rpb24gZWFjaEN1cnJlbnRBdHRyaWRzQ2hhbmdlZChrZXkpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50W2tleV0gIT09IHByZXZba2V5XSkge1xuICAgICAgICAgICAgICAkaW5kZXggPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAkKFwiLmRjcEF0dHJpYnV0ZV9fdmFsdWVbbmFtZT1zZV9mdW5jc11cIikuZWFjaChcbiAgICAgICAgICAgIGZ1bmN0aW9uIGVhY2hGdW5jc0F0dHJpZHNDaGFuZ2VkKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJGluZGV4KSB7XG4gICAgICAgICAgICAgICAgJGVudmlyb25tZW50ID0gJCh0aGlzKTtcbiAgICAgICAgICAgICAgICAkZnVuY0VsID0gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgICQoXCIuZGNwQXR0cmlidXRlX192YWx1ZVtuYW1lPXNlX2F0dHJpZHNdXCIpLmVhY2goXG4gICAgICAgICAgICBmdW5jdGlvbiBlYWNoQXR0cmlkc0F0dHJpZHNDaGFuZ2VkKGtleSkge1xuICAgICAgICAgICAgICBpZiAoa2V5ID09PSAkaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAkZGlzcGxheUF0dHJpYnV0ZSA9ICQodGhpcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIHZhciBteUF0dHJpYnV0ZSA9ICRkb2N1bWVudENvbnRyb2xsZXIuZG9jdW1lbnRDb250cm9sbGVyKFwiZ2V0VmFsdWVzXCIpXG4gICAgICAgICAgICAuc2VfYXR0cmlkc1skaW5kZXhdO1xuICAgICAgICAgIHZhciBteU9wZXJhdG9yID0gJGRvY3VtZW50Q29udHJvbGxlci5kb2N1bWVudENvbnRyb2xsZXIoXCJnZXRWYWx1ZXNcIilcbiAgICAgICAgICAgIC5zZV9mdW5jc1skaW5kZXhdO1xuICAgICAgICAgIHZhciBteUNoYW5nZWRBdHRyaWJ1dGU7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZUV4aXN0cyA9IGZhbHNlO1xuICAgICAgICAgIHZhciAkdHlwZTtcbiAgICAgICAgICB2YXIgJHNlS2V5cyA9IFtdO1xuXG4gICAgICAgICAgLy8ga2V5IHZhbHVlcyByZWxvYWRlZFxuICAgICAgICAgIGlmICghaXRlbUVtcHR5KG15T3BlcmF0b3IpICYmICFpdGVtRW1wdHkobXlBdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG15T3BlcmF0b3IudmFsdWUgIT09IFwiaXMgbnVsbFwiICYmXG4gICAgICAgICAgICAgIG15T3BlcmF0b3IudmFsdWUgIT09IFwiaXMgbm90IG51bGxcIiAmJlxuICAgICAgICAgICAgICBteU9wZXJhdG9yLnZhbHVlICE9PSBcIj48XCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcInNldFZhbHVlXCIsIFwic2Vfa2V5c1wiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgaW5kZXg6ICRpbmRleFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRkb2N1bWVudENvbnRyb2xsZXIuZG9jdW1lbnRDb250cm9sbGVyKFwic2V0VmFsdWVcIiwgXCJzZV9rZXlzXCIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJmb29cIixcbiAgICAgICAgICAgICAgICBpbmRleDogJGluZGV4XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfLmVhY2gobXlBdHRyaWJ1dGVzLCBmdW5jdGlvbiBlYWNoQXR0cmlidXRlc0RlZmluZVR5cGVJZChkYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhLmlkID09PSBteUF0dHJpYnV0ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUV4aXN0cyA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVFeGlzdHMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICRzZUtleXMgPSAkKFwiLmRjcEF0dHJpYnV0ZV9fdmFsdWVbbmFtZT1zZV9rZXlzXVwiKTtcbiAgICAgICAgICBpZiAoIWl0ZW1FbXB0eShteUF0dHJpYnV0ZSkgJiYgYXR0cmlidXRlRXhpc3RzKSB7XG4gICAgICAgICAgICAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcbiAgICAgICAgICAgICAgXCJjbGVhbkF0dHJpYnV0ZUVycm9yTWVzc2FnZVwiLFxuICAgICAgICAgICAgICBcInNlX2F0dHJpZHNcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgJC5lYWNoKFxuICAgICAgICAgICAgICAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcImdldFZhbHVlc1wiKS5zZV9hdHRyaWRzLFxuICAgICAgICAgICAgICBmdW5jdGlvbiBlYWNoQXR0cmlkc0F0dHJpYnV0ZXNGYW1pbHljaGFuZ2VkKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJJZCA9IHZhbC52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgJGNvbnRyb2xlID0gMDtcblxuICAgICAgICAgICAgICAgICQuZWFjaChcbiAgICAgICAgICAgICAgICAgIG15QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGVhY2hOZXdEYXRhYXR0cmlidXRlc0F0dHJpYnV0ZXNGYW1pbHljaGFuZ2VkKFxuICAgICAgICAgICAgICAgICAgICBta2V5LFxuICAgICAgICAgICAgICAgICAgICBtdmFsXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJJZCA9PT0gbXZhbC5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICRjb250cm9sZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICgkY29udHJvbGUgPT09IDAgJiYgIWl0ZW1FbXB0eShhdHRySWQpKSB7XG4gICAgICAgICAgICAgICAgICAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcbiAgICAgICAgICAgICAgICAgICAgXCJzZXRBdHRyaWJ1dGVFcnJvck1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzZV9hdHRyaWRzXCIsXG4gICAgICAgICAgICAgICAgICAgIGkxOG4uX19fKFwiSW52YWxpZCBhdHRyaWJ1dGVcIiwgXCJkc2VhcmNoXCIpLFxuICAgICAgICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoJGZ1bmNFbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGlmICgkZnVuY0VsLnBhcmVudEVsZW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICgkZnVuY0VsLnBhcmVudEVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9PT0gXCJoaWRkZW5cIikge1xuICAgICAgICAgICAgICAgICAgJGZ1bmNFbC5wYXJlbnRFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgJGZ1bmNFbC5wYXJlbnRFbGVtZW50Lm9mZnNldFBhcmVudC5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChteUF0dHJpYnV0ZS52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAkLmVhY2gobXlBdHRyaWJ1dGVzLCBmdW5jdGlvbiBlYWNoUGVyc29BdHRyaWJ1dGVzQXR0cmlkc0NoYW5nZWQoXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChteUF0dHJpYnV0ZS52YWx1ZSA9PT0gdmFsdWUuaWQpIHtcbiAgICAgICAgICAgICAgICAgIG15Q2hhbmdlZEF0dHJpYnV0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHZhbHVlLmlkLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogdmFsdWUubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHZhbHVlLnR5cGVcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICBpZiAobXlDaGFuZ2VkQXR0cmlidXRlLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBteUNoYW5nZWRBdHRyaWJ1dGUudHlwZSA9IFwid2lkXCI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG15Q2hhbmdlZEF0dHJpYnV0ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXNPcGVyYXRvcnMgPSBbXTtcbiAgICAgICAgICAgIGluaXRPcGVyYXRvcnMobXlPcGVyYXRvcnMsIG15Q2hhbmdlZEF0dHJpYnV0ZSwgdGhpc09wZXJhdG9ycyk7XG5cbiAgICAgICAgICAgIGlmICgkZW52aXJvbm1lbnQuZGF0YShcImtlbmRvRHJvcERvd25MaXN0XCIpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgJGVudmlyb25tZW50LmRhdGEoXCJrZW5kb0Ryb3BEb3duTGlzdFwiKS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZpbmVEcm9wRG93bigkaW5kZXgsIHRoaXNPcGVyYXRvcnMpO1xuICAgICAgICAgICAgbXlPcGVyYXRvci52YWx1ZSA9IHRoaXNPcGVyYXRvcnNbMF0ubW9uSWQ7XG4gICAgICAgICAgICAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcInNldFZhbHVlXCIsIFwic2VfZnVuY3NcIiwge1xuICAgICAgICAgICAgICB2YWx1ZTogdGhpc09wZXJhdG9yc1swXS5tb25JZCxcbiAgICAgICAgICAgICAgaW5kZXg6ICRpbmRleFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkZW52aXJvbm1lbnQuZGF0YShcImtlbmRvRHJvcERvd25MaXN0XCIpLnNlbGVjdChcbiAgICAgICAgICAgICAgJGVudmlyb25tZW50XG4gICAgICAgICAgICAgICAgLmRhdGEoXCJrZW5kb0Ryb3BEb3duTGlzdFwiKVxuICAgICAgICAgICAgICAgIC51bC5jaGlsZHJlbigpXG4gICAgICAgICAgICAgICAgLmVxKDApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgJHNlS2V5cy5lYWNoKGZ1bmN0aW9uIGVhY2hLZXlzRmlyc3RFbnZBdHRyaWRzQ2hhbmdlZChrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJGluZGV4KSB7XG4gICAgICAgICAgICAgICAgJGVudmlyb25tZW50ID0gJCh0aGlzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGRlbGV0ZSBldmVyeXRoaW5nIHRoZXJlIHdhcyBiZWZvcmUgb24gdGhlIGtleXMgZmllbGRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCRlbnZpcm9ubWVudC5jbG9zZXN0KFwiZGl2XCIpLmZpbmQoXCJidXR0b25cIikubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGlmICgkY2hlY2tNZXRoKSB7XG4gICAgICAgICAgICAgICAgJGVudmlyb25tZW50XG4gICAgICAgICAgICAgICAgICAuY2xvc2VzdChcImRpdlwiKVxuICAgICAgICAgICAgICAgICAgLmZpbmQoXCJidXR0b25cIilcbiAgICAgICAgICAgICAgICAgIC50cmlnZ2VyKFwiY2xpY2tcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZUJ1dHRvbk1ldGhvZHMoJGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgJGVudmlyb25tZW50LnBhcmVudCgpWzBdLmNoaWxkcmVuLmxlbmd0aCA9PT0gMiB8fFxuICAgICAgICAgICAgICAkZW52aXJvbm1lbnQucGFyZW50KClbMF0uY2hpbGRyZW4ubGVuZ3RoID09PSAzXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgZGVzdHJveURhdGVQaWNrZXIoJGVudmlyb25tZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgJGVudmlyb25tZW50LmRhdGEoXCJrZW5kb0NvbWJvQm94XCIpICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgJGVudmlyb25tZW50WzBdLmFOb2RlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAkZW52aXJvbm1lbnQuZGF0YShcImtlbmRvQ29tYm9Cb3hcIikuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAkbm9kZVRvU2F2ZSA9ICRlbnZpcm9ubWVudFswXS5hTm9kZTtcbiAgICAgICAgICAgICAgJHBhcmVudCA9ICRlbnZpcm9ubWVudC5wYXJlbnQoKVswXS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAkcGFyZW50LmZpcnN0RWxlbWVudENoaWxkLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAkcGFyZW50Lmluc2VydEJlZm9yZSgkbm9kZVRvU2F2ZSwgJHBhcmVudC5sYXN0RWxlbWVudENoaWxkKTtcbiAgICAgICAgICAgICAgJG5vZGVUb1NhdmUuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR0eXBlID0gZGVmaW5lVHlwZUlkQXR0cmlidXRlKG15QXR0cmlidXRlLCBteUF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgaWYgKG15QXR0cmlidXRlICE9PSB1bmRlZmluZWQgJiYgbXlPcGVyYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgaWYgdGhlIHdpZGdldCBpcyBhIGNvbWJvQm94LCB0aGUgY3VycmVudCBpbnB1dCBpcyBzYXZlZCBpbiB0aGUgcGxhY2Ugd2hlcmUgaXQgc2hvdWxkIGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFpdGVtRW1wdHkobXlPcGVyYXRvcikgJiZcbiAgICAgICAgICAgICAgICAobXlPcGVyYXRvci52YWx1ZSA9PT0gXCI9XCIgfHxcbiAgICAgICAgICAgICAgICAgIG15T3BlcmF0b3IudmFsdWUgPT09IFwiIT1cIiB8fFxuICAgICAgICAgICAgICAgICAgbXlPcGVyYXRvci52YWx1ZSA9PT0gXCJ+eVwiKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoJHR5cGUgPT09IFwiZW51bVtdXCIgfHwgJHR5cGUgPT09IFwiZW51bVwiKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoJGVudmlyb25tZW50LmRhdGEoXCJrZW5kb0NvbWJvQm94XCIpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNlS2V5cy5lYWNoKGZ1bmN0aW9uIGVhY2hLZXlzSUVudW1BdHRyaWRzQ2hhbmdlZChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAkaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRlbnZpcm9ubWVudFswXS5hTm9kZSA9ICRlbnZpcm9ubWVudC5wYXJlbnQoKVswXS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRLZW5kb0NvbWJvQm94KGZhbWlkLCAkZW52aXJvbm1lbnQsICRhdHRyaWQpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkdHlwZSA9PT0gXCJkb2NpZFwiIHx8ICR0eXBlID09PSBcImRvY2lkW11cIikge1xuICAgICAgICAgICAgICAgICAgaWYgKCRlbnZpcm9ubWVudC5kYXRhKFwia2VuZG9Db21ib0JveFwiKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICRzZUtleXMuZWFjaChmdW5jdGlvbiBlYWNoS2V5c0lSZWxhdGlvbkF0dHJpZHNDaGFuZ2VkKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICRpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGVudmlyb25tZW50WzBdLmFOb2RlID0gJGVudmlyb25tZW50LnBhcmVudCgpWzBdLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdEtlbmRvQ29tYm9Cb3hSZWxhdGlvbihmYW1pZCwgJGVudmlyb25tZW50LCAkYXR0cmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHR5cGUgPT09IFwid2lkXCIpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgkZW52aXJvbm1lbnQuZGF0YShcImtlbmRvQ29tYm9Cb3hcIikgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAkc2VLZXlzLmVhY2goZnVuY3Rpb24gZWFjaEtleXNJV29ya2xvd0F0dHJpZHNDaGFuZ2VkKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICRpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGVudmlyb25tZW50WzBdLmFOb2RlID0gJGVudmlyb25tZW50LnBhcmVudCgpWzBdLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdEtlbmRvQ29tYm9Cb3hXb3JrZmxvdyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJGVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAkZG9jdW1lbnRDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBJZiB0aGUgd2lkZ2V0IGlzIGEgZGF0ZVBpY2tlciwgYW4gYW5vdGhlciBpbnB1dCBpcyBjcmVhdGVkIHRvIGxpbmsgdGhlIGRhdGVQaWNrZXIgd2l0aFxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFpdGVtRW1wdHkobXlPcGVyYXRvcikgJiZcbiAgICAgICAgICAgICAgICAoJHR5cGUgPT09IFwiZGF0ZVwiIHx8ICR0eXBlID09PSBcInRpbWVzdGFtcFwiIHx8ICR0eXBlID09PSBcInRpbWVcIilcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCRlbnZpcm9ubWVudC5wYXJlbnQoKVswXS5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciAkaW5wdXQgPSAkKFwiPGlucHV0IC8+XCIpLmF0dHIoeyB0eXBlOiBcInRleHRcIiB9KTsgLy8gY3JlYXRlIGEgc2Vjb25kIGlucHV0IHRvIHNlcGFyYXRlIHZhbHVlIGFuZCBkaXNwbGF5IHZhbHVlXG4gICAgICAgICAgICAgICAgICAkaW5wdXQuaW5zZXJ0QmVmb3JlKCRlbnZpcm9ubWVudFswXSk7XG4gICAgICAgICAgICAgICAgICAkZW52aXJvbm1lbnQuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgaWYgKCR0eXBlID09PSBcImRhdGVcIikge1xuICAgICAgICAgICAgICAgICAgICBpbml0RGF0ZVBpY2tlcigkaW5wdXQsICRpbmRleCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCR0eXBlID09PSBcInRpbWVzdGFtcFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXREYXRlVGltZVBpY2tlcigkaW5wdXQsICRpbmRleCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCR0eXBlID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgICAgICBpbml0VGltZVBpY2tlcigkaW5wdXQsICRpbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyRpbnB1dFswXS5kaXNhYmxlZCA9IFwidHJ1ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBJZiBhdHRyaWJ1dGUgaGFzIGEgbWV0aG9kLCBkZWZpbmUgYXNzb2NpYXRlZCBkcm9wZG93biBhbmQgYnV0dG9uXG4gICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAkLmVhY2gobXlBdHRyaWJ1dGVzLCBmdW5jdGlvbiBlYWNoQXR0cmlidXRlc1NSZWFkeU1ldGhvZHMoXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChteUF0dHJpYnV0ZS52YWx1ZSA9PT0gdmFsdWUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICRtZXRob2RzID0gdmFsdWUubWV0aG9kcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmICgkbWV0aG9kcyAmJiAkbWV0aG9kcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAkKCQoXCIuZGNwQXR0cmlidXRlX19jb250ZW50W2RhdGEtYXR0cmlkPXNlX2tleXNdXCIpWyRpbmRleF0pXG4gICAgICAgICAgICAgICAgICAuZmluZChcInNwYW46Zmlyc3RcIilcbiAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcImJ1dHRvbi0tb25cIilcbiAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcImJ1dHRvbi0tb2ZmXCIpO1xuICAgICAgICAgICAgICAgICQoJChcIi5kY3BBdHRyaWJ1dGVfX2NvbnRlbnRbZGF0YS1hdHRyaWQ9c2Vfa2V5c11cIilbJGluZGV4XSlcbiAgICAgICAgICAgICAgICAgIC5maW5kKFwiaW5wdXQ6Zmlyc3RcIilcbiAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhcImJ1dHRvbi0tb25cIilcbiAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhcImJ1dHRvbi0tb2ZmXCIpO1xuICAgICAgICAgICAgICAgIGNyZWF0ZUJ1dHRvbk1ldGhvZHMoJGVudmlyb25tZW50LCAkbWV0aG9kcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJCgkKFwiLmRjcEF0dHJpYnV0ZV9fY29udGVudFtkYXRhLWF0dHJpZD1zZV9rZXlzXVwiKVskaW5kZXhdKVxuICAgICAgICAgICAgICAgICAgLmZpbmQoXCJzcGFuOmZpcnN0XCIpXG4gICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoXCJidXR0b24tLW9uXCIpXG4gICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJidXR0b24tLW9mZlwiKTtcbiAgICAgICAgICAgICAgICAkKCQoXCIuZGNwQXR0cmlidXRlX19jb250ZW50W2RhdGEtYXR0cmlkPXNlX2tleXNdXCIpWyRpbmRleF0pXG4gICAgICAgICAgICAgICAgICAuZmluZChcImlucHV0OmZpcnN0XCIpXG4gICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoXCJidXR0b24tLW9uXCIpXG4gICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJidXR0b24tLW9mZlwiKTtcbiAgICAgICAgICAgICAgICBkZWxldGVCdXR0b25NZXRob2RzKCRlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFZpc2liaWxpdHkobXlPcGVyYXRvciwgJGluZGV4LCAkZG9jdW1lbnRDb250cm9sbGVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogcmVsb2FkIHZhbHVlcyAqL1xuICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVFeGlzdHMpIHtcbiAgICAgICAgICAgICAgJGRvY3VtZW50Q29udHJvbGxlci5kb2N1bWVudENvbnRyb2xsZXIoXCJzZXRWYWx1ZVwiLCBcInNlX2tleXNcIiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBcImZvb1wiLFxuICAgICAgICAgICAgICAgIGluZGV4OiAkaW5kZXhcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICRkb2N1bWVudENvbnRyb2xsZXIuZG9jdW1lbnRDb250cm9sbGVyKFwic2V0VmFsdWVcIiwgXCJzZV9hdHRyaWRzXCIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIixcbiAgICAgICAgICAgICAgICBpbmRleDogJGluZGV4XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgIHdpdGhvdXQgYSBzZWxlY3RlZCBhdHRyaWJ1dGUsIHdpZGdldCBzaG91bGQgYmUgZGVsZXRlZFxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICgkZGlzcGxheUF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGlmICgkZGlzcGxheUF0dHJpYnV0ZS5kYXRhKFwia2VuZG9Db21ib0JveFwiKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgJGRpc3BsYXlBdHRyaWJ1dGUuZGF0YShcImtlbmRvQ29tYm9Cb3hcIikudmFsdWUoXCJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgkZnVuY0VsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaWYgKCFpdGVtRW1wdHkoJGZ1bmNFbCkgJiYgJGZ1bmNFbC5kYXRhc2V0LnJvbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIHJvbGUgaXMgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIHdpZGdldFxuICAgICAgICAgICAgICAgICRmdW5jRWwucGFyZW50RWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgICAgICAkZnVuY0VsLnBhcmVudEVsZW1lbnQub2Zmc2V0UGFyZW50LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgICAgICRmdW5jRWwudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIG15T3BlcmF0b3IudmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICRzZUtleXMuZWFjaChmdW5jdGlvbiBlYWNoS2V5c1NlY29uZEVudkF0dHJpZHNDaGFuZ2VkKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICRpbmRleCkge1xuICAgICAgICAgICAgICAgICAgJGVudmlyb25tZW50ID0gJCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIWl0ZW1FbXB0eSgkZW52aXJvbm1lbnQpICYmXG4gICAgICAgICAgICAgICAgKCRlbnZpcm9ubWVudC5wYXJlbnQoKVswXS5jaGlsZHJlbi5sZW5ndGggPT09IDMgfHxcbiAgICAgICAgICAgICAgICAgICRlbnZpcm9ubWVudC5wYXJlbnQoKVswXS5jaGlsZHJlbi5sZW5ndGggPT09IDQpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGRlc3Ryb3lEYXRlUGlja2VyKCRlbnZpcm9ubWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFpdGVtRW1wdHkoJGVudmlyb25tZW50KSAmJlxuICAgICAgICAgICAgICAgICRlbnZpcm9ubWVudC5kYXRhKFwia2VuZG9Db21ib0JveFwiKSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgJGVudmlyb25tZW50WzBdLmFOb2RlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgJGVudmlyb25tZW50LmRhdGEoXCJrZW5kb0NvbWJvQm94XCIpLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAkbm9kZVRvU2F2ZSA9ICRlbnZpcm9ubWVudFswXS5hTm9kZTtcbiAgICAgICAgICAgICAgICAkcGFyZW50ID0gJGVudmlyb25tZW50LnBhcmVudCgpWzBdLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgJHBhcmVudC5maXJzdEVsZW1lbnRDaGlsZC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAkcGFyZW50Lmluc2VydEJlZm9yZSgkbm9kZVRvU2F2ZSwgJHBhcmVudC5sYXN0RWxlbWVudENoaWxkKTtcbiAgICAgICAgICAgICAgICAkbm9kZVRvU2F2ZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNldFZpc2liaWxpdHkobXlPcGVyYXRvciwgJGluZGV4LCAkZG9jdW1lbnRDb250cm9sbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgICQodGhpcykuZG9jdW1lbnRDb250cm9sbGVyKFxuICAgICAgICBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwic2VhcmNoRnVuY3NGYW1pZENoYW5nZWQuZHNlYXJjaFwiLFxuICAgICAgICAgIGRvY3VtZW50Q2hlY2s6IGZ1bmN0aW9uIGlzRFNlYXJjaChkb2N1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnR5cGUgPT09IFwic2VhcmNoXCIgJiYgZG9jdW1lbnQucmVuZGVyTW9kZSA9PT0gXCJlZGl0XCI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdHRyaWJ1dGVDaGVjazogZnVuY3Rpb24gaXNPcGVyYXRvcihhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUuaWQgPT09IFwic2VfZmFtaWRcIikge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1cGRhdGUgYXR0cmlidXRlcyBhbmQgd29ya2Zsb3dzIGxpc3QgaWYgdGhlIGZhbWlseSBjaGFuZ2VcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGRpc3BsYXlGdW5jc0ZhbWlkQ2hhbmdlKCkge1xuICAgICAgICAgIHZhciBmYW1pZCA9ICQodGhpcykuZG9jdW1lbnRDb250cm9sbGVyKFwiZ2V0VmFsdWVzXCIpLnNlX2ZhbWlkLnZhbHVlO1xuICAgICAgICAgIHZhciAkZG9jdW1lbnRDb250cm9sbGVyID0gJCh0aGlzKTtcbiAgICAgICAgICB2YXIgdGVzdFdvcmtmbG93ID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoZmFtaWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGZhbWlkID0gXCJcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWFyY2hBdHRyaWJ1dGVzKGZhbWlkKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gcmVxdWVzdEF0dHJpYnV0ZXNGYW1pZENoYW5nZWQoZGF0YSkge1xuICAgICAgICAgICAgICBteUF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgJC5lYWNoKGRhdGEuZGF0YSwgZnVuY3Rpb24gZWFjaERhdGFBdHRyaWJ1dGVzRmFtaWRDaGFuZ2VkKFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBteUF0dHJpYnV0ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogdXBkYXRlIHRoZSB3b3JrZmxvdyBhdHRyaWJ1dGUgZ2VuZXJpYyB2YWx1ZVxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgaWYgKG15QXR0cmlidXRlc1tteUF0dHJpYnV0ZXMubGVuZ3RoIC0gMV0udHlwZSA9PT0gXCJ3aWRcIikge1xuICAgICAgICAgICAgICAgICR3ZiA9IG15QXR0cmlidXRlc1tteUF0dHJpYnV0ZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgJHdmID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0ZXN0V29ya2Zsb3cgPSBmaW5kSWZXb3JrZmxvdyhteUF0dHJpYnV0ZXMsICRkb2N1bWVudENvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIGRvbmVGYW1pZENoYW5nZWQoKSB7XG4gICAgICAgICAgICAgIGlmICh0ZXN0V29ya2Zsb3cpIHtcbiAgICAgICAgICAgICAgICAkLmdldEpTT04oXG4gICAgICAgICAgICAgICAgICBcImFwaS92Mi9kb2N1bWVudHMvXCIgK1xuICAgICAgICAgICAgICAgICAgICBmYW1pZCArXG4gICAgICAgICAgICAgICAgICAgIFwiL3dvcmtmbG93cy9zdGF0ZXMvP2FsbFN0YXRlcz0xXCIsXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbiByZXF1ZXN0V29ya2Zsb3dzRmFtaWRDaGFuZ2VkKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgbXlXb3JrZmxvd3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKFxuICAgICAgICAgICAgICAgICAgICAgIGRhdGEuZGF0YS5zdGF0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZWFjaERhdGFTdGF0ZXNGYW1pZENoYW5nZWQoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbXlXb3JrZmxvd3MucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICAkKHRoaXMpLmRvY3VtZW50Q29udHJvbGxlcihcbiAgICAgICAgXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgICAgIFwiY2hhbmdlXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInNlYXJjaEZ1bmNzQ29uZGl0aW9uQ2hhbmdlZC5kc2VhcmNoXCIsXG4gICAgICAgICAgZG9jdW1lbnRDaGVjazogZnVuY3Rpb24gaXNEU2VhcmNoKGRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQudHlwZSA9PT0gXCJzZWFyY2hcIiAmJiBkb2N1bWVudC5yZW5kZXJNb2RlID09PSBcImVkaXRcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF0dHJpYnV0ZUNoZWNrOiBmdW5jdGlvbiBpc0ZhbWlseShhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUuaWQgPT09IFwic2Vfb2xcIikge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1cGRhdGUgdmlzaWJpbGl0aWVzIHdoZW4gdGhlIGNvbmRpdGlvbiBmaWVsZCBjaGFuZ2VcbiAgICAgICAgICogaW5pdGlhbGl6ZSBvcGVyYW5kIGZpZWxkIGlmIHN3aXRjaCB0byBwZXJzb25hbGl6YXRpb24gbW9kZVxuICAgICAgICAgKiBAcGFyYW0gZXZlbnQgdW51c2VkXG4gICAgICAgICAqIEBwYXJhbSBkb2N1bWVudCB1bnVzZWRcbiAgICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZSB1bnVzZWRcbiAgICAgICAgICogQHBhcmFtIHZhbHVlcyBjdXJyZW50LCBwcmV2aW91cyBhbmQgaW5pdGlhbFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGlzcGxheUNvbmRpdGlvbkNoYW5nZShldmVudCwgZG9jdW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWVzKSB7XG4gICAgICAgICAgdmFyICRkb2N1bWVudENvbnRyb2xsZXIgPSAkKHRoaXMpO1xuICAgICAgICAgIHZhciAkdGFiT3BlcmFuZHMgPSBbXTtcbiAgICAgICAgICBjb25kaXRpb25WaXNpYmlsaXR5KCRkb2N1bWVudENvbnRyb2xsZXIpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICh2YWx1ZXMuY3VycmVudC52YWx1ZSA9PT0gXCJwZXJzb1wiICYmXG4gICAgICAgICAgICAgIHZhbHVlcy5wcmV2aW91cy52YWx1ZSA9PT0gXCJhbmRcIikgfHxcbiAgICAgICAgICAgIHZhbHVlcy5jdXJyZW50LnZhbHVlID09PSBcImFuZFwiXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAkKFwiLmRjcEF0dHJpYnV0ZV9fdmFsdWVbbmFtZT1zZV9vbHNdXCIpLmVhY2goXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGVhY2hPcGVyYW5kc09sQ2hhbmdlZEFuZCgpIHtcbiAgICAgICAgICAgICAgICAkdGFiT3BlcmFuZHMucHVzaCh7IHZhbHVlOiBcImFuZFwiLCBkaXNwbGF5VmFsdWU6IFwiZXRcIiB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICRkb2N1bWVudENvbnRyb2xsZXIuZG9jdW1lbnRDb250cm9sbGVyKFxuICAgICAgICAgICAgICBcInNldFZhbHVlXCIsXG4gICAgICAgICAgICAgIFwic2Vfb2xzXCIsXG4gICAgICAgICAgICAgICR0YWJPcGVyYW5kc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgKHZhbHVlcy5jdXJyZW50LnZhbHVlID09PSBcInBlcnNvXCIgJiZcbiAgICAgICAgICAgICAgdmFsdWVzLnByZXZpb3VzLnZhbHVlID09PSBcIm9yXCIpIHx8XG4gICAgICAgICAgICB2YWx1ZXMuY3VycmVudC52YWx1ZSA9PT0gXCJvclwiXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAkKFwiLmRjcEF0dHJpYnV0ZV9fdmFsdWVbbmFtZT1zZV9vbHNdXCIpLmVhY2goXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGVhY2hPcGVyYW5kT2xDaGFuZ2VkT3IoKSB7XG4gICAgICAgICAgICAgICAgJHRhYk9wZXJhbmRzLnB1c2goeyB2YWx1ZTogXCJvclwiLCBkaXNwbGF5VmFsdWU6IFwib3VcIiB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICRkb2N1bWVudENvbnRyb2xsZXIuZG9jdW1lbnRDb250cm9sbGVyKFxuICAgICAgICAgICAgICBcInNldFZhbHVlXCIsXG4gICAgICAgICAgICAgIFwic2Vfb2xzXCIsXG4gICAgICAgICAgICAgICR0YWJPcGVyYW5kc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgICQodGhpcykuZG9jdW1lbnRDb250cm9sbGVyKFxuICAgICAgICBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwic2VhcmNoVmlzaWJpbGl0eUZ1bmNzQ2hhbmdlZC5kc2VhcmNoXCIsXG4gICAgICAgICAgZG9jdW1lbnRDaGVjazogZnVuY3Rpb24gaXNEU2VhcmNoKGRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQudHlwZSA9PT0gXCJzZWFyY2hcIiAmJiBkb2N1bWVudC5yZW5kZXJNb2RlID09PSBcImVkaXRcIjtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF0dHJpYnV0ZUNoZWNrOiBmdW5jdGlvbiBpc09wZXJhdG9yKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5pZCA9PT0gXCJzZV9mdW5jc1wiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluaXRpYWxpemUgdGhlIGtleXdvcmRzIGZpZWxkIHdpZGdldCBhY2NvcmRpbmcgdG8gdGhlIGF0dHJpYnV0ZSdzIHR5cGVcbiAgICAgICAgICogQHBhcmFtIHZhbHVlcyBjdXJyZW50LCBwcmV2aW91cyBhbmQgaW5pdGlhbCBvZiB0aGUgY2hhbmdlZCBmdW5jXG4gICAgICAgICAqIEBwYXJhbSBldmVudCB1bnVzZWRcbiAgICAgICAgICogQHBhcmFtIGRvY3VtZW50IHVudXNlZFxuICAgICAgICAgKiBAcGFyYW0gYXR0cmlidXRlIHVudXNlZFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGlzcGxheUZ1bmNDaGFuZ2UoZXZlbnQsIGRvY3VtZW50LCBhdHRyaWJ1dGUsIHZhbHVlcykge1xuICAgICAgICAgIHZhciAkcGFyZW50O1xuICAgICAgICAgIHZhciAkbm9kZVRvU2F2ZTtcbiAgICAgICAgICB2YXIgJGluZGV4ID0gbnVsbDtcbiAgICAgICAgICB2YXIgJGRvY3VtZW50Q29udHJvbGxlciA9ICQodGhpcyk7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSB2YWx1ZXMuY3VycmVudDtcbiAgICAgICAgICB2YXIgcHJldiA9IHZhbHVlcy5wcmV2aW91cztcbiAgICAgICAgICAkLmVhY2goY3VycmVudCwgZnVuY3Rpb24gZWFjaEN1cnJlbnRGdW5jc0NoYW5nZWQoa2V5KSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFtrZXldICE9PSBwcmV2W2tleV0pIHtcbiAgICAgICAgICAgICAgJGluZGV4ID0ga2V5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBteU9wZXJhdG9yID0gJGRvY3VtZW50Q29udHJvbGxlci5kb2N1bWVudENvbnRyb2xsZXIoXCJnZXRWYWx1ZXNcIilcbiAgICAgICAgICAgIC5zZV9mdW5jc1skaW5kZXhdO1xuICAgICAgICAgIHZhciBteUF0dHJpYnV0ZSA9ICRkb2N1bWVudENvbnRyb2xsZXIuZG9jdW1lbnRDb250cm9sbGVyKFwiZ2V0VmFsdWVzXCIpXG4gICAgICAgICAgICAuc2VfYXR0cmlkc1skaW5kZXhdO1xuICAgICAgICAgIHZhciBmYW1pZCA9ICQodGhpcykuZG9jdW1lbnRDb250cm9sbGVyKFwiZ2V0VmFsdWVzXCIpLnNlX2ZhbWlkLnZhbHVlO1xuICAgICAgICAgIHZhciAkZW52aXJvbm1lbnQgPSBudWxsO1xuICAgICAgICAgIHZhciAkc2VLZXlzID0gJChcIi5kY3BBdHRyaWJ1dGVfX3ZhbHVlW25hbWU9c2Vfa2V5c11cIik7XG4gICAgICAgICAgdmFyICR0eXBlO1xuXG4gICAgICAgICAgJHNlS2V5cy5lYWNoKGZ1bmN0aW9uIGVhY2hLZXlzRnVuY3NDaGFuZ2VkKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJGluZGV4KSB7XG4gICAgICAgICAgICAgICRlbnZpcm9ubWVudCA9ICQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWl0ZW1FbXB0eSgkZW52aXJvbm1lbnQpICYmXG4gICAgICAgICAgICAkZW52aXJvbm1lbnQuY2xvc2VzdChcImRpdlwiKS5maW5kKFwiYnV0dG9uXCIpLmxlbmd0aCAhPT0gMFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKCRjaGVja01ldGgpIHtcbiAgICAgICAgICAgICAgJGVudmlyb25tZW50XG4gICAgICAgICAgICAgICAgLmNsb3Nlc3QoXCJkaXZcIilcbiAgICAgICAgICAgICAgICAuZmluZChcImJ1dHRvblwiKVxuICAgICAgICAgICAgICAgIC50cmlnZ2VyKFwiY2xpY2tcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgJHR5cGUgPSBkZWZpbmVUeXBlSWRBdHRyaWJ1dGUobXlBdHRyaWJ1dGUsIG15QXR0cmlidXRlcyk7XG4gICAgICAgICAgLy8ga2V5IHZhbHVlcyByZWxvYWRlZFxuICAgICAgICAgIGlmICghaXRlbUVtcHR5KG15T3BlcmF0b3IpKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG15T3BlcmF0b3IudmFsdWUgIT09IFwiaXMgbnVsbFwiICYmXG4gICAgICAgICAgICAgIG15T3BlcmF0b3IudmFsdWUgIT09IFwiaXMgbm90IG51bGxcIiAmJlxuICAgICAgICAgICAgICBteU9wZXJhdG9yLnZhbHVlICE9PSBcIj48XCJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAvLyAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcInNldFZhbHVlXCIsIFwic2Vfa2V5c1wiLCB7dmFsdWU6IFwiXCIsIGluZGV4OiAkaW5kZXh9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRkb2N1bWVudENvbnRyb2xsZXIuZG9jdW1lbnRDb250cm9sbGVyKFwic2V0VmFsdWVcIiwgXCJzZV9rZXlzXCIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogXCJcIixcbiAgICAgICAgICAgICAgICBpbmRleDogJGluZGV4XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoJHR5cGUgPT09IFwiZGF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgJGVudmlyb25tZW50XG4gICAgICAgICAgICAgICAgICAucGFyZW50KClcbiAgICAgICAgICAgICAgICAgIC5maW5kKFwiLmstcGlja2VyLXdyYXAgaW5wdXRcIilcbiAgICAgICAgICAgICAgICAgIC52YWwoXCJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyICRpbml0ID0gZmFsc2U7XG4gICAgICAgICAgaWYgKG15QXR0cmlidXRlICE9PSB1bmRlZmluZWQgJiYgbXlPcGVyYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgaWYgdGhlIHdpZGdldCBpcyBhIGNvbWJvQm94LCB0aGUgY3VycmVudCBpbnB1dCBpcyBzYXZlZCBpbiB0aGUgcGxhY2Ugd2hlcmUgaXQgc2hvdWxkIGJlXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhaXRlbUVtcHR5KG15T3BlcmF0b3IpICYmXG4gICAgICAgICAgICAgICEkY2hlY2tNZXRoICYmXG4gICAgICAgICAgICAgICgkdHlwZSA9PT0gXCJlbnVtW11cIiB8fFxuICAgICAgICAgICAgICAgICR0eXBlID09PSBcImVudW1cIiB8fFxuICAgICAgICAgICAgICAgICR0eXBlID09PSBcImRvY2lkXCIgfHxcbiAgICAgICAgICAgICAgICAkdHlwZSA9PT0gXCJkb2NpZFtdXCIgfHxcbiAgICAgICAgICAgICAgICAkdHlwZSA9PT0gXCJ3aWRcIilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIWl0ZW1FbXB0eSgkZW52aXJvbm1lbnQpICYmXG4gICAgICAgICAgICAgICAgJGVudmlyb25tZW50LmRhdGEoXCJrZW5kb0NvbWJvQm94XCIpICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAkZW52aXJvbm1lbnRbMF0uYU5vZGUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAkZW52aXJvbm1lbnQuZGF0YShcImtlbmRvQ29tYm9Cb3hcIikuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICRub2RlVG9TYXZlID0gJGVudmlyb25tZW50WzBdLmFOb2RlO1xuICAgICAgICAgICAgICAgICRwYXJlbnQgPSAkZW52aXJvbm1lbnQucGFyZW50KClbMF0ucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICAkcGFyZW50LmZpcnN0RWxlbWVudENoaWxkLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICRwYXJlbnQuaW5zZXJ0QmVmb3JlKCRub2RlVG9TYXZlLCAkcGFyZW50Lmxhc3RFbGVtZW50Q2hpbGQpO1xuICAgICAgICAgICAgICAgICRub2RlVG9TYXZlLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgIWl0ZW1FbXB0eShteU9wZXJhdG9yKSAmJlxuICAgICAgICAgICAgICAobXlPcGVyYXRvci52YWx1ZSA9PT0gXCI9XCIgfHxcbiAgICAgICAgICAgICAgICBteU9wZXJhdG9yLnZhbHVlID09PSBcIiE9XCIgfHxcbiAgICAgICAgICAgICAgICBteU9wZXJhdG9yLnZhbHVlID09PSBcIn55XCIpICYmXG4gICAgICAgICAgICAgICgkdHlwZSA9PT0gXCJlbnVtW11cIiB8fCAkdHlwZSA9PT0gXCJlbnVtXCIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKCRlbnZpcm9ubWVudC5kYXRhKFwia2VuZG9Db21ib0JveFwiKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgJHNlS2V5cy5lYWNoKGZ1bmN0aW9uIGVhY2hLZXlzSUVudW1GdW5jc0NoYW5nZWQoa2V5KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAkaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgJGVudmlyb25tZW50WzBdLmFOb2RlID0gJGVudmlyb25tZW50LnBhcmVudCgpWzBdLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBpbml0S2VuZG9Db21ib0JveChmYW1pZCwgJGVudmlyb25tZW50LCAkYXR0cmlkKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgIWl0ZW1FbXB0eShteU9wZXJhdG9yKSAmJlxuICAgICAgICAgICAgICAoJHR5cGUgPT09IFwiZG9jaWRcIiB8fCAkdHlwZSA9PT0gXCJkb2NpZFtdXCIpICYmXG4gICAgICAgICAgICAgIChteU9wZXJhdG9yLnZhbHVlID09PSBcIj1cIiB8fFxuICAgICAgICAgICAgICAgIG15T3BlcmF0b3IudmFsdWUgPT09IFwiIT1cIiB8fFxuICAgICAgICAgICAgICAgIG15T3BlcmF0b3IudmFsdWUgPT09IFwifnlcIilcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAoJGVudmlyb25tZW50LmRhdGEoXCJrZW5kb0NvbWJvQm94XCIpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAkc2VLZXlzLmVhY2goZnVuY3Rpb24gZWFjaEtleXNJUmVsYXRpb25GdW5jc0NoYW5nZWQoa2V5KSB7XG4gICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAkaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgJGVudmlyb25tZW50WzBdLmFOb2RlID0gJGVudmlyb25tZW50LnBhcmVudCgpWzBdLmZpcnN0RWxlbWVudENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBpbml0S2VuZG9Db21ib0JveFJlbGF0aW9uKGZhbWlkLCAkZW52aXJvbm1lbnQsICRhdHRyaWQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAhaXRlbUVtcHR5KG15T3BlcmF0b3IpICYmXG4gICAgICAgICAgICAgICR0eXBlID09PSBcIndpZFwiICYmXG4gICAgICAgICAgICAgIChteU9wZXJhdG9yLnZhbHVlID09PSBcIj1cIiB8fCBteU9wZXJhdG9yLnZhbHVlID09PSBcIiE9XCIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKCRlbnZpcm9ubWVudC5kYXRhKFwia2VuZG9Db21ib0JveFwiKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgJHNlS2V5cy5lYWNoKGZ1bmN0aW9uIGVhY2hLZXlzSVdvcmtmbG93c0Z1bmNzQ2hhbmdlZChrZXkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICRpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAkZW52aXJvbm1lbnRbMF0uYU5vZGUgPSAkZW52aXJvbm1lbnQucGFyZW50KClbMF0uZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIGluaXRLZW5kb0NvbWJvQm94V29ya2Zsb3coXG4gICAgICAgICAgICAgICAgICAgICAgJGVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgICAgICAgICRkb2N1bWVudENvbnRyb2xsZXJcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhaXRlbUVtcHR5KG15T3BlcmF0b3IpICYmXG4gICAgICAgICAgICAgICgkdHlwZSA9PT0gXCJkYXRlXCIgfHwgJHR5cGUgPT09IFwidGltZXN0YW1wXCIgfHwgJHR5cGUgPT09IFwidGltZVwiKSAmJlxuICAgICAgICAgICAgICAobXlPcGVyYXRvci52YWx1ZSAhPT0gXCJpcyBudWxsXCIgJiZcbiAgICAgICAgICAgICAgICBteU9wZXJhdG9yLnZhbHVlICE9PSBcImlzIG5vdCBudWxsXCIgJiZcbiAgICAgICAgICAgICAgICBteU9wZXJhdG9yLnZhbHVlICE9PSBcIj48XCIpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKCRlbnZpcm9ubWVudC5wYXJlbnQoKVswXS5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgJGlucHV0ID0gJChcIjxpbnB1dCAvPlwiKS5hdHRyKHsgdHlwZTogXCJ0ZXh0XCIgfSk7IC8vIGNyZWF0ZSBhIHNlY29uZCBpbnB1dCB0byBzZXBhcmF0ZSB2YWx1ZSBhbmQgZGlzcGxheSB2YWx1ZVxuICAgICAgICAgICAgICAgICRpbnB1dC5pbnNlcnRCZWZvcmUoJGVudmlyb25tZW50WzBdKTtcbiAgICAgICAgICAgICAgICAkZW52aXJvbm1lbnQuaGlkZSgpO1xuICAgICAgICAgICAgICAgIGlmICgkdHlwZSA9PT0gXCJkYXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgIGluaXREYXRlUGlja2VyKCRpbnB1dCwgJGluZGV4KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCR0eXBlID09PSBcInRpbWVzdGFtcFwiKSB7XG4gICAgICAgICAgICAgICAgICBpbml0RGF0ZVRpbWVQaWNrZXIoJGlucHV0LCAkaW5kZXgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHR5cGUgPT09IFwidGltZVwiKSB7XG4gICAgICAgICAgICAgICAgICBpbml0VGltZVBpY2tlcigkaW5wdXQsICRpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vJGlucHV0WzBdLmRpc2FibGVkID0gXCJ0cnVlXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCRlbnZpcm9ubWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICB3aXRob3V0IGEgc2VsZWN0ZWQgYXR0cmlidXRlIHdpZGdldCBzaG91bGQgYmUgZGVsZXRlZFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhJGluaXQgJiZcbiAgICAgICAgICAgICAgIWl0ZW1FbXB0eSgkZW52aXJvbm1lbnQpICYmXG4gICAgICAgICAgICAgICgkZW52aXJvbm1lbnQucGFyZW50KClbMF0uY2hpbGRyZW4ubGVuZ3RoID09PSAyIHx8XG4gICAgICAgICAgICAgICAgJGVudmlyb25tZW50LnBhcmVudCgpWzBdLmNoaWxkcmVuLmxlbmd0aCA9PT0gMylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBkZXN0cm95RGF0ZVBpY2tlcigkZW52aXJvbm1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAhJGluaXQgJiZcbiAgICAgICAgICAgICAgIWl0ZW1FbXB0eSgkZW52aXJvbm1lbnQpICYmXG4gICAgICAgICAgICAgICRlbnZpcm9ubWVudC5kYXRhKFwia2VuZG9Db21ib0JveFwiKSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICRlbnZpcm9ubWVudFswXS5hTm9kZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgJGVudmlyb25tZW50LmRhdGEoXCJrZW5kb0NvbWJvQm94XCIpLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgJG5vZGVUb1NhdmUgPSAkZW52aXJvbm1lbnRbMF0uYU5vZGU7XG4gICAgICAgICAgICAgICRwYXJlbnQgPSAkZW52aXJvbm1lbnQucGFyZW50KClbMF0ucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgJHBhcmVudC5maXJzdEVsZW1lbnRDaGlsZC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgJHBhcmVudC5pbnNlcnRCZWZvcmUoJG5vZGVUb1NhdmUsICRwYXJlbnQubGFzdEVsZW1lbnRDaGlsZCk7XG4gICAgICAgICAgICAgICRub2RlVG9TYXZlLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChteU9wZXJhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNldFZpc2liaWxpdHkobXlPcGVyYXRvciwgJGluZGV4LCAkZG9jdW1lbnRDb250cm9sbGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgICQodGhpcykuZG9jdW1lbnRDb250cm9sbGVyKFxuICAgICAgICBcImFkZEV2ZW50TGlzdGVuZXJcIixcbiAgICAgICAgXCJhdHRyaWJ1dGVBcnJheUNoYW5nZVwiLFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJzZWFyY2hGdW5jc0FkZEFycmF5LmRzZWFyY2hcIixcbiAgICAgICAgICBkb2N1bWVudENoZWNrOiBmdW5jdGlvbiBpc0RTZWFyY2goZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC50eXBlID09PSBcInNlYXJjaFwiICYmIGRvY3VtZW50LnJlbmRlck1vZGUgPT09IFwiZWRpdFwiO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXR0cmlidXRlQ2hlY2s6IGZ1bmN0aW9uIGlzQXJyYXkoYXR0cmlidXRlKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlLmlkID09PSBcInNlX3RfZGV0YWlsXCIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IGFsbCBwcmV2aW91cyBwYXJhbWV0ZXJzIHRvIGEgbmV3IGxpbmVcbiAgICAgICAgICogYXMgdmlzaWJpbGl0aWVzLCBidXR0b24gZGVsZXRpb24uLi5cbiAgICAgICAgICogQHBhcmFtIGV2ZW50IHVudXNlZFxuICAgICAgICAgKiBAcGFyYW0gZG9jdW1lbnQgdW51c2VkXG4gICAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dCB1bnVzZWRcbiAgICAgICAgICogQHBhcmFtIHR5cGUgdW51c2VkXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb25zIHJhdyBvZiB0aGUgYnV0dG9uIHRvIGRlbGV0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGlzcGxheUNoYW5nZShldmVudCwgZG9jdW1lbnQsIGF0dHJpYnV0LCB0eXBlLCBvcHRpb25zKSB7XG4gICAgICAgICAgdmFyICRkb2N1bWVudENvbnRyb2xsZXIgPSAkKHRoaXMpO1xuICAgICAgICAgIHZhciAkZW52aXJvbm1lbnQgPSBudWxsO1xuICAgICAgICAgIGlmICh0eXBlID09PSBcImFkZExpbmVcIikge1xuICAgICAgICAgICAgdmFyICRmdW5jRWw7XG4gICAgICAgICAgICB2YXIgJGZ1bmNJbnB1dCA9ICRkb2N1bWVudENvbnRyb2xsZXIuZG9jdW1lbnRDb250cm9sbGVyKFwiZ2V0VmFsdWVzXCIpXG4gICAgICAgICAgICAgIC5zZV9mdW5jc1tvcHRpb25zXTtcbiAgICAgICAgICAgICQoXCIuZGNwQXR0cmlidXRlX192YWx1ZVtuYW1lPXNlX2Z1bmNzXVwiKS5lYWNoKFxuICAgICAgICAgICAgICBmdW5jdGlvbiBlYWNoRnVuY3NBcnJheU1vZGlmaWVkKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgJGZ1bmNFbCA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoJGZ1bmNFbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICRmdW5jRWwub2Zmc2V0UGFyZW50LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgICAkZnVuY0VsLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgJGZ1bmNJbnB1dC52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkKFwiLmRjcEF0dHJpYnV0ZV9fdmFsdWVbbmFtZT1zZV9rZXlzXVwiKS5lYWNoKFxuICAgICAgICAgICAgICBmdW5jdGlvbiBlYWNoS2V5c0FycmF5TW9kaWZpZWQoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgJGVudmlyb25tZW50ID0gJCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgbXlPcGVyYXRvciA9ICRkb2N1bWVudENvbnRyb2xsZXIuZG9jdW1lbnRDb250cm9sbGVyKFwiZ2V0VmFsdWVzXCIpXG4gICAgICAgICAgICAgIC5zZV9mdW5jc1tvcHRpb25zXTtcbiAgICAgICAgICAgIHNldFZpc2liaWxpdHkobXlPcGVyYXRvciwgb3B0aW9ucywgJGRvY3VtZW50Q29udHJvbGxlcik7XG4gICAgICAgICAgICBkZWxldGVCdXR0b24oJGVudmlyb25tZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uZGl0aW9uVmlzaWJpbGl0eSgkZG9jdW1lbnRDb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9XG4gICk7XG5cbiAgd2luZG93LmRjcC5kb2N1bWVudC5kb2N1bWVudENvbnRyb2xsZXIoXG4gICAgXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgXCJjbG9zZVwiLFxuICAgIHtcbiAgICAgIG5hbWU6IFwicmVtb3ZlRHNlYXJjaEV2ZW50XCIsXG4gICAgICBkb2N1bWVudENoZWNrOiBmdW5jdGlvbihkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQudHlwZSA9PT0gXCJzZWFyY2hcIjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcbiAgICAgICR0aGlzLmRvY3VtZW50Q29udHJvbGxlcihcInJlbW92ZUV2ZW50TGlzdGVuZXJcIiwgXCIuZHNlYXJjaFwiKTtcbiAgICB9XG4gICk7XG5cbiAgLyoqXG4gICAqIHNldCB2aXNpYmlsaXRpZXMgYWNjb3JkaW5nIHRvIGNvbmRpdGlvbiBmaWVsZCAvIHN3YXAgY2xhc3NlcyB0byAgbWFrZSBjc3MgZWFzaWVyXG4gICAqIHNldCB2aXNpYmlsaXRpZXMgb2YgcGFyZW50aGVzaXMgYW5kIG9wZXJhbmQgZmllbGRzXG4gICAqIEBwYXJhbSAkZG9jdW1lbnRDb250cm9sbGVyIG9mIGN1cnJlbnQgZG9jdW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIGNvbmRpdGlvblZpc2liaWxpdHkoJGRvY3VtZW50Q29udHJvbGxlcikge1xuICAgIHZhciAkY29uZGl0aW9uID0gJGRvY3VtZW50Q29udHJvbGxlci5kb2N1bWVudENvbnRyb2xsZXIoXCJnZXRWYWx1ZXNcIikuc2Vfb2w7XG4gICAgaWYgKCRjb25kaXRpb24gJiYgJGNvbmRpdGlvbi52YWx1ZSAhPT0gXCJwZXJzb1wiKSB7XG4gICAgICAkKFwiLmRjcEFycmF5X19jb250ZW50W2RhdGEtYXR0cmlkPXNlX3RfZGV0YWlsXSA+IHRhYmxlXCIpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhcImRjcEFycmF5LS1jdXN0b21cIilcbiAgICAgICAgLmFkZENsYXNzKFwiZGNwQXJyYXktLW5vdF9jdXN0b21cIik7XG4gICAgICAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcImhpZGVBdHRyaWJ1dGVcIiwgXCJzZV9vbHNcIik7XG4gICAgICAkKCcuZGNwQXJyYXlfX2hlYWRfX2NlbGxbZGF0YS1hdHRyaWQ9XCJzZV9vbHNcIl0nKS5oaWRlKCk7XG4gICAgICAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcImhpZGVBdHRyaWJ1dGVcIiwgXCJzZV9yaWdodHBcIik7XG4gICAgICAkKCcuZGNwQXJyYXlfX2hlYWRfX2NlbGxbZGF0YS1hdHRyaWQ9XCJzZV9yaWdodHBcIl0nKS5oaWRlKCk7XG4gICAgICAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcImhpZGVBdHRyaWJ1dGVcIiwgXCJzZV9sZWZ0cFwiKTtcbiAgICAgICQoJy5kY3BBcnJheV9faGVhZF9fY2VsbFtkYXRhLWF0dHJpZD1cInNlX2xlZnRwXCJdJykuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKFwiLmRjcEFycmF5X19jb250ZW50W2RhdGEtYXR0cmlkPXNlX3RfZGV0YWlsXSA+IHRhYmxlXCIpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhcImRjcEFycmF5LS1ub3RfY3VzdG9tXCIpXG4gICAgICAgIC5hZGRDbGFzcyhcImRjcEFycmF5LS1jdXN0b21cIik7XG4gICAgICAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcInNob3dBdHRyaWJ1dGVcIiwgXCJzZV9vbHNcIik7XG4gICAgICAkKCcuZGNwQXJyYXlfX2hlYWRfX2NlbGxbZGF0YS1hdHRyaWQ9XCJzZV9vbHNcIl0nKS5zaG93KCk7XG4gICAgICAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcInNob3dBdHRyaWJ1dGVcIiwgXCJzZV9yaWdodHBcIik7XG4gICAgICAkKCcuZGNwQXJyYXlfX2hlYWRfX2NlbGxbZGF0YS1hdHRyaWQ9XCJzZV9yaWdodHBcIl0nKS5zaG93KCk7XG4gICAgICAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcInNob3dBdHRyaWJ1dGVcIiwgXCJzZV9sZWZ0cFwiKTtcbiAgICAgICQoJy5kY3BBcnJheV9faGVhZF9fY2VsbFtkYXRhLWF0dHJpZD1cInNlX2xlZnRwXCJdJykuc2hvdygpO1xuICAgICAgJChcIi5kY3BBdHRyaWJ1dGVfX3ZhbHVlW25hbWU9c2Vfb2xzXVwiKS5lYWNoKGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICAgIGlmIChrZXkgPT09IDApIHtcbiAgICAgICAgICAkKHZhbC5jbG9zZXN0KFwiZGl2XCIpKS5oaWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJCh2YWwuY2xvc2VzdChcImRpdlwiKSkuc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogcmVtb3ZlIGEgYm9vdHN0cmFwIGJ1dHRvbiBmcm9tIGEgc3BlY2lmaWMgcGxhY2VcbiAgICogQHBhcmFtICRlbnZpcm9ubWVudCBwbGFjZSB0byByZW1vdmUgdGhlIGJ1dHRvblxuICAgKi9cbiAgZnVuY3Rpb24gZGVsZXRlQnV0dG9uKCRlbnZpcm9ubWVudCkge1xuICAgIHZhciAkcGFyZW50ID0gJCgkZW52aXJvbm1lbnQpLmNsb3Nlc3QoXCJkaXZcIik7XG4gICAgaWYgKCRwYXJlbnRbMF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyICRidXR0b24gPSAkcGFyZW50WzBdLmxhc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAkYnV0dG9uLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBpbml0aWFsaXplIGEgZGF0ZVBpY2tlciBrZW5kbyB3aWRnZXRcbiAgICogQHBhcmFtICRlbnZpcm9ubWVudCBwbGFjZSB0byBwdXQgdGhlIHdpZGdldFxuICAgKiBAcGFyYW0gJGluZGV4IGluZGV4IG9mIHRoZSByYXdcbiAgICovXG4gIGZ1bmN0aW9uIGluaXREYXRlUGlja2VyKCRlbnZpcm9ubWVudCwgJGluZGV4KSB7XG4gICAgJGVudmlyb25tZW50LmtlbmRvRGF0ZVBpY2tlcih7XG4gICAgICBwYXJzZUZvcm1hdHM6IFtcInl5eXktTU0tZGRcIl0sXG4gICAgICBmb3JtYXQ6IG51bGwsIC8vIHN0YW5kYXJkIGZvcm1hdCBkZXBlbmRzIG9mIHRoZSB1c2VyJ3MgbGFuZ2FnZVxuICAgICAgLypcbiAgICAgICAgICAgICB0cmlnZ2VyIGEgZm9uY3Rpb24gdGhhdCBjaGFuZ2UgdGhlIHZhbHVlIG9mIHRoZSBkYXRlIGZyb20gdGhlIGRpc3BsYXlWYWx1ZSBhY2NvcmRpbmcgdG8gSVNPIDg2MDFcbiAgICAgICAgICAgICAqL1xuICAgICAgY2hhbmdlOiBmdW5jdGlvbiBjaGFuZ2VEYXRlUGlja2VyVmFsdXJlKCkge1xuICAgICAgICB2YXIga2V5d29yZE9iaiA9IG51bGw7XG4gICAgICAgICQoXCIuZGNwQXR0cmlidXRlX192YWx1ZVtuYW1lPXNlX2tleXNdXCIpLmVhY2goXG4gICAgICAgICAgZnVuY3Rpb24gZWFjaEtleXNDaGFuZ2VEYXRlUGlja2VyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICRpbmRleCkge1xuICAgICAgICAgICAgICBrZXl3b3JkT2JqID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICB2YXIgZGF0ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgaWYgKGRhdGUpIHtcbiAgICAgICAgICB2YXIgam91cjtcbiAgICAgICAgICBpZiAoZGF0ZS5nZXREYXRlKCkgLyAxMCA8IDEpIHtcbiAgICAgICAgICAgIGpvdXIgPSBcIjBcIiArIGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICAgIH0gZWxzZSBqb3VyID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgICAgICAgdmFyIG1vaXM7XG4gICAgICAgICAgaWYgKChkYXRlLmdldE1vbnRoKCkgKyAxKSAvIDEwIDwgMSkge1xuICAgICAgICAgICAgbW9pcyA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XG4gICAgICAgICAgICBtb2lzID0gXCIwXCIgKyBtb2lzO1xuICAgICAgICAgIH0gZWxzZSBtb2lzID0gZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgICAgICAgICAkKGtleXdvcmRPYmopLnZhbChkYXRlLmdldEZ1bGxZZWFyKCkgKyBcIi1cIiArIG1vaXMgKyBcIi1cIiArIGpvdXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICQoa2V5d29yZE9iaikudmFsKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgICQoa2V5d29yZE9iaikudHJpZ2dlcihcImNoYW5nZVwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBpbml0aWFsaXplIGEgZGF0ZVBpY2tlciBrZW5kbyB3aWRnZXRcbiAgICogQHBhcmFtICRlbnZpcm9ubWVudCBwbGFjZSB0byBwdXQgdGhlIHdpZGdldFxuICAgKiBAcGFyYW0gJGluZGV4IGluZGV4IG9mIHRoZSByYXdcbiAgICovXG4gIGZ1bmN0aW9uIGluaXREYXRlVGltZVBpY2tlcigkZW52aXJvbm1lbnQsICRpbmRleCkge1xuICAgICRlbnZpcm9ubWVudC5rZW5kb0RhdGVUaW1lUGlja2VyKHtcbiAgICAgIHBhcnNlRm9ybWF0czogW1xuICAgICAgICBcInl5eXktTU0tZGQgSEg6bW06c3NcIixcbiAgICAgICAgXCJ5eXl5LU1NLWRkVEhIOm1tOnNzXCIsXG4gICAgICAgIFwieXl5eS1NTS1kZFRISDptbVwiXG4gICAgICBdLFxuICAgICAgdGltZUZvcm1hdDogXCJISDptbVwiLFxuICAgICAgZm9ybWF0OiBudWxsLCAvLyBzdGFuZGFyZCBmb3JtYXQgZGVwZW5kcyBvZiB0aGUgdXNlcidzIGxhbmdhZ2VcbiAgICAgIC8qXG4gICAgICAgICAgICAgdHJpZ2dlciBhIGZvbmN0aW9uIHRoYXQgY2hhbmdlIHRoZSB2YWx1ZSBvZiB0aGUgZGF0ZSBmcm9tIHRoZSBkaXNwbGF5VmFsdWUgYWNjb3JkaW5nIHRvIElTTyA4NjAxXG4gICAgICAgICAgICAgKi9cbiAgICAgIGNoYW5nZTogZnVuY3Rpb24gY2hhbmdlRGF0ZVBpY2tlclZhbHVyZSgpIHtcbiAgICAgICAgdmFyIGtleXdvcmRPYmogPSBudWxsO1xuICAgICAgICAkKFwiLmRjcEF0dHJpYnV0ZV9fdmFsdWVbbmFtZT1zZV9rZXlzXVwiKS5lYWNoKFxuICAgICAgICAgIGZ1bmN0aW9uIGVhY2hLZXlzQ2hhbmdlRGF0ZVBpY2tlcihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAkaW5kZXgpIHtcbiAgICAgICAgICAgICAga2V5d29yZE9iaiA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgdGltZURhdGUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgIHZhciBzVGltZURhdGUgPSBcIlwiO1xuICAgICAgICBpZiAodGltZURhdGUpIHtcbiAgICAgICAgICBzVGltZURhdGUgPVxuICAgICAgICAgICAgdGltZURhdGUuZ2V0RnVsbFllYXIoKSArXG4gICAgICAgICAgICBcIi1cIiArXG4gICAgICAgICAgICBzZWFyY2hQYWROdW1iZXIodGltZURhdGUuZ2V0TW9udGgoKSArIDEpICtcbiAgICAgICAgICAgIFwiLVwiICtcbiAgICAgICAgICAgIHNlYXJjaFBhZE51bWJlcih0aW1lRGF0ZS5nZXREYXRlKCkpICtcbiAgICAgICAgICAgIFwiIFwiICtcbiAgICAgICAgICAgIHNlYXJjaFBhZE51bWJlcih0aW1lRGF0ZS5nZXRIb3VycygpKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICBzZWFyY2hQYWROdW1iZXIodGltZURhdGUuZ2V0TWludXRlcygpKSArXG4gICAgICAgICAgICBcIjpcIiArXG4gICAgICAgICAgICBzZWFyY2hQYWROdW1iZXIodGltZURhdGUuZ2V0U2Vjb25kcygpKTtcbiAgICAgICAgfVxuICAgICAgICAkKGtleXdvcmRPYmopLnZhbChzVGltZURhdGUpO1xuICAgICAgICAkKGtleXdvcmRPYmopLnRyaWdnZXIoXCJjaGFuZ2VcIik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogaW5pdGlhbGl6ZSBhIGRhdGVQaWNrZXIga2VuZG8gd2lkZ2V0XG4gICAqIEBwYXJhbSAkZW52aXJvbm1lbnQgcGxhY2UgdG8gcHV0IHRoZSB3aWRnZXRcbiAgICogQHBhcmFtICRpbmRleCBpbmRleCBvZiB0aGUgcmF3XG4gICAqL1xuICBmdW5jdGlvbiBpbml0VGltZVBpY2tlcigkZW52aXJvbm1lbnQsICRpbmRleCkge1xuICAgICRlbnZpcm9ubWVudC5rZW5kb1RpbWVQaWNrZXIoe1xuICAgICAgdGltZURhdGFGb3JtYXQ6IFtcIkhIOm1tXCIsIFwiSEg6bW06c3NcIl0sXG4gICAgICBmb3JtYXQ6IG51bGwsIC8vIHN0YW5kYXJkIGZvcm1hdCBkZXBlbmRzIG9mIHRoZSB1c2VyJ3MgbGFuZ2FnZVxuICAgICAgLypcbiAgICAgICAgICAgICB0cmlnZ2VyIGEgZm9uY3Rpb24gdGhhdCBjaGFuZ2UgdGhlIHZhbHVlIG9mIHRoZSBkYXRlIGZyb20gdGhlIGRpc3BsYXlWYWx1ZSBhY2NvcmRpbmcgdG8gSVNPIDg2MDFcbiAgICAgICAgICAgICAqL1xuICAgICAgY2hhbmdlOiBmdW5jdGlvbiBjaGFuZ2VEYXRlUGlja2VyVmFsdXJlKCkge1xuICAgICAgICB2YXIga2V5d29yZE9iaiA9IG51bGw7XG4gICAgICAgICQoXCIuZGNwQXR0cmlidXRlX192YWx1ZVtuYW1lPXNlX2tleXNdXCIpLmVhY2goXG4gICAgICAgICAgZnVuY3Rpb24gZWFjaEtleXNDaGFuZ2VEYXRlUGlja2VyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICRpbmRleCkge1xuICAgICAgICAgICAgICBrZXl3b3JkT2JqID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICB2YXIgdGltZURhdGUgPSB0aGlzLnZhbHVlKCk7XG4gICAgICAgIHZhciB0aW1lID0gXCJcIjtcbiAgICAgICAgaWYgKHRpbWVEYXRlKSB7XG4gICAgICAgICAgdGltZSA9XG4gICAgICAgICAgICBzZWFyY2hQYWROdW1iZXIodGltZURhdGUuZ2V0SG91cnMoKSkgK1xuICAgICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgICAgc2VhcmNoUGFkTnVtYmVyKHRpbWVEYXRlLmdldE1pbnV0ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgJChrZXl3b3JkT2JqKS52YWwodGltZSk7XG4gICAgICAgICQoa2V5d29yZE9iaikudHJpZ2dlcihcImNoYW5nZVwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlYXJjaFBhZE51bWJlcihudW1iZXIpIHtcbiAgICBpZiAobnVtYmVyIDwgMTApIHtcbiAgICAgIHJldHVybiBcIjBcIiArIG51bWJlcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiByZW1vdmUgYSBkYXRlUGlja2VyIGtlbmRvIHdpZGdldCBmcm9tIHRoZSBET01cbiAgICogQHBhcmFtICRlbnZpcm9ubWVudCBwbGFjZSB0byBkZWxldGUgdGhlIHdpZGdldFxuICAgKi9cbiAgZnVuY3Rpb24gZGVzdHJveURhdGVQaWNrZXIoJGVudmlyb25tZW50KSB7XG4gICAgdmFyICRwYXJlbnQgPSAkZW52aXJvbm1lbnQucGFyZW50KClbMF07XG4gICAgJHBhcmVudC5jaGlsZHJlblswXS5yZW1vdmUoKTtcbiAgICAkZW52aXJvbm1lbnQuc2hvdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIGRlZmluZSBhdHRyaWJ1dGUgdHlwZSBhbmQgaWRcbiAgICogQHBhcmFtIG15QXR0cmlidXRlIHNlbGVjdGVkIGF0dHJpYnV0ZVxuICAgKiBAcGFyYW0gbXlBdHRyaWJ1dGVzIGxpc3Qgb2YgYXR0cmlidXRlc1xuICAgKi9cbiAgZnVuY3Rpb24gZGVmaW5lVHlwZUlkQXR0cmlidXRlKG15QXR0cmlidXRlLCBteUF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgJGF0eXBlID0gXCJcIjtcbiAgICBpZiAoIWl0ZW1FbXB0eShteUF0dHJpYnV0ZSkpIHtcbiAgICAgIF8uZWFjaChteUF0dHJpYnV0ZXMsIGZ1bmN0aW9uIGVhY2hBdHRyaWJ1dGVzRGVmaW5lVHlwZUlkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuaWQgPT09IG15QXR0cmlidXRlLnZhbHVlKSB7XG4gICAgICAgICAgJGF0eXBlID0gZGF0YS50eXBlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgICRhdHRyaWQgPSBteUF0dHJpYnV0ZS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGF0eXBlID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKCEkYXR5cGUgJiYgbXlBdHRyaWJ1dGUudmFsdWUgPT09IFwiYWN0aXZpdHlcIikge1xuICAgICAgJGF0eXBlID0gXCJ3aWRcIjtcbiAgICAgIG15QXR0cmlidXRlLnZhbHVlID0gXCJzdGF0ZVwiO1xuICAgIH1cblxuICAgIHJldHVybiAkYXR5cGU7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB3b3JrZmxvdyBrZXl3b3JkcyBrZW5kb0NvbWJvQm94IHdpZGdldFxuICAgKiBAcGFyYW0gJGVudmlyb25tZW50IHBsYWNlIHRvIHB1dCB0aGUgd2lkZ2V0XG4gICAqIEBwYXJhbSAkZG9jdW1lbnRDb250cm9sbGVyIG9mIGN1cnJlbnQgZG9jdW1lbnRcbiAgICovXG4gIGZ1bmN0aW9uIGluaXRLZW5kb0NvbWJvQm94V29ya2Zsb3coJGVudmlyb25tZW50LCAkZG9jdW1lbnRDb250cm9sbGVyKSB7XG4gICAgdmFyIHR5cGVSZXZpc2lvbiA9ICRkb2N1bWVudENvbnRyb2xsZXIuZG9jdW1lbnRDb250cm9sbGVyKFwiZ2V0VmFsdWVzXCIpXG4gICAgICAuc2VfbGF0ZXN0LnZhbHVlO1xuICAgIHZhciBteU9iamVjdDtcbiAgICB2YXIgZGF0YVdvcmtmbG93ID0gW107XG4gICAgLypcbiAgICAgICAgIGluaXRpYWxpemUgdGhlIHdvcmtmbG93cyBrZXlzIGxpc3QsIGRlcGVuZGluZyBvbiB0aGUgcmV2aXNpb24gdmFsdWVcbiAgICAgICAgICovXG4gICAgXy5lYWNoKG15V29ya2Zsb3dzLCBmdW5jdGlvbiBlYWNoV29ya2Zsb3dzSVdvcmtmbG93KGl0ZW0pIHtcbiAgICAgIGlmIChcbiAgICAgICAgdHlwZVJldmlzaW9uID09PSBcImZpeGVkXCIgfHxcbiAgICAgICAgdHlwZVJldmlzaW9uID09PSBcImFsbGZpeGVkXCIgfHxcbiAgICAgICAgdHlwZVJldmlzaW9uID09PSBcImxhc3RmaXhlZFwiXG4gICAgICApIHtcbiAgICAgICAgbXlPYmplY3QgPSB7XG4gICAgICAgICAgaWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgbGFiZWw6IGl0ZW0ubGFiZWxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5hY3Rpdml0eSAhPT0gXCJcIikge1xuICAgICAgICBpZiAodHlwZVJldmlzaW9uID09PSBcInllc1wiKSB7XG4gICAgICAgICAgbXlPYmplY3QgPSB7XG4gICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgIGxhYmVsOiBpdGVtLmFjdGl2aXR5XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBteU9iamVjdCA9IHtcbiAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgbGFiZWw6IGl0ZW0ubGFiZWwgKyBcIi9cIiArIGl0ZW0uYWN0aXZpdHlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZVJldmlzaW9uID09PSBcInllc1wiKSB7XG4gICAgICAgICAgbXlPYmplY3QgPSB7XG4gICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgIGxhYmVsOiBpdGVtLmxhYmVsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBteU9iamVjdCA9IHtcbiAgICAgICAgICAgIGlkOiBpdGVtLmlkLFxuICAgICAgICAgICAgbGFiZWw6IGl0ZW0ubGFiZWxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkYXRhV29ya2Zsb3cucHVzaChteU9iamVjdCk7XG4gICAgfSk7XG4gICAgJGVudmlyb25tZW50LmtlbmRvQ29tYm9Cb3goe1xuICAgICAgd2lkdGg6IDIwMCxcbiAgICAgIGZpbHRlcjogXCJjb250YWluc1wiLFxuICAgICAgY2xlYXJCdXR0b246IGZhbHNlLFxuICAgICAgbWluTGVuZ3RoOiAwLFxuICAgICAgZGF0YVZhbHVlRmllbGQ6IFwiaWRcIixcbiAgICAgIGRhdGFUZXh0RmllbGQ6IFwibGFiZWxcIixcbiAgICAgIGRhdGFTb3VyY2U6IGRhdGFXb3JrZmxvd1xuICAgIH0pO1xuICAgICRlbnZpcm9ubWVudC5kYXRhKFwia2VuZG9Db21ib0JveFwiKS5saXN0LmNzcyhcIm1pbi13aWR0aFwiLCBcIjMwMHB4XCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIGRlZmluZSB0aGUgZHJvcERvd25MaXN0IGtlbmRvIHdpZGdldCBvbiB0aGUgb3BlcmF0b3IgZmllbGQgQCB0aGUgc3BlY2lmaWVkIGluZGV4XG4gICAqIEBwYXJhbSAkaW5kZXggaW5kZXggb2YgdGhlIHJhd1xuICAgKiBAcGFyYW0gbXlPcGVyYXRvcnMgbGlzdCAgb2Ygb3BlcmF0b3JzXG4gICAqL1xuICBmdW5jdGlvbiBkZWZpbmVEcm9wRG93bigkaW5kZXgsIG15T3BlcmF0b3JzKSB7XG4gICAgJChcIi5kY3BBdHRyaWJ1dGVfX3ZhbHVlW25hbWU9c2VfZnVuY3NdXCIpLmVhY2goZnVuY3Rpb24gZWFjaEZ1bmNzRGVmaW5lREQoXG4gICAgICBrZXlcbiAgICApIHtcbiAgICAgIGlmIChrZXkgPT09ICRpbmRleCkge1xuICAgICAgICAvKlxuICAgICAgICAgICAgICAgICB1cGRhdGUgb3IgY3JlYXRlIHRoZSB3aWRnZXRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgaWYgKCQodGhpcykuZGF0YShcImtlbmRvRHJvcERvd25MaXN0XCIpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgJGRhdGFTb3VyY2UgPSBuZXcga2VuZG8uZGF0YS5EYXRhU291cmNlKHtcbiAgICAgICAgICAgIGRhdGE6IG15T3BlcmF0b3JzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgJCh0aGlzKVxuICAgICAgICAgICAgLmRhdGEoXCJrZW5kb0Ryb3BEb3duTGlzdFwiKVxuICAgICAgICAgICAgLnNldERhdGFTb3VyY2UoJGRhdGFTb3VyY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICQodGhpcykua2VuZG9Ecm9wRG93bkxpc3Qoe1xuICAgICAgICAgICAgZGF0YVNvdXJjZTogbXlPcGVyYXRvcnMsXG4gICAgICAgICAgICBkYXRhVGV4dEZpZWxkOiBcIm1vblRpdHJlXCIsXG4gICAgICAgICAgICBkYXRhVmFsdWVGaWVsZDogXCJtb25JZFwiLFxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8c3BhbiBjbGFzcz1cImstc3RhdGUtZGVmYXVsdFwiPiM9IG1vblRpdHJlICM8L3NwYW4+JyxcbiAgICAgICAgICAgIHZhbHVlVGVtcGxhdGU6IFwiPHNwYW4+ICM9IG1vblRpdHJlIyA8L3NwYW4+XCIsXG4gICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgICQodGhpcylcbiAgICAgICAgICAgIC5kYXRhKFwia2VuZG9Ecm9wRG93bkxpc3RcIilcbiAgICAgICAgICAgIC5saXN0LmNzcyhcIm1pbi13aWR0aFwiLCBcIjMwMHB4XCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAgICAgICAgIHJlbW92ZSBib290c3RyYXAgYnV0dG9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgIGlmICgkKHRoaXMpWzBdLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAkKHRoaXMpWzBdLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudC5sYXN0RWxlbWVudENoaWxkLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSByZWxhdGlvbiBrZXl3b3JkcyBrZW5kb0NvbWJvQm94IHdpZGdldFxuICAgKiBAcGFyYW0gZmFtaWQgaWQgb2YgdGhlIGN1cnJlbnQgZmFtaWx5XG4gICAqIEBwYXJhbSAkZW52aXJvbm1lbnQgcGxhY2UgdG8gcHV0IHRoZSB3aWRnZXRcbiAgICogQHBhcmFtIGF0dHJpZCBpZCBvZiB0aGUgY3VycmVudCBhdHRyaWJ1dGVcbiAgICovXG4gIGZ1bmN0aW9uIGluaXRLZW5kb0NvbWJvQm94UmVsYXRpb24oZmFtaWQsICRlbnZpcm9ubWVudCwgYXR0cmlkKSB7XG4gICAgJGVudmlyb25tZW50LmtlbmRvQ29tYm9Cb3goe1xuICAgICAgd2lkdGg6IDIwMCxcbiAgICAgIGZpbHRlcjogXCJjb250YWluc1wiLFxuICAgICAgZGF0YVZhbHVlRmllbGQ6IFwiaWRcIixcbiAgICAgIGRhdGFUZXh0RmllbGQ6IFwiaHRtbFRpdGxlXCIsXG4gICAgICBjbGVhckJ1dHRvbjogZmFsc2UsXG4gICAgICBkYXRhU291cmNlOiB7XG4gICAgICAgIHR5cGU6IFwianNvblwiLFxuICAgICAgICBzZXJ2ZXJGaWx0ZXJpbmc6IHRydWUsXG4gICAgICAgIHRyYW5zcG9ydDoge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIGZ1bmN0aW9uIHRvIGdldCBkYXRhXG4gICAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgcGFyYW0gdG8gcmV0dXJuIHN1Y2Nlc3Mgb3IgZXJyb3IgZGF0YVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWREYXRhc0lSZWxhdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRhdGEuZmlsdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGF0YS5maWx0ZXIuZmlsdGVyc1swXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5kYXRhLmZpbHRlci5maWx0ZXJzWzBdLnZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgICB1cmw6XG4gICAgICAgICAgICAgICAgXCJhcGkvdjIvc21hcnRzdHJ1Y3R1cmVzL2RzZWFyY2gvcmVsYXRpb25zL1wiICtcbiAgICAgICAgICAgICAgICBmYW1pZCArXG4gICAgICAgICAgICAgICAgXCIvXCIgK1xuICAgICAgICAgICAgICAgIGF0dHJpZCArXG4gICAgICAgICAgICAgICAgXCI/c2xpY2U9MjUmb2Zmc2V0PTAma2V5d29yZD1cIiArXG4gICAgICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIHN1Y2Nlc1JlcXVlc3RSZWxhdGlvbnNJUmVsYXRpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBbXTtcbiAgICAgICAgICAgICAgICBfLmVhY2gocmVzdWx0LmRhdGEsIGZ1bmN0aW9uIGVhY2hSZXN1bHRSZWxhdGlvbnNJUmVsYXRpb24oXG4gICAgICAgICAgICAgICAgICBpdGVtXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBpbmZvLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgaHRtbFRpdGxlOiBpdGVtLmh0bWxUaXRsZVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdWNjZXNzKGluZm8pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24gZXJyb3JSZXF1ZXN0UmVsYXRpb25zSVJlbGF0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3IocmVzdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgJGVudmlyb25tZW50LmRhdGEoXCJrZW5kb0NvbWJvQm94XCIpLmxpc3QuY3NzKFwibWluLXdpZHRoXCIsIFwiMzAwcHhcIik7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBlbnVtIGtleXdvcmRzIGtlbmRvQ29tYm9Cb3ggd2lkZ2V0XG4gICAqIEBwYXJhbSBmYW1pZCBpZCBvZiB0aGUgY3VycmVudCBmYW1pbHlcbiAgICogQHBhcmFtICRlbnZpcm9ubWVudCBwbGFjZSB0byBwdXQgdGhlIHdpZGdldFxuICAgKiBAcGFyYW0gYXR0cmlkIGlkIG9mIHRoZSBjdXJyZW50IGF0dHJpYnV0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaW5pdEtlbmRvQ29tYm9Cb3goZmFtaWQsICRlbnZpcm9ubWVudCwgYXR0cmlkKSB7XG4gICAgJGVudmlyb25tZW50LmtlbmRvQ29tYm9Cb3goe1xuICAgICAgd2lkdGg6IDIwMCxcbiAgICAgIGZpbHRlcjogXCJjb250YWluc1wiLFxuICAgICAgY2xlYXJCdXR0b246IGZhbHNlLFxuICAgICAgZGF0YVZhbHVlRmllbGQ6IFwidmFsdWVcIixcbiAgICAgIGRhdGFUZXh0RmllbGQ6IFwiZGlzcGxheVZhbHVlXCIsXG4gICAgICBkYXRhU291cmNlOiB7XG4gICAgICAgIHR5cGU6IFwianNvblwiLFxuICAgICAgICBzZXJ2ZXJGaWx0ZXJpbmc6IHRydWUsXG4gICAgICAgIHRyYW5zcG9ydDoge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIGZ1bmN0aW9uIHRvIGdldCBkYXRhXG4gICAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgcGFyYW0gdG8gcmV0dXJuIHN1Y2Nlc3Mgb3IgZXJyb3IgZGF0YVxuICAgICAgICAgICAqL1xuICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWREYXRhc0lFbnVtKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBvcHRpb25zLmRhdGEuZmlsdGVyICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgb3B0aW9ucy5kYXRhLmZpbHRlci5maWx0ZXJzWzBdICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBmaWx0ZXIgPSB7XG4gICAgICAgICAgICAgICAga2V5d29yZDogb3B0aW9ucy5kYXRhLmZpbHRlci5maWx0ZXJzWzBdLnZhbHVlLFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiBvcHRpb25zLmRhdGEuZmlsdGVyLmZpbHRlcnNbMF0ub3BlcmF0b3JcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICAgIHVybDogXCJhcGkvdjIvZmFtaWxpZXMvXCIgKyBmYW1pZCArIFwiL2VudW1lcmF0ZXMvXCIgKyBhdHRyaWQsXG4gICAgICAgICAgICAgIGRhdGE6IGZpbHRlcixcbiAgICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxuICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNSZXF1ZXN0RW51bXNJRW51bShyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IFtdO1xuICAgICAgICAgICAgICAgIF8uZWFjaChyZXN1bHQuZGF0YS5lbnVtSXRlbXMsIGZ1bmN0aW9uIGVhY2hSZXN1bHRFbnVtc0lFbnVtKFxuICAgICAgICAgICAgICAgICAgZW51bUl0ZW1cbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGluZm8ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlbnVtSXRlbS5rZXksXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlWYWx1ZTogZW51bUl0ZW0ubGFiZWxcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3VjY2VzcyhpbmZvKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yUmVxdWVzdEVudW1zSUVudW0ocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5lcnJvcihyZXN1bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICAkZW52aXJvbm1lbnQuZGF0YShcImtlbmRvQ29tYm9Cb3hcIikubGlzdC5jc3MoXCJtaW4td2lkdGhcIiwgXCIzMDBweFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGxpc3Qgb2Ygb3BlcmF0b3Igd2l0aCB0aGUgdHlwZSBvZiB0aGUgc2VsZWN0ZWQgYXR0cmlidXRlXG4gICAqIEBwYXJhbSBkYXRhIGxpc3Qgb2YgYWxsIG9wZXJhdG9yc1xuICAgKiBAcGFyYW0gbXlDaGFuZ2VkQXR0cmlidXRlIGF0dHJpYnV0ZSBzZWxlY3RlZFxuICAgKiBAcGFyYW0gb3BlcmF0b3JzIGxpc3QgdG8gaW5pdFxuICAgKi9cbiAgZnVuY3Rpb24gaW5pdE9wZXJhdG9ycyhkYXRhLCBteUNoYW5nZWRBdHRyaWJ1dGUsIG9wZXJhdG9ycykge1xuICAgIGlmIChteUNoYW5nZWRBdHRyaWJ1dGUgIT09IG51bGwgJiYgbXlDaGFuZ2VkQXR0cmlidXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICQuZWFjaChkYXRhLCBmdW5jdGlvbiBlYWNoRGF0YUluaXRPcGVyYXRvcnMoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgbXlPYmplY3Q7XG4gICAgICAgIGlmICh2YWx1ZS5jb21wYXRpYmxlVHlwZXMgPT09IG51bGwpIHtcbiAgICAgICAgICBteU9iamVjdCA9IHtcbiAgICAgICAgICAgIG1vbklkOiB2YWx1ZS5pZCxcbiAgICAgICAgICAgIG1vblRpdHJlOiB2YWx1ZS50aXRsZVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHZhbHVlLnR5cGVkVGl0bGVbbXlDaGFuZ2VkQXR0cmlidXRlLnR5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG15T2JqZWN0Lm1vblRpdHJlID0gdmFsdWUudHlwZWRUaXRsZVtteUNoYW5nZWRBdHRyaWJ1dGUudHlwZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wZXJhdG9ycy5wdXNoKG15T2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICBjaGVjayBpZiB0aGUgdHlwZSBpcyBjb21wYXRpYmxlIHdpdGggdGhlIG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgdmFsdWUuY29tcGF0aWJsZVR5cGVzLmluZGV4T2YobXlDaGFuZ2VkQXR0cmlidXRlLnR5cGUpICE9PSAtMVxuICAgICAgICApIHtcbiAgICAgICAgICBteU9iamVjdCA9IHtcbiAgICAgICAgICAgIG1vbklkOiB2YWx1ZS5pZCxcbiAgICAgICAgICAgIG1vblRpdHJlOiB2YWx1ZS50aXRsZVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHZhbHVlLnR5cGVkVGl0bGVbbXlDaGFuZ2VkQXR0cmlidXRlLnR5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG15T2JqZWN0Lm1vblRpdHJlID0gdmFsdWUudHlwZWRUaXRsZVtteUNoYW5nZWRBdHRyaWJ1dGUudHlwZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wZXJhdG9ycy5wdXNoKG15T2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGNoZWNrIGlmIGFuIGl0ZW0gaXMgZW1wdHkvdW5kZWZpbmVkXG4gICAqIEBwYXJhbSBteUl0ZW0sIHRoZSBpdGVtIHRvIHRlc3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBmdW5jdGlvbiBpdGVtRW1wdHkobXlJdGVtKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIG15SXRlbSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICBteUl0ZW0gPT09IG51bGwgfHxcbiAgICAgIG15SXRlbS52YWx1ZSA9PT0gbnVsbCB8fFxuICAgICAgbXlJdGVtLnZhbHVlID09PSBcIlwiXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGN1cnJlbnQgZmFtaWx5IGlzIGEgd29ya2Zsb3dcbiAgICogcmVwbGFjZSB0aGUgd29ya2Zsb3cgYXR0cmlidXRlIGJ5IGEgbmV3IGJhc2VkIG9uIGdlbmVyaWMgd29ya2Zsb3cgYXR0cmlidXRlXG4gICAqIEBwYXJhbSAkZGF0YSBhdHRyaWJ1dGUgbGlzdFxuICAgKiBAcGFyYW0gJGRvY3VtZW50Q29udHJvbGxlclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGZpbmRJZldvcmtmbG93KCRkYXRhLCAkZG9jdW1lbnRDb250cm9sbGVyKSB7XG4gICAgdmFyICRsYXN0QXR0cmlidXRlID0gJGRhdGFbJGRhdGEubGVuZ3RoIC0gMV07XG4gICAgdmFyICRyZXZBdHRyaWJ1dGUgPSAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcImdldFZhbHVlc1wiKVxuICAgICAgLnNlX2xhdGVzdDtcbiAgICB2YXIgbXlPYmplY3Q7XG4gICAgaWYgKCRsYXN0QXR0cmlidXRlLnR5cGUgPT09IFwid2lkXCIgJiYgIWl0ZW1FbXB0eSgkcmV2QXR0cmlidXRlKSkge1xuICAgICAgJGRhdGEucG9wKCk7XG4gICAgICBpZiAoJHJldkF0dHJpYnV0ZS52YWx1ZSA9PT0gXCJ5ZXNcIikge1xuICAgICAgICBteU9iamVjdCA9IHtcbiAgICAgICAgICBpZDogJHdmLmlkLFxuICAgICAgICAgIGxhYmVsOiAkd2YubGFiZWxbMF0sXG4gICAgICAgICAgbGFiZWxfcGFyZW50OiAkd2YucGFyZW50LmxhYmVsLFxuICAgICAgICAgIHR5cGU6IFwid2lkXCJcbiAgICAgICAgfTtcbiAgICAgICAgJGRhdGEucHVzaChteU9iamVjdCk7XG4gICAgICB9IGVsc2UgaWYgKCRyZXZBdHRyaWJ1dGUudmFsdWUgPT09IFwibm9cIikge1xuICAgICAgICBteU9iamVjdCA9IHtcbiAgICAgICAgICBpZDogJHdmLmlkLFxuICAgICAgICAgIGxhYmVsOiAkd2YubGFiZWxbMV0sXG4gICAgICAgICAgbGFiZWxfcGFyZW50OiAkd2YucGFyZW50LmxhYmVsLFxuICAgICAgICAgIHR5cGU6IFwid2lkXCJcbiAgICAgICAgfTtcbiAgICAgICAgJGRhdGEucHVzaChteU9iamVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBteU9iamVjdCA9IHtcbiAgICAgICAgICBpZDogJHdmLmlkLFxuICAgICAgICAgIGxhYmVsOiAkd2YubGFiZWxbMl0sXG4gICAgICAgICAgbGFiZWxfcGFyZW50OiAkd2YucGFyZW50LmxhYmVsLFxuICAgICAgICAgIHR5cGU6IFwid2lkXCJcbiAgICAgICAgfTtcbiAgICAgICAgJGRhdGEucHVzaChteU9iamVjdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBrZXlzIHZpc2liaWxpdGllc1xuICAgKiBAcGFyYW0gbXlPcGVyYXRvciBvcGVyYXRvciB1c2VkIHRvIGtub3cgaWYgeW91IHNob3cgb3IgaGlkZSB0aGUga2V5cyBmaWVsZFxuICAgKiBAcGFyYW0gJGluZGV4IGluZGV4IG9mIHRoZSBmaWVsZCBpbiB0aGUgdGFibGVcbiAgICogQHBhcmFtICRkb2N1bWVudENvbnRyb2xsZXIgdGhlIGRvY3VtZW50IGNvbnRyb2xsZXIgb2YgdGhlIGRvY3VtZW50XG4gICAqL1xuICBmdW5jdGlvbiBzZXRWaXNpYmlsaXR5KG15T3BlcmF0b3IsICRpbmRleCwgJGRvY3VtZW50Q29udHJvbGxlcikge1xuICAgIHZhciBteUtleXdvcmQ7XG4gICAgdmFyIG1pbm9yS2V5d29yZDtcbiAgICB2YXIgdmlzaWJsZSA9IGZhbHNlO1xuICAgIHZhciAkZW52aXJvbm1lbnQgPSBudWxsO1xuICAgICQoXCIuZGNwQXR0cmlidXRlX192YWx1ZVtuYW1lPXNlX2tleXNdXCIpLmVhY2goZnVuY3Rpb24gZWFjaEtleXNTZXRWaXNpYmlsaXR5KFxuICAgICAga2V5LFxuICAgICAgdmFsdWVcbiAgICApIHtcbiAgICAgIGlmIChrZXkgPT09ICRpbmRleCkge1xuICAgICAgICAkZW52aXJvbm1lbnQgPSAkKHRoaXMpO1xuICAgICAgICBteUtleXdvcmQgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtaW5vcktleXdvcmQgPSAkZG9jdW1lbnRDb250cm9sbGVyLmRvY3VtZW50Q29udHJvbGxlcihcImdldFZhbHVlc1wiKS5zZV9rZXlzW1xuICAgICAgJGluZGV4XG4gICAgXTtcbiAgICBpZiAobXlLZXl3b3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciAkbGFiZWwgPSBudWxsO1xuXG4gICAgICBfLmVhY2gobXlPcGVyYXRvcnMsIGZ1bmN0aW9uIGVhY2hPcGVyYXRvcnNTZXRWaXNpYmlsaXR5KGRhdGEpIHtcbiAgICAgICAgaWYgKG15T3BlcmF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChteU9wZXJhdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobXlPcGVyYXRvci52YWx1ZSA9PT0gZGF0YS5pZCkge1xuICAgICAgICAgICAgICAkbGFiZWwgPSBkYXRhLmxhYmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICgkbGFiZWwgPT09IG51bGwpIHtcbiAgICAgICAgdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLypcbiAgICAgICAgICAgICBjaGVjayBpZiB0aGUgb3BlcmF0b3IgaGFzIGEgXCJyaWdodFwiIG9wZXJhbmRcbiAgICAgICAgICAgICAqL1xuICAgICAgICB2aXNpYmxlID0gJGxhYmVsLmluZGV4T2YoXCJ7cmlnaHR9XCIpICE9PSAtMTtcbiAgICAgIH1cbiAgICAgIHZhciAkcGFyZW50ID0gJGVudmlyb25tZW50LmNsb3Nlc3QoXCJkaXZcIik7XG4gICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAkcGFyZW50LnNob3coKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRwYXJlbnQuaGlkZSgpO1xuICAgICAgICBteUtleXdvcmQudmFsdWUgPSBudWxsO1xuICAgICAgICBtaW5vcktleXdvcmQudmFsdWUgPSBudWxsO1xuICAgICAgICBtaW5vcktleXdvcmQuZGlzcGxheVZhbHVlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogY3JlYXRlIGJvb3RzdHJhcCBidXR0b24gdG8gc2hvdyBtZXRob2RzIGFzc29jaWF0ZWQgdG8gY3VycmVudCBhdHRyaWJ1dGVcbiAgICogQHBhcmFtICRlbnZpcm9ubWVudFxuICAgKiBAcGFyYW0gJG1ldGhvZHNcbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZUJ1dHRvbk1ldGhvZHMoJGVudmlyb25tZW50LCAkbWV0aG9kcykge1xuICAgIHZhciAkbXlCdXR0b24gPSAkKCc8YnV0dG9uIGNsYXNzPVwiZnVuY0J0blwiPiZTaWdtYTs8L2J1dHRvbj4nKTtcbiAgICB2YXIgJGlucHV0cyA9ICQoJGVudmlyb25tZW50LmNsb3Nlc3QoXCJkaXZcIikuZmluZChcImlucHV0XCIpKTtcbiAgICB2YXIgJGluZGV4ID0gJGJlZm9yZU1ldGgubGVuZ3RoO1xuICAgIHZhciAkbWV0aG9kSW5wdXQ7XG4gICAgJGJlZm9yZU1ldGhbJGluZGV4XSA9IG51bGw7XG5cbiAgICAkbXlCdXR0b24uY2xpY2soZnVuY3Rpb24gY2xpY2tPbk1ldGhvZHNCdXR0b24oKSB7XG4gICAgICBpZiAoJGJlZm9yZU1ldGhbJGluZGV4XSA9PSBudWxsKSB7XG4gICAgICAgIGlmICgkaW5wdXRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICQoJCgkaW5wdXRzWzBdKS5jbG9zZXN0KFwic3BhblwiKVswXS5wYXJlbnRFbGVtZW50KS5oaWRlKCk7XG4gICAgICAgICAgJG1ldGhvZElucHV0ID0gJCgkaW5wdXRzWyRpbnB1dHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICRtZXRob2RJbnB1dC5zaG93KCk7XG5cbiAgICAgICAgICAkbWV0aG9kSW5wdXQudmFsKFwiXCIpO1xuICAgICAgICAgICRtZXRob2RJbnB1dC50cmlnZ2VyKFwiY2hhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgICRiZWZvcmVNZXRoWyRpbmRleF0gPSAkaW5wdXRzWyRpbnB1dHMubGVuZ3RoIC0gMV07XG4gICAgICAgICRlbnZpcm9ubWVudC5rZW5kb0NvbWJvQm94KHtcbiAgICAgICAgICB3aWR0aDogMjAwLFxuICAgICAgICAgIGZpbHRlcjogXCJjb250YWluc1wiLFxuICAgICAgICAgIGNsZWFyQnV0dG9uOiBmYWxzZSxcbiAgICAgICAgICBtaW5MZW5ndGg6IDAsXG4gICAgICAgICAgZGF0YVZhbHVlRmllbGQ6IFwibWV0aG9kXCIsXG4gICAgICAgICAgZGF0YVRleHRGaWVsZDogXCJtZXRob2RcIixcbiAgICAgICAgICB0ZW1wbGF0ZTogXCIjOiBsYWJlbCAjXCIsXG4gICAgICAgICAgZGF0YVNvdXJjZTogJG1ldGhvZHNcbiAgICAgICAgfSk7XG4gICAgICAgICRjaGVja01ldGggPSB0cnVlO1xuICAgICAgICAkZW52aXJvbm1lbnQuZGF0YShcImtlbmRvQ29tYm9Cb3hcIikubGlzdC5jc3MoXCJtaW4td2lkdGhcIiwgXCIzMDBweFwiKTtcbiAgICAgICAgJCgkZW52aXJvbm1lbnQuY2xvc2VzdChcImRpdlwiKS5maW5kKFwic3BhblwiKSlcbiAgICAgICAgICAuYWRkQ2xhc3MoXCJidXR0b24tLW9uXCIpXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKFwiYnV0dG9uLS1vZmZcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkZW52aXJvbm1lbnQuZGF0YShcImtlbmRvQ29tYm9Cb3hcIikuZGVzdHJveSgpO1xuICAgICAgICB2YXIgJG5vZGVUb1NhdmUgPSAkYmVmb3JlTWV0aFskaW5kZXhdO1xuICAgICAgICB2YXIgJHBhcmVudCA9ICRlbnZpcm9ubWVudC5wYXJlbnQoKVswXS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAkcGFyZW50LmNoaWxkcmVuWyRpbnB1dHMubGVuZ3RoIC0gMV0ucmVtb3ZlKCk7XG4gICAgICAgICRwYXJlbnQuaW5zZXJ0QmVmb3JlKCRub2RlVG9TYXZlLCAkcGFyZW50Lmxhc3RFbGVtZW50Q2hpbGQpO1xuICAgICAgICAkbm9kZVRvU2F2ZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICBpZiAoJGlucHV0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAkKCRpbnB1dHNbJGlucHV0cy5sZW5ndGggLSAxXSkuaGlkZSgpO1xuICAgICAgICAgICQoJCgkaW5wdXRzWzBdKS5jbG9zZXN0KFwic3BhblwiKVswXS5wYXJlbnRFbGVtZW50KS5zaG93KCk7XG4gICAgICAgICAgJCgkbm9kZVRvU2F2ZSkudmFsKFwiXCIpO1xuICAgICAgICAgICQoJG5vZGVUb1NhdmUpLnRyaWdnZXIoXCJjaGFuZ2VcIik7XG4gICAgICAgICAgJCgkaW5wdXRzWzBdKS52YWwoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgJGNoZWNrTWV0aCA9IGZhbHNlO1xuICAgICAgICAkYmVmb3JlTWV0aFskaW5kZXhdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAkbXlCdXR0b24ua2VuZG9CdXR0b24oKTtcbiAgICAkbXlCdXR0b24uaW5zZXJ0QWZ0ZXIoJGlucHV0c1skaW5wdXRzLmxlbmd0aCAtIDFdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUJ1dHRvbk1ldGhvZHMoJGVudmlyb25tZW50KSB7XG4gICAgJCgkZW52aXJvbm1lbnQuY2xvc2VzdChcImRpdlwiKS5maW5kKFwiYnV0dG9uXCIpKS5yZW1vdmUoKTtcbiAgfVxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///ceecf6b70dccf1a612bd\n");

/***/ }),

/***/ "f586cf5b9f4b7719b2c1":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZjU4NmNmNWI5ZjRiNzcxOWIyYzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2NlZDIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///f586cf5b9f4b7719b2c1\n");

/***/ })

/******/ });